// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: patternfill.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_patternfill_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_patternfill_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "fields.pb.h"
#include "solidfill.pb.h"
#include "gradientfill.pb.h"
#include "picturefill.pb.h"
#include "dimension.pb.h"
#include "shapegeometry.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_patternfill_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_patternfill_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_patternfill_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class PatternFill;
struct PatternFillDefaultTypeInternal;
extern PatternFillDefaultTypeInternal _PatternFill_default_instance_;
class PatternFill_DistanceBetweenShapes;
struct PatternFill_DistanceBetweenShapesDefaultTypeInternal;
extern PatternFill_DistanceBetweenShapesDefaultTypeInternal _PatternFill_DistanceBetweenShapes_default_instance_;
class PatternFill_FillValue;
struct PatternFill_FillValueDefaultTypeInternal;
extern PatternFill_FillValueDefaultTypeInternal _PatternFill_FillValue_default_instance_;
class PatternFill_ForegroundShape;
struct PatternFill_ForegroundShapeDefaultTypeInternal;
extern PatternFill_ForegroundShapeDefaultTypeInternal _PatternFill_ForegroundShape_default_instance_;
class PatternFill_StrokeValue;
struct PatternFill_StrokeValueDefaultTypeInternal;
extern PatternFill_StrokeValueDefaultTypeInternal _PatternFill_StrokeValue_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {

// ===================================================================


// -------------------------------------------------------------------

class PatternFill_DistanceBetweenShapes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PatternFill.DistanceBetweenShapes) */ {
 public:
  inline PatternFill_DistanceBetweenShapes() : PatternFill_DistanceBetweenShapes(nullptr) {}
  ~PatternFill_DistanceBetweenShapes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PatternFill_DistanceBetweenShapes(::google::protobuf::internal::ConstantInitialized);

  inline PatternFill_DistanceBetweenShapes(const PatternFill_DistanceBetweenShapes& from)
      : PatternFill_DistanceBetweenShapes(nullptr, from) {}
  PatternFill_DistanceBetweenShapes(PatternFill_DistanceBetweenShapes&& from) noexcept
    : PatternFill_DistanceBetweenShapes() {
    *this = ::std::move(from);
  }

  inline PatternFill_DistanceBetweenShapes& operator=(const PatternFill_DistanceBetweenShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternFill_DistanceBetweenShapes& operator=(PatternFill_DistanceBetweenShapes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatternFill_DistanceBetweenShapes& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternFill_DistanceBetweenShapes* internal_default_instance() {
    return reinterpret_cast<const PatternFill_DistanceBetweenShapes*>(
               &_PatternFill_DistanceBetweenShapes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PatternFill_DistanceBetweenShapes& a, PatternFill_DistanceBetweenShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternFill_DistanceBetweenShapes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternFill_DistanceBetweenShapes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatternFill_DistanceBetweenShapes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatternFill_DistanceBetweenShapes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatternFill_DistanceBetweenShapes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PatternFill_DistanceBetweenShapes& from) {
    PatternFill_DistanceBetweenShapes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PatternFill_DistanceBetweenShapes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PatternFill.DistanceBetweenShapes";
  }
  protected:
  explicit PatternFill_DistanceBetweenShapes(::google::protobuf::Arena* arena);
  PatternFill_DistanceBetweenShapes(::google::protobuf::Arena* arena, const PatternFill_DistanceBetweenShapes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kTopFieldNumber = 2,
  };
  // optional float left = 1;
  bool has_left() const;
  void clear_left() ;
  float left() const;
  void set_left(float value);

  private:
  float _internal_left() const;
  void _internal_set_left(float value);

  public:
  // optional float top = 2;
  bool has_top() const;
  void clear_top() ;
  float top() const;
  void set_top(float value);

  private:
  float _internal_top() const;
  void _internal_set_top(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PatternFill.DistanceBetweenShapes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float left_;
    float top_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_patternfill_2eproto;
};// -------------------------------------------------------------------

class PatternFill_FillValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PatternFill.FillValue) */ {
 public:
  inline PatternFill_FillValue() : PatternFill_FillValue(nullptr) {}
  ~PatternFill_FillValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PatternFill_FillValue(::google::protobuf::internal::ConstantInitialized);

  inline PatternFill_FillValue(const PatternFill_FillValue& from)
      : PatternFill_FillValue(nullptr, from) {}
  PatternFill_FillValue(PatternFill_FillValue&& from) noexcept
    : PatternFill_FillValue() {
    *this = ::std::move(from);
  }

  inline PatternFill_FillValue& operator=(const PatternFill_FillValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternFill_FillValue& operator=(PatternFill_FillValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatternFill_FillValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternFill_FillValue* internal_default_instance() {
    return reinterpret_cast<const PatternFill_FillValue*>(
               &_PatternFill_FillValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PatternFill_FillValue& a, PatternFill_FillValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternFill_FillValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternFill_FillValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatternFill_FillValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatternFill_FillValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatternFill_FillValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PatternFill_FillValue& from) {
    PatternFill_FillValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PatternFill_FillValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PatternFill.FillValue";
  }
  protected:
  explicit PatternFill_FillValue(::google::protobuf::Arena* arena);
  PatternFill_FillValue(::google::protobuf::Arena* arena, const PatternFill_FillValue& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSolidFieldNumber = 2,
    kGradientFieldNumber = 3,
    kPictFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.SolidFill solid = 2;
  bool has_solid() const;
  void clear_solid() ;
  const ::com::zoho::shapes::SolidFill& solid() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::SolidFill* release_solid();
  ::com::zoho::shapes::SolidFill* mutable_solid();
  void set_allocated_solid(::com::zoho::shapes::SolidFill* value);
  void unsafe_arena_set_allocated_solid(::com::zoho::shapes::SolidFill* value);
  ::com::zoho::shapes::SolidFill* unsafe_arena_release_solid();

  private:
  const ::com::zoho::shapes::SolidFill& _internal_solid() const;
  ::com::zoho::shapes::SolidFill* _internal_mutable_solid();

  public:
  // optional .com.zoho.shapes.GradientFill gradient = 3;
  bool has_gradient() const;
  void clear_gradient() ;
  const ::com::zoho::shapes::GradientFill& gradient() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::GradientFill* release_gradient();
  ::com::zoho::shapes::GradientFill* mutable_gradient();
  void set_allocated_gradient(::com::zoho::shapes::GradientFill* value);
  void unsafe_arena_set_allocated_gradient(::com::zoho::shapes::GradientFill* value);
  ::com::zoho::shapes::GradientFill* unsafe_arena_release_gradient();

  private:
  const ::com::zoho::shapes::GradientFill& _internal_gradient() const;
  ::com::zoho::shapes::GradientFill* _internal_mutable_gradient();

  public:
  // optional .com.zoho.shapes.PictureFill pict = 4;
  bool has_pict() const;
  void clear_pict() ;
  const ::com::zoho::shapes::PictureFill& pict() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PictureFill* release_pict();
  ::com::zoho::shapes::PictureFill* mutable_pict();
  void set_allocated_pict(::com::zoho::shapes::PictureFill* value);
  void unsafe_arena_set_allocated_pict(::com::zoho::shapes::PictureFill* value);
  ::com::zoho::shapes::PictureFill* unsafe_arena_release_pict();

  private:
  const ::com::zoho::shapes::PictureFill& _internal_pict() const;
  ::com::zoho::shapes::PictureFill* _internal_mutable_pict();

  public:
  // required .Show.FillField.FillType type = 1 [default = SOLID];
  bool has_type() const;
  void clear_type() ;
  ::Show::FillField_FillType type() const;
  void set_type(::Show::FillField_FillType value);

  private:
  ::Show::FillField_FillType _internal_type() const;
  void _internal_set_type(::Show::FillField_FillType value);

  public:
  void temp_setsolid(com::zoho::shapes::SolidFill* solid) {
    if(&this->solid() != solid) {
      set_allocated_solid(solid);
    }
  }
  
  com::zoho::shapes::SolidFill* temp_getsolid() const {
    if (has_solid()) 
      return (const_cast<com::zoho::shapes::PatternFill_FillValue*>(this))->mutable_solid();
    return nullptr;
  }
  
  void temp_setgradient(com::zoho::shapes::GradientFill* gradient) {
    if(&this->gradient() != gradient) {
      set_allocated_gradient(gradient);
    }
  }
  
  com::zoho::shapes::GradientFill* temp_getgradient() const {
    if (has_gradient()) 
      return (const_cast<com::zoho::shapes::PatternFill_FillValue*>(this))->mutable_gradient();
    return nullptr;
  }
  
  void temp_setpict(com::zoho::shapes::PictureFill* pict) {
    if(&this->pict() != pict) {
      set_allocated_pict(pict);
    }
  }
  
  com::zoho::shapes::PictureFill* temp_getpict() const {
    if (has_pict()) 
      return (const_cast<com::zoho::shapes::PatternFill_FillValue*>(this))->mutable_pict();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PatternFill.FillValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::SolidFill* solid_;
    ::com::zoho::shapes::GradientFill* gradient_;
    ::com::zoho::shapes::PictureFill* pict_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_patternfill_2eproto;
};// -------------------------------------------------------------------

class PatternFill_StrokeValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PatternFill.StrokeValue) */ {
 public:
  inline PatternFill_StrokeValue() : PatternFill_StrokeValue(nullptr) {}
  ~PatternFill_StrokeValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PatternFill_StrokeValue(::google::protobuf::internal::ConstantInitialized);

  inline PatternFill_StrokeValue(const PatternFill_StrokeValue& from)
      : PatternFill_StrokeValue(nullptr, from) {}
  PatternFill_StrokeValue(PatternFill_StrokeValue&& from) noexcept
    : PatternFill_StrokeValue() {
    *this = ::std::move(from);
  }

  inline PatternFill_StrokeValue& operator=(const PatternFill_StrokeValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternFill_StrokeValue& operator=(PatternFill_StrokeValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatternFill_StrokeValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternFill_StrokeValue* internal_default_instance() {
    return reinterpret_cast<const PatternFill_StrokeValue*>(
               &_PatternFill_StrokeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PatternFill_StrokeValue& a, PatternFill_StrokeValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternFill_StrokeValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternFill_StrokeValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatternFill_StrokeValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatternFill_StrokeValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatternFill_StrokeValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PatternFill_StrokeValue& from) {
    PatternFill_StrokeValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PatternFill_StrokeValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PatternFill.StrokeValue";
  }
  protected:
  explicit PatternFill_StrokeValue(::google::protobuf::Arena* arena);
  PatternFill_StrokeValue(::google::protobuf::Arena* arena, const PatternFill_StrokeValue& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFillFieldNumber = 3,
    kTypeFieldNumber = 1,
    kWidthFieldNumber = 2,
  };
  // optional .com.zoho.shapes.PatternFill.FillValue fill = 3;
  bool has_fill() const;
  void clear_fill() ;
  const ::com::zoho::shapes::PatternFill_FillValue& fill() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PatternFill_FillValue* release_fill();
  ::com::zoho::shapes::PatternFill_FillValue* mutable_fill();
  void set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value);
  void unsafe_arena_set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value);
  ::com::zoho::shapes::PatternFill_FillValue* unsafe_arena_release_fill();

  private:
  const ::com::zoho::shapes::PatternFill_FillValue& _internal_fill() const;
  ::com::zoho::shapes::PatternFill_FillValue* _internal_mutable_fill();

  public:
  // optional .Show.StrokeField.StrokeType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::Show::StrokeField_StrokeType type() const;
  void set_type(::Show::StrokeField_StrokeType value);

  private:
  ::Show::StrokeField_StrokeType _internal_type() const;
  void _internal_set_type(::Show::StrokeField_StrokeType value);

  public:
  // optional float width = 2;
  bool has_width() const;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  void temp_setfill(com::zoho::shapes::PatternFill_FillValue* fill) {
    if(&this->fill() != fill) {
      set_allocated_fill(fill);
    }
  }
  
  com::zoho::shapes::PatternFill_FillValue* temp_getfill() const {
    if (has_fill()) 
      return (const_cast<com::zoho::shapes::PatternFill_StrokeValue*>(this))->mutable_fill();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PatternFill.StrokeValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::PatternFill_FillValue* fill_;
    int type_;
    float width_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_patternfill_2eproto;
};// -------------------------------------------------------------------

class PatternFill_ForegroundShape final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PatternFill.ForegroundShape) */ {
 public:
  inline PatternFill_ForegroundShape() : PatternFill_ForegroundShape(nullptr) {}
  ~PatternFill_ForegroundShape() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PatternFill_ForegroundShape(::google::protobuf::internal::ConstantInitialized);

  inline PatternFill_ForegroundShape(const PatternFill_ForegroundShape& from)
      : PatternFill_ForegroundShape(nullptr, from) {}
  PatternFill_ForegroundShape(PatternFill_ForegroundShape&& from) noexcept
    : PatternFill_ForegroundShape() {
    *this = ::std::move(from);
  }

  inline PatternFill_ForegroundShape& operator=(const PatternFill_ForegroundShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternFill_ForegroundShape& operator=(PatternFill_ForegroundShape&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatternFill_ForegroundShape& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternFill_ForegroundShape* internal_default_instance() {
    return reinterpret_cast<const PatternFill_ForegroundShape*>(
               &_PatternFill_ForegroundShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PatternFill_ForegroundShape& a, PatternFill_ForegroundShape& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternFill_ForegroundShape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternFill_ForegroundShape* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatternFill_ForegroundShape* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatternFill_ForegroundShape>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatternFill_ForegroundShape& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PatternFill_ForegroundShape& from) {
    PatternFill_ForegroundShape::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PatternFill_ForegroundShape* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PatternFill.ForegroundShape";
  }
  protected:
  explicit PatternFill_ForegroundShape(::google::protobuf::Arena* arena);
  PatternFill_ForegroundShape(::google::protobuf::Arena* arena, const PatternFill_ForegroundShape& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 1,
    kFillFieldNumber = 2,
    kStrokeFieldNumber = 3,
    kGeomFieldNumber = 4,
  };
  // optional .com.zoho.common.Dimension dim = 1;
  bool has_dim() const;
  void clear_dim() ;
  const ::com::zoho::common::Dimension& dim() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Dimension* release_dim();
  ::com::zoho::common::Dimension* mutable_dim();
  void set_allocated_dim(::com::zoho::common::Dimension* value);
  void unsafe_arena_set_allocated_dim(::com::zoho::common::Dimension* value);
  ::com::zoho::common::Dimension* unsafe_arena_release_dim();

  private:
  const ::com::zoho::common::Dimension& _internal_dim() const;
  ::com::zoho::common::Dimension* _internal_mutable_dim();

  public:
  // optional .com.zoho.shapes.PatternFill.FillValue fill = 2;
  bool has_fill() const;
  void clear_fill() ;
  const ::com::zoho::shapes::PatternFill_FillValue& fill() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PatternFill_FillValue* release_fill();
  ::com::zoho::shapes::PatternFill_FillValue* mutable_fill();
  void set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value);
  void unsafe_arena_set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value);
  ::com::zoho::shapes::PatternFill_FillValue* unsafe_arena_release_fill();

  private:
  const ::com::zoho::shapes::PatternFill_FillValue& _internal_fill() const;
  ::com::zoho::shapes::PatternFill_FillValue* _internal_mutable_fill();

  public:
  // optional .com.zoho.shapes.PatternFill.StrokeValue stroke = 3;
  bool has_stroke() const;
  void clear_stroke() ;
  const ::com::zoho::shapes::PatternFill_StrokeValue& stroke() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PatternFill_StrokeValue* release_stroke();
  ::com::zoho::shapes::PatternFill_StrokeValue* mutable_stroke();
  void set_allocated_stroke(::com::zoho::shapes::PatternFill_StrokeValue* value);
  void unsafe_arena_set_allocated_stroke(::com::zoho::shapes::PatternFill_StrokeValue* value);
  ::com::zoho::shapes::PatternFill_StrokeValue* unsafe_arena_release_stroke();

  private:
  const ::com::zoho::shapes::PatternFill_StrokeValue& _internal_stroke() const;
  ::com::zoho::shapes::PatternFill_StrokeValue* _internal_mutable_stroke();

  public:
  // optional .com.zoho.shapes.ShapeGeometry geom = 4;
  bool has_geom() const;
  void clear_geom() ;
  const ::com::zoho::shapes::ShapeGeometry& geom() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::ShapeGeometry* release_geom();
  ::com::zoho::shapes::ShapeGeometry* mutable_geom();
  void set_allocated_geom(::com::zoho::shapes::ShapeGeometry* value);
  void unsafe_arena_set_allocated_geom(::com::zoho::shapes::ShapeGeometry* value);
  ::com::zoho::shapes::ShapeGeometry* unsafe_arena_release_geom();

  private:
  const ::com::zoho::shapes::ShapeGeometry& _internal_geom() const;
  ::com::zoho::shapes::ShapeGeometry* _internal_mutable_geom();

  public:
  void temp_setdim(com::zoho::common::Dimension* dim) {
    if(&this->dim() != dim) {
      set_allocated_dim(dim);
    }
  }
  
  com::zoho::common::Dimension* temp_getdim() const {
    if (has_dim()) 
      return (const_cast<com::zoho::shapes::PatternFill_ForegroundShape*>(this))->mutable_dim();
    return nullptr;
  }
  
  void temp_setfill(com::zoho::shapes::PatternFill_FillValue* fill) {
    if(&this->fill() != fill) {
      set_allocated_fill(fill);
    }
  }
  
  com::zoho::shapes::PatternFill_FillValue* temp_getfill() const {
    if (has_fill()) 
      return (const_cast<com::zoho::shapes::PatternFill_ForegroundShape*>(this))->mutable_fill();
    return nullptr;
  }
  
  void temp_setstroke(com::zoho::shapes::PatternFill_StrokeValue* stroke) {
    if(&this->stroke() != stroke) {
      set_allocated_stroke(stroke);
    }
  }
  
  com::zoho::shapes::PatternFill_StrokeValue* temp_getstroke() const {
    if (has_stroke()) 
      return (const_cast<com::zoho::shapes::PatternFill_ForegroundShape*>(this))->mutable_stroke();
    return nullptr;
  }
  
  void temp_setgeom(com::zoho::shapes::ShapeGeometry* geom) {
    if(&this->geom() != geom) {
      set_allocated_geom(geom);
    }
  }
  
  com::zoho::shapes::ShapeGeometry* temp_getgeom() const {
    if (has_geom()) 
      return (const_cast<com::zoho::shapes::PatternFill_ForegroundShape*>(this))->mutable_geom();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PatternFill.ForegroundShape)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::Dimension* dim_;
    ::com::zoho::shapes::PatternFill_FillValue* fill_;
    ::com::zoho::shapes::PatternFill_StrokeValue* stroke_;
    ::com::zoho::shapes::ShapeGeometry* geom_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_patternfill_2eproto;
};// -------------------------------------------------------------------

class PatternFill final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PatternFill) */ {
 public:
  inline PatternFill() : PatternFill(nullptr) {}
  ~PatternFill() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PatternFill(::google::protobuf::internal::ConstantInitialized);

  inline PatternFill(const PatternFill& from)
      : PatternFill(nullptr, from) {}
  PatternFill(PatternFill&& from) noexcept
    : PatternFill() {
    *this = ::std::move(from);
  }

  inline PatternFill& operator=(const PatternFill& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternFill& operator=(PatternFill&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatternFill& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternFill* internal_default_instance() {
    return reinterpret_cast<const PatternFill*>(
               &_PatternFill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PatternFill& a, PatternFill& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternFill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternFill* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatternFill* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatternFill>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PatternFill& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PatternFill& from) {
    PatternFill::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PatternFill* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PatternFill";
  }
  protected:
  explicit PatternFill(::google::protobuf::Arena* arena);
  PatternFill(::google::protobuf::Arena* arena, const PatternFill& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using FillValue = PatternFill_FillValue;
  using StrokeValue = PatternFill_StrokeValue;
  using ForegroundShape = PatternFill_ForegroundShape;
  using DistanceBetweenShapes = PatternFill_DistanceBetweenShapes;

  // accessors -------------------------------------------------------

  enum : int {
    kForegroundFieldNumber = 1,
    kPresetFieldNumber = 4,
    kBackgroundFieldNumber = 2,
    kDistanceFieldNumber = 3,
    kRotateFieldNumber = 5,
  };
  // repeated .com.zoho.shapes.PatternFill.ForegroundShape foreground = 1;
  int foreground_size() const;
  private:
  int _internal_foreground_size() const;

  public:
  void clear_foreground() ;
  ::com::zoho::shapes::PatternFill_ForegroundShape* mutable_foreground(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::PatternFill_ForegroundShape >*
      mutable_foreground();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::PatternFill_ForegroundShape>& _internal_foreground() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::PatternFill_ForegroundShape>* _internal_mutable_foreground();
  public:
  const ::com::zoho::shapes::PatternFill_ForegroundShape& foreground(int index) const;
  ::com::zoho::shapes::PatternFill_ForegroundShape* add_foreground();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::PatternFill_ForegroundShape >&
      foreground() const;
  // optional string preset = 4;
  bool has_preset() const;
  void clear_preset() ;
  const std::string& preset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_preset(Arg_&& arg, Args_... args);
  std::string* mutable_preset();
  PROTOBUF_NODISCARD std::string* release_preset();
  void set_allocated_preset(std::string* value);

  private:
  const std::string& _internal_preset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preset(
      const std::string& value);
  std::string* _internal_mutable_preset();

  public:
  // optional .com.zoho.shapes.PatternFill.FillValue background = 2;
  bool has_background() const;
  void clear_background() ;
  const ::com::zoho::shapes::PatternFill_FillValue& background() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PatternFill_FillValue* release_background();
  ::com::zoho::shapes::PatternFill_FillValue* mutable_background();
  void set_allocated_background(::com::zoho::shapes::PatternFill_FillValue* value);
  void unsafe_arena_set_allocated_background(::com::zoho::shapes::PatternFill_FillValue* value);
  ::com::zoho::shapes::PatternFill_FillValue* unsafe_arena_release_background();

  private:
  const ::com::zoho::shapes::PatternFill_FillValue& _internal_background() const;
  ::com::zoho::shapes::PatternFill_FillValue* _internal_mutable_background();

  public:
  // optional .com.zoho.shapes.PatternFill.DistanceBetweenShapes distance = 3;
  bool has_distance() const;
  void clear_distance() ;
  const ::com::zoho::shapes::PatternFill_DistanceBetweenShapes& distance() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* release_distance();
  ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* mutable_distance();
  void set_allocated_distance(::com::zoho::shapes::PatternFill_DistanceBetweenShapes* value);
  void unsafe_arena_set_allocated_distance(::com::zoho::shapes::PatternFill_DistanceBetweenShapes* value);
  ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* unsafe_arena_release_distance();

  private:
  const ::com::zoho::shapes::PatternFill_DistanceBetweenShapes& _internal_distance() const;
  ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* _internal_mutable_distance();

  public:
  // optional int32 rotate = 5;
  bool has_rotate() const;
  void clear_rotate() ;
  ::int32_t rotate() const;
  void set_rotate(::int32_t value);

  private:
  ::int32_t _internal_rotate() const;
  void _internal_set_rotate(::int32_t value);

  public:
  google::protobuf::RepeatedPtrField<com::zoho::shapes::PatternFill_ForegroundShape>* temp_getforeground() const {
    return const_cast<com::zoho::shapes::PatternFill*>(this)->mutable_foreground();
  }
  
  void temp_setforeground(const google::protobuf::RepeatedPtrField<com::zoho::shapes::PatternFill_ForegroundShape>* foreground) {
    if(this->mutable_foreground() != foreground) {
      const_cast<com::zoho::shapes::PatternFill*>(this)->mutable_foreground()->CopyFrom(*foreground);
    }}
  
  void temp_setbackground(com::zoho::shapes::PatternFill_FillValue* background) {
    if(&this->background() != background) {
      set_allocated_background(background);
    }
  }
  
  com::zoho::shapes::PatternFill_FillValue* temp_getbackground() const {
    if (has_background()) 
      return (const_cast<com::zoho::shapes::PatternFill*>(this))->mutable_background();
    return nullptr;
  }
  
  void temp_setdistance(com::zoho::shapes::PatternFill_DistanceBetweenShapes* distance) {
    if(&this->distance() != distance) {
      set_allocated_distance(distance);
    }
  }
  
  com::zoho::shapes::PatternFill_DistanceBetweenShapes* temp_getdistance() const {
    if (has_distance()) 
      return (const_cast<com::zoho::shapes::PatternFill*>(this))->mutable_distance();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PatternFill)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::PatternFill_ForegroundShape > foreground_;
    ::google::protobuf::internal::ArenaStringPtr preset_;
    ::com::zoho::shapes::PatternFill_FillValue* background_;
    ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* distance_;
    ::int32_t rotate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_patternfill_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PatternFill_FillValue

// required .Show.FillField.FillType type = 1 [default = SOLID];
inline bool PatternFill_FillValue::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PatternFill_FillValue::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 2;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Show::FillField_FillType PatternFill_FillValue::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.FillValue.type)
  return _internal_type();
}
inline void PatternFill_FillValue::set_type(::Show::FillField_FillType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PatternFill.FillValue.type)
}
inline ::Show::FillField_FillType PatternFill_FillValue::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::FillField_FillType>(_impl_.type_);
}
inline void PatternFill_FillValue::_internal_set_type(::Show::FillField_FillType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::Show::FillField_FillType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.SolidFill solid = 2;
inline bool PatternFill_FillValue::has_solid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.solid_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::SolidFill& PatternFill_FillValue::_internal_solid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::SolidFill* p = _impl_.solid_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::SolidFill&>(::com::zoho::shapes::_SolidFill_default_instance_);
}
inline const ::com::zoho::shapes::SolidFill& PatternFill_FillValue::solid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.FillValue.solid)
  return _internal_solid();
}
inline void PatternFill_FillValue::unsafe_arena_set_allocated_solid(::com::zoho::shapes::SolidFill* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.solid_);
  }
  _impl_.solid_ = reinterpret_cast<::com::zoho::shapes::SolidFill*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.FillValue.solid)
}
inline ::com::zoho::shapes::SolidFill* PatternFill_FillValue::release_solid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::SolidFill* released = _impl_.solid_;
  _impl_.solid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::SolidFill* PatternFill_FillValue::unsafe_arena_release_solid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.FillValue.solid)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::SolidFill* temp = _impl_.solid_;
  _impl_.solid_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::SolidFill* PatternFill_FillValue::_internal_mutable_solid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.solid_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::SolidFill>(GetArena());
    _impl_.solid_ = reinterpret_cast<::com::zoho::shapes::SolidFill*>(p);
  }
  return _impl_.solid_;
}
inline ::com::zoho::shapes::SolidFill* PatternFill_FillValue::mutable_solid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::SolidFill* _msg = _internal_mutable_solid();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.FillValue.solid)
  return _msg;
}
inline void PatternFill_FillValue::set_allocated_solid(::com::zoho::shapes::SolidFill* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.solid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.solid_ = reinterpret_cast<::com::zoho::shapes::SolidFill*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.FillValue.solid)
}

// optional .com.zoho.shapes.GradientFill gradient = 3;
inline bool PatternFill_FillValue::has_gradient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gradient_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::GradientFill& PatternFill_FillValue::_internal_gradient() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::GradientFill* p = _impl_.gradient_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::GradientFill&>(::com::zoho::shapes::_GradientFill_default_instance_);
}
inline const ::com::zoho::shapes::GradientFill& PatternFill_FillValue::gradient() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.FillValue.gradient)
  return _internal_gradient();
}
inline void PatternFill_FillValue::unsafe_arena_set_allocated_gradient(::com::zoho::shapes::GradientFill* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gradient_);
  }
  _impl_.gradient_ = reinterpret_cast<::com::zoho::shapes::GradientFill*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.FillValue.gradient)
}
inline ::com::zoho::shapes::GradientFill* PatternFill_FillValue::release_gradient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::GradientFill* released = _impl_.gradient_;
  _impl_.gradient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::GradientFill* PatternFill_FillValue::unsafe_arena_release_gradient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.FillValue.gradient)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::GradientFill* temp = _impl_.gradient_;
  _impl_.gradient_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::GradientFill* PatternFill_FillValue::_internal_mutable_gradient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.gradient_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::GradientFill>(GetArena());
    _impl_.gradient_ = reinterpret_cast<::com::zoho::shapes::GradientFill*>(p);
  }
  return _impl_.gradient_;
}
inline ::com::zoho::shapes::GradientFill* PatternFill_FillValue::mutable_gradient() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::GradientFill* _msg = _internal_mutable_gradient();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.FillValue.gradient)
  return _msg;
}
inline void PatternFill_FillValue::set_allocated_gradient(::com::zoho::shapes::GradientFill* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gradient_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.gradient_ = reinterpret_cast<::com::zoho::shapes::GradientFill*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.FillValue.gradient)
}

// optional .com.zoho.shapes.PictureFill pict = 4;
inline bool PatternFill_FillValue::has_pict() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pict_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::PictureFill& PatternFill_FillValue::_internal_pict() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PictureFill* p = _impl_.pict_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PictureFill&>(::com::zoho::shapes::_PictureFill_default_instance_);
}
inline const ::com::zoho::shapes::PictureFill& PatternFill_FillValue::pict() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.FillValue.pict)
  return _internal_pict();
}
inline void PatternFill_FillValue::unsafe_arena_set_allocated_pict(::com::zoho::shapes::PictureFill* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pict_);
  }
  _impl_.pict_ = reinterpret_cast<::com::zoho::shapes::PictureFill*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.FillValue.pict)
}
inline ::com::zoho::shapes::PictureFill* PatternFill_FillValue::release_pict() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::PictureFill* released = _impl_.pict_;
  _impl_.pict_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PictureFill* PatternFill_FillValue::unsafe_arena_release_pict() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.FillValue.pict)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::PictureFill* temp = _impl_.pict_;
  _impl_.pict_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PictureFill* PatternFill_FillValue::_internal_mutable_pict() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.pict_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PictureFill>(GetArena());
    _impl_.pict_ = reinterpret_cast<::com::zoho::shapes::PictureFill*>(p);
  }
  return _impl_.pict_;
}
inline ::com::zoho::shapes::PictureFill* PatternFill_FillValue::mutable_pict() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PictureFill* _msg = _internal_mutable_pict();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.FillValue.pict)
  return _msg;
}
inline void PatternFill_FillValue::set_allocated_pict(::com::zoho::shapes::PictureFill* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pict_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.pict_ = reinterpret_cast<::com::zoho::shapes::PictureFill*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.FillValue.pict)
}

// -------------------------------------------------------------------

// PatternFill_StrokeValue

// optional .Show.StrokeField.StrokeType type = 1;
inline bool PatternFill_StrokeValue::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PatternFill_StrokeValue::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Show::StrokeField_StrokeType PatternFill_StrokeValue::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.StrokeValue.type)
  return _internal_type();
}
inline void PatternFill_StrokeValue::set_type(::Show::StrokeField_StrokeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PatternFill.StrokeValue.type)
}
inline ::Show::StrokeField_StrokeType PatternFill_StrokeValue::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::StrokeField_StrokeType>(_impl_.type_);
}
inline void PatternFill_StrokeValue::_internal_set_type(::Show::StrokeField_StrokeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::Show::StrokeField_StrokeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional float width = 2;
inline bool PatternFill_StrokeValue::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PatternFill_StrokeValue::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float PatternFill_StrokeValue::width() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.StrokeValue.width)
  return _internal_width();
}
inline void PatternFill_StrokeValue::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PatternFill.StrokeValue.width)
}
inline float PatternFill_StrokeValue::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void PatternFill_StrokeValue::_internal_set_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}

// optional .com.zoho.shapes.PatternFill.FillValue fill = 3;
inline bool PatternFill_StrokeValue::has_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_ != nullptr);
  return value;
}
inline void PatternFill_StrokeValue::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fill_ != nullptr) _impl_.fill_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::PatternFill_FillValue& PatternFill_StrokeValue::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PatternFill_FillValue* p = _impl_.fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PatternFill_FillValue&>(::com::zoho::shapes::_PatternFill_FillValue_default_instance_);
}
inline const ::com::zoho::shapes::PatternFill_FillValue& PatternFill_StrokeValue::fill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.StrokeValue.fill)
  return _internal_fill();
}
inline void PatternFill_StrokeValue::unsafe_arena_set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_);
  }
  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.StrokeValue.fill)
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_StrokeValue::release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::PatternFill_FillValue* released = _impl_.fill_;
  _impl_.fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_StrokeValue::unsafe_arena_release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.StrokeValue.fill)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::PatternFill_FillValue* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_StrokeValue::_internal_mutable_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PatternFill_FillValue>(GetArena());
    _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(p);
  }
  return _impl_.fill_;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_StrokeValue::mutable_fill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PatternFill_FillValue* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.StrokeValue.fill)
  return _msg;
}
inline void PatternFill_StrokeValue::set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(_impl_.fill_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.StrokeValue.fill)
}

// -------------------------------------------------------------------

// PatternFill_ForegroundShape

// optional .com.zoho.common.Dimension dim = 1;
inline bool PatternFill_ForegroundShape::has_dim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dim_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Dimension& PatternFill_ForegroundShape::_internal_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Dimension* p = _impl_.dim_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Dimension&>(::com::zoho::common::_Dimension_default_instance_);
}
inline const ::com::zoho::common::Dimension& PatternFill_ForegroundShape::dim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.ForegroundShape.dim)
  return _internal_dim();
}
inline void PatternFill_ForegroundShape::unsafe_arena_set_allocated_dim(::com::zoho::common::Dimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dim_);
  }
  _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.dim)
}
inline ::com::zoho::common::Dimension* PatternFill_ForegroundShape::release_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* released = _impl_.dim_;
  _impl_.dim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Dimension* PatternFill_ForegroundShape::unsafe_arena_release_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.ForegroundShape.dim)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Dimension* PatternFill_ForegroundShape::_internal_mutable_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dim_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Dimension>(GetArena());
    _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(p);
  }
  return _impl_.dim_;
}
inline ::com::zoho::common::Dimension* PatternFill_ForegroundShape::mutable_dim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Dimension* _msg = _internal_mutable_dim();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.ForegroundShape.dim)
  return _msg;
}
inline void PatternFill_ForegroundShape::set_allocated_dim(::com::zoho::common::Dimension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.dim)
}

// optional .com.zoho.shapes.PatternFill.FillValue fill = 2;
inline bool PatternFill_ForegroundShape::has_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_ != nullptr);
  return value;
}
inline void PatternFill_ForegroundShape::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fill_ != nullptr) _impl_.fill_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::PatternFill_FillValue& PatternFill_ForegroundShape::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PatternFill_FillValue* p = _impl_.fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PatternFill_FillValue&>(::com::zoho::shapes::_PatternFill_FillValue_default_instance_);
}
inline const ::com::zoho::shapes::PatternFill_FillValue& PatternFill_ForegroundShape::fill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.ForegroundShape.fill)
  return _internal_fill();
}
inline void PatternFill_ForegroundShape::unsafe_arena_set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_);
  }
  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.fill)
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_ForegroundShape::release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PatternFill_FillValue* released = _impl_.fill_;
  _impl_.fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_ForegroundShape::unsafe_arena_release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.ForegroundShape.fill)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PatternFill_FillValue* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_ForegroundShape::_internal_mutable_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PatternFill_FillValue>(GetArena());
    _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(p);
  }
  return _impl_.fill_;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill_ForegroundShape::mutable_fill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PatternFill_FillValue* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.ForegroundShape.fill)
  return _msg;
}
inline void PatternFill_ForegroundShape::set_allocated_fill(::com::zoho::shapes::PatternFill_FillValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(_impl_.fill_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.fill)
}

// optional .com.zoho.shapes.PatternFill.StrokeValue stroke = 3;
inline bool PatternFill_ForegroundShape::has_stroke() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stroke_ != nullptr);
  return value;
}
inline void PatternFill_ForegroundShape::clear_stroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stroke_ != nullptr) _impl_.stroke_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::PatternFill_StrokeValue& PatternFill_ForegroundShape::_internal_stroke() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PatternFill_StrokeValue* p = _impl_.stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PatternFill_StrokeValue&>(::com::zoho::shapes::_PatternFill_StrokeValue_default_instance_);
}
inline const ::com::zoho::shapes::PatternFill_StrokeValue& PatternFill_ForegroundShape::stroke() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.ForegroundShape.stroke)
  return _internal_stroke();
}
inline void PatternFill_ForegroundShape::unsafe_arena_set_allocated_stroke(::com::zoho::shapes::PatternFill_StrokeValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stroke_);
  }
  _impl_.stroke_ = reinterpret_cast<::com::zoho::shapes::PatternFill_StrokeValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.stroke)
}
inline ::com::zoho::shapes::PatternFill_StrokeValue* PatternFill_ForegroundShape::release_stroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::PatternFill_StrokeValue* released = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PatternFill_StrokeValue* PatternFill_ForegroundShape::unsafe_arena_release_stroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.ForegroundShape.stroke)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::PatternFill_StrokeValue* temp = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PatternFill_StrokeValue* PatternFill_ForegroundShape::_internal_mutable_stroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PatternFill_StrokeValue>(GetArena());
    _impl_.stroke_ = reinterpret_cast<::com::zoho::shapes::PatternFill_StrokeValue*>(p);
  }
  return _impl_.stroke_;
}
inline ::com::zoho::shapes::PatternFill_StrokeValue* PatternFill_ForegroundShape::mutable_stroke() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PatternFill_StrokeValue* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.ForegroundShape.stroke)
  return _msg;
}
inline void PatternFill_ForegroundShape::set_allocated_stroke(::com::zoho::shapes::PatternFill_StrokeValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PatternFill_StrokeValue*>(_impl_.stroke_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PatternFill_StrokeValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.stroke_ = reinterpret_cast<::com::zoho::shapes::PatternFill_StrokeValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.stroke)
}

// optional .com.zoho.shapes.ShapeGeometry geom = 4;
inline bool PatternFill_ForegroundShape::has_geom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geom_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::ShapeGeometry& PatternFill_ForegroundShape::_internal_geom() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::ShapeGeometry* p = _impl_.geom_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::ShapeGeometry&>(::com::zoho::shapes::_ShapeGeometry_default_instance_);
}
inline const ::com::zoho::shapes::ShapeGeometry& PatternFill_ForegroundShape::geom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.ForegroundShape.geom)
  return _internal_geom();
}
inline void PatternFill_ForegroundShape::unsafe_arena_set_allocated_geom(::com::zoho::shapes::ShapeGeometry* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geom_);
  }
  _impl_.geom_ = reinterpret_cast<::com::zoho::shapes::ShapeGeometry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.geom)
}
inline ::com::zoho::shapes::ShapeGeometry* PatternFill_ForegroundShape::release_geom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::ShapeGeometry* released = _impl_.geom_;
  _impl_.geom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::ShapeGeometry* PatternFill_ForegroundShape::unsafe_arena_release_geom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.ForegroundShape.geom)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::ShapeGeometry* temp = _impl_.geom_;
  _impl_.geom_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::ShapeGeometry* PatternFill_ForegroundShape::_internal_mutable_geom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.geom_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::ShapeGeometry>(GetArena());
    _impl_.geom_ = reinterpret_cast<::com::zoho::shapes::ShapeGeometry*>(p);
  }
  return _impl_.geom_;
}
inline ::com::zoho::shapes::ShapeGeometry* PatternFill_ForegroundShape::mutable_geom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::ShapeGeometry* _msg = _internal_mutable_geom();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.ForegroundShape.geom)
  return _msg;
}
inline void PatternFill_ForegroundShape::set_allocated_geom(::com::zoho::shapes::ShapeGeometry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.geom_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.geom_ = reinterpret_cast<::com::zoho::shapes::ShapeGeometry*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.ForegroundShape.geom)
}

// -------------------------------------------------------------------

// PatternFill_DistanceBetweenShapes

// optional float left = 1;
inline bool PatternFill_DistanceBetweenShapes::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PatternFill_DistanceBetweenShapes::clear_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float PatternFill_DistanceBetweenShapes::left() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.DistanceBetweenShapes.left)
  return _internal_left();
}
inline void PatternFill_DistanceBetweenShapes::set_left(float value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PatternFill.DistanceBetweenShapes.left)
}
inline float PatternFill_DistanceBetweenShapes::_internal_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.left_;
}
inline void PatternFill_DistanceBetweenShapes::_internal_set_left(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.left_ = value;
}

// optional float top = 2;
inline bool PatternFill_DistanceBetweenShapes::has_top() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PatternFill_DistanceBetweenShapes::clear_top() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float PatternFill_DistanceBetweenShapes::top() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.DistanceBetweenShapes.top)
  return _internal_top();
}
inline void PatternFill_DistanceBetweenShapes::set_top(float value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PatternFill.DistanceBetweenShapes.top)
}
inline float PatternFill_DistanceBetweenShapes::_internal_top() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_;
}
inline void PatternFill_DistanceBetweenShapes::_internal_set_top(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.top_ = value;
}

// -------------------------------------------------------------------

// PatternFill

// repeated .com.zoho.shapes.PatternFill.ForegroundShape foreground = 1;
inline int PatternFill::_internal_foreground_size() const {
  return _internal_foreground().size();
}
inline int PatternFill::foreground_size() const {
  return _internal_foreground_size();
}
inline void PatternFill::clear_foreground() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foreground_.Clear();
}
inline ::com::zoho::shapes::PatternFill_ForegroundShape* PatternFill::mutable_foreground(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.foreground)
  return _internal_mutable_foreground()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::PatternFill_ForegroundShape>* PatternFill::mutable_foreground()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.PatternFill.foreground)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_foreground();
}
inline const ::com::zoho::shapes::PatternFill_ForegroundShape& PatternFill::foreground(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.foreground)
  return _internal_foreground().Get(index);
}
inline ::com::zoho::shapes::PatternFill_ForegroundShape* PatternFill::add_foreground() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::PatternFill_ForegroundShape* _add = _internal_mutable_foreground()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.PatternFill.foreground)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::PatternFill_ForegroundShape>& PatternFill::foreground() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.PatternFill.foreground)
  return _internal_foreground();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::PatternFill_ForegroundShape>&
PatternFill::_internal_foreground() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foreground_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::PatternFill_ForegroundShape>*
PatternFill::_internal_mutable_foreground() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.foreground_;
}

// optional .com.zoho.shapes.PatternFill.FillValue background = 2;
inline bool PatternFill::has_background() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.background_ != nullptr);
  return value;
}
inline void PatternFill::clear_background() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.background_ != nullptr) _impl_.background_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::PatternFill_FillValue& PatternFill::_internal_background() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PatternFill_FillValue* p = _impl_.background_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PatternFill_FillValue&>(::com::zoho::shapes::_PatternFill_FillValue_default_instance_);
}
inline const ::com::zoho::shapes::PatternFill_FillValue& PatternFill::background() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.background)
  return _internal_background();
}
inline void PatternFill::unsafe_arena_set_allocated_background(::com::zoho::shapes::PatternFill_FillValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.background_);
  }
  _impl_.background_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.background)
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill::release_background() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PatternFill_FillValue* released = _impl_.background_;
  _impl_.background_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill::unsafe_arena_release_background() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.background)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PatternFill_FillValue* temp = _impl_.background_;
  _impl_.background_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill::_internal_mutable_background() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.background_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PatternFill_FillValue>(GetArena());
    _impl_.background_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(p);
  }
  return _impl_.background_;
}
inline ::com::zoho::shapes::PatternFill_FillValue* PatternFill::mutable_background() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PatternFill_FillValue* _msg = _internal_mutable_background();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.background)
  return _msg;
}
inline void PatternFill::set_allocated_background(::com::zoho::shapes::PatternFill_FillValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(_impl_.background_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.background_ = reinterpret_cast<::com::zoho::shapes::PatternFill_FillValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.background)
}

// optional .com.zoho.shapes.PatternFill.DistanceBetweenShapes distance = 3;
inline bool PatternFill::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distance_ != nullptr);
  return value;
}
inline void PatternFill::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.distance_ != nullptr) _impl_.distance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::PatternFill_DistanceBetweenShapes& PatternFill::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* p = _impl_.distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PatternFill_DistanceBetweenShapes&>(::com::zoho::shapes::_PatternFill_DistanceBetweenShapes_default_instance_);
}
inline const ::com::zoho::shapes::PatternFill_DistanceBetweenShapes& PatternFill::distance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.distance)
  return _internal_distance();
}
inline void PatternFill::unsafe_arena_set_allocated_distance(::com::zoho::shapes::PatternFill_DistanceBetweenShapes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_);
  }
  _impl_.distance_ = reinterpret_cast<::com::zoho::shapes::PatternFill_DistanceBetweenShapes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PatternFill.distance)
}
inline ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* PatternFill::release_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* released = _impl_.distance_;
  _impl_.distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* PatternFill::unsafe_arena_release_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.distance)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* temp = _impl_.distance_;
  _impl_.distance_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* PatternFill::_internal_mutable_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PatternFill_DistanceBetweenShapes>(GetArena());
    _impl_.distance_ = reinterpret_cast<::com::zoho::shapes::PatternFill_DistanceBetweenShapes*>(p);
  }
  return _impl_.distance_;
}
inline ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* PatternFill::mutable_distance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PatternFill_DistanceBetweenShapes* _msg = _internal_mutable_distance();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.distance)
  return _msg;
}
inline void PatternFill::set_allocated_distance(::com::zoho::shapes::PatternFill_DistanceBetweenShapes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PatternFill_DistanceBetweenShapes*>(_impl_.distance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PatternFill_DistanceBetweenShapes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.distance_ = reinterpret_cast<::com::zoho::shapes::PatternFill_DistanceBetweenShapes*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.distance)
}

// optional string preset = 4;
inline bool PatternFill::has_preset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PatternFill::clear_preset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.preset_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PatternFill::preset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.preset)
  return _internal_preset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PatternFill::set_preset(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.preset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PatternFill.preset)
}
inline std::string* PatternFill::mutable_preset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_preset();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PatternFill.preset)
  return _s;
}
inline const std::string& PatternFill::_internal_preset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.preset_.Get();
}
inline void PatternFill::_internal_set_preset(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.preset_.Set(value, GetArena());
}
inline std::string* PatternFill::_internal_mutable_preset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.preset_.Mutable( GetArena());
}
inline std::string* PatternFill::release_preset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PatternFill.preset)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.preset_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.preset_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PatternFill::set_allocated_preset(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.preset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.preset_.IsDefault()) {
          _impl_.preset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PatternFill.preset)
}

// optional int32 rotate = 5;
inline bool PatternFill::has_rotate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PatternFill::clear_rotate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rotate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t PatternFill::rotate() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PatternFill.rotate)
  return _internal_rotate();
}
inline void PatternFill::set_rotate(::int32_t value) {
  _internal_set_rotate(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PatternFill.rotate)
}
inline ::int32_t PatternFill::_internal_rotate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotate_;
}
inline void PatternFill::_internal_set_rotate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rotate_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_patternfill_2eproto_2epb_2eh
