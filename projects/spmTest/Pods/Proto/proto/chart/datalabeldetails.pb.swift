// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: datalabeldetails.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct DataLabelDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data Label position.
  public var pos: ChartField.DataLabelPosition {
    get {return _storage._pos ?? .bestfit}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  public var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  public mutating func clearPos() {_uniqueStorage()._pos = nil}

  /// Show Bubble Size or not , for Bubble-Charts.
  public var bubbleSize: Bool {
    get {return _storage._bubbleSize ?? false}
    set {_uniqueStorage()._bubbleSize = newValue}
  }
  /// Returns true if `bubbleSize` has been explicitly set.
  public var hasBubbleSize: Bool {return _storage._bubbleSize != nil}
  /// Clears the value of `bubbleSize`. Subsequent reads from it will return its default value.
  public mutating func clearBubbleSize() {_uniqueStorage()._bubbleSize = nil}

  /// Show Category name or not.
  public var categoryName: Bool {
    get {return _storage._categoryName ?? false}
    set {_uniqueStorage()._categoryName = newValue}
  }
  /// Returns true if `categoryName` has been explicitly set.
  public var hasCategoryName: Bool {return _storage._categoryName != nil}
  /// Clears the value of `categoryName`. Subsequent reads from it will return its default value.
  public mutating func clearCategoryName() {_uniqueStorage()._categoryName = nil}

  /// Show LegendKey or not.
  public var legendKey: Bool {
    get {return _storage._legendKey ?? false}
    set {_uniqueStorage()._legendKey = newValue}
  }
  /// Returns true if `legendKey` has been explicitly set.
  public var hasLegendKey: Bool {return _storage._legendKey != nil}
  /// Clears the value of `legendKey`. Subsequent reads from it will return its default value.
  public mutating func clearLegendKey() {_uniqueStorage()._legendKey = nil}

  /// Show Value or not.
  public var value: Bool {
    get {return _storage._value ?? false}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  /// Show Percent or not.
  public var percent: Bool {
    get {return _storage._percent ?? false}
    set {_uniqueStorage()._percent = newValue}
  }
  /// Returns true if `percent` has been explicitly set.
  public var hasPercent: Bool {return _storage._percent != nil}
  /// Clears the value of `percent`. Subsequent reads from it will return its default value.
  public mutating func clearPercent() {_uniqueStorage()._percent = nil}

  /// Show Series Name or not.
  public var seriesName: Bool {
    get {return _storage._seriesName ?? false}
    set {_uniqueStorage()._seriesName = newValue}
  }
  /// Returns true if `seriesName` has been explicitly set.
  public var hasSeriesName: Bool {return _storage._seriesName != nil}
  /// Clears the value of `seriesName`. Subsequent reads from it will return its default value.
  public mutating func clearSeriesName() {_uniqueStorage()._seriesName = nil}

  /// Show Leader lines or not.
  public var leaderLine: Bool {
    get {return _storage._leaderLine ?? false}
    set {_uniqueStorage()._leaderLine = newValue}
  }
  /// Returns true if `leaderLine` has been explicitly set.
  public var hasLeaderLine: Bool {return _storage._leaderLine != nil}
  /// Clears the value of `leaderLine`. Subsequent reads from it will return its default value.
  public mutating func clearLeaderLine() {_uniqueStorage()._leaderLine = nil}

  public var sep: DataLabelDetails.Separator {
    get {return _storage._sep ?? DataLabelDetails.Separator()}
    set {_uniqueStorage()._sep = newValue}
  }
  /// Returns true if `sep` has been explicitly set.
  public var hasSep: Bool {return _storage._sep != nil}
  /// Clears the value of `sep`. Subsequent reads from it will return its default value.
  public mutating func clearSep() {_uniqueStorage()._sep = nil}

  /// Text
  public var textBody: TextBody {
    get {return _storage._textBody ?? TextBody()}
    set {_uniqueStorage()._textBody = newValue}
  }
  /// Returns true if `textBody` has been explicitly set.
  public var hasTextBody: Bool {return _storage._textBody != nil}
  /// Clears the value of `textBody`. Subsequent reads from it will return its default value.
  public mutating func clearTextBody() {_uniqueStorage()._textBody = nil}

  /// Properties
  public var props: Properties {
    get {return _storage._props ?? Properties()}
    set {_uniqueStorage()._props = newValue}
  }
  /// Returns true if `props` has been explicitly set.
  public var hasProps: Bool {return _storage._props != nil}
  /// Clears the value of `props`. Subsequent reads from it will return its default value.
  public mutating func clearProps() {_uniqueStorage()._props = nil}

  public var numberFormat: NumberFormat {
    get {return _storage._numberFormat ?? NumberFormat()}
    set {_uniqueStorage()._numberFormat = newValue}
  }
  /// Returns true if `numberFormat` has been explicitly set.
  public var hasNumberFormat: Bool {return _storage._numberFormat != nil}
  /// Clears the value of `numberFormat`. Subsequent reads from it will return its default value.
  public mutating func clearNumberFormat() {_uniqueStorage()._numberFormat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Separator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: DataLabelDetails.Separator.SeparatorType {
      get {return _type ?? .comma}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var t: String {
      get {return _t ?? String()}
      set {_t = newValue}
    }
    /// Returns true if `t` has been explicitly set.
    public var hasT: Bool {return self._t != nil}
    /// Clears the value of `t`. Subsequent reads from it will return its default value.
    public mutating func clearT() {self._t = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum SeparatorType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case comma // = 0
      case semicolon // = 1
      case period // = 2
      case newline // = 3
      case space // = 4
      case any // = 5

      public init() {
        self = .comma
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .comma
        case 1: self = .semicolon
        case 2: self = .period
        case 3: self = .newline
        case 4: self = .space
        case 5: self = .any
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .comma: return 0
        case .semicolon: return 1
        case .period: return 2
        case .newline: return 3
        case .space: return 4
        case .any: return 5
        }
      }

    }

    public init() {}

    fileprivate var _type: DataLabelDetails.Separator.SeparatorType? = nil
    fileprivate var _t: String? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension DataLabelDetails.Separator.SeparatorType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension DataLabelDetails: @unchecked Sendable {}
extension DataLabelDetails.Separator: @unchecked Sendable {}
extension DataLabelDetails.Separator.SeparatorType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.chart"

extension DataLabelDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataLabelDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "bubbleSize"),
    3: .same(proto: "categoryName"),
    4: .same(proto: "legendKey"),
    5: .same(proto: "value"),
    6: .same(proto: "percent"),
    7: .same(proto: "seriesName"),
    8: .same(proto: "leaderLine"),
    9: .same(proto: "sep"),
    10: .same(proto: "textBody"),
    11: .same(proto: "props"),
    12: .same(proto: "numberFormat"),
  ]

  fileprivate class _StorageClass {
    var _pos: ChartField.DataLabelPosition? = nil
    var _bubbleSize: Bool? = nil
    var _categoryName: Bool? = nil
    var _legendKey: Bool? = nil
    var _value: Bool? = nil
    var _percent: Bool? = nil
    var _seriesName: Bool? = nil
    var _leaderLine: Bool? = nil
    var _sep: DataLabelDetails.Separator? = nil
    var _textBody: TextBody? = nil
    var _props: Properties? = nil
    var _numberFormat: NumberFormat? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pos = source._pos
      _bubbleSize = source._bubbleSize
      _categoryName = source._categoryName
      _legendKey = source._legendKey
      _value = source._value
      _percent = source._percent
      _seriesName = source._seriesName
      _leaderLine = source._leaderLine
      _sep = source._sep
      _textBody = source._textBody
      _props = source._props
      _numberFormat = source._numberFormat
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sep, !v.isInitialized {return false}
      if let v = _storage._textBody, !v.isInitialized {return false}
      if let v = _storage._props, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._pos) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._bubbleSize) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._categoryName) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._legendKey) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._value) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._percent) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._seriesName) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._leaderLine) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._sep) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._textBody) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._props) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._numberFormat) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pos {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._bubbleSize {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._categoryName {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._legendKey {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._percent {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._seriesName {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._leaderLine {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._sep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._textBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._props {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._numberFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataLabelDetails, rhs: DataLabelDetails) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._bubbleSize != rhs_storage._bubbleSize {return false}
        if _storage._categoryName != rhs_storage._categoryName {return false}
        if _storage._legendKey != rhs_storage._legendKey {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._percent != rhs_storage._percent {return false}
        if _storage._seriesName != rhs_storage._seriesName {return false}
        if _storage._leaderLine != rhs_storage._leaderLine {return false}
        if _storage._sep != rhs_storage._sep {return false}
        if _storage._textBody != rhs_storage._textBody {return false}
        if _storage._props != rhs_storage._props {return false}
        if _storage._numberFormat != rhs_storage._numberFormat {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataLabelDetails.Separator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DataLabelDetails.protoMessageName + ".Separator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "t"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._t) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._t {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataLabelDetails.Separator, rhs: DataLabelDetails.Separator) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._t != rhs._t {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataLabelDetails.Separator.SeparatorType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMA"),
    1: .same(proto: "SEMICOLON"),
    2: .same(proto: "PERIOD"),
    3: .same(proto: "NEWLINE"),
    4: .same(proto: "SPACE"),
    5: .same(proto: "ANY"),
  ]
}
