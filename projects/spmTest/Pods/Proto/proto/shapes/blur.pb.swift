// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: blur.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Blur {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Blur.BlurType {
    get {return _type ?? .unknownType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var box: Blur.BaseBlur {
    get {return _box ?? Blur.BaseBlur()}
    set {_box = newValue}
  }
  /// Returns true if `box` has been explicitly set.
  public var hasBox: Bool {return self._box != nil}
  /// Clears the value of `box`. Subsequent reads from it will return its default value.
  public mutating func clearBox() {self._box = nil}

  public var disc: Blur.BaseBlur {
    get {return _disc ?? Blur.BaseBlur()}
    set {_disc = newValue}
  }
  /// Returns true if `disc` has been explicitly set.
  public var hasDisc: Bool {return self._disc != nil}
  /// Clears the value of `disc`. Subsequent reads from it will return its default value.
  public mutating func clearDisc() {self._disc = nil}

  public var gaussian: Blur.BaseBlur {
    get {return _gaussian ?? Blur.BaseBlur()}
    set {_gaussian = newValue}
  }
  /// Returns true if `gaussian` has been explicitly set.
  public var hasGaussian: Bool {return self._gaussian != nil}
  /// Clears the value of `gaussian`. Subsequent reads from it will return its default value.
  public mutating func clearGaussian() {self._gaussian = nil}

  public var motion: Blur.MotionBlur {
    get {return _motion ?? Blur.MotionBlur()}
    set {_motion = newValue}
  }
  /// Returns true if `motion` has been explicitly set.
  public var hasMotion: Bool {return self._motion != nil}
  /// Clears the value of `motion`. Subsequent reads from it will return its default value.
  public mutating func clearMotion() {self._motion = nil}

  public var zoom: Blur.ZoomBlur {
    get {return _zoom ?? Blur.ZoomBlur()}
    set {_zoom = newValue}
  }
  /// Returns true if `zoom` has been explicitly set.
  public var hasZoom: Bool {return self._zoom != nil}
  /// Clears the value of `zoom`. Subsequent reads from it will return its default value.
  public mutating func clearZoom() {self._zoom = nil}

  public var masked: Blur.BaseBlur {
    get {return _masked ?? Blur.BaseBlur()}
    set {_masked = newValue}
  }
  /// Returns true if `masked` has been explicitly set.
  public var hasMasked: Bool {return self._masked != nil}
  /// Clears the value of `masked`. Subsequent reads from it will return its default value.
  public mutating func clearMasked() {self._masked = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum BlurType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case box // = 1
    case disc // = 2
    case gaussian // = 3
    case motion // = 4
    case zoom // = 5
    case masked // = 6

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .box
      case 2: self = .disc
      case 3: self = .gaussian
      case 4: self = .motion
      case 5: self = .zoom
      case 6: self = .masked
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .box: return 1
      case .disc: return 2
      case .gaussian: return 3
      case .motion: return 4
      case .zoom: return 5
      case .masked: return 6
      }
    }

  }

  public struct BaseBlur {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var radius: Float {
      get {return _radius ?? 0}
      set {_radius = newValue}
    }
    /// Returns true if `radius` has been explicitly set.
    public var hasRadius: Bool {return self._radius != nil}
    /// Clears the value of `radius`. Subsequent reads from it will return its default value.
    public mutating func clearRadius() {self._radius = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _radius: Float? = nil
  }

  public struct MotionBlur {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var radius: Float {
      get {return _radius ?? 0}
      set {_radius = newValue}
    }
    /// Returns true if `radius` has been explicitly set.
    public var hasRadius: Bool {return self._radius != nil}
    /// Clears the value of `radius`. Subsequent reads from it will return its default value.
    public mutating func clearRadius() {self._radius = nil}

    public var angle: Float {
      get {return _angle ?? 0}
      set {_angle = newValue}
    }
    /// Returns true if `angle` has been explicitly set.
    public var hasAngle: Bool {return self._angle != nil}
    /// Clears the value of `angle`. Subsequent reads from it will return its default value.
    public mutating func clearAngle() {self._angle = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _radius: Float? = nil
    fileprivate var _angle: Float? = nil
  }

  public struct ZoomBlur {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var center: Position {
      get {return _center ?? Position()}
      set {_center = newValue}
    }
    /// Returns true if `center` has been explicitly set.
    public var hasCenter: Bool {return self._center != nil}
    /// Clears the value of `center`. Subsequent reads from it will return its default value.
    public mutating func clearCenter() {self._center = nil}

    public var distance: Float {
      get {return _distance ?? 0}
      set {_distance = newValue}
    }
    /// Returns true if `distance` has been explicitly set.
    public var hasDistance: Bool {return self._distance != nil}
    /// Clears the value of `distance`. Subsequent reads from it will return its default value.
    public mutating func clearDistance() {self._distance = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _center: Position? = nil
    fileprivate var _distance: Float? = nil
  }

  public init() {}

  fileprivate var _type: Blur.BlurType? = nil
  fileprivate var _box: Blur.BaseBlur? = nil
  fileprivate var _disc: Blur.BaseBlur? = nil
  fileprivate var _gaussian: Blur.BaseBlur? = nil
  fileprivate var _motion: Blur.MotionBlur? = nil
  fileprivate var _zoom: Blur.ZoomBlur? = nil
  fileprivate var _masked: Blur.BaseBlur? = nil
}

#if swift(>=4.2)

extension Blur.BlurType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Blur: @unchecked Sendable {}
extension Blur.BlurType: @unchecked Sendable {}
extension Blur.BaseBlur: @unchecked Sendable {}
extension Blur.MotionBlur: @unchecked Sendable {}
extension Blur.ZoomBlur: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension Blur: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Blur"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "box"),
    3: .same(proto: "disc"),
    4: .same(proto: "gaussian"),
    5: .same(proto: "motion"),
    6: .same(proto: "zoom"),
    7: .same(proto: "masked"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._box) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._disc) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._gaussian) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._motion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._zoom) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._masked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._box {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._disc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gaussian {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._motion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._zoom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._masked {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blur, rhs: Blur) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._box != rhs._box {return false}
    if lhs._disc != rhs._disc {return false}
    if lhs._gaussian != rhs._gaussian {return false}
    if lhs._motion != rhs._motion {return false}
    if lhs._zoom != rhs._zoom {return false}
    if lhs._masked != rhs._masked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blur.BlurType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "BOX"),
    2: .same(proto: "DISC"),
    3: .same(proto: "GAUSSIAN"),
    4: .same(proto: "MOTION"),
    5: .same(proto: "ZOOM"),
    6: .same(proto: "MASKED"),
  ]
}

extension Blur.BaseBlur: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Blur.protoMessageName + ".BaseBlur"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "radius"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._radius) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._radius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blur.BaseBlur, rhs: Blur.BaseBlur) -> Bool {
    if lhs._radius != rhs._radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blur.MotionBlur: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Blur.protoMessageName + ".MotionBlur"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "radius"),
    2: .same(proto: "angle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._radius) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._angle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._radius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._angle {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blur.MotionBlur, rhs: Blur.MotionBlur) -> Bool {
    if lhs._radius != rhs._radius {return false}
    if lhs._angle != rhs._angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blur.ZoomBlur: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Blur.protoMessageName + ".ZoomBlur"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "center"),
    2: .same(proto: "distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._center) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._distance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._center {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._distance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blur.ZoomBlur, rhs: Blur.ZoomBlur) -> Bool {
    if lhs._center != rhs._center {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
