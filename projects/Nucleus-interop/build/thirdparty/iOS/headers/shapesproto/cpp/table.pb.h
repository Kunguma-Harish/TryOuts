// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: table.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_table_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_table_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "fields.pb.h"
#include "textbody.pb.h"
#include "fill.pb.h"
#include "margin.pb.h"
#include "effects.pb.h"
#include "verticalaligntype.pb.h"
#include "tablecellstyle.pb.h"
#include "color.pb.h"
#include "animation.pb.h"
#include "animationdata.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_table_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_table_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_table_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class Table;
struct TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class Table_TableGrid;
struct Table_TableGridDefaultTypeInternal;
extern Table_TableGridDefaultTypeInternal _Table_TableGrid_default_instance_;
class Table_TableGrid_GridColumn;
struct Table_TableGrid_GridColumnDefaultTypeInternal;
extern Table_TableGrid_GridColumnDefaultTypeInternal _Table_TableGrid_GridColumn_default_instance_;
class Table_TableProperties;
struct Table_TablePropertiesDefaultTypeInternal;
extern Table_TablePropertiesDefaultTypeInternal _Table_TableProperties_default_instance_;
class Table_TableRow;
struct Table_TableRowDefaultTypeInternal;
extern Table_TableRowDefaultTypeInternal _Table_TableRow_default_instance_;
class Table_TableRow_TableCell;
struct Table_TableRow_TableCellDefaultTypeInternal;
extern Table_TableRow_TableCellDefaultTypeInternal _Table_TableRow_TableCell_default_instance_;
class Table_TableRow_TableCell_MergeCell;
struct Table_TableRow_TableCell_MergeCellDefaultTypeInternal;
extern Table_TableRow_TableCell_MergeCellDefaultTypeInternal _Table_TableRow_TableCell_MergeCell_default_instance_;
class Table_TableRow_TableCell_TableCellProperties;
struct Table_TableRow_TableCell_TableCellPropertiesDefaultTypeInternal;
extern Table_TableRow_TableCell_TableCellPropertiesDefaultTypeInternal _Table_TableRow_TableCell_TableCellProperties_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {
enum Table_TableRow_TableCell_TableCellProperties_TextOverflow : int {
  Table_TableRow_TableCell_TableCellProperties_TextOverflow_CLIP = 0,
  Table_TableRow_TableCell_TableCellProperties_TextOverflow_ALLOW = 1,
};

bool Table_TableRow_TableCell_TableCellProperties_TextOverflow_IsValid(int value);
extern const uint32_t Table_TableRow_TableCell_TableCellProperties_TextOverflow_internal_data_[];
constexpr Table_TableRow_TableCell_TableCellProperties_TextOverflow Table_TableRow_TableCell_TableCellProperties_TextOverflow_TextOverflow_MIN = static_cast<Table_TableRow_TableCell_TableCellProperties_TextOverflow>(0);
constexpr Table_TableRow_TableCell_TableCellProperties_TextOverflow Table_TableRow_TableCell_TableCellProperties_TextOverflow_TextOverflow_MAX = static_cast<Table_TableRow_TableCell_TableCellProperties_TextOverflow>(1);
constexpr int Table_TableRow_TableCell_TableCellProperties_TextOverflow_TextOverflow_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Table_TableRow_TableCell_TableCellProperties_TextOverflow_descriptor();
template <typename T>
const std::string& Table_TableRow_TableCell_TableCellProperties_TextOverflow_Name(T value) {
  static_assert(std::is_same<T, Table_TableRow_TableCell_TableCellProperties_TextOverflow>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TextOverflow_Name().");
  return Table_TableRow_TableCell_TableCellProperties_TextOverflow_Name(static_cast<Table_TableRow_TableCell_TableCellProperties_TextOverflow>(value));
}
template <>
inline const std::string& Table_TableRow_TableCell_TableCellProperties_TextOverflow_Name(Table_TableRow_TableCell_TableCellProperties_TextOverflow value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Table_TableRow_TableCell_TableCellProperties_TextOverflow_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Table_TableRow_TableCell_TableCellProperties_TextOverflow_Parse(absl::string_view name, Table_TableRow_TableCell_TableCellProperties_TextOverflow* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Table_TableRow_TableCell_TableCellProperties_TextOverflow>(
      Table_TableRow_TableCell_TableCellProperties_TextOverflow_descriptor(), name, value);
}
enum Table_TableDataType : int {
  Table_TableDataType_DEFAULT_TABLE_DATA = 0,
  Table_TableDataType_BASIC = 1,
  Table_TableDataType_DATAFIELD = 2,
};

bool Table_TableDataType_IsValid(int value);
extern const uint32_t Table_TableDataType_internal_data_[];
constexpr Table_TableDataType Table_TableDataType_TableDataType_MIN = static_cast<Table_TableDataType>(0);
constexpr Table_TableDataType Table_TableDataType_TableDataType_MAX = static_cast<Table_TableDataType>(2);
constexpr int Table_TableDataType_TableDataType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Table_TableDataType_descriptor();
template <typename T>
const std::string& Table_TableDataType_Name(T value) {
  static_assert(std::is_same<T, Table_TableDataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TableDataType_Name().");
  return Table_TableDataType_Name(static_cast<Table_TableDataType>(value));
}
template <>
inline const std::string& Table_TableDataType_Name(Table_TableDataType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Table_TableDataType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Table_TableDataType_Parse(absl::string_view name, Table_TableDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Table_TableDataType>(
      Table_TableDataType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Table_TableRow_TableCell_MergeCell final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table.TableRow.TableCell.MergeCell) */ {
 public:
  inline Table_TableRow_TableCell_MergeCell() : Table_TableRow_TableCell_MergeCell(nullptr) {}
  ~Table_TableRow_TableCell_MergeCell() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table_TableRow_TableCell_MergeCell(::google::protobuf::internal::ConstantInitialized);

  inline Table_TableRow_TableCell_MergeCell(const Table_TableRow_TableCell_MergeCell& from)
      : Table_TableRow_TableCell_MergeCell(nullptr, from) {}
  Table_TableRow_TableCell_MergeCell(Table_TableRow_TableCell_MergeCell&& from) noexcept
    : Table_TableRow_TableCell_MergeCell() {
    *this = ::std::move(from);
  }

  inline Table_TableRow_TableCell_MergeCell& operator=(const Table_TableRow_TableCell_MergeCell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_TableRow_TableCell_MergeCell& operator=(Table_TableRow_TableCell_MergeCell&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_TableRow_TableCell_MergeCell& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_TableRow_TableCell_MergeCell* internal_default_instance() {
    return reinterpret_cast<const Table_TableRow_TableCell_MergeCell*>(
               &_Table_TableRow_TableCell_MergeCell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Table_TableRow_TableCell_MergeCell& a, Table_TableRow_TableCell_MergeCell& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_TableRow_TableCell_MergeCell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_TableRow_TableCell_MergeCell* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_TableRow_TableCell_MergeCell* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_TableRow_TableCell_MergeCell>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table_TableRow_TableCell_MergeCell& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table_TableRow_TableCell_MergeCell& from) {
    Table_TableRow_TableCell_MergeCell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table_TableRow_TableCell_MergeCell* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table.TableRow.TableCell.MergeCell";
  }
  protected:
  explicit Table_TableRow_TableCell_MergeCell(::google::protobuf::Arena* arena);
  Table_TableRow_TableCell_MergeCell(::google::protobuf::Arena* arena, const Table_TableRow_TableCell_MergeCell& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpanFieldNumber = 1,
    kMergeFieldNumber = 2,
  };
  // optional int32 span = 1;
  bool has_span() const;
  void clear_span() ;
  ::int32_t span() const;
  void set_span(::int32_t value);

  private:
  ::int32_t _internal_span() const;
  void _internal_set_span(::int32_t value);

  public:
  // optional int32 merge = 2;
  bool has_merge() const;
  void clear_merge() ;
  ::int32_t merge() const;
  void set_merge(::int32_t value);

  private:
  ::int32_t _internal_merge() const;
  void _internal_set_merge(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table.TableRow.TableCell.MergeCell)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t span_;
    ::int32_t merge_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};// -------------------------------------------------------------------

class Table_TableRow_TableCell_TableCellProperties final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties) */ {
 public:
  inline Table_TableRow_TableCell_TableCellProperties() : Table_TableRow_TableCell_TableCellProperties(nullptr) {}
  ~Table_TableRow_TableCell_TableCellProperties() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table_TableRow_TableCell_TableCellProperties(::google::protobuf::internal::ConstantInitialized);

  inline Table_TableRow_TableCell_TableCellProperties(const Table_TableRow_TableCell_TableCellProperties& from)
      : Table_TableRow_TableCell_TableCellProperties(nullptr, from) {}
  Table_TableRow_TableCell_TableCellProperties(Table_TableRow_TableCell_TableCellProperties&& from) noexcept
    : Table_TableRow_TableCell_TableCellProperties() {
    *this = ::std::move(from);
  }

  inline Table_TableRow_TableCell_TableCellProperties& operator=(const Table_TableRow_TableCell_TableCellProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_TableRow_TableCell_TableCellProperties& operator=(Table_TableRow_TableCell_TableCellProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_TableRow_TableCell_TableCellProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_TableRow_TableCell_TableCellProperties* internal_default_instance() {
    return reinterpret_cast<const Table_TableRow_TableCell_TableCellProperties*>(
               &_Table_TableRow_TableCell_TableCellProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Table_TableRow_TableCell_TableCellProperties& a, Table_TableRow_TableCell_TableCellProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_TableRow_TableCell_TableCellProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_TableRow_TableCell_TableCellProperties* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_TableRow_TableCell_TableCellProperties* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_TableRow_TableCell_TableCellProperties>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table_TableRow_TableCell_TableCellProperties& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table_TableRow_TableCell_TableCellProperties& from) {
    Table_TableRow_TableCell_TableCellProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table_TableRow_TableCell_TableCellProperties* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties";
  }
  protected:
  explicit Table_TableRow_TableCell_TableCellProperties(::google::protobuf::Arena* arena);
  Table_TableRow_TableCell_TableCellProperties(::google::protobuf::Arena* arena, const Table_TableRow_TableCell_TableCellProperties& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TextOverflow = Table_TableRow_TableCell_TableCellProperties_TextOverflow;
  static constexpr TextOverflow CLIP = Table_TableRow_TableCell_TableCellProperties_TextOverflow_CLIP;
  static constexpr TextOverflow ALLOW = Table_TableRow_TableCell_TableCellProperties_TextOverflow_ALLOW;
  static inline bool TextOverflow_IsValid(int value) {
    return Table_TableRow_TableCell_TableCellProperties_TextOverflow_IsValid(value);
  }
  static constexpr TextOverflow TextOverflow_MIN = Table_TableRow_TableCell_TableCellProperties_TextOverflow_TextOverflow_MIN;
  static constexpr TextOverflow TextOverflow_MAX = Table_TableRow_TableCell_TableCellProperties_TextOverflow_TextOverflow_MAX;
  static constexpr int TextOverflow_ARRAYSIZE = Table_TableRow_TableCell_TableCellProperties_TextOverflow_TextOverflow_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TextOverflow_descriptor() {
    return Table_TableRow_TableCell_TableCellProperties_TextOverflow_descriptor();
  }
  template <typename T>
  static inline const std::string& TextOverflow_Name(T value) {
    return Table_TableRow_TableCell_TableCellProperties_TextOverflow_Name(value);
  }
  static inline bool TextOverflow_Parse(absl::string_view name, TextOverflow* value) {
    return Table_TableRow_TableCell_TableCellProperties_TextOverflow_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 2,
    kStyleFieldNumber = 1,
    kMarginFieldNumber = 3,
    kTextDirFieldNumber = 5,
    kTextOverflowFieldNumber = 6,
    kValignFieldNumber = 4,
  };
  // repeated string headers = 2;
  int headers_size() const;
  private:
  int _internal_headers_size() const;

  public:
  void clear_headers() ;
  const std::string& headers(int index) const;
  std::string* mutable_headers(int index);
  void set_headers(int index, const std::string& value);
  void set_headers(int index, std::string&& value);
  void set_headers(int index, const char* value);
  void set_headers(int index, const char* value, std::size_t size);
  void set_headers(int index, absl::string_view value);
  std::string* add_headers();
  void add_headers(const std::string& value);
  void add_headers(std::string&& value);
  void add_headers(const char* value);
  void add_headers(const char* value, std::size_t size);
  void add_headers(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& headers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_headers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_headers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_headers();

  public:
  // optional .com.zoho.shapes.TableCellStyle style = 1;
  bool has_style() const;
  void clear_style() ;
  const ::com::zoho::shapes::TableCellStyle& style() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::TableCellStyle* release_style();
  ::com::zoho::shapes::TableCellStyle* mutable_style();
  void set_allocated_style(::com::zoho::shapes::TableCellStyle* value);
  void unsafe_arena_set_allocated_style(::com::zoho::shapes::TableCellStyle* value);
  ::com::zoho::shapes::TableCellStyle* unsafe_arena_release_style();

  private:
  const ::com::zoho::shapes::TableCellStyle& _internal_style() const;
  ::com::zoho::shapes::TableCellStyle* _internal_mutable_style();

  public:
  // optional .com.zoho.shapes.Margin margin = 3;
  bool has_margin() const;
  void clear_margin() ;
  const ::com::zoho::shapes::Margin& margin() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Margin* release_margin();
  ::com::zoho::shapes::Margin* mutable_margin();
  void set_allocated_margin(::com::zoho::shapes::Margin* value);
  void unsafe_arena_set_allocated_margin(::com::zoho::shapes::Margin* value);
  ::com::zoho::shapes::Margin* unsafe_arena_release_margin();

  private:
  const ::com::zoho::shapes::Margin& _internal_margin() const;
  ::com::zoho::shapes::Margin* _internal_mutable_margin();

  public:
  // optional .Show.TableField.TextDirection textDir = 5;
  bool has_textdir() const;
  void clear_textdir() ;
  ::Show::TableField_TextDirection textdir() const;
  void set_textdir(::Show::TableField_TextDirection value);

  private:
  ::Show::TableField_TextDirection _internal_textdir() const;
  void _internal_set_textdir(::Show::TableField_TextDirection value);

  public:
  // optional .com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.TextOverflow textOverflow = 6;
  bool has_textoverflow() const;
  void clear_textoverflow() ;
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow textoverflow() const;
  void set_textoverflow(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow value);

  private:
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow _internal_textoverflow() const;
  void _internal_set_textoverflow(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow value);

  public:
  // optional .com.zoho.common.VerticalAlignType valign = 4 [default = TOP];
  bool has_valign() const;
  void clear_valign() ;
  ::com::zoho::common::VerticalAlignType valign() const;
  void set_valign(::com::zoho::common::VerticalAlignType value);

  private:
  ::com::zoho::common::VerticalAlignType _internal_valign() const;
  void _internal_set_valign(::com::zoho::common::VerticalAlignType value);

  public:
  void temp_setstyle(com::zoho::shapes::TableCellStyle* style) {
    if(&this->style() != style) {
      set_allocated_style(style);
    }
  }
  
  com::zoho::shapes::TableCellStyle* temp_getstyle() const {
    if (has_style()) 
      return (const_cast<com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(this))->mutable_style();
    return nullptr;
  }
  
  google::protobuf::RepeatedPtrField<std::string>* temp_getheaders() const {
    return const_cast<com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(this)->mutable_headers();
  }
  
  void temp_setheaders(const google::protobuf::RepeatedPtrField<std::string>* headers) {
    if(this->mutable_headers() != headers) {
      const_cast<com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(this)->mutable_headers()->CopyFrom(*headers);
    }}
  
  void temp_setmargin(com::zoho::shapes::Margin* margin) {
    if(&this->margin() != margin) {
      set_allocated_margin(margin);
    }
  }
  
  com::zoho::shapes::Margin* temp_getmargin() const {
    if (has_margin()) 
      return (const_cast<com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(this))->mutable_margin();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> headers_;
    ::com::zoho::shapes::TableCellStyle* style_;
    ::com::zoho::shapes::Margin* margin_;
    int textdir_;
    int textoverflow_;
    int valign_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};// -------------------------------------------------------------------

class Table_TableGrid_GridColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table.TableGrid.GridColumn) */ {
 public:
  inline Table_TableGrid_GridColumn() : Table_TableGrid_GridColumn(nullptr) {}
  ~Table_TableGrid_GridColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table_TableGrid_GridColumn(::google::protobuf::internal::ConstantInitialized);

  inline Table_TableGrid_GridColumn(const Table_TableGrid_GridColumn& from)
      : Table_TableGrid_GridColumn(nullptr, from) {}
  Table_TableGrid_GridColumn(Table_TableGrid_GridColumn&& from) noexcept
    : Table_TableGrid_GridColumn() {
    *this = ::std::move(from);
  }

  inline Table_TableGrid_GridColumn& operator=(const Table_TableGrid_GridColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_TableGrid_GridColumn& operator=(Table_TableGrid_GridColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_TableGrid_GridColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_TableGrid_GridColumn* internal_default_instance() {
    return reinterpret_cast<const Table_TableGrid_GridColumn*>(
               &_Table_TableGrid_GridColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Table_TableGrid_GridColumn& a, Table_TableGrid_GridColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_TableGrid_GridColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_TableGrid_GridColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_TableGrid_GridColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_TableGrid_GridColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table_TableGrid_GridColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table_TableGrid_GridColumn& from) {
    Table_TableGrid_GridColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table_TableGrid_GridColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table.TableGrid.GridColumn";
  }
  protected:
  explicit Table_TableGrid_GridColumn(::google::protobuf::Arena* arena);
  Table_TableGrid_GridColumn(::google::protobuf::Arena* arena, const Table_TableGrid_GridColumn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimDatasFieldNumber = 2,
    kIdFieldNumber = 3,
    kWidthFieldNumber = 1,
  };
  // repeated .com.zoho.shapes.AnimationData animDatas = 2;
  int animdatas_size() const;
  private:
  int _internal_animdatas_size() const;

  public:
  void clear_animdatas() ;
  ::com::zoho::shapes::AnimationData* mutable_animdatas(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData >*
      mutable_animdatas();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>& _internal_animdatas() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>* _internal_mutable_animdatas();
  public:
  const ::com::zoho::shapes::AnimationData& animdatas(int index) const;
  ::com::zoho::shapes::AnimationData* add_animdatas();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData >&
      animdatas() const;
  // optional string id = 3;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required float width = 1;
  bool has_width() const;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  google::protobuf::RepeatedPtrField<com::zoho::shapes::AnimationData>* temp_getanimDatas() const {
    return const_cast<com::zoho::shapes::Table_TableGrid_GridColumn*>(this)->mutable_animdatas();
  }
  
  void temp_setanimDatas(const google::protobuf::RepeatedPtrField<com::zoho::shapes::AnimationData>* animDatas) {
    if(this->mutable_animdatas() != animDatas) {
      const_cast<com::zoho::shapes::Table_TableGrid_GridColumn*>(this)->mutable_animdatas()->CopyFrom(*animDatas);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table.TableGrid.GridColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData > animdatas_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    float width_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};// -------------------------------------------------------------------

class Table_TableProperties final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table.TableProperties) */ {
 public:
  inline Table_TableProperties() : Table_TableProperties(nullptr) {}
  ~Table_TableProperties() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table_TableProperties(::google::protobuf::internal::ConstantInitialized);

  inline Table_TableProperties(const Table_TableProperties& from)
      : Table_TableProperties(nullptr, from) {}
  Table_TableProperties(Table_TableProperties&& from) noexcept
    : Table_TableProperties() {
    *this = ::std::move(from);
  }

  inline Table_TableProperties& operator=(const Table_TableProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_TableProperties& operator=(Table_TableProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_TableProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_TableProperties* internal_default_instance() {
    return reinterpret_cast<const Table_TableProperties*>(
               &_Table_TableProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Table_TableProperties& a, Table_TableProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_TableProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_TableProperties* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_TableProperties* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_TableProperties>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table_TableProperties& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table_TableProperties& from) {
    Table_TableProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table_TableProperties* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table.TableProperties";
  }
  protected:
  explicit Table_TableProperties(::google::protobuf::Arena* arena);
  Table_TableProperties(::google::protobuf::Arena* arena, const Table_TableProperties& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimFieldNumber = 11,
    kStyleIdFieldNumber = 3,
    kFillFieldNumber = 1,
    kEffectsFieldNumber = 2,
    kStyleColorFieldNumber = 10,
    kFirstRowFieldNumber = 4,
    kLastRowFieldNumber = 5,
    kBandColFieldNumber = 6,
    kBandRowFieldNumber = 7,
    kFirstColFieldNumber = 8,
    kLastColFieldNumber = 9,
  };
  // repeated .com.zoho.shapes.Animation anim = 11;
  int anim_size() const;
  private:
  int _internal_anim_size() const;

  public:
  void clear_anim() ;
  ::com::zoho::shapes::Animation* mutable_anim(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Animation >*
      mutable_anim();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Animation>& _internal_anim() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Animation>* _internal_mutable_anim();
  public:
  const ::com::zoho::shapes::Animation& anim(int index) const;
  ::com::zoho::shapes::Animation* add_anim();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Animation >&
      anim() const;
  // optional string styleId = 3;
  bool has_styleid() const;
  void clear_styleid() ;
  const std::string& styleid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_styleid(Arg_&& arg, Args_... args);
  std::string* mutable_styleid();
  PROTOBUF_NODISCARD std::string* release_styleid();
  void set_allocated_styleid(std::string* value);

  private:
  const std::string& _internal_styleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_styleid(
      const std::string& value);
  std::string* _internal_mutable_styleid();

  public:
  // optional .com.zoho.shapes.Fill fill = 1;
  bool has_fill() const;
  void clear_fill() ;
  const ::com::zoho::shapes::Fill& fill() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Fill* release_fill();
  ::com::zoho::shapes::Fill* mutable_fill();
  void set_allocated_fill(::com::zoho::shapes::Fill* value);
  void unsafe_arena_set_allocated_fill(::com::zoho::shapes::Fill* value);
  ::com::zoho::shapes::Fill* unsafe_arena_release_fill();

  private:
  const ::com::zoho::shapes::Fill& _internal_fill() const;
  ::com::zoho::shapes::Fill* _internal_mutable_fill();

  public:
  // optional .com.zoho.shapes.Effects effects = 2;
  bool has_effects() const;
  void clear_effects() ;
  const ::com::zoho::shapes::Effects& effects() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Effects* release_effects();
  ::com::zoho::shapes::Effects* mutable_effects();
  void set_allocated_effects(::com::zoho::shapes::Effects* value);
  void unsafe_arena_set_allocated_effects(::com::zoho::shapes::Effects* value);
  ::com::zoho::shapes::Effects* unsafe_arena_release_effects();

  private:
  const ::com::zoho::shapes::Effects& _internal_effects() const;
  ::com::zoho::shapes::Effects* _internal_mutable_effects();

  public:
  // optional .com.zoho.shapes.Color styleColor = 10;
  bool has_stylecolor() const;
  void clear_stylecolor() ;
  const ::com::zoho::shapes::Color& stylecolor() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Color* release_stylecolor();
  ::com::zoho::shapes::Color* mutable_stylecolor();
  void set_allocated_stylecolor(::com::zoho::shapes::Color* value);
  void unsafe_arena_set_allocated_stylecolor(::com::zoho::shapes::Color* value);
  ::com::zoho::shapes::Color* unsafe_arena_release_stylecolor();

  private:
  const ::com::zoho::shapes::Color& _internal_stylecolor() const;
  ::com::zoho::shapes::Color* _internal_mutable_stylecolor();

  public:
  // optional bool firstRow = 4;
  bool has_firstrow() const;
  void clear_firstrow() ;
  bool firstrow() const;
  void set_firstrow(bool value);

  private:
  bool _internal_firstrow() const;
  void _internal_set_firstrow(bool value);

  public:
  // optional bool lastRow = 5;
  bool has_lastrow() const;
  void clear_lastrow() ;
  bool lastrow() const;
  void set_lastrow(bool value);

  private:
  bool _internal_lastrow() const;
  void _internal_set_lastrow(bool value);

  public:
  // optional bool bandCol = 6;
  bool has_bandcol() const;
  void clear_bandcol() ;
  bool bandcol() const;
  void set_bandcol(bool value);

  private:
  bool _internal_bandcol() const;
  void _internal_set_bandcol(bool value);

  public:
  // optional bool bandRow = 7;
  bool has_bandrow() const;
  void clear_bandrow() ;
  bool bandrow() const;
  void set_bandrow(bool value);

  private:
  bool _internal_bandrow() const;
  void _internal_set_bandrow(bool value);

  public:
  // optional bool firstCol = 8;
  bool has_firstcol() const;
  void clear_firstcol() ;
  bool firstcol() const;
  void set_firstcol(bool value);

  private:
  bool _internal_firstcol() const;
  void _internal_set_firstcol(bool value);

  public:
  // optional bool lastCol = 9;
  bool has_lastcol() const;
  void clear_lastcol() ;
  bool lastcol() const;
  void set_lastcol(bool value);

  private:
  bool _internal_lastcol() const;
  void _internal_set_lastcol(bool value);

  public:
  void temp_setfill(com::zoho::shapes::Fill* fill) {
    if(&this->fill() != fill) {
      set_allocated_fill(fill);
    }
  }
  
  com::zoho::shapes::Fill* temp_getfill() const {
    if (has_fill()) 
      return (const_cast<com::zoho::shapes::Table_TableProperties*>(this))->mutable_fill();
    return nullptr;
  }
  
  void temp_seteffects(com::zoho::shapes::Effects* effects) {
    if(&this->effects() != effects) {
      set_allocated_effects(effects);
    }
  }
  
  com::zoho::shapes::Effects* temp_geteffects() const {
    if (has_effects()) 
      return (const_cast<com::zoho::shapes::Table_TableProperties*>(this))->mutable_effects();
    return nullptr;
  }
  
  void temp_setstyleColor(com::zoho::shapes::Color* styleColor) {
    if(&this->stylecolor() != styleColor) {
      set_allocated_stylecolor(styleColor);
    }
  }
  
  com::zoho::shapes::Color* temp_getstyleColor() const {
    if (has_stylecolor()) 
      return (const_cast<com::zoho::shapes::Table_TableProperties*>(this))->mutable_stylecolor();
    return nullptr;
  }
  
  google::protobuf::RepeatedPtrField<com::zoho::shapes::Animation>* temp_getanim() const {
    return const_cast<com::zoho::shapes::Table_TableProperties*>(this)->mutable_anim();
  }
  
  void temp_setanim(const google::protobuf::RepeatedPtrField<com::zoho::shapes::Animation>* anim) {
    if(this->mutable_anim() != anim) {
      const_cast<com::zoho::shapes::Table_TableProperties*>(this)->mutable_anim()->CopyFrom(*anim);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table.TableProperties)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 4,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Animation > anim_;
    ::google::protobuf::internal::ArenaStringPtr styleid_;
    ::com::zoho::shapes::Fill* fill_;
    ::com::zoho::shapes::Effects* effects_;
    ::com::zoho::shapes::Color* stylecolor_;
    bool firstrow_;
    bool lastrow_;
    bool bandcol_;
    bool bandrow_;
    bool firstcol_;
    bool lastcol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};// -------------------------------------------------------------------

class Table_TableGrid final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table.TableGrid) */ {
 public:
  inline Table_TableGrid() : Table_TableGrid(nullptr) {}
  ~Table_TableGrid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table_TableGrid(::google::protobuf::internal::ConstantInitialized);

  inline Table_TableGrid(const Table_TableGrid& from)
      : Table_TableGrid(nullptr, from) {}
  Table_TableGrid(Table_TableGrid&& from) noexcept
    : Table_TableGrid() {
    *this = ::std::move(from);
  }

  inline Table_TableGrid& operator=(const Table_TableGrid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_TableGrid& operator=(Table_TableGrid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_TableGrid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_TableGrid* internal_default_instance() {
    return reinterpret_cast<const Table_TableGrid*>(
               &_Table_TableGrid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Table_TableGrid& a, Table_TableGrid& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_TableGrid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_TableGrid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_TableGrid* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_TableGrid>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table_TableGrid& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table_TableGrid& from) {
    Table_TableGrid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table_TableGrid* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table.TableGrid";
  }
  protected:
  explicit Table_TableGrid(::google::protobuf::Arena* arena);
  Table_TableGrid(::google::protobuf::Arena* arena, const Table_TableGrid& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using GridColumn = Table_TableGrid_GridColumn;

  // accessors -------------------------------------------------------

  enum : int {
    kColFieldNumber = 1,
  };
  // repeated .com.zoho.shapes.Table.TableGrid.GridColumn col = 1;
  int col_size() const;
  private:
  int _internal_col_size() const;

  public:
  void clear_col() ;
  ::com::zoho::shapes::Table_TableGrid_GridColumn* mutable_col(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableGrid_GridColumn >*
      mutable_col();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableGrid_GridColumn>& _internal_col() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableGrid_GridColumn>* _internal_mutable_col();
  public:
  const ::com::zoho::shapes::Table_TableGrid_GridColumn& col(int index) const;
  ::com::zoho::shapes::Table_TableGrid_GridColumn* add_col();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableGrid_GridColumn >&
      col() const;
  google::protobuf::RepeatedPtrField<com::zoho::shapes::Table_TableGrid_GridColumn>* temp_getcol() const {
    return const_cast<com::zoho::shapes::Table_TableGrid*>(this)->mutable_col();
  }
  
  void temp_setcol(const google::protobuf::RepeatedPtrField<com::zoho::shapes::Table_TableGrid_GridColumn>* col) {
    if(this->mutable_col() != col) {
      const_cast<com::zoho::shapes::Table_TableGrid*>(this)->mutable_col()->CopyFrom(*col);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table.TableGrid)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableGrid_GridColumn > col_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};// -------------------------------------------------------------------

class Table_TableRow_TableCell final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table.TableRow.TableCell) */ {
 public:
  inline Table_TableRow_TableCell() : Table_TableRow_TableCell(nullptr) {}
  ~Table_TableRow_TableCell() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table_TableRow_TableCell(::google::protobuf::internal::ConstantInitialized);

  inline Table_TableRow_TableCell(const Table_TableRow_TableCell& from)
      : Table_TableRow_TableCell(nullptr, from) {}
  Table_TableRow_TableCell(Table_TableRow_TableCell&& from) noexcept
    : Table_TableRow_TableCell() {
    *this = ::std::move(from);
  }

  inline Table_TableRow_TableCell& operator=(const Table_TableRow_TableCell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_TableRow_TableCell& operator=(Table_TableRow_TableCell&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_TableRow_TableCell& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_TableRow_TableCell* internal_default_instance() {
    return reinterpret_cast<const Table_TableRow_TableCell*>(
               &_Table_TableRow_TableCell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Table_TableRow_TableCell& a, Table_TableRow_TableCell& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_TableRow_TableCell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_TableRow_TableCell* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_TableRow_TableCell* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_TableRow_TableCell>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table_TableRow_TableCell& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table_TableRow_TableCell& from) {
    Table_TableRow_TableCell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table_TableRow_TableCell* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table.TableRow.TableCell";
  }
  protected:
  explicit Table_TableRow_TableCell(::google::protobuf::Arena* arena);
  Table_TableRow_TableCell(::google::protobuf::Arena* arena, const Table_TableRow_TableCell& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MergeCell = Table_TableRow_TableCell_MergeCell;
  using TableCellProperties = Table_TableRow_TableCell_TableCellProperties;

  // accessors -------------------------------------------------------

  enum : int {
    kAnimDatasFieldNumber = 6,
    kIdFieldNumber = 1,
    kTextBodyFieldNumber = 2,
    kColFieldNumber = 3,
    kRowFieldNumber = 4,
    kPropsFieldNumber = 5,
  };
  // repeated .com.zoho.shapes.AnimationData animDatas = 6;
  int animdatas_size() const;
  private:
  int _internal_animdatas_size() const;

  public:
  void clear_animdatas() ;
  ::com::zoho::shapes::AnimationData* mutable_animdatas(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData >*
      mutable_animdatas();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>& _internal_animdatas() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>* _internal_mutable_animdatas();
  public:
  const ::com::zoho::shapes::AnimationData& animdatas(int index) const;
  ::com::zoho::shapes::AnimationData* add_animdatas();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData >&
      animdatas() const;
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .com.zoho.shapes.TextBody textBody = 2;
  bool has_textbody() const;
  void clear_textbody() ;
  const ::com::zoho::shapes::TextBody& textbody() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::TextBody* release_textbody();
  ::com::zoho::shapes::TextBody* mutable_textbody();
  void set_allocated_textbody(::com::zoho::shapes::TextBody* value);
  void unsafe_arena_set_allocated_textbody(::com::zoho::shapes::TextBody* value);
  ::com::zoho::shapes::TextBody* unsafe_arena_release_textbody();

  private:
  const ::com::zoho::shapes::TextBody& _internal_textbody() const;
  ::com::zoho::shapes::TextBody* _internal_mutable_textbody();

  public:
  // optional .com.zoho.shapes.Table.TableRow.TableCell.MergeCell col = 3;
  bool has_col() const;
  void clear_col() ;
  const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& col() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* release_col();
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* mutable_col();
  void set_allocated_col(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value);
  void unsafe_arena_set_allocated_col(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value);
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* unsafe_arena_release_col();

  private:
  const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& _internal_col() const;
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* _internal_mutable_col();

  public:
  // optional .com.zoho.shapes.Table.TableRow.TableCell.MergeCell row = 4;
  bool has_row() const;
  void clear_row() ;
  const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& row() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* release_row();
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* mutable_row();
  void set_allocated_row(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value);
  void unsafe_arena_set_allocated_row(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value);
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* unsafe_arena_release_row();

  private:
  const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& _internal_row() const;
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* _internal_mutable_row();

  public:
  // optional .com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties props = 5;
  bool has_props() const;
  void clear_props() ;
  const ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties& props() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* release_props();
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* mutable_props();
  void set_allocated_props(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* value);
  void unsafe_arena_set_allocated_props(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* value);
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* unsafe_arena_release_props();

  private:
  const ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties& _internal_props() const;
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* _internal_mutable_props();

  public:
  void temp_settextBody(com::zoho::shapes::TextBody* textBody) {
    if(&this->textbody() != textBody) {
      set_allocated_textbody(textBody);
    }
  }
  
  com::zoho::shapes::TextBody* temp_gettextBody() const {
    if (has_textbody()) 
      return (const_cast<com::zoho::shapes::Table_TableRow_TableCell*>(this))->mutable_textbody();
    return nullptr;
  }
  
  void temp_setcol(com::zoho::shapes::Table_TableRow_TableCell_MergeCell* col) {
    if(&this->col() != col) {
      set_allocated_col(col);
    }
  }
  
  com::zoho::shapes::Table_TableRow_TableCell_MergeCell* temp_getcol() const {
    if (has_col()) 
      return (const_cast<com::zoho::shapes::Table_TableRow_TableCell*>(this))->mutable_col();
    return nullptr;
  }
  
  void temp_setrow(com::zoho::shapes::Table_TableRow_TableCell_MergeCell* row) {
    if(&this->row() != row) {
      set_allocated_row(row);
    }
  }
  
  com::zoho::shapes::Table_TableRow_TableCell_MergeCell* temp_getrow() const {
    if (has_row()) 
      return (const_cast<com::zoho::shapes::Table_TableRow_TableCell*>(this))->mutable_row();
    return nullptr;
  }
  
  void temp_setprops(com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* props) {
    if(&this->props() != props) {
      set_allocated_props(props);
    }
  }
  
  com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* temp_getprops() const {
    if (has_props()) 
      return (const_cast<com::zoho::shapes::Table_TableRow_TableCell*>(this))->mutable_props();
    return nullptr;
  }
  
  google::protobuf::RepeatedPtrField<com::zoho::shapes::AnimationData>* temp_getanimDatas() const {
    return const_cast<com::zoho::shapes::Table_TableRow_TableCell*>(this)->mutable_animdatas();
  }
  
  void temp_setanimDatas(const google::protobuf::RepeatedPtrField<com::zoho::shapes::AnimationData>* animDatas) {
    if(this->mutable_animdatas() != animDatas) {
      const_cast<com::zoho::shapes::Table_TableRow_TableCell*>(this)->mutable_animdatas()->CopyFrom(*animDatas);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table.TableRow.TableCell)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData > animdatas_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::com::zoho::shapes::TextBody* textbody_;
    ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* col_;
    ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* row_;
    ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* props_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};// -------------------------------------------------------------------

class Table_TableRow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table.TableRow) */ {
 public:
  inline Table_TableRow() : Table_TableRow(nullptr) {}
  ~Table_TableRow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table_TableRow(::google::protobuf::internal::ConstantInitialized);

  inline Table_TableRow(const Table_TableRow& from)
      : Table_TableRow(nullptr, from) {}
  Table_TableRow(Table_TableRow&& from) noexcept
    : Table_TableRow() {
    *this = ::std::move(from);
  }

  inline Table_TableRow& operator=(const Table_TableRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table_TableRow& operator=(Table_TableRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table_TableRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table_TableRow* internal_default_instance() {
    return reinterpret_cast<const Table_TableRow*>(
               &_Table_TableRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Table_TableRow& a, Table_TableRow& b) {
    a.Swap(&b);
  }
  inline void Swap(Table_TableRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table_TableRow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table_TableRow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table_TableRow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table_TableRow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table_TableRow& from) {
    Table_TableRow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table_TableRow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table.TableRow";
  }
  protected:
  explicit Table_TableRow(::google::protobuf::Arena* arena);
  Table_TableRow(::google::protobuf::Arena* arena, const Table_TableRow& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TableCell = Table_TableRow_TableCell;

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 2,
    kAnimDatasFieldNumber = 3,
    kDatafieldIdFieldNumber = 4,
    kIdFieldNumber = 5,
    kHeightFieldNumber = 1,
  };
  // repeated .com.zoho.shapes.Table.TableRow.TableCell cell = 2;
  int cell_size() const;
  private:
  int _internal_cell_size() const;

  public:
  void clear_cell() ;
  ::com::zoho::shapes::Table_TableRow_TableCell* mutable_cell(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableRow_TableCell >*
      mutable_cell();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow_TableCell>& _internal_cell() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow_TableCell>* _internal_mutable_cell();
  public:
  const ::com::zoho::shapes::Table_TableRow_TableCell& cell(int index) const;
  ::com::zoho::shapes::Table_TableRow_TableCell* add_cell();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableRow_TableCell >&
      cell() const;
  // repeated .com.zoho.shapes.AnimationData animDatas = 3;
  int animdatas_size() const;
  private:
  int _internal_animdatas_size() const;

  public:
  void clear_animdatas() ;
  ::com::zoho::shapes::AnimationData* mutable_animdatas(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData >*
      mutable_animdatas();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>& _internal_animdatas() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>* _internal_mutable_animdatas();
  public:
  const ::com::zoho::shapes::AnimationData& animdatas(int index) const;
  ::com::zoho::shapes::AnimationData* add_animdatas();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData >&
      animdatas() const;
  // optional string datafieldId = 4;
  bool has_datafieldid() const;
  void clear_datafieldid() ;
  const std::string& datafieldid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_datafieldid(Arg_&& arg, Args_... args);
  std::string* mutable_datafieldid();
  PROTOBUF_NODISCARD std::string* release_datafieldid();
  void set_allocated_datafieldid(std::string* value);

  private:
  const std::string& _internal_datafieldid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datafieldid(
      const std::string& value);
  std::string* _internal_mutable_datafieldid();

  public:
  // optional string id = 5;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // required float height = 1;
  bool has_height() const;
  void clear_height() ;
  float height() const;
  void set_height(float value);

  private:
  float _internal_height() const;
  void _internal_set_height(float value);

  public:
  google::protobuf::RepeatedPtrField<com::zoho::shapes::Table_TableRow_TableCell>* temp_getcell() const {
    return const_cast<com::zoho::shapes::Table_TableRow*>(this)->mutable_cell();
  }
  
  void temp_setcell(const google::protobuf::RepeatedPtrField<com::zoho::shapes::Table_TableRow_TableCell>* cell) {
    if(this->mutable_cell() != cell) {
      const_cast<com::zoho::shapes::Table_TableRow*>(this)->mutable_cell()->CopyFrom(*cell);
    }}
  
  google::protobuf::RepeatedPtrField<com::zoho::shapes::AnimationData>* temp_getanimDatas() const {
    return const_cast<com::zoho::shapes::Table_TableRow*>(this)->mutable_animdatas();
  }
  
  void temp_setanimDatas(const google::protobuf::RepeatedPtrField<com::zoho::shapes::AnimationData>* animDatas) {
    if(this->mutable_animdatas() != animDatas) {
      const_cast<com::zoho::shapes::Table_TableRow*>(this)->mutable_animdatas()->CopyFrom(*animDatas);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table.TableRow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableRow_TableCell > cell_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::AnimationData > animdatas_;
    ::google::protobuf::internal::ArenaStringPtr datafieldid_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    float height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};// -------------------------------------------------------------------

class Table final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  ~Table() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table(::google::protobuf::internal::ConstantInitialized);

  inline Table(const Table& from)
      : Table(nullptr, from) {}
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table& from) {
    Table::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Table";
  }
  protected:
  explicit Table(::google::protobuf::Arena* arena);
  Table(::google::protobuf::Arena* arena, const Table& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TableGrid = Table_TableGrid;
  using TableRow = Table_TableRow;
  using TableProperties = Table_TableProperties;

  using TableDataType = Table_TableDataType;
  static constexpr TableDataType DEFAULT_TABLE_DATA = Table_TableDataType_DEFAULT_TABLE_DATA;
  static constexpr TableDataType BASIC = Table_TableDataType_BASIC;
  static constexpr TableDataType DATAFIELD = Table_TableDataType_DATAFIELD;
  static inline bool TableDataType_IsValid(int value) {
    return Table_TableDataType_IsValid(value);
  }
  static constexpr TableDataType TableDataType_MIN = Table_TableDataType_TableDataType_MIN;
  static constexpr TableDataType TableDataType_MAX = Table_TableDataType_TableDataType_MAX;
  static constexpr int TableDataType_ARRAYSIZE = Table_TableDataType_TableDataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TableDataType_descriptor() {
    return Table_TableDataType_descriptor();
  }
  template <typename T>
  static inline const std::string& TableDataType_Name(T value) {
    return Table_TableDataType_Name(value);
  }
  static inline bool TableDataType_Parse(absl::string_view name, TableDataType* value) {
    return Table_TableDataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 2,
    kDatafieldIdFieldNumber = 5,
    kGridFieldNumber = 1,
    kPropsFieldNumber = 3,
    kIgnoreMinimumHeightFieldNumber = 4,
    kDataTypeFieldNumber = 6,
  };
  // repeated .com.zoho.shapes.Table.TableRow row = 2;
  int row_size() const;
  private:
  int _internal_row_size() const;

  public:
  void clear_row() ;
  ::com::zoho::shapes::Table_TableRow* mutable_row(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableRow >*
      mutable_row();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow>& _internal_row() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow>* _internal_mutable_row();
  public:
  const ::com::zoho::shapes::Table_TableRow& row(int index) const;
  ::com::zoho::shapes::Table_TableRow* add_row();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableRow >&
      row() const;
  // optional string datafieldId = 5;
  bool has_datafieldid() const;
  void clear_datafieldid() ;
  const std::string& datafieldid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_datafieldid(Arg_&& arg, Args_... args);
  std::string* mutable_datafieldid();
  PROTOBUF_NODISCARD std::string* release_datafieldid();
  void set_allocated_datafieldid(std::string* value);

  private:
  const std::string& _internal_datafieldid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datafieldid(
      const std::string& value);
  std::string* _internal_mutable_datafieldid();

  public:
  // required .com.zoho.shapes.Table.TableGrid grid = 1;
  bool has_grid() const;
  void clear_grid() ;
  const ::com::zoho::shapes::Table_TableGrid& grid() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Table_TableGrid* release_grid();
  ::com::zoho::shapes::Table_TableGrid* mutable_grid();
  void set_allocated_grid(::com::zoho::shapes::Table_TableGrid* value);
  void unsafe_arena_set_allocated_grid(::com::zoho::shapes::Table_TableGrid* value);
  ::com::zoho::shapes::Table_TableGrid* unsafe_arena_release_grid();

  private:
  const ::com::zoho::shapes::Table_TableGrid& _internal_grid() const;
  ::com::zoho::shapes::Table_TableGrid* _internal_mutable_grid();

  public:
  // optional .com.zoho.shapes.Table.TableProperties props = 3;
  bool has_props() const;
  void clear_props() ;
  const ::com::zoho::shapes::Table_TableProperties& props() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Table_TableProperties* release_props();
  ::com::zoho::shapes::Table_TableProperties* mutable_props();
  void set_allocated_props(::com::zoho::shapes::Table_TableProperties* value);
  void unsafe_arena_set_allocated_props(::com::zoho::shapes::Table_TableProperties* value);
  ::com::zoho::shapes::Table_TableProperties* unsafe_arena_release_props();

  private:
  const ::com::zoho::shapes::Table_TableProperties& _internal_props() const;
  ::com::zoho::shapes::Table_TableProperties* _internal_mutable_props();

  public:
  // optional bool ignoreMinimumHeight = 4;
  bool has_ignoreminimumheight() const;
  void clear_ignoreminimumheight() ;
  bool ignoreminimumheight() const;
  void set_ignoreminimumheight(bool value);

  private:
  bool _internal_ignoreminimumheight() const;
  void _internal_set_ignoreminimumheight(bool value);

  public:
  // optional .com.zoho.shapes.Table.TableDataType dataType = 6;
  bool has_datatype() const;
  void clear_datatype() ;
  ::com::zoho::shapes::Table_TableDataType datatype() const;
  void set_datatype(::com::zoho::shapes::Table_TableDataType value);

  private:
  ::com::zoho::shapes::Table_TableDataType _internal_datatype() const;
  void _internal_set_datatype(::com::zoho::shapes::Table_TableDataType value);

  public:
  void temp_setgrid(com::zoho::shapes::Table_TableGrid* grid) {
    if(&this->grid() != grid) {
      set_allocated_grid(grid);
    }
  }
  
  com::zoho::shapes::Table_TableGrid* temp_getgrid() const {
    if (has_grid()) 
      return (const_cast<com::zoho::shapes::Table*>(this))->mutable_grid();
    return nullptr;
  }
  
  google::protobuf::RepeatedPtrField<com::zoho::shapes::Table_TableRow>* temp_getrow() const {
    return const_cast<com::zoho::shapes::Table*>(this)->mutable_row();
  }
  
  void temp_setrow(const google::protobuf::RepeatedPtrField<com::zoho::shapes::Table_TableRow>* row) {
    if(this->mutable_row() != row) {
      const_cast<com::zoho::shapes::Table*>(this)->mutable_row()->CopyFrom(*row);
    }}
  
  void temp_setprops(com::zoho::shapes::Table_TableProperties* props) {
    if(&this->props() != props) {
      set_allocated_props(props);
    }
  }
  
  com::zoho::shapes::Table_TableProperties* temp_getprops() const {
    if (has_props()) 
      return (const_cast<com::zoho::shapes::Table*>(this))->mutable_props();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Table)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Table_TableRow > row_;
    ::google::protobuf::internal::ArenaStringPtr datafieldid_;
    ::com::zoho::shapes::Table_TableGrid* grid_;
    ::com::zoho::shapes::Table_TableProperties* props_;
    bool ignoreminimumheight_;
    int datatype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_table_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Table_TableGrid_GridColumn

// required float width = 1;
inline bool Table_TableGrid_GridColumn::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Table_TableGrid_GridColumn::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Table_TableGrid_GridColumn::width() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableGrid.GridColumn.width)
  return _internal_width();
}
inline void Table_TableGrid_GridColumn::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableGrid.GridColumn.width)
}
inline float Table_TableGrid_GridColumn::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Table_TableGrid_GridColumn::_internal_set_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.width_ = value;
}

// repeated .com.zoho.shapes.AnimationData animDatas = 2;
inline int Table_TableGrid_GridColumn::_internal_animdatas_size() const {
  return _internal_animdatas().size();
}
inline int Table_TableGrid_GridColumn::animdatas_size() const {
  return _internal_animdatas_size();
}
inline ::com::zoho::shapes::AnimationData* Table_TableGrid_GridColumn::mutable_animdatas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableGrid.GridColumn.animDatas)
  return _internal_mutable_animdatas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>* Table_TableGrid_GridColumn::mutable_animdatas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.TableGrid.GridColumn.animDatas)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_animdatas();
}
inline const ::com::zoho::shapes::AnimationData& Table_TableGrid_GridColumn::animdatas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableGrid.GridColumn.animDatas)
  return _internal_animdatas().Get(index);
}
inline ::com::zoho::shapes::AnimationData* Table_TableGrid_GridColumn::add_animdatas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::AnimationData* _add = _internal_mutable_animdatas()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableGrid.GridColumn.animDatas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>& Table_TableGrid_GridColumn::animdatas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.TableGrid.GridColumn.animDatas)
  return _internal_animdatas();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>&
Table_TableGrid_GridColumn::_internal_animdatas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.animdatas_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>*
Table_TableGrid_GridColumn::_internal_mutable_animdatas() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.animdatas_;
}

// optional string id = 3;
inline bool Table_TableGrid_GridColumn::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Table_TableGrid_GridColumn::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Table_TableGrid_GridColumn::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableGrid.GridColumn.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table_TableGrid_GridColumn::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableGrid.GridColumn.id)
}
inline std::string* Table_TableGrid_GridColumn::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableGrid.GridColumn.id)
  return _s;
}
inline const std::string& Table_TableGrid_GridColumn::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Table_TableGrid_GridColumn::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Table_TableGrid_GridColumn::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Table_TableGrid_GridColumn::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableGrid.GridColumn.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Table_TableGrid_GridColumn::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableGrid.GridColumn.id)
}

// -------------------------------------------------------------------

// Table_TableGrid

// repeated .com.zoho.shapes.Table.TableGrid.GridColumn col = 1;
inline int Table_TableGrid::_internal_col_size() const {
  return _internal_col().size();
}
inline int Table_TableGrid::col_size() const {
  return _internal_col_size();
}
inline void Table_TableGrid::clear_col() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.col_.Clear();
}
inline ::com::zoho::shapes::Table_TableGrid_GridColumn* Table_TableGrid::mutable_col(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableGrid.col)
  return _internal_mutable_col()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableGrid_GridColumn>* Table_TableGrid::mutable_col()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.TableGrid.col)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_col();
}
inline const ::com::zoho::shapes::Table_TableGrid_GridColumn& Table_TableGrid::col(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableGrid.col)
  return _internal_col().Get(index);
}
inline ::com::zoho::shapes::Table_TableGrid_GridColumn* Table_TableGrid::add_col() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::Table_TableGrid_GridColumn* _add = _internal_mutable_col()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableGrid.col)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableGrid_GridColumn>& Table_TableGrid::col() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.TableGrid.col)
  return _internal_col();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableGrid_GridColumn>&
Table_TableGrid::_internal_col() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.col_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableGrid_GridColumn>*
Table_TableGrid::_internal_mutable_col() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.col_;
}

// -------------------------------------------------------------------

// Table_TableRow_TableCell_MergeCell

// optional int32 span = 1;
inline bool Table_TableRow_TableCell_MergeCell::has_span() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Table_TableRow_TableCell_MergeCell::clear_span() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.span_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Table_TableRow_TableCell_MergeCell::span() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.MergeCell.span)
  return _internal_span();
}
inline void Table_TableRow_TableCell_MergeCell::set_span(::int32_t value) {
  _internal_set_span(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.MergeCell.span)
}
inline ::int32_t Table_TableRow_TableCell_MergeCell::_internal_span() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.span_;
}
inline void Table_TableRow_TableCell_MergeCell::_internal_set_span(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.span_ = value;
}

// optional int32 merge = 2;
inline bool Table_TableRow_TableCell_MergeCell::has_merge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Table_TableRow_TableCell_MergeCell::clear_merge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.merge_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Table_TableRow_TableCell_MergeCell::merge() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.MergeCell.merge)
  return _internal_merge();
}
inline void Table_TableRow_TableCell_MergeCell::set_merge(::int32_t value) {
  _internal_set_merge(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.MergeCell.merge)
}
inline ::int32_t Table_TableRow_TableCell_MergeCell::_internal_merge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.merge_;
}
inline void Table_TableRow_TableCell_MergeCell::_internal_set_merge(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.merge_ = value;
}

// -------------------------------------------------------------------

// Table_TableRow_TableCell_TableCellProperties

// optional .com.zoho.shapes.TableCellStyle style = 1;
inline bool Table_TableRow_TableCell_TableCellProperties::has_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.style_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::TableCellStyle& Table_TableRow_TableCell_TableCellProperties::_internal_style() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::TableCellStyle* p = _impl_.style_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::TableCellStyle&>(::com::zoho::shapes::_TableCellStyle_default_instance_);
}
inline const ::com::zoho::shapes::TableCellStyle& Table_TableRow_TableCell_TableCellProperties::style() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.style)
  return _internal_style();
}
inline void Table_TableRow_TableCell_TableCellProperties::unsafe_arena_set_allocated_style(::com::zoho::shapes::TableCellStyle* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.style_);
  }
  _impl_.style_ = reinterpret_cast<::com::zoho::shapes::TableCellStyle*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.style)
}
inline ::com::zoho::shapes::TableCellStyle* Table_TableRow_TableCell_TableCellProperties::release_style() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::TableCellStyle* released = _impl_.style_;
  _impl_.style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::TableCellStyle* Table_TableRow_TableCell_TableCellProperties::unsafe_arena_release_style() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.style)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::TableCellStyle* temp = _impl_.style_;
  _impl_.style_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::TableCellStyle* Table_TableRow_TableCell_TableCellProperties::_internal_mutable_style() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.style_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::TableCellStyle>(GetArena());
    _impl_.style_ = reinterpret_cast<::com::zoho::shapes::TableCellStyle*>(p);
  }
  return _impl_.style_;
}
inline ::com::zoho::shapes::TableCellStyle* Table_TableRow_TableCell_TableCellProperties::mutable_style() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::TableCellStyle* _msg = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.style)
  return _msg;
}
inline void Table_TableRow_TableCell_TableCellProperties::set_allocated_style(::com::zoho::shapes::TableCellStyle* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.style_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.style_ = reinterpret_cast<::com::zoho::shapes::TableCellStyle*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.style)
}

// repeated string headers = 2;
inline int Table_TableRow_TableCell_TableCellProperties::_internal_headers_size() const {
  return _internal_headers().size();
}
inline int Table_TableRow_TableCell_TableCellProperties::headers_size() const {
  return _internal_headers_size();
}
inline void Table_TableRow_TableCell_TableCellProperties::clear_headers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headers_.Clear();
}
inline std::string* Table_TableRow_TableCell_TableCellProperties::add_headers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_headers()->Add();
  // @@protoc_insertion_point(field_add_mutable:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
  return _s;
}
inline const std::string& Table_TableRow_TableCell_TableCellProperties::headers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
  return _internal_headers().Get(index);
}
inline std::string* Table_TableRow_TableCell_TableCellProperties::mutable_headers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
  return _internal_mutable_headers()->Mutable(index);
}
inline void Table_TableRow_TableCell_TableCellProperties::set_headers(int index, const std::string& value) {
  _internal_mutable_headers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::set_headers(int index, std::string&& value) {
  _internal_mutable_headers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::set_headers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_headers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::set_headers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_headers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::set_headers(int index, absl::string_view value) {
  _internal_mutable_headers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::add_headers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_headers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::add_headers(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_headers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::add_headers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_headers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::add_headers(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_headers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline void Table_TableRow_TableCell_TableCellProperties::add_headers(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_headers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Table_TableRow_TableCell_TableCellProperties::headers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
  return _internal_headers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Table_TableRow_TableCell_TableCellProperties::mutable_headers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.headers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_headers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Table_TableRow_TableCell_TableCellProperties::_internal_headers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Table_TableRow_TableCell_TableCellProperties::_internal_mutable_headers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.headers_;
}

// optional .com.zoho.shapes.Margin margin = 3;
inline bool Table_TableRow_TableCell_TableCellProperties::has_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.margin_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Margin& Table_TableRow_TableCell_TableCellProperties::_internal_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Margin* p = _impl_.margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Margin&>(::com::zoho::shapes::_Margin_default_instance_);
}
inline const ::com::zoho::shapes::Margin& Table_TableRow_TableCell_TableCellProperties::margin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.margin)
  return _internal_margin();
}
inline void Table_TableRow_TableCell_TableCellProperties::unsafe_arena_set_allocated_margin(::com::zoho::shapes::Margin* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.margin_);
  }
  _impl_.margin_ = reinterpret_cast<::com::zoho::shapes::Margin*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.margin)
}
inline ::com::zoho::shapes::Margin* Table_TableRow_TableCell_TableCellProperties::release_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Margin* released = _impl_.margin_;
  _impl_.margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Margin* Table_TableRow_TableCell_TableCellProperties::unsafe_arena_release_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.margin)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Margin* temp = _impl_.margin_;
  _impl_.margin_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Margin* Table_TableRow_TableCell_TableCellProperties::_internal_mutable_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Margin>(GetArena());
    _impl_.margin_ = reinterpret_cast<::com::zoho::shapes::Margin*>(p);
  }
  return _impl_.margin_;
}
inline ::com::zoho::shapes::Margin* Table_TableRow_TableCell_TableCellProperties::mutable_margin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Margin* _msg = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.margin)
  return _msg;
}
inline void Table_TableRow_TableCell_TableCellProperties::set_allocated_margin(::com::zoho::shapes::Margin* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.margin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.margin_ = reinterpret_cast<::com::zoho::shapes::Margin*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.margin)
}

// optional .com.zoho.common.VerticalAlignType valign = 4 [default = TOP];
inline bool Table_TableRow_TableCell_TableCellProperties::has_valign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Table_TableRow_TableCell_TableCellProperties::clear_valign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.valign_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::com::zoho::common::VerticalAlignType Table_TableRow_TableCell_TableCellProperties::valign() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.valign)
  return _internal_valign();
}
inline void Table_TableRow_TableCell_TableCellProperties::set_valign(::com::zoho::common::VerticalAlignType value) {
  _internal_set_valign(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.valign)
}
inline ::com::zoho::common::VerticalAlignType Table_TableRow_TableCell_TableCellProperties::_internal_valign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::VerticalAlignType>(_impl_.valign_);
}
inline void Table_TableRow_TableCell_TableCellProperties::_internal_set_valign(::com::zoho::common::VerticalAlignType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::com::zoho::common::VerticalAlignType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.valign_ = value;
}

// optional .Show.TableField.TextDirection textDir = 5;
inline bool Table_TableRow_TableCell_TableCellProperties::has_textdir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Table_TableRow_TableCell_TableCellProperties::clear_textdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.textdir_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::Show::TableField_TextDirection Table_TableRow_TableCell_TableCellProperties::textdir() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.textDir)
  return _internal_textdir();
}
inline void Table_TableRow_TableCell_TableCellProperties::set_textdir(::Show::TableField_TextDirection value) {
  _internal_set_textdir(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.textDir)
}
inline ::Show::TableField_TextDirection Table_TableRow_TableCell_TableCellProperties::_internal_textdir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::TableField_TextDirection>(_impl_.textdir_);
}
inline void Table_TableRow_TableCell_TableCellProperties::_internal_set_textdir(::Show::TableField_TextDirection value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::Show::TableField_TextDirection_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.textdir_ = value;
}

// optional .com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.TextOverflow textOverflow = 6;
inline bool Table_TableRow_TableCell_TableCellProperties::has_textoverflow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Table_TableRow_TableCell_TableCellProperties::clear_textoverflow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.textoverflow_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow Table_TableRow_TableCell_TableCellProperties::textoverflow() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.textOverflow)
  return _internal_textoverflow();
}
inline void Table_TableRow_TableCell_TableCellProperties::set_textoverflow(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow value) {
  _internal_set_textoverflow(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties.textOverflow)
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow Table_TableRow_TableCell_TableCellProperties::_internal_textoverflow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow>(_impl_.textoverflow_);
}
inline void Table_TableRow_TableCell_TableCellProperties::_internal_set_textoverflow(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.textoverflow_ = value;
}

// -------------------------------------------------------------------

// Table_TableRow_TableCell

// optional string id = 1;
inline bool Table_TableRow_TableCell::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Table_TableRow_TableCell::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Table_TableRow_TableCell::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table_TableRow_TableCell::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.TableCell.id)
}
inline std::string* Table_TableRow_TableCell::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.id)
  return _s;
}
inline const std::string& Table_TableRow_TableCell::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Table_TableRow_TableCell::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Table_TableRow_TableCell::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Table_TableRow_TableCell::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.TableCell.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Table_TableRow_TableCell::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.id)
}

// optional .com.zoho.shapes.TextBody textBody = 2;
inline bool Table_TableRow_TableCell::has_textbody() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.textbody_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::TextBody& Table_TableRow_TableCell::_internal_textbody() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::TextBody* p = _impl_.textbody_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::TextBody&>(::com::zoho::shapes::_TextBody_default_instance_);
}
inline const ::com::zoho::shapes::TextBody& Table_TableRow_TableCell::textbody() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.textBody)
  return _internal_textbody();
}
inline void Table_TableRow_TableCell::unsafe_arena_set_allocated_textbody(::com::zoho::shapes::TextBody* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textbody_);
  }
  _impl_.textbody_ = reinterpret_cast<::com::zoho::shapes::TextBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.textBody)
}
inline ::com::zoho::shapes::TextBody* Table_TableRow_TableCell::release_textbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::TextBody* released = _impl_.textbody_;
  _impl_.textbody_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::TextBody* Table_TableRow_TableCell::unsafe_arena_release_textbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.TableCell.textBody)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::TextBody* temp = _impl_.textbody_;
  _impl_.textbody_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::TextBody* Table_TableRow_TableCell::_internal_mutable_textbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.textbody_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::TextBody>(GetArena());
    _impl_.textbody_ = reinterpret_cast<::com::zoho::shapes::TextBody*>(p);
  }
  return _impl_.textbody_;
}
inline ::com::zoho::shapes::TextBody* Table_TableRow_TableCell::mutable_textbody() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::TextBody* _msg = _internal_mutable_textbody();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.textBody)
  return _msg;
}
inline void Table_TableRow_TableCell::set_allocated_textbody(::com::zoho::shapes::TextBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textbody_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.textbody_ = reinterpret_cast<::com::zoho::shapes::TextBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.textBody)
}

// optional .com.zoho.shapes.Table.TableRow.TableCell.MergeCell col = 3;
inline bool Table_TableRow_TableCell::has_col() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.col_ != nullptr);
  return value;
}
inline void Table_TableRow_TableCell::clear_col() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.col_ != nullptr) _impl_.col_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& Table_TableRow_TableCell::_internal_col() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* p = _impl_.col_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell&>(::com::zoho::shapes::_Table_TableRow_TableCell_MergeCell_default_instance_);
}
inline const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& Table_TableRow_TableCell::col() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.col)
  return _internal_col();
}
inline void Table_TableRow_TableCell::unsafe_arena_set_allocated_col(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.col_);
  }
  _impl_.col_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.col)
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::release_col() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* released = _impl_.col_;
  _impl_.col_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::unsafe_arena_release_col() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.TableCell.col)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* temp = _impl_.col_;
  _impl_.col_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::_internal_mutable_col() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.col_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell>(GetArena());
    _impl_.col_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(p);
  }
  return _impl_.col_;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::mutable_col() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* _msg = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.col)
  return _msg;
}
inline void Table_TableRow_TableCell::set_allocated_col(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(_impl_.col_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.col_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.col)
}

// optional .com.zoho.shapes.Table.TableRow.TableCell.MergeCell row = 4;
inline bool Table_TableRow_TableCell::has_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.row_ != nullptr);
  return value;
}
inline void Table_TableRow_TableCell::clear_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.row_ != nullptr) _impl_.row_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& Table_TableRow_TableCell::_internal_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* p = _impl_.row_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell&>(::com::zoho::shapes::_Table_TableRow_TableCell_MergeCell_default_instance_);
}
inline const ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell& Table_TableRow_TableCell::row() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.row)
  return _internal_row();
}
inline void Table_TableRow_TableCell::unsafe_arena_set_allocated_row(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.row_);
  }
  _impl_.row_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.row)
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::release_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* released = _impl_.row_;
  _impl_.row_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::unsafe_arena_release_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.TableCell.row)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* temp = _impl_.row_;
  _impl_.row_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::_internal_mutable_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.row_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell>(GetArena());
    _impl_.row_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(p);
  }
  return _impl_.row_;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* Table_TableRow_TableCell::mutable_row() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* _msg = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.row)
  return _msg;
}
inline void Table_TableRow_TableCell::set_allocated_row(::com::zoho::shapes::Table_TableRow_TableCell_MergeCell* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(_impl_.row_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.row_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_MergeCell*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.row)
}

// optional .com.zoho.shapes.Table.TableRow.TableCell.TableCellProperties props = 5;
inline bool Table_TableRow_TableCell::has_props() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.props_ != nullptr);
  return value;
}
inline void Table_TableRow_TableCell::clear_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.props_ != nullptr) _impl_.props_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties& Table_TableRow_TableCell::_internal_props() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* p = _impl_.props_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties&>(::com::zoho::shapes::_Table_TableRow_TableCell_TableCellProperties_default_instance_);
}
inline const ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties& Table_TableRow_TableCell::props() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.props)
  return _internal_props();
}
inline void Table_TableRow_TableCell::unsafe_arena_set_allocated_props(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.props_);
  }
  _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.props)
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* Table_TableRow_TableCell::release_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* released = _impl_.props_;
  _impl_.props_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* Table_TableRow_TableCell::unsafe_arena_release_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.TableCell.props)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* temp = _impl_.props_;
  _impl_.props_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* Table_TableRow_TableCell::_internal_mutable_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.props_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties>(GetArena());
    _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(p);
  }
  return _impl_.props_;
}
inline ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* Table_TableRow_TableCell::mutable_props() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* _msg = _internal_mutable_props();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.props)
  return _msg;
}
inline void Table_TableRow_TableCell::set_allocated_props(::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(_impl_.props_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.TableCell.props)
}

// repeated .com.zoho.shapes.AnimationData animDatas = 6;
inline int Table_TableRow_TableCell::_internal_animdatas_size() const {
  return _internal_animdatas().size();
}
inline int Table_TableRow_TableCell::animdatas_size() const {
  return _internal_animdatas_size();
}
inline ::com::zoho::shapes::AnimationData* Table_TableRow_TableCell::mutable_animdatas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.TableCell.animDatas)
  return _internal_mutable_animdatas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>* Table_TableRow_TableCell::mutable_animdatas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.TableRow.TableCell.animDatas)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_animdatas();
}
inline const ::com::zoho::shapes::AnimationData& Table_TableRow_TableCell::animdatas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.TableCell.animDatas)
  return _internal_animdatas().Get(index);
}
inline ::com::zoho::shapes::AnimationData* Table_TableRow_TableCell::add_animdatas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::AnimationData* _add = _internal_mutable_animdatas()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableRow.TableCell.animDatas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>& Table_TableRow_TableCell::animdatas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.TableRow.TableCell.animDatas)
  return _internal_animdatas();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>&
Table_TableRow_TableCell::_internal_animdatas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.animdatas_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>*
Table_TableRow_TableCell::_internal_mutable_animdatas() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.animdatas_;
}

// -------------------------------------------------------------------

// Table_TableRow

// required float height = 1;
inline bool Table_TableRow::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Table_TableRow::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Table_TableRow::height() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.height)
  return _internal_height();
}
inline void Table_TableRow::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.height)
}
inline float Table_TableRow::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Table_TableRow::_internal_set_height(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_ = value;
}

// repeated .com.zoho.shapes.Table.TableRow.TableCell cell = 2;
inline int Table_TableRow::_internal_cell_size() const {
  return _internal_cell().size();
}
inline int Table_TableRow::cell_size() const {
  return _internal_cell_size();
}
inline void Table_TableRow::clear_cell() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cell_.Clear();
}
inline ::com::zoho::shapes::Table_TableRow_TableCell* Table_TableRow::mutable_cell(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.cell)
  return _internal_mutable_cell()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow_TableCell>* Table_TableRow::mutable_cell()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.TableRow.cell)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cell();
}
inline const ::com::zoho::shapes::Table_TableRow_TableCell& Table_TableRow::cell(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.cell)
  return _internal_cell().Get(index);
}
inline ::com::zoho::shapes::Table_TableRow_TableCell* Table_TableRow::add_cell() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::Table_TableRow_TableCell* _add = _internal_mutable_cell()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableRow.cell)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow_TableCell>& Table_TableRow::cell() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.TableRow.cell)
  return _internal_cell();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow_TableCell>&
Table_TableRow::_internal_cell() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cell_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow_TableCell>*
Table_TableRow::_internal_mutable_cell() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cell_;
}

// repeated .com.zoho.shapes.AnimationData animDatas = 3;
inline int Table_TableRow::_internal_animdatas_size() const {
  return _internal_animdatas().size();
}
inline int Table_TableRow::animdatas_size() const {
  return _internal_animdatas_size();
}
inline ::com::zoho::shapes::AnimationData* Table_TableRow::mutable_animdatas(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.animDatas)
  return _internal_mutable_animdatas()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>* Table_TableRow::mutable_animdatas()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.TableRow.animDatas)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_animdatas();
}
inline const ::com::zoho::shapes::AnimationData& Table_TableRow::animdatas(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.animDatas)
  return _internal_animdatas().Get(index);
}
inline ::com::zoho::shapes::AnimationData* Table_TableRow::add_animdatas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::AnimationData* _add = _internal_mutable_animdatas()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableRow.animDatas)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>& Table_TableRow::animdatas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.TableRow.animDatas)
  return _internal_animdatas();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>&
Table_TableRow::_internal_animdatas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.animdatas_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::AnimationData>*
Table_TableRow::_internal_mutable_animdatas() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.animdatas_;
}

// optional string datafieldId = 4;
inline bool Table_TableRow::has_datafieldid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Table_TableRow::clear_datafieldid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datafieldid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Table_TableRow::datafieldid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.datafieldId)
  return _internal_datafieldid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table_TableRow::set_datafieldid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.datafieldid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.datafieldId)
}
inline std::string* Table_TableRow::mutable_datafieldid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_datafieldid();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.datafieldId)
  return _s;
}
inline const std::string& Table_TableRow::_internal_datafieldid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.datafieldid_.Get();
}
inline void Table_TableRow::_internal_set_datafieldid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.datafieldid_.Set(value, GetArena());
}
inline std::string* Table_TableRow::_internal_mutable_datafieldid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.datafieldid_.Mutable( GetArena());
}
inline std::string* Table_TableRow::release_datafieldid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.datafieldId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.datafieldid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.datafieldid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Table_TableRow::set_allocated_datafieldid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.datafieldid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.datafieldid_.IsDefault()) {
          _impl_.datafieldid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.datafieldId)
}

// optional string id = 5;
inline bool Table_TableRow::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Table_TableRow::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Table_TableRow::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableRow.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table_TableRow::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableRow.id)
}
inline std::string* Table_TableRow::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableRow.id)
  return _s;
}
inline const std::string& Table_TableRow::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Table_TableRow::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Table_TableRow::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Table_TableRow::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableRow.id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Table_TableRow::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableRow.id)
}

// -------------------------------------------------------------------

// Table_TableProperties

// optional .com.zoho.shapes.Fill fill = 1;
inline bool Table_TableProperties::has_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Fill& Table_TableProperties::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Fill* p = _impl_.fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Fill&>(::com::zoho::shapes::_Fill_default_instance_);
}
inline const ::com::zoho::shapes::Fill& Table_TableProperties::fill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.fill)
  return _internal_fill();
}
inline void Table_TableProperties::unsafe_arena_set_allocated_fill(::com::zoho::shapes::Fill* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_);
  }
  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::Fill*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableProperties.fill)
}
inline ::com::zoho::shapes::Fill* Table_TableProperties::release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Fill* released = _impl_.fill_;
  _impl_.fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Fill* Table_TableProperties::unsafe_arena_release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableProperties.fill)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Fill* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Fill* Table_TableProperties::_internal_mutable_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Fill>(GetArena());
    _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::Fill*>(p);
  }
  return _impl_.fill_;
}
inline ::com::zoho::shapes::Fill* Table_TableProperties::mutable_fill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Fill* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableProperties.fill)
  return _msg;
}
inline void Table_TableProperties::set_allocated_fill(::com::zoho::shapes::Fill* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::Fill*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableProperties.fill)
}

// optional .com.zoho.shapes.Effects effects = 2;
inline bool Table_TableProperties::has_effects() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.effects_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Effects& Table_TableProperties::_internal_effects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Effects* p = _impl_.effects_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Effects&>(::com::zoho::shapes::_Effects_default_instance_);
}
inline const ::com::zoho::shapes::Effects& Table_TableProperties::effects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.effects)
  return _internal_effects();
}
inline void Table_TableProperties::unsafe_arena_set_allocated_effects(::com::zoho::shapes::Effects* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.effects_);
  }
  _impl_.effects_ = reinterpret_cast<::com::zoho::shapes::Effects*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableProperties.effects)
}
inline ::com::zoho::shapes::Effects* Table_TableProperties::release_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Effects* released = _impl_.effects_;
  _impl_.effects_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Effects* Table_TableProperties::unsafe_arena_release_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableProperties.effects)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Effects* temp = _impl_.effects_;
  _impl_.effects_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Effects* Table_TableProperties::_internal_mutable_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.effects_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Effects>(GetArena());
    _impl_.effects_ = reinterpret_cast<::com::zoho::shapes::Effects*>(p);
  }
  return _impl_.effects_;
}
inline ::com::zoho::shapes::Effects* Table_TableProperties::mutable_effects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Effects* _msg = _internal_mutable_effects();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableProperties.effects)
  return _msg;
}
inline void Table_TableProperties::set_allocated_effects(::com::zoho::shapes::Effects* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.effects_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.effects_ = reinterpret_cast<::com::zoho::shapes::Effects*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableProperties.effects)
}

// optional string styleId = 3;
inline bool Table_TableProperties::has_styleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Table_TableProperties::clear_styleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.styleid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Table_TableProperties::styleid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.styleId)
  return _internal_styleid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table_TableProperties::set_styleid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.styleid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableProperties.styleId)
}
inline std::string* Table_TableProperties::mutable_styleid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_styleid();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableProperties.styleId)
  return _s;
}
inline const std::string& Table_TableProperties::_internal_styleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.styleid_.Get();
}
inline void Table_TableProperties::_internal_set_styleid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.styleid_.Set(value, GetArena());
}
inline std::string* Table_TableProperties::_internal_mutable_styleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.styleid_.Mutable( GetArena());
}
inline std::string* Table_TableProperties::release_styleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableProperties.styleId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.styleid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.styleid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Table_TableProperties::set_allocated_styleid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.styleid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.styleid_.IsDefault()) {
          _impl_.styleid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableProperties.styleId)
}

// optional bool firstRow = 4;
inline bool Table_TableProperties::has_firstrow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Table_TableProperties::clear_firstrow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firstrow_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Table_TableProperties::firstrow() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.firstRow)
  return _internal_firstrow();
}
inline void Table_TableProperties::set_firstrow(bool value) {
  _internal_set_firstrow(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableProperties.firstRow)
}
inline bool Table_TableProperties::_internal_firstrow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.firstrow_;
}
inline void Table_TableProperties::_internal_set_firstrow(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.firstrow_ = value;
}

// optional bool lastRow = 5;
inline bool Table_TableProperties::has_lastrow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Table_TableProperties::clear_lastrow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lastrow_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Table_TableProperties::lastrow() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.lastRow)
  return _internal_lastrow();
}
inline void Table_TableProperties::set_lastrow(bool value) {
  _internal_set_lastrow(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableProperties.lastRow)
}
inline bool Table_TableProperties::_internal_lastrow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lastrow_;
}
inline void Table_TableProperties::_internal_set_lastrow(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.lastrow_ = value;
}

// optional bool bandCol = 6;
inline bool Table_TableProperties::has_bandcol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Table_TableProperties::clear_bandcol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bandcol_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Table_TableProperties::bandcol() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.bandCol)
  return _internal_bandcol();
}
inline void Table_TableProperties::set_bandcol(bool value) {
  _internal_set_bandcol(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableProperties.bandCol)
}
inline bool Table_TableProperties::_internal_bandcol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bandcol_;
}
inline void Table_TableProperties::_internal_set_bandcol(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.bandcol_ = value;
}

// optional bool bandRow = 7;
inline bool Table_TableProperties::has_bandrow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Table_TableProperties::clear_bandrow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bandrow_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Table_TableProperties::bandrow() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.bandRow)
  return _internal_bandrow();
}
inline void Table_TableProperties::set_bandrow(bool value) {
  _internal_set_bandrow(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableProperties.bandRow)
}
inline bool Table_TableProperties::_internal_bandrow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bandrow_;
}
inline void Table_TableProperties::_internal_set_bandrow(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.bandrow_ = value;
}

// optional bool firstCol = 8;
inline bool Table_TableProperties::has_firstcol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void Table_TableProperties::clear_firstcol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.firstcol_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool Table_TableProperties::firstcol() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.firstCol)
  return _internal_firstcol();
}
inline void Table_TableProperties::set_firstcol(bool value) {
  _internal_set_firstcol(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableProperties.firstCol)
}
inline bool Table_TableProperties::_internal_firstcol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.firstcol_;
}
inline void Table_TableProperties::_internal_set_firstcol(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.firstcol_ = value;
}

// optional bool lastCol = 9;
inline bool Table_TableProperties::has_lastcol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void Table_TableProperties::clear_lastcol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lastcol_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool Table_TableProperties::lastcol() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.lastCol)
  return _internal_lastcol();
}
inline void Table_TableProperties::set_lastcol(bool value) {
  _internal_set_lastcol(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.TableProperties.lastCol)
}
inline bool Table_TableProperties::_internal_lastcol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lastcol_;
}
inline void Table_TableProperties::_internal_set_lastcol(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.lastcol_ = value;
}

// optional .com.zoho.shapes.Color styleColor = 10;
inline bool Table_TableProperties::has_stylecolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stylecolor_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Color& Table_TableProperties::_internal_stylecolor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Color* p = _impl_.stylecolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Color&>(::com::zoho::shapes::_Color_default_instance_);
}
inline const ::com::zoho::shapes::Color& Table_TableProperties::stylecolor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.styleColor)
  return _internal_stylecolor();
}
inline void Table_TableProperties::unsafe_arena_set_allocated_stylecolor(::com::zoho::shapes::Color* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stylecolor_);
  }
  _impl_.stylecolor_ = reinterpret_cast<::com::zoho::shapes::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.TableProperties.styleColor)
}
inline ::com::zoho::shapes::Color* Table_TableProperties::release_stylecolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Color* released = _impl_.stylecolor_;
  _impl_.stylecolor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Color* Table_TableProperties::unsafe_arena_release_stylecolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.TableProperties.styleColor)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Color* temp = _impl_.stylecolor_;
  _impl_.stylecolor_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Color* Table_TableProperties::_internal_mutable_stylecolor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.stylecolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Color>(GetArena());
    _impl_.stylecolor_ = reinterpret_cast<::com::zoho::shapes::Color*>(p);
  }
  return _impl_.stylecolor_;
}
inline ::com::zoho::shapes::Color* Table_TableProperties::mutable_stylecolor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Color* _msg = _internal_mutable_stylecolor();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableProperties.styleColor)
  return _msg;
}
inline void Table_TableProperties::set_allocated_stylecolor(::com::zoho::shapes::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stylecolor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.stylecolor_ = reinterpret_cast<::com::zoho::shapes::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.TableProperties.styleColor)
}

// repeated .com.zoho.shapes.Animation anim = 11;
inline int Table_TableProperties::_internal_anim_size() const {
  return _internal_anim().size();
}
inline int Table_TableProperties::anim_size() const {
  return _internal_anim_size();
}
inline ::com::zoho::shapes::Animation* Table_TableProperties::mutable_anim(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.TableProperties.anim)
  return _internal_mutable_anim()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Animation>* Table_TableProperties::mutable_anim()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.TableProperties.anim)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_anim();
}
inline const ::com::zoho::shapes::Animation& Table_TableProperties::anim(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.TableProperties.anim)
  return _internal_anim().Get(index);
}
inline ::com::zoho::shapes::Animation* Table_TableProperties::add_anim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::Animation* _add = _internal_mutable_anim()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.TableProperties.anim)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Animation>& Table_TableProperties::anim() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.TableProperties.anim)
  return _internal_anim();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Animation>&
Table_TableProperties::_internal_anim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.anim_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Animation>*
Table_TableProperties::_internal_mutable_anim() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.anim_;
}

// -------------------------------------------------------------------

// Table

// required .com.zoho.shapes.Table.TableGrid grid = 1;
inline bool Table::has_grid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grid_ != nullptr);
  return value;
}
inline void Table::clear_grid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.grid_ != nullptr) _impl_.grid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::Table_TableGrid& Table::_internal_grid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Table_TableGrid* p = _impl_.grid_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Table_TableGrid&>(::com::zoho::shapes::_Table_TableGrid_default_instance_);
}
inline const ::com::zoho::shapes::Table_TableGrid& Table::grid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.grid)
  return _internal_grid();
}
inline void Table::unsafe_arena_set_allocated_grid(::com::zoho::shapes::Table_TableGrid* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.grid_);
  }
  _impl_.grid_ = reinterpret_cast<::com::zoho::shapes::Table_TableGrid*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.grid)
}
inline ::com::zoho::shapes::Table_TableGrid* Table::release_grid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Table_TableGrid* released = _impl_.grid_;
  _impl_.grid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Table_TableGrid* Table::unsafe_arena_release_grid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.grid)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Table_TableGrid* temp = _impl_.grid_;
  _impl_.grid_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Table_TableGrid* Table::_internal_mutable_grid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.grid_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Table_TableGrid>(GetArena());
    _impl_.grid_ = reinterpret_cast<::com::zoho::shapes::Table_TableGrid*>(p);
  }
  return _impl_.grid_;
}
inline ::com::zoho::shapes::Table_TableGrid* Table::mutable_grid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Table_TableGrid* _msg = _internal_mutable_grid();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.grid)
  return _msg;
}
inline void Table::set_allocated_grid(::com::zoho::shapes::Table_TableGrid* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Table_TableGrid*>(_impl_.grid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Table_TableGrid*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.grid_ = reinterpret_cast<::com::zoho::shapes::Table_TableGrid*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.grid)
}

// repeated .com.zoho.shapes.Table.TableRow row = 2;
inline int Table::_internal_row_size() const {
  return _internal_row().size();
}
inline int Table::row_size() const {
  return _internal_row_size();
}
inline void Table::clear_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.row_.Clear();
}
inline ::com::zoho::shapes::Table_TableRow* Table::mutable_row(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.row)
  return _internal_mutable_row()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow>* Table::mutable_row()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Table.row)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_row();
}
inline const ::com::zoho::shapes::Table_TableRow& Table::row(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.row)
  return _internal_row().Get(index);
}
inline ::com::zoho::shapes::Table_TableRow* Table::add_row() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::Table_TableRow* _add = _internal_mutable_row()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Table.row)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow>& Table::row() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Table.row)
  return _internal_row();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow>&
Table::_internal_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.row_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Table_TableRow>*
Table::_internal_mutable_row() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.row_;
}

// optional .com.zoho.shapes.Table.TableProperties props = 3;
inline bool Table::has_props() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.props_ != nullptr);
  return value;
}
inline void Table::clear_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.props_ != nullptr) _impl_.props_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::Table_TableProperties& Table::_internal_props() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Table_TableProperties* p = _impl_.props_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Table_TableProperties&>(::com::zoho::shapes::_Table_TableProperties_default_instance_);
}
inline const ::com::zoho::shapes::Table_TableProperties& Table::props() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.props)
  return _internal_props();
}
inline void Table::unsafe_arena_set_allocated_props(::com::zoho::shapes::Table_TableProperties* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.props_);
  }
  _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Table_TableProperties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Table.props)
}
inline ::com::zoho::shapes::Table_TableProperties* Table::release_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Table_TableProperties* released = _impl_.props_;
  _impl_.props_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Table_TableProperties* Table::unsafe_arena_release_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.props)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Table_TableProperties* temp = _impl_.props_;
  _impl_.props_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Table_TableProperties* Table::_internal_mutable_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.props_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Table_TableProperties>(GetArena());
    _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Table_TableProperties*>(p);
  }
  return _impl_.props_;
}
inline ::com::zoho::shapes::Table_TableProperties* Table::mutable_props() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Table_TableProperties* _msg = _internal_mutable_props();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.props)
  return _msg;
}
inline void Table::set_allocated_props(::com::zoho::shapes::Table_TableProperties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Table_TableProperties*>(_impl_.props_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Table_TableProperties*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Table_TableProperties*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.props)
}

// optional bool ignoreMinimumHeight = 4;
inline bool Table::has_ignoreminimumheight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Table::clear_ignoreminimumheight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignoreminimumheight_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Table::ignoreminimumheight() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.ignoreMinimumHeight)
  return _internal_ignoreminimumheight();
}
inline void Table::set_ignoreminimumheight(bool value) {
  _internal_set_ignoreminimumheight(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.ignoreMinimumHeight)
}
inline bool Table::_internal_ignoreminimumheight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignoreminimumheight_;
}
inline void Table::_internal_set_ignoreminimumheight(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ignoreminimumheight_ = value;
}

// optional string datafieldId = 5;
inline bool Table::has_datafieldid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Table::clear_datafieldid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datafieldid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Table::datafieldid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.datafieldId)
  return _internal_datafieldid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table::set_datafieldid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.datafieldid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.datafieldId)
}
inline std::string* Table::mutable_datafieldid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_datafieldid();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Table.datafieldId)
  return _s;
}
inline const std::string& Table::_internal_datafieldid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.datafieldid_.Get();
}
inline void Table::_internal_set_datafieldid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.datafieldid_.Set(value, GetArena());
}
inline std::string* Table::_internal_mutable_datafieldid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.datafieldid_.Mutable( GetArena());
}
inline std::string* Table::release_datafieldid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Table.datafieldId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.datafieldid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.datafieldid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Table::set_allocated_datafieldid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.datafieldid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.datafieldid_.IsDefault()) {
          _impl_.datafieldid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Table.datafieldId)
}

// optional .com.zoho.shapes.Table.TableDataType dataType = 6;
inline bool Table::has_datatype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Table::clear_datatype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datatype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::com::zoho::shapes::Table_TableDataType Table::datatype() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Table.dataType)
  return _internal_datatype();
}
inline void Table::set_datatype(::com::zoho::shapes::Table_TableDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Table.dataType)
}
inline ::com::zoho::shapes::Table_TableDataType Table::_internal_datatype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::Table_TableDataType>(_impl_.datatype_);
}
inline void Table::_internal_set_datatype(::com::zoho::shapes::Table_TableDataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::com::zoho::shapes::Table_TableDataType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.datatype_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow>() {
  return ::com::zoho::shapes::Table_TableRow_TableCell_TableCellProperties_TextOverflow_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::Table_TableDataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::Table_TableDataType>() {
  return ::com::zoho::shapes::Table_TableDataType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_table_2eproto_2epb_2eh
