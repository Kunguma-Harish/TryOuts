// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: notificationsettings.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum SettingLevelType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownType // = 0
  case all // = 1
  case granular // = 2

  public init() {
    self = .unknownType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownType
    case 1: self = .all
    case 2: self = .granular
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownType: return 0
    case .all: return 1
    case .granular: return 2
    }
  }

}

#if swift(>=4.2)

extension SettingLevelType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct NotificationSettingOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mail: Bool {
    get {return _mail ?? false}
    set {_mail = newValue}
  }
  /// Returns true if `mail` has been explicitly set.
  public var hasMail: Bool {return self._mail != nil}
  /// Clears the value of `mail`. Subsequent reads from it will return its default value.
  public mutating func clearMail() {self._mail = nil}

  public var push: Bool {
    get {return _push ?? false}
    set {_push = newValue}
  }
  /// Returns true if `push` has been explicitly set.
  public var hasPush: Bool {return self._push != nil}
  /// Clears the value of `push`. Subsequent reads from it will return its default value.
  public mutating func clearPush() {self._push = nil}

  public var app: Bool {
    get {return _app ?? false}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  public var bot: Bool {
    get {return _bot ?? false}
    set {_bot = newValue}
  }
  /// Returns true if `bot` has been explicitly set.
  public var hasBot: Bool {return self._bot != nil}
  /// Clears the value of `bot`. Subsequent reads from it will return its default value.
  public mutating func clearBot() {self._bot = nil}

  public var muteNotification: NotificationSettingOptions.MuteNotification {
    get {return _muteNotification ?? NotificationSettingOptions.MuteNotification()}
    set {_muteNotification = newValue}
  }
  /// Returns true if `muteNotification` has been explicitly set.
  public var hasMuteNotification: Bool {return self._muteNotification != nil}
  /// Clears the value of `muteNotification`. Subsequent reads from it will return its default value.
  public mutating func clearMuteNotification() {self._muteNotification = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct MuteNotification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mutedAt: Time {
      get {return _mutedAt ?? Time()}
      set {_mutedAt = newValue}
    }
    /// Returns true if `mutedAt` has been explicitly set.
    public var hasMutedAt: Bool {return self._mutedAt != nil}
    /// Clears the value of `mutedAt`. Subsequent reads from it will return its default value.
    public mutating func clearMutedAt() {self._mutedAt = nil}

    public var muteFor: Time {
      get {return _muteFor ?? Time()}
      set {_muteFor = newValue}
    }
    /// Returns true if `muteFor` has been explicitly set.
    public var hasMuteFor: Bool {return self._muteFor != nil}
    /// Clears the value of `muteFor`. Subsequent reads from it will return its default value.
    public mutating func clearMuteFor() {self._muteFor = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _mutedAt: Time? = nil
    fileprivate var _muteFor: Time? = nil
  }

  public init() {}

  fileprivate var _mail: Bool? = nil
  fileprivate var _push: Bool? = nil
  fileprivate var _app: Bool? = nil
  fileprivate var _bot: Bool? = nil
  fileprivate var _muteNotification: NotificationSettingOptions.MuteNotification? = nil
}

public struct NotificationSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///it will turn off globally
  public var options: NotificationSettingOptions {
    get {return _options ?? NotificationSettingOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var projectSettings: ProjectLevelSettings {
    get {return _projectSettings ?? ProjectLevelSettings()}
    set {_projectSettings = newValue}
  }
  /// Returns true if `projectSettings` has been explicitly set.
  public var hasProjectSettings: Bool {return self._projectSettings != nil}
  /// Clears the value of `projectSettings`. Subsequent reads from it will return its default value.
  public mutating func clearProjectSettings() {self._projectSettings = nil}

  public var orgSettings: OrgLevelSettings {
    get {return _orgSettings ?? OrgLevelSettings()}
    set {_orgSettings = newValue}
  }
  /// Returns true if `orgSettings` has been explicitly set.
  public var hasOrgSettings: Bool {return self._orgSettings != nil}
  /// Clears the value of `orgSettings`. Subsequent reads from it will return its default value.
  public mutating func clearOrgSettings() {self._orgSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: NotificationSettingOptions? = nil
  fileprivate var _projectSettings: ProjectLevelSettings? = nil
  fileprivate var _orgSettings: OrgLevelSettings? = nil
}

public struct MemberLevelSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var memberLevelType: SettingLevelType {
    get {return _memberLevelType ?? .unknownType}
    set {_memberLevelType = newValue}
  }
  /// Returns true if `memberLevelType` has been explicitly set.
  public var hasMemberLevelType: Bool {return self._memberLevelType != nil}
  /// Clears the value of `memberLevelType`. Subsequent reads from it will return its default value.
  public mutating func clearMemberLevelType() {self._memberLevelType = nil}

  public var memberGranular: [MemberLevelSetting.GranularMemberLevel] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct GranularMemberLevel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var memberOperationType: OperationFields.MemberOperationType {
      get {return _memberOperationType ?? .unknownMember}
      set {_memberOperationType = newValue}
    }
    /// Returns true if `memberOperationType` has been explicitly set.
    public var hasMemberOperationType: Bool {return self._memberOperationType != nil}
    /// Clears the value of `memberOperationType`. Subsequent reads from it will return its default value.
    public mutating func clearMemberOperationType() {self._memberOperationType = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _memberOperationType: OperationFields.MemberOperationType? = nil
  }

  public init() {}

  fileprivate var _memberLevelType: SettingLevelType? = nil
}

public struct ProjectLevelSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectLevel: SettingLevelType {
    get {return _projectLevel ?? .unknownType}
    set {_projectLevel = newValue}
  }
  /// Returns true if `projectLevel` has been explicitly set.
  public var hasProjectLevel: Bool {return self._projectLevel != nil}
  /// Clears the value of `projectLevel`. Subsequent reads from it will return its default value.
  public mutating func clearProjectLevel() {self._projectLevel = nil}

  public var granularProjectLevelSetting: [ProjectLevelSettings.GranularProjectLevelSetting] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// GRANULAR
  public struct GranularProjectLevelSetting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var opType: OperationFields.OperationFieldType {
      get {return _storage._opType ?? .unknownOperation}
      set {_uniqueStorage()._opType = newValue}
    }
    /// Returns true if `opType` has been explicitly set.
    public var hasOpType: Bool {return _storage._opType != nil}
    /// Clears the value of `opType`. Subsequent reads from it will return its default value.
    public mutating func clearOpType() {_uniqueStorage()._opType = nil}

    public var shareLevel: ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting {
      get {return _storage._shareLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting()}
      set {_uniqueStorage()._shareLevel = newValue}
    }
    /// Returns true if `shareLevel` has been explicitly set.
    public var hasShareLevel: Bool {return _storage._shareLevel != nil}
    /// Clears the value of `shareLevel`. Subsequent reads from it will return its default value.
    public mutating func clearShareLevel() {_uniqueStorage()._shareLevel = nil}

    public var fileLevel: ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting {
      get {return _storage._fileLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting()}
      set {_uniqueStorage()._fileLevel = newValue}
    }
    /// Returns true if `fileLevel` has been explicitly set.
    public var hasFileLevel: Bool {return _storage._fileLevel != nil}
    /// Clears the value of `fileLevel`. Subsequent reads from it will return its default value.
    public mutating func clearFileLevel() {_uniqueStorage()._fileLevel = nil}

    public var publishLevel: ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting {
      get {return _storage._publishLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting()}
      set {_uniqueStorage()._publishLevel = newValue}
    }
    /// Returns true if `publishLevel` has been explicitly set.
    public var hasPublishLevel: Bool {return _storage._publishLevel != nil}
    /// Clears the value of `publishLevel`. Subsequent reads from it will return its default value.
    public mutating func clearPublishLevel() {_uniqueStorage()._publishLevel = nil}

    public var editLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting {
      get {return _storage._editLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting()}
      set {_uniqueStorage()._editLevel = newValue}
    }
    /// Returns true if `editLevel` has been explicitly set.
    public var hasEditLevel: Bool {return _storage._editLevel != nil}
    /// Clears the value of `editLevel`. Subsequent reads from it will return its default value.
    public mutating func clearEditLevel() {_uniqueStorage()._editLevel = nil}

    public var memberLevel: MemberLevelSetting {
      get {return _storage._memberLevel ?? MemberLevelSetting()}
      set {_uniqueStorage()._memberLevel = newValue}
    }
    /// Returns true if `memberLevel` has been explicitly set.
    public var hasMemberLevel: Bool {return _storage._memberLevel != nil}
    /// Clears the value of `memberLevel`. Subsequent reads from it will return its default value.
    public mutating func clearMemberLevel() {_uniqueStorage()._memberLevel = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ShareLevelSetting {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var shareLevelType: SettingLevelType {
        get {return _shareLevelType ?? .unknownType}
        set {_shareLevelType = newValue}
      }
      /// Returns true if `shareLevelType` has been explicitly set.
      public var hasShareLevelType: Bool {return self._shareLevelType != nil}
      /// Clears the value of `shareLevelType`. Subsequent reads from it will return its default value.
      public mutating func clearShareLevelType() {self._shareLevelType = nil}

      public var shareGranular: [ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting.GranularShareLevel] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct GranularShareLevel {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var shareOperationType: OperationFields.ShareOperationType {
          get {return _shareOperationType ?? .unknownSharePermission}
          set {_shareOperationType = newValue}
        }
        /// Returns true if `shareOperationType` has been explicitly set.
        public var hasShareOperationType: Bool {return self._shareOperationType != nil}
        /// Clears the value of `shareOperationType`. Subsequent reads from it will return its default value.
        public mutating func clearShareOperationType() {self._shareOperationType = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _shareOperationType: OperationFields.ShareOperationType? = nil
      }

      public init() {}

      fileprivate var _shareLevelType: SettingLevelType? = nil
    }

    public struct FileLevelSetting {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var fileLevelType: SettingLevelType {
        get {return _fileLevelType ?? .unknownType}
        set {_fileLevelType = newValue}
      }
      /// Returns true if `fileLevelType` has been explicitly set.
      public var hasFileLevelType: Bool {return self._fileLevelType != nil}
      /// Clears the value of `fileLevelType`. Subsequent reads from it will return its default value.
      public mutating func clearFileLevelType() {self._fileLevelType = nil}

      public var fileGranular: [ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting.GranularFileLevel] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct GranularFileLevel {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var fileOperationType: OperationFields.FileOperationType {
          get {return _fileOperationType ?? .unknownFile}
          set {_fileOperationType = newValue}
        }
        /// Returns true if `fileOperationType` has been explicitly set.
        public var hasFileOperationType: Bool {return self._fileOperationType != nil}
        /// Clears the value of `fileOperationType`. Subsequent reads from it will return its default value.
        public mutating func clearFileOperationType() {self._fileOperationType = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _fileOperationType: OperationFields.FileOperationType? = nil
      }

      public init() {}

      fileprivate var _fileLevelType: SettingLevelType? = nil
    }

    public struct PublishLevelSetting {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var publishLevelType: SettingLevelType {
        get {return _publishLevelType ?? .unknownType}
        set {_publishLevelType = newValue}
      }
      /// Returns true if `publishLevelType` has been explicitly set.
      public var hasPublishLevelType: Bool {return self._publishLevelType != nil}
      /// Clears the value of `publishLevelType`. Subsequent reads from it will return its default value.
      public mutating func clearPublishLevelType() {self._publishLevelType = nil}

      public var publishGranular: [ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting.GranularPublishLevel] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct GranularPublishLevel {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var publishOperationType: OperationFields.PublishOperationType {
          get {return _publishOperationType ?? .unknownPublish}
          set {_publishOperationType = newValue}
        }
        /// Returns true if `publishOperationType` has been explicitly set.
        public var hasPublishOperationType: Bool {return self._publishOperationType != nil}
        /// Clears the value of `publishOperationType`. Subsequent reads from it will return its default value.
        public mutating func clearPublishOperationType() {self._publishOperationType = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _publishOperationType: OperationFields.PublishOperationType? = nil
      }

      public init() {}

      fileprivate var _publishLevelType: SettingLevelType? = nil
    }

    public struct EditLevelSetting {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var editLevelType: SettingLevelType {
        get {return _editLevelType ?? .unknownType}
        set {_editLevelType = newValue}
      }
      /// Returns true if `editLevelType` has been explicitly set.
      public var hasEditLevelType: Bool {return self._editLevelType != nil}
      /// Clears the value of `editLevelType`. Subsequent reads from it will return its default value.
      public mutating func clearEditLevelType() {self._editLevelType = nil}

      public var editGranular: [ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.GranularEditLevel] = []

      public var modifyLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting {
        get {return _modifyLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting()}
        set {_modifyLevel = newValue}
      }
      /// Returns true if `modifyLevel` has been explicitly set.
      public var hasModifyLevel: Bool {return self._modifyLevel != nil}
      /// Clears the value of `modifyLevel`. Subsequent reads from it will return its default value.
      public mutating func clearModifyLevel() {self._modifyLevel = nil}

      public var commentLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting {
        get {return _commentLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting()}
        set {_commentLevel = newValue}
      }
      /// Returns true if `commentLevel` has been explicitly set.
      public var hasCommentLevel: Bool {return self._commentLevel != nil}
      /// Clears the value of `commentLevel`. Subsequent reads from it will return its default value.
      public mutating func clearCommentLevel() {self._commentLevel = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct GranularEditLevel {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var editOperationType: OperationFields.EditOperationType {
          get {return _editOperationType ?? .unknownEdit}
          set {_editOperationType = newValue}
        }
        /// Returns true if `editOperationType` has been explicitly set.
        public var hasEditOperationType: Bool {return self._editOperationType != nil}
        /// Clears the value of `editOperationType`. Subsequent reads from it will return its default value.
        public mutating func clearEditOperationType() {self._editOperationType = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _editOperationType: OperationFields.EditOperationType? = nil
      }

      public struct ModifyLevelSetting {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var modifyLevelType: SettingLevelType {
          get {return _modifyLevelType ?? .unknownType}
          set {_modifyLevelType = newValue}
        }
        /// Returns true if `modifyLevelType` has been explicitly set.
        public var hasModifyLevelType: Bool {return self._modifyLevelType != nil}
        /// Clears the value of `modifyLevelType`. Subsequent reads from it will return its default value.
        public mutating func clearModifyLevelType() {self._modifyLevelType = nil}

        public var modifyGranular: [ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.GranularModifyLevel] = []

        public var metaLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting {
          get {return _metaLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting()}
          set {_metaLevel = newValue}
        }
        /// Returns true if `metaLevel` has been explicitly set.
        public var hasMetaLevel: Bool {return self._metaLevel != nil}
        /// Clears the value of `metaLevel`. Subsequent reads from it will return its default value.
        public mutating func clearMetaLevel() {self._metaLevel = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct GranularModifyLevel {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var modifyOperationType: OperationFields.ModifyOperationType {
            get {return _modifyOperationType ?? .unknownModify}
            set {_modifyOperationType = newValue}
          }
          /// Returns true if `modifyOperationType` has been explicitly set.
          public var hasModifyOperationType: Bool {return self._modifyOperationType != nil}
          /// Clears the value of `modifyOperationType`. Subsequent reads from it will return its default value.
          public mutating func clearModifyOperationType() {self._modifyOperationType = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _modifyOperationType: OperationFields.ModifyOperationType? = nil
        }

        public struct MetaLevelSetting {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var metaLevelType: SettingLevelType {
            get {return _metaLevelType ?? .unknownType}
            set {_metaLevelType = newValue}
          }
          /// Returns true if `metaLevelType` has been explicitly set.
          public var hasMetaLevelType: Bool {return self._metaLevelType != nil}
          /// Clears the value of `metaLevelType`. Subsequent reads from it will return its default value.
          public mutating func clearMetaLevelType() {self._metaLevelType = nil}

          public var metaGranular: [ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.GranularMetaLevel] = []

          public var documentStatusLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting {
            get {return _documentStatusLevel ?? ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting()}
            set {_documentStatusLevel = newValue}
          }
          /// Returns true if `documentStatusLevel` has been explicitly set.
          public var hasDocumentStatusLevel: Bool {return self._documentStatusLevel != nil}
          /// Clears the value of `documentStatusLevel`. Subsequent reads from it will return its default value.
          public mutating func clearDocumentStatusLevel() {self._documentStatusLevel = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public struct GranularMetaLevel {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var metaOperationType: OperationFields.MetaOperationType {
              get {return _metaOperationType ?? .unknownMetaType}
              set {_metaOperationType = newValue}
            }
            /// Returns true if `metaOperationType` has been explicitly set.
            public var hasMetaOperationType: Bool {return self._metaOperationType != nil}
            /// Clears the value of `metaOperationType`. Subsequent reads from it will return its default value.
            public mutating func clearMetaOperationType() {self._metaOperationType = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _metaOperationType: OperationFields.MetaOperationType? = nil
          }

          public struct DocumentStatusLevelSetting {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var documentStatusLevelType: SettingLevelType {
              get {return _documentStatusLevelType ?? .unknownType}
              set {_documentStatusLevelType = newValue}
            }
            /// Returns true if `documentStatusLevelType` has been explicitly set.
            public var hasDocumentStatusLevelType: Bool {return self._documentStatusLevelType != nil}
            /// Clears the value of `documentStatusLevelType`. Subsequent reads from it will return its default value.
            public mutating func clearDocumentStatusLevelType() {self._documentStatusLevelType = nil}

            public var documentStatusGranular: [ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting.GranularDocumentStatusLevel] = []

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public struct GranularDocumentStatusLevel {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var documentStatusOperationType: DocumentStatusField.DocumentStatusType {
                get {return _documentStatusOperationType ?? .unknownStatus}
                set {_documentStatusOperationType = newValue}
              }
              /// Returns true if `documentStatusOperationType` has been explicitly set.
              public var hasDocumentStatusOperationType: Bool {return self._documentStatusOperationType != nil}
              /// Clears the value of `documentStatusOperationType`. Subsequent reads from it will return its default value.
              public mutating func clearDocumentStatusOperationType() {self._documentStatusOperationType = nil}

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public init() {}

              fileprivate var _documentStatusOperationType: DocumentStatusField.DocumentStatusType? = nil
            }

            public init() {}

            fileprivate var _documentStatusLevelType: SettingLevelType? = nil
          }

          public init() {}

          fileprivate var _metaLevelType: SettingLevelType? = nil
          fileprivate var _documentStatusLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting? = nil
        }

        public init() {}

        fileprivate var _modifyLevelType: SettingLevelType? = nil
        fileprivate var _metaLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting? = nil
      }

      public struct CommentLevelSetting {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var commentLevelType: SettingLevelType {
          get {return _commentLevelType ?? .unknownType}
          set {_commentLevelType = newValue}
        }
        /// Returns true if `commentLevelType` has been explicitly set.
        public var hasCommentLevelType: Bool {return self._commentLevelType != nil}
        /// Clears the value of `commentLevelType`. Subsequent reads from it will return its default value.
        public mutating func clearCommentLevelType() {self._commentLevelType = nil}

        public var commentGranular: [ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting.GranularCommentLevel] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct GranularCommentLevel {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var commentOperationType: OperationFields.CommentOperationType {
            get {return _commentOperationType ?? .unknownComment}
            set {_commentOperationType = newValue}
          }
          /// Returns true if `commentOperationType` has been explicitly set.
          public var hasCommentOperationType: Bool {return self._commentOperationType != nil}
          /// Clears the value of `commentOperationType`. Subsequent reads from it will return its default value.
          public mutating func clearCommentOperationType() {self._commentOperationType = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _commentOperationType: OperationFields.CommentOperationType? = nil
        }

        public init() {}

        fileprivate var _commentLevelType: SettingLevelType? = nil
      }

      public init() {}

      fileprivate var _editLevelType: SettingLevelType? = nil
      fileprivate var _modifyLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting? = nil
      fileprivate var _commentLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _projectLevel: SettingLevelType? = nil
}

public struct OrgLevelSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var orgLevel: SettingLevelType {
    get {return _orgLevel ?? .unknownType}
    set {_orgLevel = newValue}
  }
  /// Returns true if `orgLevel` has been explicitly set.
  public var hasOrgLevel: Bool {return self._orgLevel != nil}
  /// Clears the value of `orgLevel`. Subsequent reads from it will return its default value.
  public mutating func clearOrgLevel() {self._orgLevel = nil}

  public var granularOrgLevelSetting: [OrgLevelSettings.GranularOrgLevelSetting] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// GRANULAR
  public struct GranularOrgLevelSetting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var opType: OperationFields.OperationFieldType {
      get {return _opType ?? .unknownOperation}
      set {_opType = newValue}
    }
    /// Returns true if `opType` has been explicitly set.
    public var hasOpType: Bool {return self._opType != nil}
    /// Clears the value of `opType`. Subsequent reads from it will return its default value.
    public mutating func clearOpType() {self._opType = nil}

    public var memberLevel: MemberLevelSetting {
      get {return _memberLevel ?? MemberLevelSetting()}
      set {_memberLevel = newValue}
    }
    /// Returns true if `memberLevel` has been explicitly set.
    public var hasMemberLevel: Bool {return self._memberLevel != nil}
    /// Clears the value of `memberLevel`. Subsequent reads from it will return its default value.
    public mutating func clearMemberLevel() {self._memberLevel = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _opType: OperationFields.OperationFieldType? = nil
    fileprivate var _memberLevel: MemberLevelSetting? = nil
  }

  public init() {}

  fileprivate var _orgLevel: SettingLevelType? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SettingLevelType: @unchecked Sendable {}
extension NotificationSettingOptions: @unchecked Sendable {}
extension NotificationSettingOptions.MuteNotification: @unchecked Sendable {}
extension NotificationSettings: @unchecked Sendable {}
extension MemberLevelSetting: @unchecked Sendable {}
extension MemberLevelSetting.GranularMemberLevel: @unchecked Sendable {}
extension ProjectLevelSettings: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting.GranularShareLevel: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting.GranularFileLevel: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting.GranularPublishLevel: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.GranularEditLevel: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.GranularModifyLevel: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.GranularMetaLevel: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting.GranularDocumentStatusLevel: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting: @unchecked Sendable {}
extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting.GranularCommentLevel: @unchecked Sendable {}
extension OrgLevelSettings: @unchecked Sendable {}
extension OrgLevelSettings.GranularOrgLevelSetting: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.common"

extension SettingLevelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "ALL"),
    2: .same(proto: "GRANULAR"),
  ]
}

extension NotificationSettingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationSettingOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mail"),
    2: .same(proto: "push"),
    3: .same(proto: "app"),
    4: .same(proto: "bot"),
    5: .same(proto: "muteNotification"),
  ]

  public var isInitialized: Bool {
    if let v = self._muteNotification, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._mail) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._push) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._app) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._bot) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._muteNotification) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mail {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._push {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._app {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bot {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._muteNotification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationSettingOptions, rhs: NotificationSettingOptions) -> Bool {
    if lhs._mail != rhs._mail {return false}
    if lhs._push != rhs._push {return false}
    if lhs._app != rhs._app {return false}
    if lhs._bot != rhs._bot {return false}
    if lhs._muteNotification != rhs._muteNotification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationSettingOptions.MuteNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NotificationSettingOptions.protoMessageName + ".MuteNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mutedAt"),
    2: .same(proto: "muteFor"),
  ]

  public var isInitialized: Bool {
    if let v = self._mutedAt, !v.isInitialized {return false}
    if let v = self._muteFor, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mutedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._muteFor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mutedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._muteFor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationSettingOptions.MuteNotification, rhs: NotificationSettingOptions.MuteNotification) -> Bool {
    if lhs._mutedAt != rhs._mutedAt {return false}
    if lhs._muteFor != rhs._muteFor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
    2: .same(proto: "projectSettings"),
    3: .same(proto: "orgSettings"),
  ]

  public var isInitialized: Bool {
    if let v = self._options, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._projectSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._orgSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._projectSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._orgSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationSettings, rhs: NotificationSettings) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs._projectSettings != rhs._projectSettings {return false}
    if lhs._orgSettings != rhs._orgSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MemberLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memberLevelType"),
    2: .same(proto: "memberGranular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._memberLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.memberGranular) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.memberGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memberGranular, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MemberLevelSetting, rhs: MemberLevelSetting) -> Bool {
    if lhs._memberLevelType != rhs._memberLevelType {return false}
    if lhs.memberGranular != rhs.memberGranular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MemberLevelSetting.GranularMemberLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MemberLevelSetting.protoMessageName + ".GranularMemberLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memberOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._memberOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MemberLevelSetting.GranularMemberLevel, rhs: MemberLevelSetting.GranularMemberLevel) -> Bool {
    if lhs._memberOperationType != rhs._memberOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProjectLevelSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projectLevel"),
    2: .same(proto: "granularProjectLevelSetting"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._projectLevel) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.granularProjectLevelSetting) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._projectLevel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.granularProjectLevelSetting.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.granularProjectLevelSetting, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings, rhs: ProjectLevelSettings) -> Bool {
    if lhs._projectLevel != rhs._projectLevel {return false}
    if lhs.granularProjectLevelSetting != rhs.granularProjectLevelSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.protoMessageName + ".GranularProjectLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "opType"),
    2: .same(proto: "shareLevel"),
    3: .same(proto: "fileLevel"),
    4: .same(proto: "publishLevel"),
    5: .same(proto: "editLevel"),
    6: .same(proto: "memberLevel"),
  ]

  fileprivate class _StorageClass {
    var _opType: OperationFields.OperationFieldType? = nil
    var _shareLevel: ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting? = nil
    var _fileLevel: ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting? = nil
    var _publishLevel: ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting? = nil
    var _editLevel: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting? = nil
    var _memberLevel: MemberLevelSetting? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _opType = source._opType
      _shareLevel = source._shareLevel
      _fileLevel = source._fileLevel
      _publishLevel = source._publishLevel
      _editLevel = source._editLevel
      _memberLevel = source._memberLevel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._opType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._shareLevel) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._fileLevel) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._publishLevel) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._editLevel) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._memberLevel) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._opType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._shareLevel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._fileLevel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._publishLevel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._editLevel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._memberLevel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._opType != rhs_storage._opType {return false}
        if _storage._shareLevel != rhs_storage._shareLevel {return false}
        if _storage._fileLevel != rhs_storage._fileLevel {return false}
        if _storage._publishLevel != rhs_storage._publishLevel {return false}
        if _storage._editLevel != rhs_storage._editLevel {return false}
        if _storage._memberLevel != rhs_storage._memberLevel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.protoMessageName + ".ShareLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shareLevelType"),
    2: .same(proto: "shareGranular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._shareLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.shareGranular) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shareLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.shareGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shareGranular, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting) -> Bool {
    if lhs._shareLevelType != rhs._shareLevelType {return false}
    if lhs.shareGranular != rhs.shareGranular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting.GranularShareLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting.protoMessageName + ".GranularShareLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shareOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._shareOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shareOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting.GranularShareLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.ShareLevelSetting.GranularShareLevel) -> Bool {
    if lhs._shareOperationType != rhs._shareOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.protoMessageName + ".FileLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileLevelType"),
    2: .same(proto: "fileGranular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fileLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fileGranular) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fileLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.fileGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileGranular, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting) -> Bool {
    if lhs._fileLevelType != rhs._fileLevelType {return false}
    if lhs.fileGranular != rhs.fileGranular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting.GranularFileLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting.protoMessageName + ".GranularFileLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fileOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fileOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting.GranularFileLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.FileLevelSetting.GranularFileLevel) -> Bool {
    if lhs._fileOperationType != rhs._fileOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.protoMessageName + ".PublishLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publishLevelType"),
    2: .same(proto: "publishGranular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._publishLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.publishGranular) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publishLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.publishGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publishGranular, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting) -> Bool {
    if lhs._publishLevelType != rhs._publishLevelType {return false}
    if lhs.publishGranular != rhs.publishGranular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting.GranularPublishLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting.protoMessageName + ".GranularPublishLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publishOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._publishOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publishOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting.GranularPublishLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.PublishLevelSetting.GranularPublishLevel) -> Bool {
    if lhs._publishOperationType != rhs._publishOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.protoMessageName + ".EditLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "editLevelType"),
    2: .same(proto: "editGranular"),
    4: .same(proto: "modifyLevel"),
    5: .same(proto: "commentLevel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._editLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.editGranular) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._modifyLevel) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._commentLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._editLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.editGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.editGranular, fieldNumber: 2)
    }
    try { if let v = self._modifyLevel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._commentLevel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting) -> Bool {
    if lhs._editLevelType != rhs._editLevelType {return false}
    if lhs.editGranular != rhs.editGranular {return false}
    if lhs._modifyLevel != rhs._modifyLevel {return false}
    if lhs._commentLevel != rhs._commentLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.GranularEditLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.protoMessageName + ".GranularEditLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "editOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._editOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._editOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.GranularEditLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.GranularEditLevel) -> Bool {
    if lhs._editOperationType != rhs._editOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.protoMessageName + ".ModifyLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modifyLevelType"),
    2: .same(proto: "modifyGranular"),
    4: .same(proto: "metaLevel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._modifyLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modifyGranular) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metaLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modifyLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.modifyGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modifyGranular, fieldNumber: 2)
    }
    try { if let v = self._metaLevel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting) -> Bool {
    if lhs._modifyLevelType != rhs._modifyLevelType {return false}
    if lhs.modifyGranular != rhs.modifyGranular {return false}
    if lhs._metaLevel != rhs._metaLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.GranularModifyLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.protoMessageName + ".GranularModifyLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modifyOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._modifyOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modifyOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.GranularModifyLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.GranularModifyLevel) -> Bool {
    if lhs._modifyOperationType != rhs._modifyOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.protoMessageName + ".MetaLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metaLevelType"),
    2: .same(proto: "metaGranular"),
    4: .same(proto: "documentStatusLevel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._metaLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metaGranular) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._documentStatusLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metaLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.metaGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metaGranular, fieldNumber: 2)
    }
    try { if let v = self._documentStatusLevel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting) -> Bool {
    if lhs._metaLevelType != rhs._metaLevelType {return false}
    if lhs.metaGranular != rhs.metaGranular {return false}
    if lhs._documentStatusLevel != rhs._documentStatusLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.GranularMetaLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.protoMessageName + ".GranularMetaLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metaOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._metaOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metaOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.GranularMetaLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.GranularMetaLevel) -> Bool {
    if lhs._metaOperationType != rhs._metaOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.protoMessageName + ".DocumentStatusLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documentStatusLevelType"),
    2: .same(proto: "documentStatusGranular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._documentStatusLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.documentStatusGranular) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentStatusLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.documentStatusGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.documentStatusGranular, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting) -> Bool {
    if lhs._documentStatusLevelType != rhs._documentStatusLevelType {return false}
    if lhs.documentStatusGranular != rhs.documentStatusGranular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting.GranularDocumentStatusLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting.protoMessageName + ".GranularDocumentStatusLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documentStatusOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._documentStatusOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentStatusOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting.GranularDocumentStatusLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.ModifyLevelSetting.MetaLevelSetting.DocumentStatusLevelSetting.GranularDocumentStatusLevel) -> Bool {
    if lhs._documentStatusOperationType != rhs._documentStatusOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.protoMessageName + ".CommentLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentLevelType"),
    2: .same(proto: "commentGranular"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._commentLevelType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.commentGranular) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commentLevelType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.commentGranular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commentGranular, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting) -> Bool {
    if lhs._commentLevelType != rhs._commentLevelType {return false}
    if lhs.commentGranular != rhs.commentGranular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting.GranularCommentLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting.protoMessageName + ".GranularCommentLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentOperationType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._commentOperationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commentOperationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting.GranularCommentLevel, rhs: ProjectLevelSettings.GranularProjectLevelSetting.EditLevelSetting.CommentLevelSetting.GranularCommentLevel) -> Bool {
    if lhs._commentOperationType != rhs._commentOperationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrgLevelSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrgLevelSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orgLevel"),
    2: .same(proto: "granularOrgLevelSetting"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._orgLevel) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.granularOrgLevelSetting) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._orgLevel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.granularOrgLevelSetting.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.granularOrgLevelSetting, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrgLevelSettings, rhs: OrgLevelSettings) -> Bool {
    if lhs._orgLevel != rhs._orgLevel {return false}
    if lhs.granularOrgLevelSetting != rhs.granularOrgLevelSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrgLevelSettings.GranularOrgLevelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = OrgLevelSettings.protoMessageName + ".GranularOrgLevelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "opType"),
    2: .same(proto: "memberLevel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._opType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._opType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memberLevel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrgLevelSettings.GranularOrgLevelSetting, rhs: OrgLevelSettings.GranularOrgLevelSetting) -> Bool {
    if lhs._opType != rhs._opType {return false}
    if lhs._memberLevel != rhs._memberLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
