// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: picturevalue.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PictureValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique Picture ID
  public var id: String {
    get {return _storage._id ?? String()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// Type of the picture. The URL for the picture will be generated according to the type. 
  public var type: PictureValue.PictureType {
    get {return _storage._type ?? .userdefined}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// use the 'pictureUrl" variable instead of this.
  public var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {_uniqueStorage()._url = nil}

  /// Name of the picture 
  public var pictureName: String {
    get {return _storage._pictureName ?? String()}
    set {_uniqueStorage()._pictureName = newValue}
  }
  /// Returns true if `pictureName` has been explicitly set.
  public var hasPictureName: Bool {return _storage._pictureName != nil}
  /// Clears the value of `pictureName`. Subsequent reads from it will return its default value.
  public mutating func clearPictureName() {_uniqueStorage()._pictureName = nil}

  /// Used for ClipArt/Texture/ThemeBG images.
  public var relID: String {
    get {return _storage._relID ?? String()}
    set {_uniqueStorage()._relID = newValue}
  }
  /// Returns true if `relID` has been explicitly set.
  public var hasRelID: Bool {return _storage._relID != nil}
  /// Clears the value of `relID`. Subsequent reads from it will return its default value.
  public mutating func clearRelID() {_uniqueStorage()._relID = nil}

  public var license: PictureValue.LicenseDetails {
    get {return _storage._license ?? PictureValue.LicenseDetails()}
    set {_uniqueStorage()._license = newValue}
  }
  /// Returns true if `license` has been explicitly set.
  public var hasLicense: Bool {return _storage._license != nil}
  /// Clears the value of `license`. Subsequent reads from it will return its default value.
  public mutating func clearLicense() {_uniqueStorage()._license = nil}

  /// Using the URL proto instead of string. This will help us security wise.
  public var pictureURL: URL {
    get {return _storage._pictureURL ?? URL()}
    set {_uniqueStorage()._pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return _storage._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {_uniqueStorage()._pictureURL = nil}

  /// This will be used in case of alternate URLs for Gif images
  public var staticURL: URL {
    get {return _storage._staticURL ?? URL()}
    set {_uniqueStorage()._staticURL = newValue}
  }
  /// Returns true if `staticURL` has been explicitly set.
  public var hasStaticURL: Bool {return _storage._staticURL != nil}
  /// Clears the value of `staticURL`. Subsequent reads from it will return its default value.
  public mutating func clearStaticURL() {_uniqueStorage()._staticURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PictureType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// either Uploaded or imported.
    case userdefined // = 0

    /// Theme Background.
    case themebg // = 1

    /// Clip Art image
    case clipart // = 2

    /// Texture Image
    case texture // = 3

    /// Externally linked image
    case external // = 4

    /// PlaceHolder image - will be used by layouts.
    case placeholder // = 5

    public init() {
      self = .userdefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .userdefined
      case 1: self = .themebg
      case 2: self = .clipart
      case 3: self = .texture
      case 4: self = .external
      case 5: self = .placeholder
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .userdefined: return 0
      case .themebg: return 1
      case .clipart: return 2
      case .texture: return 3
      case .external: return 4
      case .placeholder: return 5
      }
    }

  }

  public struct LicenseDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var from: PictureValue.LicenseDetails.SearchedFrom {
      get {return _from ?? .defImageDomain}
      set {_from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    public var hasFrom: Bool {return self._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    public mutating func clearFrom() {self._from = nil}

    public var type: PictureValue.LicenseDetails.CreativeCommonsLicense {
      get {return _type ?? .defCcLicense}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    /// Date at which this picture was downloaded.
    public var date: Int64 {
      get {return _date ?? 0}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    public var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    public mutating func clearDate() {self._date = nil}

    /// Actual Site URL of the picture.
    public var url: URL {
      get {return _url ?? URL()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    public var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    public mutating func clearURL() {self._url = nil}

    /// Owner of the picture.	
    public var owner: PictureValue.LicenseDetails.OwnerInfo {
      get {return _owner ?? PictureValue.LicenseDetails.OwnerInfo()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    public var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    public mutating func clearOwner() {self._owner = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum SearchedFrom: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case defImageDomain // = 0
      case flickr // = 1
      case google // = 2
      case picasa // = 3
      case unsplash // = 4
      case pexels // = 5
      case pixabay // = 6

      public init() {
        self = .defImageDomain
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .defImageDomain
        case 1: self = .flickr
        case 2: self = .google
        case 3: self = .picasa
        case 4: self = .unsplash
        case 5: self = .pexels
        case 6: self = .pixabay
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .defImageDomain: return 0
        case .flickr: return 1
        case .google: return 2
        case .picasa: return 3
        case .unsplash: return 4
        case .pexels: return 5
        case .pixabay: return 6
        }
      }

    }

    public enum CreativeCommonsLicense: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case defCcLicense // = 0

      /// Attribution Non Commercial Share Alike license , http://creativecommons.org/licenses/by-nc-sa/2.0/
      case ancs // = 1

      /// Attribution Non Commercial license , http://creativecommons.org/licenses/by-nc/2.0/
      case anc // = 2

      /// Attribution Non Commercial No-Derivs license , http://creativecommons.org/licenses/by-nc-nd/2.0/
      case ann // = 3

      /// Attribution license , http://creativecommons.org/licenses/by/2.0/
      case a // = 4

      /// Attribution Share Alike , http://creativecommons.org/licenses/by-sa/2.0/
      case `as` // = 5

      /// Attribution No-Derivs , http://creativecommons.org/licenses/by-nd/2.0/
      case an // = 6

      /// grants you an irrevocable, nonexclusive, worldwide copyright license to download, copy, modify, distribute, perform, and use photos for free
      case noAtt // = 7

      public init() {
        self = .defCcLicense
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .defCcLicense
        case 1: self = .ancs
        case 2: self = .anc
        case 3: self = .ann
        case 4: self = .a
        case 5: self = .as
        case 6: self = .an
        case 7: self = .noAtt
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .defCcLicense: return 0
        case .ancs: return 1
        case .anc: return 2
        case .ann: return 3
        case .a: return 4
        case .as: return 5
        case .an: return 6
        case .noAtt: return 7
        }
      }

    }

    public struct OwnerInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String {
        get {return _storage._name ?? String()}
        set {_uniqueStorage()._name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      public var hasName: Bool {return _storage._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      public mutating func clearName() {_uniqueStorage()._name = nil}

      /// Owner profile page URL.
      public var profileURL: URL {
        get {return _storage._profileURL ?? URL()}
        set {_uniqueStorage()._profileURL = newValue}
      }
      /// Returns true if `profileURL` has been explicitly set.
      public var hasProfileURL: Bool {return _storage._profileURL != nil}
      /// Clears the value of `profileURL`. Subsequent reads from it will return its default value.
      public mutating func clearProfileURL() {_uniqueStorage()._profileURL = nil}

      /// Pictures album URL.
      public var albumURL: URL {
        get {return _storage._albumURL ?? URL()}
        set {_uniqueStorage()._albumURL = newValue}
      }
      /// Returns true if `albumURL` has been explicitly set.
      public var hasAlbumURL: Bool {return _storage._albumURL != nil}
      /// Clears the value of `albumURL`. Subsequent reads from it will return its default value.
      public mutating func clearAlbumURL() {_uniqueStorage()._albumURL = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}

    fileprivate var _from: PictureValue.LicenseDetails.SearchedFrom? = nil
    fileprivate var _type: PictureValue.LicenseDetails.CreativeCommonsLicense? = nil
    fileprivate var _date: Int64? = nil
    fileprivate var _url: URL? = nil
    fileprivate var _owner: PictureValue.LicenseDetails.OwnerInfo? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension PictureValue.PictureType: CaseIterable {
  // Support synthesized by the compiler.
}

extension PictureValue.LicenseDetails.SearchedFrom: CaseIterable {
  // Support synthesized by the compiler.
}

extension PictureValue.LicenseDetails.CreativeCommonsLicense: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension PictureValue: @unchecked Sendable {}
extension PictureValue.PictureType: @unchecked Sendable {}
extension PictureValue.LicenseDetails: @unchecked Sendable {}
extension PictureValue.LicenseDetails.SearchedFrom: @unchecked Sendable {}
extension PictureValue.LicenseDetails.CreativeCommonsLicense: @unchecked Sendable {}
extension PictureValue.LicenseDetails.OwnerInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension PictureValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "url"),
    4: .same(proto: "pictureName"),
    5: .same(proto: "relId"),
    6: .same(proto: "license"),
    7: .same(proto: "pictureUrl"),
    8: .same(proto: "staticUrl"),
  ]

  fileprivate class _StorageClass {
    var _id: String? = nil
    var _type: PictureValue.PictureType? = nil
    var _url: String? = nil
    var _pictureName: String? = nil
    var _relID: String? = nil
    var _license: PictureValue.LicenseDetails? = nil
    var _pictureURL: URL? = nil
    var _staticURL: URL? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _url = source._url
      _pictureName = source._pictureName
      _relID = source._relID
      _license = source._license
      _pictureURL = source._pictureURL
      _staticURL = source._staticURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id == nil {return false}
      if _storage._type == nil {return false}
      if let v = _storage._license, !v.isInitialized {return false}
      if let v = _storage._pictureURL, !v.isInitialized {return false}
      if let v = _storage._staticURL, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._pictureName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._relID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._license) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._pictureURL) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._staticURL) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._pictureName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._relID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._license {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._pictureURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._staticURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureValue, rhs: PictureValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._pictureName != rhs_storage._pictureName {return false}
        if _storage._relID != rhs_storage._relID {return false}
        if _storage._license != rhs_storage._license {return false}
        if _storage._pictureURL != rhs_storage._pictureURL {return false}
        if _storage._staticURL != rhs_storage._staticURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureValue.PictureType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USERDEFINED"),
    1: .same(proto: "THEMEBG"),
    2: .same(proto: "CLIPART"),
    3: .same(proto: "TEXTURE"),
    4: .same(proto: "EXTERNAL"),
    5: .same(proto: "PLACEHOLDER"),
  ]
}

extension PictureValue.LicenseDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PictureValue.protoMessageName + ".LicenseDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "type"),
    3: .same(proto: "date"),
    4: .same(proto: "url"),
    5: .same(proto: "owner"),
  ]

  public var isInitialized: Bool {
    if self._from == nil {return false}
    if self._type == nil {return false}
    if self._date == nil {return false}
    if self._url == nil {return false}
    if self._owner == nil {return false}
    if let v = self._url, !v.isInitialized {return false}
    if let v = self._owner, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._from) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._date) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._from {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureValue.LicenseDetails, rhs: PictureValue.LicenseDetails) -> Bool {
    if lhs._from != rhs._from {return false}
    if lhs._type != rhs._type {return false}
    if lhs._date != rhs._date {return false}
    if lhs._url != rhs._url {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureValue.LicenseDetails.SearchedFrom: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_IMAGE_DOMAIN"),
    1: .same(proto: "FLICKR"),
    2: .same(proto: "GOOGLE"),
    3: .same(proto: "PICASA"),
    4: .same(proto: "UNSPLASH"),
    5: .same(proto: "PEXELS"),
    6: .same(proto: "PIXABAY"),
  ]
}

extension PictureValue.LicenseDetails.CreativeCommonsLicense: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_CC_LICENSE"),
    1: .same(proto: "ANCS"),
    2: .same(proto: "ANC"),
    3: .same(proto: "ANN"),
    4: .same(proto: "A"),
    5: .same(proto: "AS"),
    6: .same(proto: "AN"),
    7: .same(proto: "NO_ATT"),
  ]
}

extension PictureValue.LicenseDetails.OwnerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PictureValue.LicenseDetails.protoMessageName + ".OwnerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "profileUrl"),
    3: .same(proto: "albumUrl"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _profileURL: URL? = nil
    var _albumURL: URL? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _profileURL = source._profileURL
      _albumURL = source._albumURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if let v = _storage._profileURL, !v.isInitialized {return false}
      if let v = _storage._albumURL, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._profileURL) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._albumURL) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._profileURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._albumURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureValue.LicenseDetails.OwnerInfo, rhs: PictureValue.LicenseDetails.OwnerInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._profileURL != rhs_storage._profileURL {return false}
        if _storage._albumURL != rhs_storage._albumURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
