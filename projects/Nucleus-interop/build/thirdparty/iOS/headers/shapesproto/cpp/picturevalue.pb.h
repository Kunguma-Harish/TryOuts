// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: picturevalue.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_picturevalue_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_picturevalue_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "url.pb.h"
#include "google/protobuf/protoextensions.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_picturevalue_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_picturevalue_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_picturevalue_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class PictureValue;
struct PictureValueDefaultTypeInternal;
extern PictureValueDefaultTypeInternal _PictureValue_default_instance_;
class PictureValue_LicenseDetails;
struct PictureValue_LicenseDetailsDefaultTypeInternal;
extern PictureValue_LicenseDetailsDefaultTypeInternal _PictureValue_LicenseDetails_default_instance_;
class PictureValue_LicenseDetails_OwnerInfo;
struct PictureValue_LicenseDetails_OwnerInfoDefaultTypeInternal;
extern PictureValue_LicenseDetails_OwnerInfoDefaultTypeInternal _PictureValue_LicenseDetails_OwnerInfo_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {
enum PictureValue_LicenseDetails_SearchedFrom : int {
  PictureValue_LicenseDetails_SearchedFrom_DEF_IMAGE_DOMAIN = 0,
  PictureValue_LicenseDetails_SearchedFrom_FLICKR = 1,
  PictureValue_LicenseDetails_SearchedFrom_GOOGLE = 2,
  PictureValue_LicenseDetails_SearchedFrom_PICASA = 3,
  PictureValue_LicenseDetails_SearchedFrom_UNSPLASH = 4,
  PictureValue_LicenseDetails_SearchedFrom_PEXELS = 5,
  PictureValue_LicenseDetails_SearchedFrom_PIXABAY = 6,
  PictureValue_LicenseDetails_SearchedFrom_PictureValue_LicenseDetails_SearchedFrom_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PictureValue_LicenseDetails_SearchedFrom_PictureValue_LicenseDetails_SearchedFrom_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PictureValue_LicenseDetails_SearchedFrom_IsValid(int value);
extern const uint32_t PictureValue_LicenseDetails_SearchedFrom_internal_data_[];
constexpr PictureValue_LicenseDetails_SearchedFrom PictureValue_LicenseDetails_SearchedFrom_SearchedFrom_MIN = static_cast<PictureValue_LicenseDetails_SearchedFrom>(0);
constexpr PictureValue_LicenseDetails_SearchedFrom PictureValue_LicenseDetails_SearchedFrom_SearchedFrom_MAX = static_cast<PictureValue_LicenseDetails_SearchedFrom>(6);
constexpr int PictureValue_LicenseDetails_SearchedFrom_SearchedFrom_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
PictureValue_LicenseDetails_SearchedFrom_descriptor();
template <typename T>
const std::string& PictureValue_LicenseDetails_SearchedFrom_Name(T value) {
  static_assert(std::is_same<T, PictureValue_LicenseDetails_SearchedFrom>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SearchedFrom_Name().");
  return PictureValue_LicenseDetails_SearchedFrom_Name(static_cast<PictureValue_LicenseDetails_SearchedFrom>(value));
}
template <>
inline const std::string& PictureValue_LicenseDetails_SearchedFrom_Name(PictureValue_LicenseDetails_SearchedFrom value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PictureValue_LicenseDetails_SearchedFrom_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool PictureValue_LicenseDetails_SearchedFrom_Parse(absl::string_view name, PictureValue_LicenseDetails_SearchedFrom* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PictureValue_LicenseDetails_SearchedFrom>(
      PictureValue_LicenseDetails_SearchedFrom_descriptor(), name, value);
}
enum PictureValue_LicenseDetails_CreativeCommonsLicense : int {
  PictureValue_LicenseDetails_CreativeCommonsLicense_DEF_CC_LICENSE = 0,
  PictureValue_LicenseDetails_CreativeCommonsLicense_ANCS = 1,
  PictureValue_LicenseDetails_CreativeCommonsLicense_ANC = 2,
  PictureValue_LicenseDetails_CreativeCommonsLicense_ANN = 3,
  PictureValue_LicenseDetails_CreativeCommonsLicense_A = 4,
  PictureValue_LicenseDetails_CreativeCommonsLicense_AS = 5,
  PictureValue_LicenseDetails_CreativeCommonsLicense_AN = 6,
  PictureValue_LicenseDetails_CreativeCommonsLicense_NO_ATT = 7,
  PictureValue_LicenseDetails_CreativeCommonsLicense_PictureValue_LicenseDetails_CreativeCommonsLicense_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PictureValue_LicenseDetails_CreativeCommonsLicense_PictureValue_LicenseDetails_CreativeCommonsLicense_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PictureValue_LicenseDetails_CreativeCommonsLicense_IsValid(int value);
extern const uint32_t PictureValue_LicenseDetails_CreativeCommonsLicense_internal_data_[];
constexpr PictureValue_LicenseDetails_CreativeCommonsLicense PictureValue_LicenseDetails_CreativeCommonsLicense_CreativeCommonsLicense_MIN = static_cast<PictureValue_LicenseDetails_CreativeCommonsLicense>(0);
constexpr PictureValue_LicenseDetails_CreativeCommonsLicense PictureValue_LicenseDetails_CreativeCommonsLicense_CreativeCommonsLicense_MAX = static_cast<PictureValue_LicenseDetails_CreativeCommonsLicense>(7);
constexpr int PictureValue_LicenseDetails_CreativeCommonsLicense_CreativeCommonsLicense_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
PictureValue_LicenseDetails_CreativeCommonsLicense_descriptor();
template <typename T>
const std::string& PictureValue_LicenseDetails_CreativeCommonsLicense_Name(T value) {
  static_assert(std::is_same<T, PictureValue_LicenseDetails_CreativeCommonsLicense>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CreativeCommonsLicense_Name().");
  return PictureValue_LicenseDetails_CreativeCommonsLicense_Name(static_cast<PictureValue_LicenseDetails_CreativeCommonsLicense>(value));
}
template <>
inline const std::string& PictureValue_LicenseDetails_CreativeCommonsLicense_Name(PictureValue_LicenseDetails_CreativeCommonsLicense value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PictureValue_LicenseDetails_CreativeCommonsLicense_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool PictureValue_LicenseDetails_CreativeCommonsLicense_Parse(absl::string_view name, PictureValue_LicenseDetails_CreativeCommonsLicense* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PictureValue_LicenseDetails_CreativeCommonsLicense>(
      PictureValue_LicenseDetails_CreativeCommonsLicense_descriptor(), name, value);
}
enum PictureValue_PictureType : int {
  PictureValue_PictureType_USERDEFINED = 0,
  PictureValue_PictureType_THEMEBG = 1,
  PictureValue_PictureType_CLIPART = 2,
  PictureValue_PictureType_TEXTURE = 3,
  PictureValue_PictureType_EXTERNAL = 4,
  PictureValue_PictureType_PLACEHOLDER = 5,
  PictureValue_PictureType_PictureValue_PictureType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PictureValue_PictureType_PictureValue_PictureType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PictureValue_PictureType_IsValid(int value);
extern const uint32_t PictureValue_PictureType_internal_data_[];
constexpr PictureValue_PictureType PictureValue_PictureType_PictureType_MIN = static_cast<PictureValue_PictureType>(0);
constexpr PictureValue_PictureType PictureValue_PictureType_PictureType_MAX = static_cast<PictureValue_PictureType>(5);
constexpr int PictureValue_PictureType_PictureType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
PictureValue_PictureType_descriptor();
template <typename T>
const std::string& PictureValue_PictureType_Name(T value) {
  static_assert(std::is_same<T, PictureValue_PictureType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PictureType_Name().");
  return PictureValue_PictureType_Name(static_cast<PictureValue_PictureType>(value));
}
template <>
inline const std::string& PictureValue_PictureType_Name(PictureValue_PictureType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PictureValue_PictureType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool PictureValue_PictureType_Parse(absl::string_view name, PictureValue_PictureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PictureValue_PictureType>(
      PictureValue_PictureType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PictureValue_LicenseDetails_OwnerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo) */ {
 public:
  inline PictureValue_LicenseDetails_OwnerInfo() : PictureValue_LicenseDetails_OwnerInfo(nullptr) {}
  ~PictureValue_LicenseDetails_OwnerInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PictureValue_LicenseDetails_OwnerInfo(::google::protobuf::internal::ConstantInitialized);

  inline PictureValue_LicenseDetails_OwnerInfo(const PictureValue_LicenseDetails_OwnerInfo& from)
      : PictureValue_LicenseDetails_OwnerInfo(nullptr, from) {}
  PictureValue_LicenseDetails_OwnerInfo(PictureValue_LicenseDetails_OwnerInfo&& from) noexcept
    : PictureValue_LicenseDetails_OwnerInfo() {
    *this = ::std::move(from);
  }

  inline PictureValue_LicenseDetails_OwnerInfo& operator=(const PictureValue_LicenseDetails_OwnerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PictureValue_LicenseDetails_OwnerInfo& operator=(PictureValue_LicenseDetails_OwnerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PictureValue_LicenseDetails_OwnerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PictureValue_LicenseDetails_OwnerInfo* internal_default_instance() {
    return reinterpret_cast<const PictureValue_LicenseDetails_OwnerInfo*>(
               &_PictureValue_LicenseDetails_OwnerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PictureValue_LicenseDetails_OwnerInfo& a, PictureValue_LicenseDetails_OwnerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PictureValue_LicenseDetails_OwnerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PictureValue_LicenseDetails_OwnerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PictureValue_LicenseDetails_OwnerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PictureValue_LicenseDetails_OwnerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PictureValue_LicenseDetails_OwnerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PictureValue_LicenseDetails_OwnerInfo& from) {
    PictureValue_LicenseDetails_OwnerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PictureValue_LicenseDetails_OwnerInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo";
  }
  protected:
  explicit PictureValue_LicenseDetails_OwnerInfo(::google::protobuf::Arena* arena);
  PictureValue_LicenseDetails_OwnerInfo(::google::protobuf::Arena* arena, const PictureValue_LicenseDetails_OwnerInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kProfileUrlFieldNumber = 2,
    kAlbumUrlFieldNumber = 3,
  };
  // optional string name = 1 [(.com.zoho.common.customOptions) = {
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .com.zoho.common.URL profileUrl = 2;
  bool has_profileurl() const;
  void clear_profileurl() ;
  const ::com::zoho::common::URL& profileurl() const;
  PROTOBUF_NODISCARD ::com::zoho::common::URL* release_profileurl();
  ::com::zoho::common::URL* mutable_profileurl();
  void set_allocated_profileurl(::com::zoho::common::URL* value);
  void unsafe_arena_set_allocated_profileurl(::com::zoho::common::URL* value);
  ::com::zoho::common::URL* unsafe_arena_release_profileurl();

  private:
  const ::com::zoho::common::URL& _internal_profileurl() const;
  ::com::zoho::common::URL* _internal_mutable_profileurl();

  public:
  // optional .com.zoho.common.URL albumUrl = 3;
  bool has_albumurl() const;
  void clear_albumurl() ;
  const ::com::zoho::common::URL& albumurl() const;
  PROTOBUF_NODISCARD ::com::zoho::common::URL* release_albumurl();
  ::com::zoho::common::URL* mutable_albumurl();
  void set_allocated_albumurl(::com::zoho::common::URL* value);
  void unsafe_arena_set_allocated_albumurl(::com::zoho::common::URL* value);
  ::com::zoho::common::URL* unsafe_arena_release_albumurl();

  private:
  const ::com::zoho::common::URL& _internal_albumurl() const;
  ::com::zoho::common::URL* _internal_mutable_albumurl();

  public:
  void temp_setprofileUrl(com::zoho::common::URL* profileUrl) {
    if(&this->profileurl() != profileUrl) {
      set_allocated_profileurl(profileUrl);
    }
  }
  
  com::zoho::common::URL* temp_getprofileUrl() const {
    if (has_profileurl()) 
      return (const_cast<com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo*>(this))->mutable_profileurl();
    return nullptr;
  }
  
  void temp_setalbumUrl(com::zoho::common::URL* albumUrl) {
    if(&this->albumurl() != albumUrl) {
      set_allocated_albumurl(albumUrl);
    }
  }
  
  com::zoho::common::URL* temp_getalbumUrl() const {
    if (has_albumurl()) 
      return (const_cast<com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo*>(this))->mutable_albumurl();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::com::zoho::common::URL* profileurl_;
    ::com::zoho::common::URL* albumurl_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_picturevalue_2eproto;
};// -------------------------------------------------------------------

class PictureValue_LicenseDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PictureValue.LicenseDetails) */ {
 public:
  inline PictureValue_LicenseDetails() : PictureValue_LicenseDetails(nullptr) {}
  ~PictureValue_LicenseDetails() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PictureValue_LicenseDetails(::google::protobuf::internal::ConstantInitialized);

  inline PictureValue_LicenseDetails(const PictureValue_LicenseDetails& from)
      : PictureValue_LicenseDetails(nullptr, from) {}
  PictureValue_LicenseDetails(PictureValue_LicenseDetails&& from) noexcept
    : PictureValue_LicenseDetails() {
    *this = ::std::move(from);
  }

  inline PictureValue_LicenseDetails& operator=(const PictureValue_LicenseDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PictureValue_LicenseDetails& operator=(PictureValue_LicenseDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PictureValue_LicenseDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const PictureValue_LicenseDetails* internal_default_instance() {
    return reinterpret_cast<const PictureValue_LicenseDetails*>(
               &_PictureValue_LicenseDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PictureValue_LicenseDetails& a, PictureValue_LicenseDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PictureValue_LicenseDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PictureValue_LicenseDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PictureValue_LicenseDetails* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PictureValue_LicenseDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PictureValue_LicenseDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PictureValue_LicenseDetails& from) {
    PictureValue_LicenseDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PictureValue_LicenseDetails* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PictureValue.LicenseDetails";
  }
  protected:
  explicit PictureValue_LicenseDetails(::google::protobuf::Arena* arena);
  PictureValue_LicenseDetails(::google::protobuf::Arena* arena, const PictureValue_LicenseDetails& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using OwnerInfo = PictureValue_LicenseDetails_OwnerInfo;

  using SearchedFrom = PictureValue_LicenseDetails_SearchedFrom;
  static constexpr SearchedFrom DEF_IMAGE_DOMAIN = PictureValue_LicenseDetails_SearchedFrom_DEF_IMAGE_DOMAIN;
  static constexpr SearchedFrom FLICKR = PictureValue_LicenseDetails_SearchedFrom_FLICKR;
  static constexpr SearchedFrom GOOGLE = PictureValue_LicenseDetails_SearchedFrom_GOOGLE;
  static constexpr SearchedFrom PICASA = PictureValue_LicenseDetails_SearchedFrom_PICASA;
  static constexpr SearchedFrom UNSPLASH = PictureValue_LicenseDetails_SearchedFrom_UNSPLASH;
  static constexpr SearchedFrom PEXELS = PictureValue_LicenseDetails_SearchedFrom_PEXELS;
  static constexpr SearchedFrom PIXABAY = PictureValue_LicenseDetails_SearchedFrom_PIXABAY;
  static inline bool SearchedFrom_IsValid(int value) {
    return PictureValue_LicenseDetails_SearchedFrom_IsValid(value);
  }
  static constexpr SearchedFrom SearchedFrom_MIN = PictureValue_LicenseDetails_SearchedFrom_SearchedFrom_MIN;
  static constexpr SearchedFrom SearchedFrom_MAX = PictureValue_LicenseDetails_SearchedFrom_SearchedFrom_MAX;
  static constexpr int SearchedFrom_ARRAYSIZE = PictureValue_LicenseDetails_SearchedFrom_SearchedFrom_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SearchedFrom_descriptor() {
    return PictureValue_LicenseDetails_SearchedFrom_descriptor();
  }
  template <typename T>
  static inline const std::string& SearchedFrom_Name(T value) {
    return PictureValue_LicenseDetails_SearchedFrom_Name(value);
  }
  static inline bool SearchedFrom_Parse(absl::string_view name, SearchedFrom* value) {
    return PictureValue_LicenseDetails_SearchedFrom_Parse(name, value);
  }

  using CreativeCommonsLicense = PictureValue_LicenseDetails_CreativeCommonsLicense;
  static constexpr CreativeCommonsLicense DEF_CC_LICENSE = PictureValue_LicenseDetails_CreativeCommonsLicense_DEF_CC_LICENSE;
  static constexpr CreativeCommonsLicense ANCS = PictureValue_LicenseDetails_CreativeCommonsLicense_ANCS;
  static constexpr CreativeCommonsLicense ANC = PictureValue_LicenseDetails_CreativeCommonsLicense_ANC;
  static constexpr CreativeCommonsLicense ANN = PictureValue_LicenseDetails_CreativeCommonsLicense_ANN;
  static constexpr CreativeCommonsLicense A = PictureValue_LicenseDetails_CreativeCommonsLicense_A;
  static constexpr CreativeCommonsLicense AS = PictureValue_LicenseDetails_CreativeCommonsLicense_AS;
  static constexpr CreativeCommonsLicense AN = PictureValue_LicenseDetails_CreativeCommonsLicense_AN;
  static constexpr CreativeCommonsLicense NO_ATT = PictureValue_LicenseDetails_CreativeCommonsLicense_NO_ATT;
  static inline bool CreativeCommonsLicense_IsValid(int value) {
    return PictureValue_LicenseDetails_CreativeCommonsLicense_IsValid(value);
  }
  static constexpr CreativeCommonsLicense CreativeCommonsLicense_MIN = PictureValue_LicenseDetails_CreativeCommonsLicense_CreativeCommonsLicense_MIN;
  static constexpr CreativeCommonsLicense CreativeCommonsLicense_MAX = PictureValue_LicenseDetails_CreativeCommonsLicense_CreativeCommonsLicense_MAX;
  static constexpr int CreativeCommonsLicense_ARRAYSIZE = PictureValue_LicenseDetails_CreativeCommonsLicense_CreativeCommonsLicense_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CreativeCommonsLicense_descriptor() {
    return PictureValue_LicenseDetails_CreativeCommonsLicense_descriptor();
  }
  template <typename T>
  static inline const std::string& CreativeCommonsLicense_Name(T value) {
    return PictureValue_LicenseDetails_CreativeCommonsLicense_Name(value);
  }
  static inline bool CreativeCommonsLicense_Parse(absl::string_view name, CreativeCommonsLicense* value) {
    return PictureValue_LicenseDetails_CreativeCommonsLicense_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 4,
    kOwnerFieldNumber = 5,
    kFromFieldNumber = 1,
    kTypeFieldNumber = 2,
    kDateFieldNumber = 3,
  };
  // optional .com.zoho.common.URL url = 4 [(.com.zoho.common.customOptions) = {
  bool has_url() const;
  void clear_url() ;
  const ::com::zoho::common::URL& url() const;
  PROTOBUF_NODISCARD ::com::zoho::common::URL* release_url();
  ::com::zoho::common::URL* mutable_url();
  void set_allocated_url(::com::zoho::common::URL* value);
  void unsafe_arena_set_allocated_url(::com::zoho::common::URL* value);
  ::com::zoho::common::URL* unsafe_arena_release_url();

  private:
  const ::com::zoho::common::URL& _internal_url() const;
  ::com::zoho::common::URL* _internal_mutable_url();

  public:
  // optional .com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo owner = 5 [(.com.zoho.common.customOptions) = {
  bool has_owner() const;
  void clear_owner() ;
  const ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo& owner() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* release_owner();
  ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* mutable_owner();
  void set_allocated_owner(::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* value);
  void unsafe_arena_set_allocated_owner(::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* value);
  ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* unsafe_arena_release_owner();

  private:
  const ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo& _internal_owner() const;
  ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* _internal_mutable_owner();

  public:
  // optional .com.zoho.shapes.PictureValue.LicenseDetails.SearchedFrom from = 1 [(.com.zoho.common.customOptions) = {
  bool has_from() const;
  void clear_from() ;
  ::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom from() const;
  void set_from(::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom value);

  private:
  ::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom _internal_from() const;
  void _internal_set_from(::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom value);

  public:
  // optional .com.zoho.shapes.PictureValue.LicenseDetails.CreativeCommonsLicense type = 2 [(.com.zoho.common.customOptions) = {
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense type() const;
  void set_type(::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense value);

  private:
  ::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense value);

  public:
  // optional int64 date = 3 [(.com.zoho.common.customOptions) = {
  bool has_date() const;
  void clear_date() ;
  ::int64_t date() const;
  void set_date(::int64_t value);

  private:
  ::int64_t _internal_date() const;
  void _internal_set_date(::int64_t value);

  public:
  void temp_seturl(com::zoho::common::URL* url) {
    if(&this->url() != url) {
      set_allocated_url(url);
    }
  }
  
  com::zoho::common::URL* temp_geturl() const {
    if (has_url()) 
      return (const_cast<com::zoho::shapes::PictureValue_LicenseDetails*>(this))->mutable_url();
    return nullptr;
  }
  
  void temp_setowner(com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* owner) {
    if(&this->owner() != owner) {
      set_allocated_owner(owner);
    }
  }
  
  com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* temp_getowner() const {
    if (has_owner()) 
      return (const_cast<com::zoho::shapes::PictureValue_LicenseDetails*>(this))->mutable_owner();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PictureValue.LicenseDetails)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::URL* url_;
    ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* owner_;
    int from_;
    int type_;
    ::int64_t date_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_picturevalue_2eproto;
};// -------------------------------------------------------------------

class PictureValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PictureValue) */ {
 public:
  inline PictureValue() : PictureValue(nullptr) {}
  ~PictureValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PictureValue(::google::protobuf::internal::ConstantInitialized);

  inline PictureValue(const PictureValue& from)
      : PictureValue(nullptr, from) {}
  PictureValue(PictureValue&& from) noexcept
    : PictureValue() {
    *this = ::std::move(from);
  }

  inline PictureValue& operator=(const PictureValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PictureValue& operator=(PictureValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PictureValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PictureValue* internal_default_instance() {
    return reinterpret_cast<const PictureValue*>(
               &_PictureValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PictureValue& a, PictureValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PictureValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PictureValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PictureValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PictureValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PictureValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PictureValue& from) {
    PictureValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PictureValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PictureValue";
  }
  protected:
  explicit PictureValue(::google::protobuf::Arena* arena);
  PictureValue(::google::protobuf::Arena* arena, const PictureValue& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LicenseDetails = PictureValue_LicenseDetails;

  using PictureType = PictureValue_PictureType;
  static constexpr PictureType USERDEFINED = PictureValue_PictureType_USERDEFINED;
  static constexpr PictureType THEMEBG = PictureValue_PictureType_THEMEBG;
  static constexpr PictureType CLIPART = PictureValue_PictureType_CLIPART;
  static constexpr PictureType TEXTURE = PictureValue_PictureType_TEXTURE;
  static constexpr PictureType EXTERNAL = PictureValue_PictureType_EXTERNAL;
  static constexpr PictureType PLACEHOLDER = PictureValue_PictureType_PLACEHOLDER;
  static inline bool PictureType_IsValid(int value) {
    return PictureValue_PictureType_IsValid(value);
  }
  static constexpr PictureType PictureType_MIN = PictureValue_PictureType_PictureType_MIN;
  static constexpr PictureType PictureType_MAX = PictureValue_PictureType_PictureType_MAX;
  static constexpr int PictureType_ARRAYSIZE = PictureValue_PictureType_PictureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PictureType_descriptor() {
    return PictureValue_PictureType_descriptor();
  }
  template <typename T>
  static inline const std::string& PictureType_Name(T value) {
    return PictureValue_PictureType_Name(value);
  }
  static inline bool PictureType_Parse(absl::string_view name, PictureType* value) {
    return PictureValue_PictureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUrlFieldNumber = 3,
    kPictureNameFieldNumber = 4,
    kRelIdFieldNumber = 5,
    kClientKeyFieldNumber = 9,
    kLicenseFieldNumber = 6,
    kPictureUrlFieldNumber = 7,
    kStaticUrlFieldNumber = 8,
    kTypeFieldNumber = 2,
  };
  // optional string id = 1 [(.com.zoho.common.customOptions) = {
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string url = 3;
  bool has_url() const;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // optional string pictureName = 4;
  bool has_picturename() const;
  void clear_picturename() ;
  const std::string& picturename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_picturename(Arg_&& arg, Args_... args);
  std::string* mutable_picturename();
  PROTOBUF_NODISCARD std::string* release_picturename();
  void set_allocated_picturename(std::string* value);

  private:
  const std::string& _internal_picturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picturename(
      const std::string& value);
  std::string* _internal_mutable_picturename();

  public:
  // optional string relId = 5;
  bool has_relid() const;
  void clear_relid() ;
  const std::string& relid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relid(Arg_&& arg, Args_... args);
  std::string* mutable_relid();
  PROTOBUF_NODISCARD std::string* release_relid();
  void set_allocated_relid(std::string* value);

  private:
  const std::string& _internal_relid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relid(
      const std::string& value);
  std::string* _internal_mutable_relid();

  public:
  // optional string clientKey = 9;
  bool has_clientkey() const;
  void clear_clientkey() ;
  const std::string& clientkey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientkey(Arg_&& arg, Args_... args);
  std::string* mutable_clientkey();
  PROTOBUF_NODISCARD std::string* release_clientkey();
  void set_allocated_clientkey(std::string* value);

  private:
  const std::string& _internal_clientkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientkey(
      const std::string& value);
  std::string* _internal_mutable_clientkey();

  public:
  // optional .com.zoho.shapes.PictureValue.LicenseDetails license = 6;
  bool has_license() const;
  void clear_license() ;
  const ::com::zoho::shapes::PictureValue_LicenseDetails& license() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PictureValue_LicenseDetails* release_license();
  ::com::zoho::shapes::PictureValue_LicenseDetails* mutable_license();
  void set_allocated_license(::com::zoho::shapes::PictureValue_LicenseDetails* value);
  void unsafe_arena_set_allocated_license(::com::zoho::shapes::PictureValue_LicenseDetails* value);
  ::com::zoho::shapes::PictureValue_LicenseDetails* unsafe_arena_release_license();

  private:
  const ::com::zoho::shapes::PictureValue_LicenseDetails& _internal_license() const;
  ::com::zoho::shapes::PictureValue_LicenseDetails* _internal_mutable_license();

  public:
  // optional .com.zoho.common.URL pictureUrl = 7;
  bool has_pictureurl() const;
  void clear_pictureurl() ;
  const ::com::zoho::common::URL& pictureurl() const;
  PROTOBUF_NODISCARD ::com::zoho::common::URL* release_pictureurl();
  ::com::zoho::common::URL* mutable_pictureurl();
  void set_allocated_pictureurl(::com::zoho::common::URL* value);
  void unsafe_arena_set_allocated_pictureurl(::com::zoho::common::URL* value);
  ::com::zoho::common::URL* unsafe_arena_release_pictureurl();

  private:
  const ::com::zoho::common::URL& _internal_pictureurl() const;
  ::com::zoho::common::URL* _internal_mutable_pictureurl();

  public:
  // optional .com.zoho.common.URL staticUrl = 8;
  bool has_staticurl() const;
  void clear_staticurl() ;
  const ::com::zoho::common::URL& staticurl() const;
  PROTOBUF_NODISCARD ::com::zoho::common::URL* release_staticurl();
  ::com::zoho::common::URL* mutable_staticurl();
  void set_allocated_staticurl(::com::zoho::common::URL* value);
  void unsafe_arena_set_allocated_staticurl(::com::zoho::common::URL* value);
  ::com::zoho::common::URL* unsafe_arena_release_staticurl();

  private:
  const ::com::zoho::common::URL& _internal_staticurl() const;
  ::com::zoho::common::URL* _internal_mutable_staticurl();

  public:
  // optional .com.zoho.shapes.PictureValue.PictureType type = 2 [(.com.zoho.common.customOptions) = {
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::PictureValue_PictureType type() const;
  void set_type(::com::zoho::shapes::PictureValue_PictureType value);

  private:
  ::com::zoho::shapes::PictureValue_PictureType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::PictureValue_PictureType value);

  public:
  void temp_setlicense(com::zoho::shapes::PictureValue_LicenseDetails* license) {
    if(&this->license() != license) {
      set_allocated_license(license);
    }
  }
  
  com::zoho::shapes::PictureValue_LicenseDetails* temp_getlicense() const {
    if (has_license()) 
      return (const_cast<com::zoho::shapes::PictureValue*>(this))->mutable_license();
    return nullptr;
  }
  
  void temp_setpictureUrl(com::zoho::common::URL* pictureUrl) {
    if(&this->pictureurl() != pictureUrl) {
      set_allocated_pictureurl(pictureUrl);
    }
  }
  
  com::zoho::common::URL* temp_getpictureUrl() const {
    if (has_pictureurl()) 
      return (const_cast<com::zoho::shapes::PictureValue*>(this))->mutable_pictureurl();
    return nullptr;
  }
  
  void temp_setstaticUrl(com::zoho::common::URL* staticUrl) {
    if(&this->staticurl() != staticUrl) {
      set_allocated_staticurl(staticUrl);
    }
  }
  
  com::zoho::common::URL* temp_getstaticUrl() const {
    if (has_staticurl()) 
      return (const_cast<com::zoho::shapes::PictureValue*>(this))->mutable_staticurl();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PictureValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr picturename_;
    ::google::protobuf::internal::ArenaStringPtr relid_;
    ::google::protobuf::internal::ArenaStringPtr clientkey_;
    ::com::zoho::shapes::PictureValue_LicenseDetails* license_;
    ::com::zoho::common::URL* pictureurl_;
    ::com::zoho::common::URL* staticurl_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_picturevalue_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PictureValue_LicenseDetails_OwnerInfo

// optional string name = 1 [(.com.zoho.common.customOptions) = {
inline bool PictureValue_LicenseDetails_OwnerInfo::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PictureValue_LicenseDetails_OwnerInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PictureValue_LicenseDetails_OwnerInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PictureValue_LicenseDetails_OwnerInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.name)
}
inline std::string* PictureValue_LicenseDetails_OwnerInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.name)
  return _s;
}
inline const std::string& PictureValue_LicenseDetails_OwnerInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void PictureValue_LicenseDetails_OwnerInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PictureValue_LicenseDetails_OwnerInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PictureValue_LicenseDetails_OwnerInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PictureValue_LicenseDetails_OwnerInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.name)
}

// optional .com.zoho.common.URL profileUrl = 2;
inline bool PictureValue_LicenseDetails_OwnerInfo::has_profileurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profileurl_ != nullptr);
  return value;
}
inline const ::com::zoho::common::URL& PictureValue_LicenseDetails_OwnerInfo::_internal_profileurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::URL* p = _impl_.profileurl_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::URL&>(::com::zoho::common::_URL_default_instance_);
}
inline const ::com::zoho::common::URL& PictureValue_LicenseDetails_OwnerInfo::profileurl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.profileUrl)
  return _internal_profileurl();
}
inline void PictureValue_LicenseDetails_OwnerInfo::unsafe_arena_set_allocated_profileurl(::com::zoho::common::URL* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.profileurl_);
  }
  _impl_.profileurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.profileUrl)
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::release_profileurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::URL* released = _impl_.profileurl_;
  _impl_.profileurl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::unsafe_arena_release_profileurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.profileUrl)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::URL* temp = _impl_.profileurl_;
  _impl_.profileurl_ = nullptr;
  return temp;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::_internal_mutable_profileurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.profileurl_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::URL>(GetArena());
    _impl_.profileurl_ = reinterpret_cast<::com::zoho::common::URL*>(p);
  }
  return _impl_.profileurl_;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::mutable_profileurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::URL* _msg = _internal_mutable_profileurl();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.profileUrl)
  return _msg;
}
inline void PictureValue_LicenseDetails_OwnerInfo::set_allocated_profileurl(::com::zoho::common::URL* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.profileurl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.profileurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.profileUrl)
}

// optional .com.zoho.common.URL albumUrl = 3;
inline bool PictureValue_LicenseDetails_OwnerInfo::has_albumurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.albumurl_ != nullptr);
  return value;
}
inline const ::com::zoho::common::URL& PictureValue_LicenseDetails_OwnerInfo::_internal_albumurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::URL* p = _impl_.albumurl_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::URL&>(::com::zoho::common::_URL_default_instance_);
}
inline const ::com::zoho::common::URL& PictureValue_LicenseDetails_OwnerInfo::albumurl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.albumUrl)
  return _internal_albumurl();
}
inline void PictureValue_LicenseDetails_OwnerInfo::unsafe_arena_set_allocated_albumurl(::com::zoho::common::URL* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.albumurl_);
  }
  _impl_.albumurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.albumUrl)
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::release_albumurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::common::URL* released = _impl_.albumurl_;
  _impl_.albumurl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::unsafe_arena_release_albumurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.albumUrl)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::common::URL* temp = _impl_.albumurl_;
  _impl_.albumurl_ = nullptr;
  return temp;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::_internal_mutable_albumurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.albumurl_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::URL>(GetArena());
    _impl_.albumurl_ = reinterpret_cast<::com::zoho::common::URL*>(p);
  }
  return _impl_.albumurl_;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails_OwnerInfo::mutable_albumurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::URL* _msg = _internal_mutable_albumurl();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.albumUrl)
  return _msg;
}
inline void PictureValue_LicenseDetails_OwnerInfo::set_allocated_albumurl(::com::zoho::common::URL* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.albumurl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.albumurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo.albumUrl)
}

// -------------------------------------------------------------------

// PictureValue_LicenseDetails

// optional .com.zoho.shapes.PictureValue.LicenseDetails.SearchedFrom from = 1 [(.com.zoho.common.customOptions) = {
inline bool PictureValue_LicenseDetails::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PictureValue_LicenseDetails::clear_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom PictureValue_LicenseDetails::from() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.from)
  return _internal_from();
}
inline void PictureValue_LicenseDetails::set_from(::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.LicenseDetails.from)
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom PictureValue_LicenseDetails::_internal_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom>(_impl_.from_);
}
inline void PictureValue_LicenseDetails::_internal_set_from(::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_ = value;
}

// optional .com.zoho.shapes.PictureValue.LicenseDetails.CreativeCommonsLicense type = 2 [(.com.zoho.common.customOptions) = {
inline bool PictureValue_LicenseDetails::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PictureValue_LicenseDetails::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense PictureValue_LicenseDetails::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.type)
  return _internal_type();
}
inline void PictureValue_LicenseDetails::set_type(::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.LicenseDetails.type)
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense PictureValue_LicenseDetails::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense>(_impl_.type_);
}
inline void PictureValue_LicenseDetails::_internal_set_type(::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional int64 date = 3 [(.com.zoho.common.customOptions) = {
inline bool PictureValue_LicenseDetails::has_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PictureValue_LicenseDetails::clear_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.date_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t PictureValue_LicenseDetails::date() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.date)
  return _internal_date();
}
inline void PictureValue_LicenseDetails::set_date(::int64_t value) {
  _internal_set_date(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.LicenseDetails.date)
}
inline ::int64_t PictureValue_LicenseDetails::_internal_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.date_;
}
inline void PictureValue_LicenseDetails::_internal_set_date(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.date_ = value;
}

// optional .com.zoho.common.URL url = 4 [(.com.zoho.common.customOptions) = {
inline bool PictureValue_LicenseDetails::has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.url_ != nullptr);
  return value;
}
inline const ::com::zoho::common::URL& PictureValue_LicenseDetails::_internal_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::URL* p = _impl_.url_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::URL&>(::com::zoho::common::_URL_default_instance_);
}
inline const ::com::zoho::common::URL& PictureValue_LicenseDetails::url() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.url)
  return _internal_url();
}
inline void PictureValue_LicenseDetails::unsafe_arena_set_allocated_url(::com::zoho::common::URL* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.url_);
  }
  _impl_.url_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.url)
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails::release_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::URL* released = _impl_.url_;
  _impl_.url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails::unsafe_arena_release_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.LicenseDetails.url)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::URL* temp = _impl_.url_;
  _impl_.url_ = nullptr;
  return temp;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails::_internal_mutable_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.url_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::URL>(GetArena());
    _impl_.url_ = reinterpret_cast<::com::zoho::common::URL*>(p);
  }
  return _impl_.url_;
}
inline ::com::zoho::common::URL* PictureValue_LicenseDetails::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::URL* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.LicenseDetails.url)
  return _msg;
}
inline void PictureValue_LicenseDetails::set_allocated_url(::com::zoho::common::URL* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.url_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.url_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.url)
}

// optional .com.zoho.shapes.PictureValue.LicenseDetails.OwnerInfo owner = 5 [(.com.zoho.common.customOptions) = {
inline bool PictureValue_LicenseDetails::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_ != nullptr);
  return value;
}
inline void PictureValue_LicenseDetails::clear_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.owner_ != nullptr) _impl_.owner_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo& PictureValue_LicenseDetails::_internal_owner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo&>(::com::zoho::shapes::_PictureValue_LicenseDetails_OwnerInfo_default_instance_);
}
inline const ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo& PictureValue_LicenseDetails::owner() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.LicenseDetails.owner)
  return _internal_owner();
}
inline void PictureValue_LicenseDetails::unsafe_arena_set_allocated_owner(::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.owner)
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* PictureValue_LicenseDetails::release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* released = _impl_.owner_;
  _impl_.owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* PictureValue_LicenseDetails::unsafe_arena_release_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.LicenseDetails.owner)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* PictureValue_LicenseDetails::_internal_mutable_owner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo>(GetArena());
    _impl_.owner_ = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo*>(p);
  }
  return _impl_.owner_;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* PictureValue_LicenseDetails::mutable_owner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.LicenseDetails.owner)
  return _msg;
}
inline void PictureValue_LicenseDetails::set_allocated_owner(::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo*>(_impl_.owner_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.owner_ = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails_OwnerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.LicenseDetails.owner)
}

// -------------------------------------------------------------------

// PictureValue

// optional string id = 1 [(.com.zoho.common.customOptions) = {
inline bool PictureValue::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PictureValue::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PictureValue::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PictureValue::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.id)
}
inline std::string* PictureValue::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.id)
  return _s;
}
inline const std::string& PictureValue::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void PictureValue::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* PictureValue::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* PictureValue::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PictureValue::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.id)
}

// optional .com.zoho.shapes.PictureValue.PictureType type = 2 [(.com.zoho.common.customOptions) = {
inline bool PictureValue::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void PictureValue::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::com::zoho::shapes::PictureValue_PictureType PictureValue::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.type)
  return _internal_type();
}
inline void PictureValue::set_type(::com::zoho::shapes::PictureValue_PictureType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.type)
}
inline ::com::zoho::shapes::PictureValue_PictureType PictureValue::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::PictureValue_PictureType>(_impl_.type_);
}
inline void PictureValue::_internal_set_type(::com::zoho::shapes::PictureValue_PictureType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.type_ = value;
}

// optional string url = 3;
inline bool PictureValue::has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PictureValue::clear_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PictureValue::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PictureValue::set_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.url)
}
inline std::string* PictureValue::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.url)
  return _s;
}
inline const std::string& PictureValue::_internal_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.url_.Get();
}
inline void PictureValue::_internal_set_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* PictureValue::_internal_mutable_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* PictureValue::release_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.url)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.url_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PictureValue::set_allocated_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.url)
}

// optional string pictureName = 4;
inline bool PictureValue::has_picturename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PictureValue::clear_picturename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.picturename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PictureValue::picturename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.pictureName)
  return _internal_picturename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PictureValue::set_picturename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.picturename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.pictureName)
}
inline std::string* PictureValue::mutable_picturename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_picturename();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.pictureName)
  return _s;
}
inline const std::string& PictureValue::_internal_picturename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.picturename_.Get();
}
inline void PictureValue::_internal_set_picturename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.picturename_.Set(value, GetArena());
}
inline std::string* PictureValue::_internal_mutable_picturename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.picturename_.Mutable( GetArena());
}
inline std::string* PictureValue::release_picturename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.pictureName)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.picturename_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.picturename_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PictureValue::set_allocated_picturename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.picturename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.picturename_.IsDefault()) {
          _impl_.picturename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.pictureName)
}

// optional string relId = 5;
inline bool PictureValue::has_relid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PictureValue::clear_relid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PictureValue::relid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.relId)
  return _internal_relid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PictureValue::set_relid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.relid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.relId)
}
inline std::string* PictureValue::mutable_relid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_relid();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.relId)
  return _s;
}
inline const std::string& PictureValue::_internal_relid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relid_.Get();
}
inline void PictureValue::_internal_set_relid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.relid_.Set(value, GetArena());
}
inline std::string* PictureValue::_internal_mutable_relid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.relid_.Mutable( GetArena());
}
inline std::string* PictureValue::release_relid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.relId)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.relid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PictureValue::set_allocated_relid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.relid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relid_.IsDefault()) {
          _impl_.relid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.relId)
}

// optional .com.zoho.shapes.PictureValue.LicenseDetails license = 6;
inline bool PictureValue::has_license() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.license_ != nullptr);
  return value;
}
inline void PictureValue::clear_license() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.license_ != nullptr) _impl_.license_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::com::zoho::shapes::PictureValue_LicenseDetails& PictureValue::_internal_license() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PictureValue_LicenseDetails* p = _impl_.license_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PictureValue_LicenseDetails&>(::com::zoho::shapes::_PictureValue_LicenseDetails_default_instance_);
}
inline const ::com::zoho::shapes::PictureValue_LicenseDetails& PictureValue::license() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.license)
  return _internal_license();
}
inline void PictureValue::unsafe_arena_set_allocated_license(::com::zoho::shapes::PictureValue_LicenseDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.license_);
  }
  _impl_.license_ = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PictureValue.license)
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails* PictureValue::release_license() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::PictureValue_LicenseDetails* released = _impl_.license_;
  _impl_.license_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails* PictureValue::unsafe_arena_release_license() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.license)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::PictureValue_LicenseDetails* temp = _impl_.license_;
  _impl_.license_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails* PictureValue::_internal_mutable_license() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.license_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PictureValue_LicenseDetails>(GetArena());
    _impl_.license_ = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails*>(p);
  }
  return _impl_.license_;
}
inline ::com::zoho::shapes::PictureValue_LicenseDetails* PictureValue::mutable_license() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PictureValue_LicenseDetails* _msg = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.license)
  return _msg;
}
inline void PictureValue::set_allocated_license(::com::zoho::shapes::PictureValue_LicenseDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails*>(_impl_.license_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.license_ = reinterpret_cast<::com::zoho::shapes::PictureValue_LicenseDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.license)
}

// optional .com.zoho.common.URL pictureUrl = 7;
inline bool PictureValue::has_pictureurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pictureurl_ != nullptr);
  return value;
}
inline const ::com::zoho::common::URL& PictureValue::_internal_pictureurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::URL* p = _impl_.pictureurl_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::URL&>(::com::zoho::common::_URL_default_instance_);
}
inline const ::com::zoho::common::URL& PictureValue::pictureurl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.pictureUrl)
  return _internal_pictureurl();
}
inline void PictureValue::unsafe_arena_set_allocated_pictureurl(::com::zoho::common::URL* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pictureurl_);
  }
  _impl_.pictureurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PictureValue.pictureUrl)
}
inline ::com::zoho::common::URL* PictureValue::release_pictureurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::common::URL* released = _impl_.pictureurl_;
  _impl_.pictureurl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::URL* PictureValue::unsafe_arena_release_pictureurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.pictureUrl)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::common::URL* temp = _impl_.pictureurl_;
  _impl_.pictureurl_ = nullptr;
  return temp;
}
inline ::com::zoho::common::URL* PictureValue::_internal_mutable_pictureurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.pictureurl_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::URL>(GetArena());
    _impl_.pictureurl_ = reinterpret_cast<::com::zoho::common::URL*>(p);
  }
  return _impl_.pictureurl_;
}
inline ::com::zoho::common::URL* PictureValue::mutable_pictureurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::URL* _msg = _internal_mutable_pictureurl();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.pictureUrl)
  return _msg;
}
inline void PictureValue::set_allocated_pictureurl(::com::zoho::common::URL* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pictureurl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.pictureurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.pictureUrl)
}

// optional .com.zoho.common.URL staticUrl = 8;
inline bool PictureValue::has_staticurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.staticurl_ != nullptr);
  return value;
}
inline const ::com::zoho::common::URL& PictureValue::_internal_staticurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::URL* p = _impl_.staticurl_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::URL&>(::com::zoho::common::_URL_default_instance_);
}
inline const ::com::zoho::common::URL& PictureValue::staticurl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.staticUrl)
  return _internal_staticurl();
}
inline void PictureValue::unsafe_arena_set_allocated_staticurl(::com::zoho::common::URL* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.staticurl_);
  }
  _impl_.staticurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PictureValue.staticUrl)
}
inline ::com::zoho::common::URL* PictureValue::release_staticurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::common::URL* released = _impl_.staticurl_;
  _impl_.staticurl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::URL* PictureValue::unsafe_arena_release_staticurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.staticUrl)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::common::URL* temp = _impl_.staticurl_;
  _impl_.staticurl_ = nullptr;
  return temp;
}
inline ::com::zoho::common::URL* PictureValue::_internal_mutable_staticurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.staticurl_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::URL>(GetArena());
    _impl_.staticurl_ = reinterpret_cast<::com::zoho::common::URL*>(p);
  }
  return _impl_.staticurl_;
}
inline ::com::zoho::common::URL* PictureValue::mutable_staticurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::URL* _msg = _internal_mutable_staticurl();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.staticUrl)
  return _msg;
}
inline void PictureValue::set_allocated_staticurl(::com::zoho::common::URL* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.staticurl_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.staticurl_ = reinterpret_cast<::com::zoho::common::URL*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.staticUrl)
}

// optional string clientKey = 9;
inline bool PictureValue::has_clientkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PictureValue::clear_clientkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientkey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PictureValue::clientkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PictureValue.clientKey)
  return _internal_clientkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PictureValue::set_clientkey(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.clientkey_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PictureValue.clientKey)
}
inline std::string* PictureValue::mutable_clientkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientkey();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PictureValue.clientKey)
  return _s;
}
inline const std::string& PictureValue::_internal_clientkey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientkey_.Get();
}
inline void PictureValue::_internal_set_clientkey(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.clientkey_.Set(value, GetArena());
}
inline std::string* PictureValue::_internal_mutable_clientkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.clientkey_.Mutable( GetArena());
}
inline std::string* PictureValue::release_clientkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PictureValue.clientKey)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.clientkey_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.clientkey_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PictureValue::set_allocated_clientkey(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.clientkey_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientkey_.IsDefault()) {
          _impl_.clientkey_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PictureValue.clientKey)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom>() {
  return ::com::zoho::shapes::PictureValue_LicenseDetails_SearchedFrom_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense>() {
  return ::com::zoho::shapes::PictureValue_LicenseDetails_CreativeCommonsLicense_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::PictureValue_PictureType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::PictureValue_PictureType>() {
  return ::com::zoho::shapes::PictureValue_PictureType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_picturevalue_2eproto_2epb_2eh
