// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: patternfill.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PatternFill {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mostly the first shape will be used for pattern creation. At times , when we need multiple shapes with different colors we will have them in this array.
  public var foreground: [PatternFill.ForegroundShape] = []

  public var background: PatternFill.FillValue {
    get {return _background ?? PatternFill.FillValue()}
    set {_background = newValue}
  }
  /// Returns true if `background` has been explicitly set.
  public var hasBackground: Bool {return self._background != nil}
  /// Clears the value of `background`. Subsequent reads from it will return its default value.
  public mutating func clearBackground() {self._background = nil}

  public var distance: PatternFill.DistanceBetweenShapes {
    get {return _distance ?? PatternFill.DistanceBetweenShapes()}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  public var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  public mutating func clearDistance() {self._distance = nil}

  /// Added for PPTX compatibility.
  public var preset: String {
    get {return _preset ?? String()}
    set {_preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  public var hasPreset: Bool {return self._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  public mutating func clearPreset() {self._preset = nil}

  /// rotated value
  public var rotate: Int32 {
    get {return _rotate ?? 0}
    set {_rotate = newValue}
  }
  /// Returns true if `rotate` has been explicitly set.
  public var hasRotate: Bool {return self._rotate != nil}
  /// Clears the value of `rotate`. Subsequent reads from it will return its default value.
  public mutating func clearRotate() {self._rotate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct FillValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// type of fill
    public var type: FillField.FillType {
      get {return _storage._type ?? .solid}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    /// Solid fill
    public var solid: SolidFill {
      get {return _storage._solid ?? SolidFill()}
      set {_uniqueStorage()._solid = newValue}
    }
    /// Returns true if `solid` has been explicitly set.
    public var hasSolid: Bool {return _storage._solid != nil}
    /// Clears the value of `solid`. Subsequent reads from it will return its default value.
    public mutating func clearSolid() {_uniqueStorage()._solid = nil}

    public var gradient: GradientFill {
      get {return _storage._gradient ?? GradientFill()}
      set {_uniqueStorage()._gradient = newValue}
    }
    /// Returns true if `gradient` has been explicitly set.
    public var hasGradient: Bool {return _storage._gradient != nil}
    /// Clears the value of `gradient`. Subsequent reads from it will return its default value.
    public mutating func clearGradient() {_uniqueStorage()._gradient = nil}

    /// Picture URL
    public var pict: PictureFill {
      get {return _storage._pict ?? PictureFill()}
      set {_uniqueStorage()._pict = newValue}
    }
    /// Returns true if `pict` has been explicitly set.
    public var hasPict: Bool {return _storage._pict != nil}
    /// Clears the value of `pict`. Subsequent reads from it will return its default value.
    public mutating func clearPict() {_uniqueStorage()._pict = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct StrokeValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// stroke type
    public var type: StrokeField.StrokeType {
      get {return _type ?? .solid}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    /// stroke width , indicated in px. 
    public var width: Float {
      get {return _width ?? 0}
      set {_width = newValue}
    }
    /// Returns true if `width` has been explicitly set.
    public var hasWidth: Bool {return self._width != nil}
    /// Clears the value of `width`. Subsequent reads from it will return its default value.
    public mutating func clearWidth() {self._width = nil}

    public var fill: PatternFill.FillValue {
      get {return _fill ?? PatternFill.FillValue()}
      set {_fill = newValue}
    }
    /// Returns true if `fill` has been explicitly set.
    public var hasFill: Bool {return self._fill != nil}
    /// Clears the value of `fill`. Subsequent reads from it will return its default value.
    public mutating func clearFill() {self._fill = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _type: StrokeField.StrokeType? = nil
    fileprivate var _width: Float? = nil
    fileprivate var _fill: PatternFill.FillValue? = nil
  }

  public struct ForegroundShape {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Dimension
    public var dim: Dimension {
      get {return _dim ?? Dimension()}
      set {_dim = newValue}
    }
    /// Returns true if `dim` has been explicitly set.
    public var hasDim: Bool {return self._dim != nil}
    /// Clears the value of `dim`. Subsequent reads from it will return its default value.
    public mutating func clearDim() {self._dim = nil}

    public var fill: PatternFill.FillValue {
      get {return _fill ?? PatternFill.FillValue()}
      set {_fill = newValue}
    }
    /// Returns true if `fill` has been explicitly set.
    public var hasFill: Bool {return self._fill != nil}
    /// Clears the value of `fill`. Subsequent reads from it will return its default value.
    public mutating func clearFill() {self._fill = nil}

    public var stroke: PatternFill.StrokeValue {
      get {return _stroke ?? PatternFill.StrokeValue()}
      set {_stroke = newValue}
    }
    /// Returns true if `stroke` has been explicitly set.
    public var hasStroke: Bool {return self._stroke != nil}
    /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
    public mutating func clearStroke() {self._stroke = nil}

    /// Shape Geometry. 	
    public var geom: ShapeGeometry {
      get {return _geom ?? ShapeGeometry()}
      set {_geom = newValue}
    }
    /// Returns true if `geom` has been explicitly set.
    public var hasGeom: Bool {return self._geom != nil}
    /// Clears the value of `geom`. Subsequent reads from it will return its default value.
    public mutating func clearGeom() {self._geom = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _dim: Dimension? = nil
    fileprivate var _fill: PatternFill.FillValue? = nil
    fileprivate var _stroke: PatternFill.StrokeValue? = nil
    fileprivate var _geom: ShapeGeometry? = nil
  }

  public struct DistanceBetweenShapes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var left: Float {
      get {return _left ?? 0}
      set {_left = newValue}
    }
    /// Returns true if `left` has been explicitly set.
    public var hasLeft: Bool {return self._left != nil}
    /// Clears the value of `left`. Subsequent reads from it will return its default value.
    public mutating func clearLeft() {self._left = nil}

    public var top: Float {
      get {return _top ?? 0}
      set {_top = newValue}
    }
    /// Returns true if `top` has been explicitly set.
    public var hasTop: Bool {return self._top != nil}
    /// Clears the value of `top`. Subsequent reads from it will return its default value.
    public mutating func clearTop() {self._top = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _left: Float? = nil
    fileprivate var _top: Float? = nil
  }

  public init() {}

  fileprivate var _background: PatternFill.FillValue? = nil
  fileprivate var _distance: PatternFill.DistanceBetweenShapes? = nil
  fileprivate var _preset: String? = nil
  fileprivate var _rotate: Int32? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PatternFill: @unchecked Sendable {}
extension PatternFill.FillValue: @unchecked Sendable {}
extension PatternFill.StrokeValue: @unchecked Sendable {}
extension PatternFill.ForegroundShape: @unchecked Sendable {}
extension PatternFill.DistanceBetweenShapes: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension PatternFill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatternFill"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "foreground"),
    2: .same(proto: "background"),
    3: .same(proto: "distance"),
    4: .same(proto: "preset"),
    5: .same(proto: "rotate"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.foreground) {return false}
    if let v = self._background, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.foreground) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._background) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._distance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._preset) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._rotate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.foreground.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.foreground, fieldNumber: 1)
    }
    try { if let v = self._background {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._distance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._preset {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._rotate {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PatternFill, rhs: PatternFill) -> Bool {
    if lhs.foreground != rhs.foreground {return false}
    if lhs._background != rhs._background {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs._preset != rhs._preset {return false}
    if lhs._rotate != rhs._rotate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PatternFill.FillValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PatternFill.protoMessageName + ".FillValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "solid"),
    3: .same(proto: "gradient"),
    4: .same(proto: "pict"),
  ]

  fileprivate class _StorageClass {
    var _type: FillField.FillType? = nil
    var _solid: SolidFill? = nil
    var _gradient: GradientFill? = nil
    var _pict: PictureFill? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _solid = source._solid
      _gradient = source._gradient
      _pict = source._pict
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._solid, !v.isInitialized {return false}
      if let v = _storage._gradient, !v.isInitialized {return false}
      if let v = _storage._pict, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._solid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._gradient) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._pict) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._solid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._gradient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._pict {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PatternFill.FillValue, rhs: PatternFill.FillValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._solid != rhs_storage._solid {return false}
        if _storage._gradient != rhs_storage._gradient {return false}
        if _storage._pict != rhs_storage._pict {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PatternFill.StrokeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PatternFill.protoMessageName + ".StrokeValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "width"),
    3: .same(proto: "fill"),
  ]

  public var isInitialized: Bool {
    if let v = self._fill, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._width) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PatternFill.StrokeValue, rhs: PatternFill.StrokeValue) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._width != rhs._width {return false}
    if lhs._fill != rhs._fill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PatternFill.ForegroundShape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PatternFill.protoMessageName + ".ForegroundShape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dim"),
    2: .same(proto: "fill"),
    3: .same(proto: "stroke"),
    4: .same(proto: "geom"),
  ]

  public var isInitialized: Bool {
    if let v = self._fill, !v.isInitialized {return false}
    if let v = self._stroke, !v.isInitialized {return false}
    if let v = self._geom, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dim) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stroke) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._geom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._geom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PatternFill.ForegroundShape, rhs: PatternFill.ForegroundShape) -> Bool {
    if lhs._dim != rhs._dim {return false}
    if lhs._fill != rhs._fill {return false}
    if lhs._stroke != rhs._stroke {return false}
    if lhs._geom != rhs._geom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PatternFill.DistanceBetweenShapes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PatternFill.protoMessageName + ".DistanceBetweenShapes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
    2: .same(proto: "top"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._left) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._top) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._left {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._top {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PatternFill.DistanceBetweenShapes, rhs: PatternFill.DistanceBetweenShapes) -> Bool {
    if lhs._left != rhs._left {return false}
    if lhs._top != rhs._top {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
