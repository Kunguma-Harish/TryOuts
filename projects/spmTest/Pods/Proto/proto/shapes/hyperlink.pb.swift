// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: hyperlink.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct HyperLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type of link
  public var type: HyperLink.LinkType {
    get {return _storage._type ?? .none}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  ///<regex name="url" value="^(ht|f)tp(s?)\:\/\/[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*(:(0-9)*)*(\/?)([a-zA-Z0-9\-\.\?\,\:\'\/\\\+=&amp;%\$#_]*)?$"/>
  /// Use the linkUrl variabl instead of this.
  public var link: String {
    get {return _storage._link ?? String()}
    set {_uniqueStorage()._link = newValue}
  }
  /// Returns true if `link` has been explicitly set.
  public var hasLink: Bool {return _storage._link != nil}
  /// Clears the value of `link`. Subsequent reads from it will return its default value.
  public mutating func clearLink() {_uniqueStorage()._link = nil}

  /// email address link
  public var email: HyperLink.Email {
    get {return _storage._email ?? HyperLink.Email()}
    set {_uniqueStorage()._email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  public var hasEmail: Bool {return _storage._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  public mutating func clearEmail() {_uniqueStorage()._email = nil}

  /// linked to a slide.
  public var slide: HyperLink.LinkSlide {
    get {return _storage._slide ?? HyperLink.LinkSlide()}
    set {_uniqueStorage()._slide = newValue}
  }
  /// Returns true if `slide` has been explicitly set.
  public var hasSlide: Bool {return _storage._slide != nil}
  /// Clears the value of `slide`. Subsequent reads from it will return its default value.
  public mutating func clearSlide() {_uniqueStorage()._slide = nil}

  /// Linked to a Custom Show.
  public var custom: HyperLink.CustomShowLink {
    get {return _storage._custom ?? HyperLink.CustomShowLink()}
    set {_uniqueStorage()._custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  public var hasCustom: Bool {return _storage._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  public mutating func clearCustom() {_uniqueStorage()._custom = nil}

  ///<regex name="document_name" value="[0-9a-zA-Z_~`#%&amp;\^\*\(\)\{\}\[\]\+\*\|\=\-\.\$@\?\,\:;\'\/\!\P{InBasicLatin}\s]+"/>
  public var tooltip: String {
    get {return _storage._tooltip ?? String()}
    set {_uniqueStorage()._tooltip = newValue}
  }
  /// Returns true if `tooltip` has been explicitly set.
  public var hasTooltip: Bool {return _storage._tooltip != nil}
  /// Clears the value of `tooltip`. Subsequent reads from it will return its default value.
  public mutating func clearTooltip() {_uniqueStorage()._tooltip = nil}

  public var opentype: HyperLink.LinkOpenType {
    get {return _storage._opentype ?? .new}
    set {_uniqueStorage()._opentype = newValue}
  }
  /// Returns true if `opentype` has been explicitly set.
  public var hasOpentype: Bool {return _storage._opentype != nil}
  /// Clears the value of `opentype`. Subsequent reads from it will return its default value.
  public mutating func clearOpentype() {_uniqueStorage()._opentype = nil}

  /// Using the URL proto instead of string. This will help us security wise.
  public var linkURL: URL {
    get {return _storage._linkURL ?? URL()}
    set {_uniqueStorage()._linkURL = newValue}
  }
  /// Returns true if `linkURL` has been explicitly set.
  public var hasLinkURL: Bool {return _storage._linkURL != nil}
  /// Clears the value of `linkURL`. Subsequent reads from it will return its default value.
  public mutating func clearLinkURL() {_uniqueStorage()._linkURL = nil}

  public var linkStyle: HyperLink.HyperLinkStyle {
    get {return _storage._linkStyle ?? HyperLink.HyperLinkStyle()}
    set {_uniqueStorage()._linkStyle = newValue}
  }
  /// Returns true if `linkStyle` has been explicitly set.
  public var hasLinkStyle: Bool {return _storage._linkStyle != nil}
  /// Clears the value of `linkStyle`. Subsequent reads from it will return its default value.
  public mutating func clearLinkStyle() {_uniqueStorage()._linkStyle = nil}

  public var anchorPoint: HyperLink.AnchorPointLink {
    get {return _storage._anchorPoint ?? HyperLink.AnchorPointLink()}
    set {_uniqueStorage()._anchorPoint = newValue}
  }
  /// Returns true if `anchorPoint` has been explicitly set.
  public var hasAnchorPoint: Bool {return _storage._anchorPoint != nil}
  /// Clears the value of `anchorPoint`. Subsequent reads from it will return its default value.
  public mutating func clearAnchorPoint() {_uniqueStorage()._anchorPoint = nil}

  public var frame: HyperLink.FrameLink {
    get {return _storage._frame ?? HyperLink.FrameLink()}
    set {_uniqueStorage()._frame = newValue}
  }
  /// Returns true if `frame` has been explicitly set.
  public var hasFrame: Bool {return _storage._frame != nil}
  /// Clears the value of `frame`. Subsequent reads from it will return its default value.
  public mutating func clearFrame() {_uniqueStorage()._frame = nil}

  public var shapeObject: HyperLink.ShapeObjectLink {
    get {return _storage._shapeObject ?? HyperLink.ShapeObjectLink()}
    set {_uniqueStorage()._shapeObject = newValue}
  }
  /// Returns true if `shapeObject` has been explicitly set.
  public var hasShapeObject: Bool {return _storage._shapeObject != nil}
  /// Clears the value of `shapeObject`. Subsequent reads from it will return its default value.
  public mutating func clearShapeObject() {_uniqueStorage()._shapeObject = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum LinkType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// no link
    case none // = 0

    /// url link
    case link // = 1

    /// linked to email
    case email // = 2

    /// linked to a slide
    case slide // = 3

    /// Linked to a Custom Show.
    case custom // = 4

    /// Linked to an anchor point
    case anchorPoint // = 5

    /// Linked to a frame
    case frame // = 6

    /// Linked to a shapeObject
    case shapeobject // = 7

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .link
      case 2: self = .email
      case 3: self = .slide
      case 4: self = .custom
      case 5: self = .anchorPoint
      case 6: self = .frame
      case 7: self = .shapeobject
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .link: return 1
      case .email: return 2
      case .slide: return 3
      case .custom: return 4
      case .anchorPoint: return 5
      case .frame: return 6
      case .shapeobject: return 7
      }
    }

  }

  public enum LinkOpenType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case defLinkOpenType // = 0

    /// open in new window.
    case new // = 1

    /// open in self.
    case self_ // = 2

    public init() {
      self = .defLinkOpenType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .defLinkOpenType
      case 1: self = .new
      case 2: self = .self_
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .defLinkOpenType: return 0
      case .new: return 1
      case .self_: return 2
      }
    }

  }

  public struct Email {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///<regex name="email" value="^[a-zA-Z0-9]([\w\-\.\+\']*)@([\w\-\.]*)(\.[a-zA-Z]{2,8}(\.[a-zA-Z]{2}){0,2})$"/>
    public var address: String {
      get {return _address ?? String()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    public var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    public mutating func clearAddress() {self._address = nil}

    ///<regex name="document_name" value="[0-9a-zA-Z_~`#%&amp;\^\*\(\)\{\}\[\]\+\*\|\=\-\.\$@\?\,\:;\'\/\!\P{InBasicLatin}\s]+"/>
    public var subject: String {
      get {return _subject ?? String()}
      set {_subject = newValue}
    }
    /// Returns true if `subject` has been explicitly set.
    public var hasSubject: Bool {return self._subject != nil}
    /// Clears the value of `subject`. Subsequent reads from it will return its default value.
    public mutating func clearSubject() {self._subject = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _address: String? = nil
    fileprivate var _subject: String? = nil
  }

  public struct LinkSlide {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// slide link type
    public var type: HyperLink.LinkSlide.LinkSlideType {
      get {return _type ?? .defLinkSlideType}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    /// <regex name="mathuuid"  value="^[a-f0-9A-F]{8}-[a-f0-9A-F]{4}-[a-f0-9A-F]{4}-[a-f0-9A-F]{4}-[a-f0-9A-F]{12}$" />
    public var fixed: String {
      get {return _fixed ?? String()}
      set {_fixed = newValue}
    }
    /// Returns true if `fixed` has been explicitly set.
    public var hasFixed: Bool {return self._fixed != nil}
    /// Clears the value of `fixed`. Subsequent reads from it will return its default value.
    public mutating func clearFixed() {self._fixed = nil}

    /// dynamic link
    public var dynamic: HyperLink.LinkSlide.DynamicSlideType {
      get {return _dynamic ?? .defDynamicSlide}
      set {_dynamic = newValue}
    }
    /// Returns true if `dynamic` has been explicitly set.
    public var hasDynamic: Bool {return self._dynamic != nil}
    /// Clears the value of `dynamic`. Subsequent reads from it will return its default value.
    public mutating func clearDynamic() {self._dynamic = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum LinkSlideType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case defLinkSlideType // = 0

      /// fixed to a particular slide , will point to the slide unique id.
      case fixed // = 1

      /// linked dynamically to a slide, meaning always linked to the previous slide etc...
      case dynamic // = 2

      public init() {
        self = .defLinkSlideType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .defLinkSlideType
        case 1: self = .fixed
        case 2: self = .dynamic
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .defLinkSlideType: return 0
        case .fixed: return 1
        case .dynamic: return 2
        }
      }

    }

    public enum DynamicSlideType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case defDynamicSlide // = 0

      /// next slide
      case next // = 1

      /// previous slide
      case previous // = 2

      /// first slide
      case first // = 3

      /// last slide
      case last // = 4

      /// last viewed slide.
      case lastviewed // = 5

      public init() {
        self = .defDynamicSlide
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .defDynamicSlide
        case 1: self = .next
        case 2: self = .previous
        case 3: self = .first
        case 4: self = .last
        case 5: self = .lastviewed
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .defDynamicSlide: return 0
        case .next: return 1
        case .previous: return 2
        case .first: return 3
        case .last: return 4
        case .lastviewed: return 5
        }
      }

    }

    public init() {}

    fileprivate var _type: HyperLink.LinkSlide.LinkSlideType? = nil
    fileprivate var _fixed: String? = nil
    fileprivate var _dynamic: HyperLink.LinkSlide.DynamicSlideType? = nil
  }

  public struct CustomShowLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// <regex name="mathuuid"  value="^[a-f0-9A-F]{8}-[a-f0-9A-F]{4}-[a-f0-9A-F]{4}-[a-f0-9A-F]{4}-[a-f0-9A-F]{12}$" />
    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    /// Return to slideshow at the end of Custom show.
    public var `return`: Bool {
      get {return _return ?? true}
      set {_return = newValue}
    }
    /// Returns true if ``return`` has been explicitly set.
    public var hasReturn: Bool {return self._return != nil}
    /// Clears the value of ``return``. Subsequent reads from it will return its default value.
    public mutating func clearReturn() {self._return = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
    fileprivate var _return: Bool? = nil
  }

  public struct HyperLinkStyle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// click fill
    public var fill: Fill {
      get {return _fill ?? Fill()}
      set {_fill = newValue}
    }
    /// Returns true if `fill` has been explicitly set.
    public var hasFill: Bool {return self._fill != nil}
    /// Clears the value of `fill`. Subsequent reads from it will return its default value.
    public mutating func clearFill() {self._fill = nil}

    /// Underline
    public var underline: LineType {
      get {return _underline ?? .none}
      set {_underline = newValue}
    }
    /// Returns true if `underline` has been explicitly set.
    public var hasUnderline: Bool {return self._underline != nil}
    /// Clears the value of `underline`. Subsequent reads from it will return its default value.
    public mutating func clearUnderline() {self._underline = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _fill: Fill? = nil
    fileprivate var _underline: LineType? = nil
  }

  public struct AnchorPointLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  public struct FrameLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  public struct ShapeObjectLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension HyperLink.LinkType: CaseIterable {
  // Support synthesized by the compiler.
}

extension HyperLink.LinkOpenType: CaseIterable {
  // Support synthesized by the compiler.
}

extension HyperLink.LinkSlide.LinkSlideType: CaseIterable {
  // Support synthesized by the compiler.
}

extension HyperLink.LinkSlide.DynamicSlideType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension HyperLink: @unchecked Sendable {}
extension HyperLink.LinkType: @unchecked Sendable {}
extension HyperLink.LinkOpenType: @unchecked Sendable {}
extension HyperLink.Email: @unchecked Sendable {}
extension HyperLink.LinkSlide: @unchecked Sendable {}
extension HyperLink.LinkSlide.LinkSlideType: @unchecked Sendable {}
extension HyperLink.LinkSlide.DynamicSlideType: @unchecked Sendable {}
extension HyperLink.CustomShowLink: @unchecked Sendable {}
extension HyperLink.HyperLinkStyle: @unchecked Sendable {}
extension HyperLink.AnchorPointLink: @unchecked Sendable {}
extension HyperLink.FrameLink: @unchecked Sendable {}
extension HyperLink.ShapeObjectLink: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension HyperLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HyperLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "link"),
    3: .same(proto: "email"),
    4: .same(proto: "slide"),
    5: .same(proto: "custom"),
    6: .same(proto: "tooltip"),
    7: .same(proto: "opentype"),
    8: .same(proto: "linkUrl"),
    9: .same(proto: "linkStyle"),
    10: .same(proto: "anchorPoint"),
    11: .same(proto: "frame"),
    12: .same(proto: "shapeObject"),
  ]

  fileprivate class _StorageClass {
    var _type: HyperLink.LinkType? = nil
    var _link: String? = nil
    var _email: HyperLink.Email? = nil
    var _slide: HyperLink.LinkSlide? = nil
    var _custom: HyperLink.CustomShowLink? = nil
    var _tooltip: String? = nil
    var _opentype: HyperLink.LinkOpenType? = nil
    var _linkURL: URL? = nil
    var _linkStyle: HyperLink.HyperLinkStyle? = nil
    var _anchorPoint: HyperLink.AnchorPointLink? = nil
    var _frame: HyperLink.FrameLink? = nil
    var _shapeObject: HyperLink.ShapeObjectLink? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _link = source._link
      _email = source._email
      _slide = source._slide
      _custom = source._custom
      _tooltip = source._tooltip
      _opentype = source._opentype
      _linkURL = source._linkURL
      _linkStyle = source._linkStyle
      _anchorPoint = source._anchorPoint
      _frame = source._frame
      _shapeObject = source._shapeObject
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._email, !v.isInitialized {return false}
      if let v = _storage._slide, !v.isInitialized {return false}
      if let v = _storage._custom, !v.isInitialized {return false}
      if let v = _storage._linkURL, !v.isInitialized {return false}
      if let v = _storage._linkStyle, !v.isInitialized {return false}
      if let v = _storage._anchorPoint, !v.isInitialized {return false}
      if let v = _storage._frame, !v.isInitialized {return false}
      if let v = _storage._shapeObject, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._link) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._email) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._slide) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._custom) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._tooltip) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._opentype) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._linkURL) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._linkStyle) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._anchorPoint) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._frame) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._shapeObject) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._link {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._email {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._slide {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._custom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._tooltip {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._opentype {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._linkURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._linkStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._anchorPoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._frame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._shapeObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink, rhs: HyperLink) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._link != rhs_storage._link {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._slide != rhs_storage._slide {return false}
        if _storage._custom != rhs_storage._custom {return false}
        if _storage._tooltip != rhs_storage._tooltip {return false}
        if _storage._opentype != rhs_storage._opentype {return false}
        if _storage._linkURL != rhs_storage._linkURL {return false}
        if _storage._linkStyle != rhs_storage._linkStyle {return false}
        if _storage._anchorPoint != rhs_storage._anchorPoint {return false}
        if _storage._frame != rhs_storage._frame {return false}
        if _storage._shapeObject != rhs_storage._shapeObject {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HyperLink.LinkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "LINK"),
    2: .same(proto: "EMAIL"),
    3: .same(proto: "SLIDE"),
    4: .same(proto: "CUSTOM"),
    5: .same(proto: "ANCHOR_POINT"),
    6: .same(proto: "FRAME"),
    7: .same(proto: "SHAPEOBJECT"),
  ]
}

extension HyperLink.LinkOpenType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_LINK_OPEN_TYPE"),
    1: .same(proto: "NEW"),
    2: .same(proto: "SELF"),
  ]
}

extension HyperLink.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = HyperLink.protoMessageName + ".Email"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "subject"),
  ]

  public var isInitialized: Bool {
    if self._address == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._subject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subject {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink.Email, rhs: HyperLink.Email) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs._subject != rhs._subject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HyperLink.LinkSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = HyperLink.protoMessageName + ".LinkSlide"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "fixed"),
    3: .same(proto: "dynamic"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fixed) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._dynamic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fixed {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dynamic {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink.LinkSlide, rhs: HyperLink.LinkSlide) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._fixed != rhs._fixed {return false}
    if lhs._dynamic != rhs._dynamic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HyperLink.LinkSlide.LinkSlideType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_LINK_SLIDE_TYPE"),
    1: .same(proto: "FIXED"),
    2: .same(proto: "DYNAMIC"),
  ]
}

extension HyperLink.LinkSlide.DynamicSlideType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_DYNAMIC_SLIDE"),
    1: .same(proto: "NEXT"),
    2: .same(proto: "PREVIOUS"),
    3: .same(proto: "FIRST"),
    4: .same(proto: "LAST"),
    5: .same(proto: "LASTVIEWED"),
  ]
}

extension HyperLink.CustomShowLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = HyperLink.protoMessageName + ".CustomShowLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "return"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._return) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._return {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink.CustomShowLink, rhs: HyperLink.CustomShowLink) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._return != rhs._return {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HyperLink.HyperLinkStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = HyperLink.protoMessageName + ".HyperLinkStyle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fill"),
    3: .same(proto: "underline"),
  ]

  public var isInitialized: Bool {
    if let v = self._fill, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._underline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._underline {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink.HyperLinkStyle, rhs: HyperLink.HyperLinkStyle) -> Bool {
    if lhs._fill != rhs._fill {return false}
    if lhs._underline != rhs._underline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HyperLink.AnchorPointLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = HyperLink.protoMessageName + ".AnchorPointLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink.AnchorPointLink, rhs: HyperLink.AnchorPointLink) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HyperLink.FrameLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = HyperLink.protoMessageName + ".FrameLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink.FrameLink, rhs: HyperLink.FrameLink) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HyperLink.ShapeObjectLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = HyperLink.protoMessageName + ".ShapeObjectLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HyperLink.ShapeObjectLink, rhs: HyperLink.ShapeObjectLink) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
