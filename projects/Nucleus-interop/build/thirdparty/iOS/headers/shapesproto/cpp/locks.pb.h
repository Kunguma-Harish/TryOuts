// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: locks.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_locks_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_locks_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/protoextensions.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_locks_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_locks_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_locks_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class Locks;
struct LocksDefaultTypeInternal;
extern LocksDefaultTypeInternal _Locks_default_instance_;
class Locks_LockedBy;
struct Locks_LockedByDefaultTypeInternal;
extern Locks_LockedByDefaultTypeInternal _Locks_LockedBy_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {
enum Locks_LockedBy_LockProp : int {
  Locks_LockedBy_LockProp_HANDLES = 0,
  Locks_LockedBy_LockProp_ASPECT_CHANGE = 1,
  Locks_LockedBy_LockProp_ARROW_HEAD_CHANGE = 2,
  Locks_LockedBy_LockProp_ROTATION = 3,
  Locks_LockedBy_LockProp_RESIZE = 4,
  Locks_LockedBy_LockProp_MOVE = 5,
  Locks_LockedBy_LockProp_SHAPE_TYPE_CHANGE = 6,
  Locks_LockedBy_LockProp_CROP = 7,
  Locks_LockedBy_LockProp_GROUP = 8,
  Locks_LockedBy_LockProp_UNGROUP = 9,
  Locks_LockedBy_LockProp_SELECT = 10,
  Locks_LockedBy_LockProp_MODIFY = 11,
  Locks_LockedBy_LockProp_FILL = 12,
  Locks_LockedBy_LockProp_STROKE = 13,
  Locks_LockedBy_LockProp_EFFECTS = 14,
  Locks_LockedBy_LockProp_STYLE = 15,
  Locks_LockedBy_LockProp_TEXT_PROPS = 16,
  Locks_LockedBy_LockProp_PARA_PROPS = 17,
  Locks_LockedBy_LockProp_PORTION_PROPS = 18,
  Locks_LockedBy_LockProp_TEXTBODY_PROPS = 19,
  Locks_LockedBy_LockProp_SHAPE_PROPS = 20,
  Locks_LockedBy_LockProp_TEXT_INPUT = 21,
  Locks_LockedBy_LockProp_Locks_LockedBy_LockProp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Locks_LockedBy_LockProp_Locks_LockedBy_LockProp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Locks_LockedBy_LockProp_IsValid(int value);
extern const uint32_t Locks_LockedBy_LockProp_internal_data_[];
constexpr Locks_LockedBy_LockProp Locks_LockedBy_LockProp_LockProp_MIN = static_cast<Locks_LockedBy_LockProp>(0);
constexpr Locks_LockedBy_LockProp Locks_LockedBy_LockProp_LockProp_MAX = static_cast<Locks_LockedBy_LockProp>(21);
constexpr int Locks_LockedBy_LockProp_LockProp_ARRAYSIZE = 21 + 1;
const ::google::protobuf::EnumDescriptor*
Locks_LockedBy_LockProp_descriptor();
template <typename T>
const std::string& Locks_LockedBy_LockProp_Name(T value) {
  static_assert(std::is_same<T, Locks_LockedBy_LockProp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LockProp_Name().");
  return Locks_LockedBy_LockProp_Name(static_cast<Locks_LockedBy_LockProp>(value));
}
template <>
inline const std::string& Locks_LockedBy_LockProp_Name(Locks_LockedBy_LockProp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Locks_LockedBy_LockProp_descriptor,
                                                 0, 21>(
      static_cast<int>(value));
}
inline bool Locks_LockedBy_LockProp_Parse(absl::string_view name, Locks_LockedBy_LockProp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Locks_LockedBy_LockProp>(
      Locks_LockedBy_LockProp_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Locks_LockedBy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Locks.LockedBy) */ {
 public:
  inline Locks_LockedBy() : Locks_LockedBy(nullptr) {}
  ~Locks_LockedBy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Locks_LockedBy(::google::protobuf::internal::ConstantInitialized);

  inline Locks_LockedBy(const Locks_LockedBy& from)
      : Locks_LockedBy(nullptr, from) {}
  Locks_LockedBy(Locks_LockedBy&& from) noexcept
    : Locks_LockedBy() {
    *this = ::std::move(from);
  }

  inline Locks_LockedBy& operator=(const Locks_LockedBy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locks_LockedBy& operator=(Locks_LockedBy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Locks_LockedBy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Locks_LockedBy* internal_default_instance() {
    return reinterpret_cast<const Locks_LockedBy*>(
               &_Locks_LockedBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Locks_LockedBy& a, Locks_LockedBy& b) {
    a.Swap(&b);
  }
  inline void Swap(Locks_LockedBy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Locks_LockedBy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Locks_LockedBy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Locks_LockedBy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Locks_LockedBy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Locks_LockedBy& from) {
    Locks_LockedBy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Locks_LockedBy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Locks.LockedBy";
  }
  protected:
  explicit Locks_LockedBy(::google::protobuf::Arena* arena);
  Locks_LockedBy(::google::protobuf::Arena* arena, const Locks_LockedBy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LockProp = Locks_LockedBy_LockProp;
  static constexpr LockProp HANDLES = Locks_LockedBy_LockProp_HANDLES;
  static constexpr LockProp ASPECT_CHANGE = Locks_LockedBy_LockProp_ASPECT_CHANGE;
  static constexpr LockProp ARROW_HEAD_CHANGE = Locks_LockedBy_LockProp_ARROW_HEAD_CHANGE;
  static constexpr LockProp ROTATION = Locks_LockedBy_LockProp_ROTATION;
  static constexpr LockProp RESIZE = Locks_LockedBy_LockProp_RESIZE;
  static constexpr LockProp MOVE = Locks_LockedBy_LockProp_MOVE;
  static constexpr LockProp SHAPE_TYPE_CHANGE = Locks_LockedBy_LockProp_SHAPE_TYPE_CHANGE;
  static constexpr LockProp CROP = Locks_LockedBy_LockProp_CROP;
  static constexpr LockProp GROUP = Locks_LockedBy_LockProp_GROUP;
  static constexpr LockProp UNGROUP = Locks_LockedBy_LockProp_UNGROUP;
  static constexpr LockProp SELECT = Locks_LockedBy_LockProp_SELECT;
  static constexpr LockProp MODIFY = Locks_LockedBy_LockProp_MODIFY;
  static constexpr LockProp FILL = Locks_LockedBy_LockProp_FILL;
  static constexpr LockProp STROKE = Locks_LockedBy_LockProp_STROKE;
  static constexpr LockProp EFFECTS = Locks_LockedBy_LockProp_EFFECTS;
  static constexpr LockProp STYLE = Locks_LockedBy_LockProp_STYLE;
  static constexpr LockProp TEXT_PROPS = Locks_LockedBy_LockProp_TEXT_PROPS;
  static constexpr LockProp PARA_PROPS = Locks_LockedBy_LockProp_PARA_PROPS;
  static constexpr LockProp PORTION_PROPS = Locks_LockedBy_LockProp_PORTION_PROPS;
  static constexpr LockProp TEXTBODY_PROPS = Locks_LockedBy_LockProp_TEXTBODY_PROPS;
  static constexpr LockProp SHAPE_PROPS = Locks_LockedBy_LockProp_SHAPE_PROPS;
  static constexpr LockProp TEXT_INPUT = Locks_LockedBy_LockProp_TEXT_INPUT;
  static inline bool LockProp_IsValid(int value) {
    return Locks_LockedBy_LockProp_IsValid(value);
  }
  static constexpr LockProp LockProp_MIN = Locks_LockedBy_LockProp_LockProp_MIN;
  static constexpr LockProp LockProp_MAX = Locks_LockedBy_LockProp_LockProp_MAX;
  static constexpr int LockProp_ARRAYSIZE = Locks_LockedBy_LockProp_LockProp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LockProp_descriptor() {
    return Locks_LockedBy_LockProp_descriptor();
  }
  template <typename T>
  static inline const std::string& LockProp_Name(T value) {
    return Locks_LockedBy_LockProp_Name(value);
  }
  static inline bool LockProp_Parse(absl::string_view name, LockProp* value) {
    return Locks_LockedBy_LockProp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLockerFieldNumber = 2,
    kPropFieldNumber = 1,
  };
  // optional string locker = 2 [(.com.zoho.common.customOptions) = {
  bool has_locker() const;
  void clear_locker() ;
  const std::string& locker() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locker(Arg_&& arg, Args_... args);
  std::string* mutable_locker();
  PROTOBUF_NODISCARD std::string* release_locker();
  void set_allocated_locker(std::string* value);

  private:
  const std::string& _internal_locker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locker(
      const std::string& value);
  std::string* _internal_mutable_locker();

  public:
  // optional .com.zoho.shapes.Locks.LockedBy.LockProp prop = 1 [(.com.zoho.common.customOptions) = {
  bool has_prop() const;
  void clear_prop() ;
  ::com::zoho::shapes::Locks_LockedBy_LockProp prop() const;
  void set_prop(::com::zoho::shapes::Locks_LockedBy_LockProp value);

  private:
  ::com::zoho::shapes::Locks_LockedBy_LockProp _internal_prop() const;
  void _internal_set_prop(::com::zoho::shapes::Locks_LockedBy_LockProp value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Locks.LockedBy)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr locker_;
    int prop_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_locks_2eproto;
};// -------------------------------------------------------------------

class Locks final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Locks) */ {
 public:
  inline Locks() : Locks(nullptr) {}
  ~Locks() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Locks(::google::protobuf::internal::ConstantInitialized);

  inline Locks(const Locks& from)
      : Locks(nullptr, from) {}
  Locks(Locks&& from) noexcept
    : Locks() {
    *this = ::std::move(from);
  }

  inline Locks& operator=(const Locks& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locks& operator=(Locks&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Locks& default_instance() {
    return *internal_default_instance();
  }
  static inline const Locks* internal_default_instance() {
    return reinterpret_cast<const Locks*>(
               &_Locks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Locks& a, Locks& b) {
    a.Swap(&b);
  }
  inline void Swap(Locks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Locks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Locks* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Locks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Locks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Locks& from) {
    Locks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Locks* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Locks";
  }
  protected:
  explicit Locks(::google::protobuf::Arena* arena);
  Locks(::google::protobuf::Arena* arena, const Locks& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LockedBy = Locks_LockedBy;

  // accessors -------------------------------------------------------

  enum : int {
    kLockersFieldNumber = 13,
    kNoHandlesFieldNumber = 1,
    kNoAspectChangeFieldNumber = 2,
    kNoArrowHeadChangeFieldNumber = 3,
    kNoRotationFieldNumber = 4,
    kNoResizeFieldNumber = 5,
    kNoMoveFieldNumber = 6,
    kNoShapeTypeChangeFieldNumber = 7,
    kNoCropFieldNumber = 8,
    kNoGroupFieldNumber = 9,
    kNoUnGroupFieldNumber = 10,
    kNoSelectFieldNumber = 11,
    kNoModifyFieldNumber = 12,
    kNoFillFieldNumber = 14,
    kNoStrokeFieldNumber = 15,
    kNoEffectsFieldNumber = 16,
    kNoStyleFieldNumber = 17,
    kNoTextPropsFieldNumber = 18,
    kNoParaPropsFieldNumber = 19,
    kNoPortionPropsFieldNumber = 20,
    kNoTextBodyPropsFieldNumber = 21,
    kNoShapePropsModifyFieldNumber = 22,
    kNoTextInputFieldNumber = 23,
    kNoShapePropsModifySansTextOpFieldNumber = 24,
    kNoBboxFieldNumber = 25,
  };
  // repeated .com.zoho.shapes.Locks.LockedBy lockers = 13;
  int lockers_size() const;
  private:
  int _internal_lockers_size() const;

  public:
  void clear_lockers() ;
  ::com::zoho::shapes::Locks_LockedBy* mutable_lockers(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Locks_LockedBy >*
      mutable_lockers();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Locks_LockedBy>& _internal_lockers() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Locks_LockedBy>* _internal_mutable_lockers();
  public:
  const ::com::zoho::shapes::Locks_LockedBy& lockers(int index) const;
  ::com::zoho::shapes::Locks_LockedBy* add_lockers();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Locks_LockedBy >&
      lockers() const;
  // optional bool noHandles = 1;
  bool has_nohandles() const;
  void clear_nohandles() ;
  bool nohandles() const;
  void set_nohandles(bool value);

  private:
  bool _internal_nohandles() const;
  void _internal_set_nohandles(bool value);

  public:
  // optional bool noAspectChange = 2;
  bool has_noaspectchange() const;
  void clear_noaspectchange() ;
  bool noaspectchange() const;
  void set_noaspectchange(bool value);

  private:
  bool _internal_noaspectchange() const;
  void _internal_set_noaspectchange(bool value);

  public:
  // optional bool noArrowHeadChange = 3;
  bool has_noarrowheadchange() const;
  void clear_noarrowheadchange() ;
  bool noarrowheadchange() const;
  void set_noarrowheadchange(bool value);

  private:
  bool _internal_noarrowheadchange() const;
  void _internal_set_noarrowheadchange(bool value);

  public:
  // optional bool noRotation = 4;
  bool has_norotation() const;
  void clear_norotation() ;
  bool norotation() const;
  void set_norotation(bool value);

  private:
  bool _internal_norotation() const;
  void _internal_set_norotation(bool value);

  public:
  // optional bool noResize = 5;
  bool has_noresize() const;
  void clear_noresize() ;
  bool noresize() const;
  void set_noresize(bool value);

  private:
  bool _internal_noresize() const;
  void _internal_set_noresize(bool value);

  public:
  // optional bool noMove = 6;
  bool has_nomove() const;
  void clear_nomove() ;
  bool nomove() const;
  void set_nomove(bool value);

  private:
  bool _internal_nomove() const;
  void _internal_set_nomove(bool value);

  public:
  // optional bool noShapeTypeChange = 7;
  bool has_noshapetypechange() const;
  void clear_noshapetypechange() ;
  bool noshapetypechange() const;
  void set_noshapetypechange(bool value);

  private:
  bool _internal_noshapetypechange() const;
  void _internal_set_noshapetypechange(bool value);

  public:
  // optional bool noCrop = 8;
  bool has_nocrop() const;
  void clear_nocrop() ;
  bool nocrop() const;
  void set_nocrop(bool value);

  private:
  bool _internal_nocrop() const;
  void _internal_set_nocrop(bool value);

  public:
  // optional bool noGroup = 9;
  bool has_nogroup() const;
  void clear_nogroup() ;
  bool nogroup() const;
  void set_nogroup(bool value);

  private:
  bool _internal_nogroup() const;
  void _internal_set_nogroup(bool value);

  public:
  // optional bool noUnGroup = 10;
  bool has_noungroup() const;
  void clear_noungroup() ;
  bool noungroup() const;
  void set_noungroup(bool value);

  private:
  bool _internal_noungroup() const;
  void _internal_set_noungroup(bool value);

  public:
  // optional bool noSelect = 11;
  bool has_noselect() const;
  void clear_noselect() ;
  bool noselect() const;
  void set_noselect(bool value);

  private:
  bool _internal_noselect() const;
  void _internal_set_noselect(bool value);

  public:
  // optional bool noModify = 12;
  bool has_nomodify() const;
  void clear_nomodify() ;
  bool nomodify() const;
  void set_nomodify(bool value);

  private:
  bool _internal_nomodify() const;
  void _internal_set_nomodify(bool value);

  public:
  // optional bool noFill = 14;
  bool has_nofill() const;
  void clear_nofill() ;
  bool nofill() const;
  void set_nofill(bool value);

  private:
  bool _internal_nofill() const;
  void _internal_set_nofill(bool value);

  public:
  // optional bool noStroke = 15;
  bool has_nostroke() const;
  void clear_nostroke() ;
  bool nostroke() const;
  void set_nostroke(bool value);

  private:
  bool _internal_nostroke() const;
  void _internal_set_nostroke(bool value);

  public:
  // optional bool noEffects = 16;
  bool has_noeffects() const;
  void clear_noeffects() ;
  bool noeffects() const;
  void set_noeffects(bool value);

  private:
  bool _internal_noeffects() const;
  void _internal_set_noeffects(bool value);

  public:
  // optional bool noStyle = 17;
  bool has_nostyle() const;
  void clear_nostyle() ;
  bool nostyle() const;
  void set_nostyle(bool value);

  private:
  bool _internal_nostyle() const;
  void _internal_set_nostyle(bool value);

  public:
  // optional bool noTextProps = 18;
  bool has_notextprops() const;
  void clear_notextprops() ;
  bool notextprops() const;
  void set_notextprops(bool value);

  private:
  bool _internal_notextprops() const;
  void _internal_set_notextprops(bool value);

  public:
  // optional bool noParaProps = 19;
  bool has_noparaprops() const;
  void clear_noparaprops() ;
  bool noparaprops() const;
  void set_noparaprops(bool value);

  private:
  bool _internal_noparaprops() const;
  void _internal_set_noparaprops(bool value);

  public:
  // optional bool noPortionProps = 20;
  bool has_noportionprops() const;
  void clear_noportionprops() ;
  bool noportionprops() const;
  void set_noportionprops(bool value);

  private:
  bool _internal_noportionprops() const;
  void _internal_set_noportionprops(bool value);

  public:
  // optional bool noTextBodyProps = 21;
  bool has_notextbodyprops() const;
  void clear_notextbodyprops() ;
  bool notextbodyprops() const;
  void set_notextbodyprops(bool value);

  private:
  bool _internal_notextbodyprops() const;
  void _internal_set_notextbodyprops(bool value);

  public:
  // optional bool noShapePropsModify = 22;
  bool has_noshapepropsmodify() const;
  void clear_noshapepropsmodify() ;
  bool noshapepropsmodify() const;
  void set_noshapepropsmodify(bool value);

  private:
  bool _internal_noshapepropsmodify() const;
  void _internal_set_noshapepropsmodify(bool value);

  public:
  // optional bool noTextInput = 23;
  bool has_notextinput() const;
  void clear_notextinput() ;
  bool notextinput() const;
  void set_notextinput(bool value);

  private:
  bool _internal_notextinput() const;
  void _internal_set_notextinput(bool value);

  public:
  // optional bool noShapePropsModifySansTextOp = 24;
  bool has_noshapepropsmodifysanstextop() const;
  void clear_noshapepropsmodifysanstextop() ;
  bool noshapepropsmodifysanstextop() const;
  void set_noshapepropsmodifysanstextop(bool value);

  private:
  bool _internal_noshapepropsmodifysanstextop() const;
  void _internal_set_noshapepropsmodifysanstextop(bool value);

  public:
  // optional bool noBbox = 25;
  bool has_nobbox() const;
  void clear_nobbox() ;
  bool nobbox() const;
  void set_nobbox(bool value);

  private:
  bool _internal_nobbox() const;
  void _internal_set_nobbox(bool value);

  public:
  google::protobuf::RepeatedPtrField<com::zoho::shapes::Locks_LockedBy>* temp_getlockers() const {
    return const_cast<com::zoho::shapes::Locks*>(this)->mutable_lockers();
  }
  
  void temp_setlockers(const google::protobuf::RepeatedPtrField<com::zoho::shapes::Locks_LockedBy>* lockers) {
    if(this->mutable_lockers() != lockers) {
      const_cast<com::zoho::shapes::Locks*>(this)->mutable_lockers()->CopyFrom(*lockers);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Locks)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 25, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::Locks_LockedBy > lockers_;
    bool nohandles_;
    bool noaspectchange_;
    bool noarrowheadchange_;
    bool norotation_;
    bool noresize_;
    bool nomove_;
    bool noshapetypechange_;
    bool nocrop_;
    bool nogroup_;
    bool noungroup_;
    bool noselect_;
    bool nomodify_;
    bool nofill_;
    bool nostroke_;
    bool noeffects_;
    bool nostyle_;
    bool notextprops_;
    bool noparaprops_;
    bool noportionprops_;
    bool notextbodyprops_;
    bool noshapepropsmodify_;
    bool notextinput_;
    bool noshapepropsmodifysanstextop_;
    bool nobbox_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_locks_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Locks_LockedBy

// optional .com.zoho.shapes.Locks.LockedBy.LockProp prop = 1 [(.com.zoho.common.customOptions) = {
inline bool Locks_LockedBy::has_prop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Locks_LockedBy::clear_prop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prop_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::Locks_LockedBy_LockProp Locks_LockedBy::prop() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.LockedBy.prop)
  return _internal_prop();
}
inline void Locks_LockedBy::set_prop(::com::zoho::shapes::Locks_LockedBy_LockProp value) {
  _internal_set_prop(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.LockedBy.prop)
}
inline ::com::zoho::shapes::Locks_LockedBy_LockProp Locks_LockedBy::_internal_prop() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::Locks_LockedBy_LockProp>(_impl_.prop_);
}
inline void Locks_LockedBy::_internal_set_prop(::com::zoho::shapes::Locks_LockedBy_LockProp value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.prop_ = value;
}

// optional string locker = 2 [(.com.zoho.common.customOptions) = {
inline bool Locks_LockedBy::has_locker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Locks_LockedBy::clear_locker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locker_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Locks_LockedBy::locker() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.LockedBy.locker)
  return _internal_locker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Locks_LockedBy::set_locker(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locker_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.LockedBy.locker)
}
inline std::string* Locks_LockedBy::mutable_locker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_locker();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Locks.LockedBy.locker)
  return _s;
}
inline const std::string& Locks_LockedBy::_internal_locker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locker_.Get();
}
inline void Locks_LockedBy::_internal_set_locker(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locker_.Set(value, GetArena());
}
inline std::string* Locks_LockedBy::_internal_mutable_locker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.locker_.Mutable( GetArena());
}
inline std::string* Locks_LockedBy::release_locker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Locks.LockedBy.locker)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.locker_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locker_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Locks_LockedBy::set_allocated_locker(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locker_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locker_.IsDefault()) {
          _impl_.locker_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Locks.LockedBy.locker)
}

// -------------------------------------------------------------------

// Locks

// optional bool noHandles = 1;
inline bool Locks::has_nohandles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Locks::clear_nohandles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nohandles_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Locks::nohandles() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noHandles)
  return _internal_nohandles();
}
inline void Locks::set_nohandles(bool value) {
  _internal_set_nohandles(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noHandles)
}
inline bool Locks::_internal_nohandles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nohandles_;
}
inline void Locks::_internal_set_nohandles(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nohandles_ = value;
}

// optional bool noAspectChange = 2;
inline bool Locks::has_noaspectchange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Locks::clear_noaspectchange() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noaspectchange_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Locks::noaspectchange() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noAspectChange)
  return _internal_noaspectchange();
}
inline void Locks::set_noaspectchange(bool value) {
  _internal_set_noaspectchange(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noAspectChange)
}
inline bool Locks::_internal_noaspectchange() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noaspectchange_;
}
inline void Locks::_internal_set_noaspectchange(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.noaspectchange_ = value;
}

// optional bool noArrowHeadChange = 3;
inline bool Locks::has_noarrowheadchange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Locks::clear_noarrowheadchange() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noarrowheadchange_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Locks::noarrowheadchange() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noArrowHeadChange)
  return _internal_noarrowheadchange();
}
inline void Locks::set_noarrowheadchange(bool value) {
  _internal_set_noarrowheadchange(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noArrowHeadChange)
}
inline bool Locks::_internal_noarrowheadchange() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noarrowheadchange_;
}
inline void Locks::_internal_set_noarrowheadchange(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.noarrowheadchange_ = value;
}

// optional bool noRotation = 4;
inline bool Locks::has_norotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Locks::clear_norotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.norotation_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Locks::norotation() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noRotation)
  return _internal_norotation();
}
inline void Locks::set_norotation(bool value) {
  _internal_set_norotation(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noRotation)
}
inline bool Locks::_internal_norotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.norotation_;
}
inline void Locks::_internal_set_norotation(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.norotation_ = value;
}

// optional bool noResize = 5;
inline bool Locks::has_noresize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Locks::clear_noresize() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noresize_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Locks::noresize() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noResize)
  return _internal_noresize();
}
inline void Locks::set_noresize(bool value) {
  _internal_set_noresize(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noResize)
}
inline bool Locks::_internal_noresize() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noresize_;
}
inline void Locks::_internal_set_noresize(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.noresize_ = value;
}

// optional bool noMove = 6;
inline bool Locks::has_nomove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Locks::clear_nomove() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nomove_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Locks::nomove() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noMove)
  return _internal_nomove();
}
inline void Locks::set_nomove(bool value) {
  _internal_set_nomove(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noMove)
}
inline bool Locks::_internal_nomove() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nomove_;
}
inline void Locks::_internal_set_nomove(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nomove_ = value;
}

// optional bool noShapeTypeChange = 7;
inline bool Locks::has_noshapetypechange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Locks::clear_noshapetypechange() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noshapetypechange_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Locks::noshapetypechange() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noShapeTypeChange)
  return _internal_noshapetypechange();
}
inline void Locks::set_noshapetypechange(bool value) {
  _internal_set_noshapetypechange(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noShapeTypeChange)
}
inline bool Locks::_internal_noshapetypechange() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noshapetypechange_;
}
inline void Locks::_internal_set_noshapetypechange(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.noshapetypechange_ = value;
}

// optional bool noCrop = 8;
inline bool Locks::has_nocrop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Locks::clear_nocrop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nocrop_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Locks::nocrop() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noCrop)
  return _internal_nocrop();
}
inline void Locks::set_nocrop(bool value) {
  _internal_set_nocrop(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noCrop)
}
inline bool Locks::_internal_nocrop() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nocrop_;
}
inline void Locks::_internal_set_nocrop(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.nocrop_ = value;
}

// optional bool noGroup = 9;
inline bool Locks::has_nogroup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void Locks::clear_nogroup() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nogroup_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool Locks::nogroup() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noGroup)
  return _internal_nogroup();
}
inline void Locks::set_nogroup(bool value) {
  _internal_set_nogroup(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noGroup)
}
inline bool Locks::_internal_nogroup() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nogroup_;
}
inline void Locks::_internal_set_nogroup(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.nogroup_ = value;
}

// optional bool noUnGroup = 10;
inline bool Locks::has_noungroup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void Locks::clear_noungroup() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noungroup_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool Locks::noungroup() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noUnGroup)
  return _internal_noungroup();
}
inline void Locks::set_noungroup(bool value) {
  _internal_set_noungroup(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noUnGroup)
}
inline bool Locks::_internal_noungroup() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noungroup_;
}
inline void Locks::_internal_set_noungroup(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.noungroup_ = value;
}

// optional bool noSelect = 11;
inline bool Locks::has_noselect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void Locks::clear_noselect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noselect_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool Locks::noselect() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noSelect)
  return _internal_noselect();
}
inline void Locks::set_noselect(bool value) {
  _internal_set_noselect(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noSelect)
}
inline bool Locks::_internal_noselect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noselect_;
}
inline void Locks::_internal_set_noselect(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.noselect_ = value;
}

// optional bool noModify = 12;
inline bool Locks::has_nomodify() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void Locks::clear_nomodify() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nomodify_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool Locks::nomodify() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noModify)
  return _internal_nomodify();
}
inline void Locks::set_nomodify(bool value) {
  _internal_set_nomodify(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noModify)
}
inline bool Locks::_internal_nomodify() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nomodify_;
}
inline void Locks::_internal_set_nomodify(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.nomodify_ = value;
}

// optional bool noFill = 14;
inline bool Locks::has_nofill() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void Locks::clear_nofill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nofill_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool Locks::nofill() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noFill)
  return _internal_nofill();
}
inline void Locks::set_nofill(bool value) {
  _internal_set_nofill(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noFill)
}
inline bool Locks::_internal_nofill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nofill_;
}
inline void Locks::_internal_set_nofill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.nofill_ = value;
}

// optional bool noStroke = 15;
inline bool Locks::has_nostroke() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void Locks::clear_nostroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nostroke_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool Locks::nostroke() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noStroke)
  return _internal_nostroke();
}
inline void Locks::set_nostroke(bool value) {
  _internal_set_nostroke(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noStroke)
}
inline bool Locks::_internal_nostroke() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nostroke_;
}
inline void Locks::_internal_set_nostroke(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.nostroke_ = value;
}

// optional bool noEffects = 16;
inline bool Locks::has_noeffects() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void Locks::clear_noeffects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noeffects_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Locks::noeffects() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noEffects)
  return _internal_noeffects();
}
inline void Locks::set_noeffects(bool value) {
  _internal_set_noeffects(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noEffects)
}
inline bool Locks::_internal_noeffects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noeffects_;
}
inline void Locks::_internal_set_noeffects(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.noeffects_ = value;
}

// optional bool noStyle = 17;
inline bool Locks::has_nostyle() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void Locks::clear_nostyle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nostyle_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool Locks::nostyle() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noStyle)
  return _internal_nostyle();
}
inline void Locks::set_nostyle(bool value) {
  _internal_set_nostyle(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noStyle)
}
inline bool Locks::_internal_nostyle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nostyle_;
}
inline void Locks::_internal_set_nostyle(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.nostyle_ = value;
}

// optional bool noTextProps = 18;
inline bool Locks::has_notextprops() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void Locks::clear_notextprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notextprops_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool Locks::notextprops() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noTextProps)
  return _internal_notextprops();
}
inline void Locks::set_notextprops(bool value) {
  _internal_set_notextprops(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noTextProps)
}
inline bool Locks::_internal_notextprops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notextprops_;
}
inline void Locks::_internal_set_notextprops(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.notextprops_ = value;
}

// optional bool noParaProps = 19;
inline bool Locks::has_noparaprops() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void Locks::clear_noparaprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noparaprops_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool Locks::noparaprops() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noParaProps)
  return _internal_noparaprops();
}
inline void Locks::set_noparaprops(bool value) {
  _internal_set_noparaprops(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noParaProps)
}
inline bool Locks::_internal_noparaprops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noparaprops_;
}
inline void Locks::_internal_set_noparaprops(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.noparaprops_ = value;
}

// optional bool noPortionProps = 20;
inline bool Locks::has_noportionprops() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void Locks::clear_noportionprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noportionprops_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool Locks::noportionprops() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noPortionProps)
  return _internal_noportionprops();
}
inline void Locks::set_noportionprops(bool value) {
  _internal_set_noportionprops(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noPortionProps)
}
inline bool Locks::_internal_noportionprops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noportionprops_;
}
inline void Locks::_internal_set_noportionprops(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.noportionprops_ = value;
}

// optional bool noTextBodyProps = 21;
inline bool Locks::has_notextbodyprops() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void Locks::clear_notextbodyprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notextbodyprops_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool Locks::notextbodyprops() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noTextBodyProps)
  return _internal_notextbodyprops();
}
inline void Locks::set_notextbodyprops(bool value) {
  _internal_set_notextbodyprops(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noTextBodyProps)
}
inline bool Locks::_internal_notextbodyprops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notextbodyprops_;
}
inline void Locks::_internal_set_notextbodyprops(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.notextbodyprops_ = value;
}

// optional bool noShapePropsModify = 22;
inline bool Locks::has_noshapepropsmodify() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void Locks::clear_noshapepropsmodify() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noshapepropsmodify_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool Locks::noshapepropsmodify() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noShapePropsModify)
  return _internal_noshapepropsmodify();
}
inline void Locks::set_noshapepropsmodify(bool value) {
  _internal_set_noshapepropsmodify(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noShapePropsModify)
}
inline bool Locks::_internal_noshapepropsmodify() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noshapepropsmodify_;
}
inline void Locks::_internal_set_noshapepropsmodify(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.noshapepropsmodify_ = value;
}

// optional bool noTextInput = 23;
inline bool Locks::has_notextinput() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void Locks::clear_notextinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notextinput_ = false;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline bool Locks::notextinput() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noTextInput)
  return _internal_notextinput();
}
inline void Locks::set_notextinput(bool value) {
  _internal_set_notextinput(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noTextInput)
}
inline bool Locks::_internal_notextinput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notextinput_;
}
inline void Locks::_internal_set_notextinput(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.notextinput_ = value;
}

// optional bool noShapePropsModifySansTextOp = 24;
inline bool Locks::has_noshapepropsmodifysanstextop() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void Locks::clear_noshapepropsmodifysanstextop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noshapepropsmodifysanstextop_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool Locks::noshapepropsmodifysanstextop() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noShapePropsModifySansTextOp)
  return _internal_noshapepropsmodifysanstextop();
}
inline void Locks::set_noshapepropsmodifysanstextop(bool value) {
  _internal_set_noshapepropsmodifysanstextop(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noShapePropsModifySansTextOp)
}
inline bool Locks::_internal_noshapepropsmodifysanstextop() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noshapepropsmodifysanstextop_;
}
inline void Locks::_internal_set_noshapepropsmodifysanstextop(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.noshapepropsmodifysanstextop_ = value;
}

// optional bool noBbox = 25;
inline bool Locks::has_nobbox() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void Locks::clear_nobbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nobbox_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool Locks::nobbox() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.noBbox)
  return _internal_nobbox();
}
inline void Locks::set_nobbox(bool value) {
  _internal_set_nobbox(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Locks.noBbox)
}
inline bool Locks::_internal_nobbox() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nobbox_;
}
inline void Locks::_internal_set_nobbox(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.nobbox_ = value;
}

// repeated .com.zoho.shapes.Locks.LockedBy lockers = 13;
inline int Locks::_internal_lockers_size() const {
  return _internal_lockers().size();
}
inline int Locks::lockers_size() const {
  return _internal_lockers_size();
}
inline void Locks::clear_lockers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lockers_.Clear();
}
inline ::com::zoho::shapes::Locks_LockedBy* Locks::mutable_lockers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Locks.lockers)
  return _internal_mutable_lockers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Locks_LockedBy>* Locks::mutable_lockers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.Locks.lockers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lockers();
}
inline const ::com::zoho::shapes::Locks_LockedBy& Locks::lockers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Locks.lockers)
  return _internal_lockers().Get(index);
}
inline ::com::zoho::shapes::Locks_LockedBy* Locks::add_lockers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::Locks_LockedBy* _add = _internal_mutable_lockers()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.Locks.lockers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Locks_LockedBy>& Locks::lockers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.Locks.lockers)
  return _internal_lockers();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Locks_LockedBy>&
Locks::_internal_lockers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lockers_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::Locks_LockedBy>*
Locks::_internal_mutable_lockers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lockers_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::shapes::Locks_LockedBy_LockProp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::Locks_LockedBy_LockProp>() {
  return ::com::zoho::shapes::Locks_LockedBy_LockProp_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_locks_2eproto_2epb_2eh
