// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autofit.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_autofit_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_autofit_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "dimension.pb.h"
#include "google/protobuf/protoextensions.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_autofit_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_autofit_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_autofit_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class AutoFit;
struct AutoFitDefaultTypeInternal;
extern AutoFitDefaultTypeInternal _AutoFit_default_instance_;
class AutoFit_BestAutoFit;
struct AutoFit_BestAutoFitDefaultTypeInternal;
extern AutoFit_BestAutoFitDefaultTypeInternal _AutoFit_BestAutoFit_default_instance_;
class AutoFit_NormalAutoFit;
struct AutoFit_NormalAutoFitDefaultTypeInternal;
extern AutoFit_NormalAutoFitDefaultTypeInternal _AutoFit_NormalAutoFit_default_instance_;
class AutoFit_ShapeAutoFit;
struct AutoFit_ShapeAutoFitDefaultTypeInternal;
extern AutoFit_ShapeAutoFitDefaultTypeInternal _AutoFit_ShapeAutoFit_default_instance_;
class AutoFit_ShapeAutoFit_DefinedBoundary;
struct AutoFit_ShapeAutoFit_DefinedBoundaryDefaultTypeInternal;
extern AutoFit_ShapeAutoFit_DefinedBoundaryDefaultTypeInternal _AutoFit_ShapeAutoFit_DefinedBoundary_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {
enum AutoFit_ShapeAutoFit_ShapeAutoFitType : int {
  AutoFit_ShapeAutoFit_ShapeAutoFitType_NO_BOUNDARY = 0,
  AutoFit_ShapeAutoFit_ShapeAutoFitType_DEFINED_BOUNDARY = 1,
  AutoFit_ShapeAutoFit_ShapeAutoFitType_AutoFit_ShapeAutoFit_ShapeAutoFitType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AutoFit_ShapeAutoFit_ShapeAutoFitType_AutoFit_ShapeAutoFit_ShapeAutoFitType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AutoFit_ShapeAutoFit_ShapeAutoFitType_IsValid(int value);
extern const uint32_t AutoFit_ShapeAutoFit_ShapeAutoFitType_internal_data_[];
constexpr AutoFit_ShapeAutoFit_ShapeAutoFitType AutoFit_ShapeAutoFit_ShapeAutoFitType_ShapeAutoFitType_MIN = static_cast<AutoFit_ShapeAutoFit_ShapeAutoFitType>(0);
constexpr AutoFit_ShapeAutoFit_ShapeAutoFitType AutoFit_ShapeAutoFit_ShapeAutoFitType_ShapeAutoFitType_MAX = static_cast<AutoFit_ShapeAutoFit_ShapeAutoFitType>(1);
constexpr int AutoFit_ShapeAutoFit_ShapeAutoFitType_ShapeAutoFitType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AutoFit_ShapeAutoFit_ShapeAutoFitType_descriptor();
template <typename T>
const std::string& AutoFit_ShapeAutoFit_ShapeAutoFitType_Name(T value) {
  static_assert(std::is_same<T, AutoFit_ShapeAutoFit_ShapeAutoFitType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShapeAutoFitType_Name().");
  return AutoFit_ShapeAutoFit_ShapeAutoFitType_Name(static_cast<AutoFit_ShapeAutoFit_ShapeAutoFitType>(value));
}
template <>
inline const std::string& AutoFit_ShapeAutoFit_ShapeAutoFitType_Name(AutoFit_ShapeAutoFit_ShapeAutoFitType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AutoFit_ShapeAutoFit_ShapeAutoFitType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AutoFit_ShapeAutoFit_ShapeAutoFitType_Parse(absl::string_view name, AutoFit_ShapeAutoFit_ShapeAutoFitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AutoFit_ShapeAutoFit_ShapeAutoFitType>(
      AutoFit_ShapeAutoFit_ShapeAutoFitType_descriptor(), name, value);
}
enum AutoFit_AutoFitType : int {
  AutoFit_AutoFitType_NONE = 0,
  AutoFit_AutoFitType_NORMAL = 1,
  AutoFit_AutoFitType_SHAPE = 2,
  AutoFit_AutoFitType_BEST = 3,
  AutoFit_AutoFitType_RESTRICT = 4,
  AutoFit_AutoFitType_AutoFit_AutoFitType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AutoFit_AutoFitType_AutoFit_AutoFitType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AutoFit_AutoFitType_IsValid(int value);
extern const uint32_t AutoFit_AutoFitType_internal_data_[];
constexpr AutoFit_AutoFitType AutoFit_AutoFitType_AutoFitType_MIN = static_cast<AutoFit_AutoFitType>(0);
constexpr AutoFit_AutoFitType AutoFit_AutoFitType_AutoFitType_MAX = static_cast<AutoFit_AutoFitType>(4);
constexpr int AutoFit_AutoFitType_AutoFitType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
AutoFit_AutoFitType_descriptor();
template <typename T>
const std::string& AutoFit_AutoFitType_Name(T value) {
  static_assert(std::is_same<T, AutoFit_AutoFitType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AutoFitType_Name().");
  return AutoFit_AutoFitType_Name(static_cast<AutoFit_AutoFitType>(value));
}
template <>
inline const std::string& AutoFit_AutoFitType_Name(AutoFit_AutoFitType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AutoFit_AutoFitType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool AutoFit_AutoFitType_Parse(absl::string_view name, AutoFit_AutoFitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AutoFit_AutoFitType>(
      AutoFit_AutoFitType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class AutoFit_NormalAutoFit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.AutoFit.NormalAutoFit) */ {
 public:
  inline AutoFit_NormalAutoFit() : AutoFit_NormalAutoFit(nullptr) {}
  ~AutoFit_NormalAutoFit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AutoFit_NormalAutoFit(::google::protobuf::internal::ConstantInitialized);

  inline AutoFit_NormalAutoFit(const AutoFit_NormalAutoFit& from)
      : AutoFit_NormalAutoFit(nullptr, from) {}
  AutoFit_NormalAutoFit(AutoFit_NormalAutoFit&& from) noexcept
    : AutoFit_NormalAutoFit() {
    *this = ::std::move(from);
  }

  inline AutoFit_NormalAutoFit& operator=(const AutoFit_NormalAutoFit& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoFit_NormalAutoFit& operator=(AutoFit_NormalAutoFit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoFit_NormalAutoFit& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoFit_NormalAutoFit* internal_default_instance() {
    return reinterpret_cast<const AutoFit_NormalAutoFit*>(
               &_AutoFit_NormalAutoFit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AutoFit_NormalAutoFit& a, AutoFit_NormalAutoFit& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoFit_NormalAutoFit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoFit_NormalAutoFit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoFit_NormalAutoFit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoFit_NormalAutoFit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoFit_NormalAutoFit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AutoFit_NormalAutoFit& from) {
    AutoFit_NormalAutoFit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutoFit_NormalAutoFit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.AutoFit.NormalAutoFit";
  }
  protected:
  explicit AutoFit_NormalAutoFit(::google::protobuf::Arena* arena);
  AutoFit_NormalAutoFit(::google::protobuf::Arena* arena, const AutoFit_NormalAutoFit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFontScaleFieldNumber = 1,
    kLineSpaceScaleFieldNumber = 2,
  };
  // optional float fontScale = 1;
  bool has_fontscale() const;
  void clear_fontscale() ;
  float fontscale() const;
  void set_fontscale(float value);

  private:
  float _internal_fontscale() const;
  void _internal_set_fontscale(float value);

  public:
  // optional float lineSpaceScale = 2;
  bool has_linespacescale() const;
  void clear_linespacescale() ;
  float linespacescale() const;
  void set_linespacescale(float value);

  private:
  float _internal_linespacescale() const;
  void _internal_set_linespacescale(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.AutoFit.NormalAutoFit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float fontscale_;
    float linespacescale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autofit_2eproto;
};// -------------------------------------------------------------------

class AutoFit_BestAutoFit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.AutoFit.BestAutoFit) */ {
 public:
  inline AutoFit_BestAutoFit() : AutoFit_BestAutoFit(nullptr) {}
  ~AutoFit_BestAutoFit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AutoFit_BestAutoFit(::google::protobuf::internal::ConstantInitialized);

  inline AutoFit_BestAutoFit(const AutoFit_BestAutoFit& from)
      : AutoFit_BestAutoFit(nullptr, from) {}
  AutoFit_BestAutoFit(AutoFit_BestAutoFit&& from) noexcept
    : AutoFit_BestAutoFit() {
    *this = ::std::move(from);
  }

  inline AutoFit_BestAutoFit& operator=(const AutoFit_BestAutoFit& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoFit_BestAutoFit& operator=(AutoFit_BestAutoFit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoFit_BestAutoFit& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoFit_BestAutoFit* internal_default_instance() {
    return reinterpret_cast<const AutoFit_BestAutoFit*>(
               &_AutoFit_BestAutoFit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AutoFit_BestAutoFit& a, AutoFit_BestAutoFit& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoFit_BestAutoFit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoFit_BestAutoFit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoFit_BestAutoFit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoFit_BestAutoFit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoFit_BestAutoFit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AutoFit_BestAutoFit& from) {
    AutoFit_BestAutoFit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutoFit_BestAutoFit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.AutoFit.BestAutoFit";
  }
  protected:
  explicit AutoFit_BestAutoFit(::google::protobuf::Arena* arena);
  AutoFit_BestAutoFit(::google::protobuf::Arena* arena, const AutoFit_BestAutoFit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFontScaleFieldNumber = 1,
    kLineSpaceScaleFieldNumber = 2,
  };
  // optional float fontScale = 1;
  bool has_fontscale() const;
  void clear_fontscale() ;
  float fontscale() const;
  void set_fontscale(float value);

  private:
  float _internal_fontscale() const;
  void _internal_set_fontscale(float value);

  public:
  // optional float lineSpaceScale = 2;
  bool has_linespacescale() const;
  void clear_linespacescale() ;
  float linespacescale() const;
  void set_linespacescale(float value);

  private:
  float _internal_linespacescale() const;
  void _internal_set_linespacescale(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.AutoFit.BestAutoFit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float fontscale_;
    float linespacescale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autofit_2eproto;
};// -------------------------------------------------------------------

class AutoFit_ShapeAutoFit_DefinedBoundary final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary) */ {
 public:
  inline AutoFit_ShapeAutoFit_DefinedBoundary() : AutoFit_ShapeAutoFit_DefinedBoundary(nullptr) {}
  ~AutoFit_ShapeAutoFit_DefinedBoundary() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AutoFit_ShapeAutoFit_DefinedBoundary(::google::protobuf::internal::ConstantInitialized);

  inline AutoFit_ShapeAutoFit_DefinedBoundary(const AutoFit_ShapeAutoFit_DefinedBoundary& from)
      : AutoFit_ShapeAutoFit_DefinedBoundary(nullptr, from) {}
  AutoFit_ShapeAutoFit_DefinedBoundary(AutoFit_ShapeAutoFit_DefinedBoundary&& from) noexcept
    : AutoFit_ShapeAutoFit_DefinedBoundary() {
    *this = ::std::move(from);
  }

  inline AutoFit_ShapeAutoFit_DefinedBoundary& operator=(const AutoFit_ShapeAutoFit_DefinedBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoFit_ShapeAutoFit_DefinedBoundary& operator=(AutoFit_ShapeAutoFit_DefinedBoundary&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoFit_ShapeAutoFit_DefinedBoundary& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoFit_ShapeAutoFit_DefinedBoundary* internal_default_instance() {
    return reinterpret_cast<const AutoFit_ShapeAutoFit_DefinedBoundary*>(
               &_AutoFit_ShapeAutoFit_DefinedBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AutoFit_ShapeAutoFit_DefinedBoundary& a, AutoFit_ShapeAutoFit_DefinedBoundary& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoFit_ShapeAutoFit_DefinedBoundary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoFit_ShapeAutoFit_DefinedBoundary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoFit_ShapeAutoFit_DefinedBoundary* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoFit_ShapeAutoFit_DefinedBoundary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoFit_ShapeAutoFit_DefinedBoundary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AutoFit_ShapeAutoFit_DefinedBoundary& from) {
    AutoFit_ShapeAutoFit_DefinedBoundary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutoFit_ShapeAutoFit_DefinedBoundary* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary";
  }
  protected:
  explicit AutoFit_ShapeAutoFit_DefinedBoundary(::google::protobuf::Arena* arena);
  AutoFit_ShapeAutoFit_DefinedBoundary(::google::protobuf::Arena* arena, const AutoFit_ShapeAutoFit_DefinedBoundary& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxDimFieldNumber = 1,
    kFontScaleFieldNumber = 2,
    kLineSpaceScaleFieldNumber = 3,
  };
  // optional .com.zoho.common.Dimension maxDim = 1;
  bool has_maxdim() const;
  void clear_maxdim() ;
  const ::com::zoho::common::Dimension& maxdim() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Dimension* release_maxdim();
  ::com::zoho::common::Dimension* mutable_maxdim();
  void set_allocated_maxdim(::com::zoho::common::Dimension* value);
  void unsafe_arena_set_allocated_maxdim(::com::zoho::common::Dimension* value);
  ::com::zoho::common::Dimension* unsafe_arena_release_maxdim();

  private:
  const ::com::zoho::common::Dimension& _internal_maxdim() const;
  ::com::zoho::common::Dimension* _internal_mutable_maxdim();

  public:
  // optional float fontScale = 2;
  bool has_fontscale() const;
  void clear_fontscale() ;
  float fontscale() const;
  void set_fontscale(float value);

  private:
  float _internal_fontscale() const;
  void _internal_set_fontscale(float value);

  public:
  // optional float lineSpaceScale = 3;
  bool has_linespacescale() const;
  void clear_linespacescale() ;
  float linespacescale() const;
  void set_linespacescale(float value);

  private:
  float _internal_linespacescale() const;
  void _internal_set_linespacescale(float value);

  public:
  void temp_setmaxDim(com::zoho::common::Dimension* maxDim) {
    if(&this->maxdim() != maxDim) {
      set_allocated_maxdim(maxDim);
    }
  }
  
  com::zoho::common::Dimension* temp_getmaxDim() const {
    if (has_maxdim()) 
      return (const_cast<com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary*>(this))->mutable_maxdim();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::Dimension* maxdim_;
    float fontscale_;
    float linespacescale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autofit_2eproto;
};// -------------------------------------------------------------------

class AutoFit_ShapeAutoFit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.AutoFit.ShapeAutoFit) */ {
 public:
  inline AutoFit_ShapeAutoFit() : AutoFit_ShapeAutoFit(nullptr) {}
  ~AutoFit_ShapeAutoFit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AutoFit_ShapeAutoFit(::google::protobuf::internal::ConstantInitialized);

  inline AutoFit_ShapeAutoFit(const AutoFit_ShapeAutoFit& from)
      : AutoFit_ShapeAutoFit(nullptr, from) {}
  AutoFit_ShapeAutoFit(AutoFit_ShapeAutoFit&& from) noexcept
    : AutoFit_ShapeAutoFit() {
    *this = ::std::move(from);
  }

  inline AutoFit_ShapeAutoFit& operator=(const AutoFit_ShapeAutoFit& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoFit_ShapeAutoFit& operator=(AutoFit_ShapeAutoFit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoFit_ShapeAutoFit& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoFit_ShapeAutoFit* internal_default_instance() {
    return reinterpret_cast<const AutoFit_ShapeAutoFit*>(
               &_AutoFit_ShapeAutoFit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AutoFit_ShapeAutoFit& a, AutoFit_ShapeAutoFit& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoFit_ShapeAutoFit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoFit_ShapeAutoFit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoFit_ShapeAutoFit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoFit_ShapeAutoFit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoFit_ShapeAutoFit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AutoFit_ShapeAutoFit& from) {
    AutoFit_ShapeAutoFit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutoFit_ShapeAutoFit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.AutoFit.ShapeAutoFit";
  }
  protected:
  explicit AutoFit_ShapeAutoFit(::google::protobuf::Arena* arena);
  AutoFit_ShapeAutoFit(::google::protobuf::Arena* arena, const AutoFit_ShapeAutoFit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DefinedBoundary = AutoFit_ShapeAutoFit_DefinedBoundary;

  using ShapeAutoFitType = AutoFit_ShapeAutoFit_ShapeAutoFitType;
  static constexpr ShapeAutoFitType NO_BOUNDARY = AutoFit_ShapeAutoFit_ShapeAutoFitType_NO_BOUNDARY;
  static constexpr ShapeAutoFitType DEFINED_BOUNDARY = AutoFit_ShapeAutoFit_ShapeAutoFitType_DEFINED_BOUNDARY;
  static inline bool ShapeAutoFitType_IsValid(int value) {
    return AutoFit_ShapeAutoFit_ShapeAutoFitType_IsValid(value);
  }
  static constexpr ShapeAutoFitType ShapeAutoFitType_MIN = AutoFit_ShapeAutoFit_ShapeAutoFitType_ShapeAutoFitType_MIN;
  static constexpr ShapeAutoFitType ShapeAutoFitType_MAX = AutoFit_ShapeAutoFit_ShapeAutoFitType_ShapeAutoFitType_MAX;
  static constexpr int ShapeAutoFitType_ARRAYSIZE = AutoFit_ShapeAutoFit_ShapeAutoFitType_ShapeAutoFitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ShapeAutoFitType_descriptor() {
    return AutoFit_ShapeAutoFit_ShapeAutoFitType_descriptor();
  }
  template <typename T>
  static inline const std::string& ShapeAutoFitType_Name(T value) {
    return AutoFit_ShapeAutoFit_ShapeAutoFitType_Name(value);
  }
  static inline bool ShapeAutoFitType_Parse(absl::string_view name, ShapeAutoFitType* value) {
    return AutoFit_ShapeAutoFit_ShapeAutoFitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDefinedBoundaryFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary definedBoundary = 2;
  bool has_definedboundary() const;
  void clear_definedboundary() ;
  const ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary& definedboundary() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* release_definedboundary();
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* mutable_definedboundary();
  void set_allocated_definedboundary(::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* value);
  void unsafe_arena_set_allocated_definedboundary(::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* value);
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* unsafe_arena_release_definedboundary();

  private:
  const ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary& _internal_definedboundary() const;
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* _internal_mutable_definedboundary();

  public:
  // optional .com.zoho.shapes.AutoFit.ShapeAutoFit.ShapeAutoFitType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType type() const;
  void set_type(::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType value);

  private:
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType value);

  public:
  void temp_setdefinedBoundary(com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* definedBoundary) {
    if(&this->definedboundary() != definedBoundary) {
      set_allocated_definedboundary(definedBoundary);
    }
  }
  
  com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* temp_getdefinedBoundary() const {
    if (has_definedboundary()) 
      return (const_cast<com::zoho::shapes::AutoFit_ShapeAutoFit*>(this))->mutable_definedboundary();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.AutoFit.ShapeAutoFit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* definedboundary_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autofit_2eproto;
};// -------------------------------------------------------------------

class AutoFit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.AutoFit) */ {
 public:
  inline AutoFit() : AutoFit(nullptr) {}
  ~AutoFit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AutoFit(::google::protobuf::internal::ConstantInitialized);

  inline AutoFit(const AutoFit& from)
      : AutoFit(nullptr, from) {}
  AutoFit(AutoFit&& from) noexcept
    : AutoFit() {
    *this = ::std::move(from);
  }

  inline AutoFit& operator=(const AutoFit& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoFit& operator=(AutoFit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoFit& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoFit* internal_default_instance() {
    return reinterpret_cast<const AutoFit*>(
               &_AutoFit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AutoFit& a, AutoFit& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoFit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoFit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoFit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoFit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoFit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AutoFit& from) {
    AutoFit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutoFit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.AutoFit";
  }
  protected:
  explicit AutoFit(::google::protobuf::Arena* arena);
  AutoFit(::google::protobuf::Arena* arena, const AutoFit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using NormalAutoFit = AutoFit_NormalAutoFit;
  using ShapeAutoFit = AutoFit_ShapeAutoFit;
  using BestAutoFit = AutoFit_BestAutoFit;

  using AutoFitType = AutoFit_AutoFitType;
  static constexpr AutoFitType NONE = AutoFit_AutoFitType_NONE;
  static constexpr AutoFitType NORMAL = AutoFit_AutoFitType_NORMAL;
  static constexpr AutoFitType SHAPE = AutoFit_AutoFitType_SHAPE;
  static constexpr AutoFitType BEST = AutoFit_AutoFitType_BEST;
  static constexpr AutoFitType RESTRICT = AutoFit_AutoFitType_RESTRICT;
  static inline bool AutoFitType_IsValid(int value) {
    return AutoFit_AutoFitType_IsValid(value);
  }
  static constexpr AutoFitType AutoFitType_MIN = AutoFit_AutoFitType_AutoFitType_MIN;
  static constexpr AutoFitType AutoFitType_MAX = AutoFit_AutoFitType_AutoFitType_MAX;
  static constexpr int AutoFitType_ARRAYSIZE = AutoFit_AutoFitType_AutoFitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AutoFitType_descriptor() {
    return AutoFit_AutoFitType_descriptor();
  }
  template <typename T>
  static inline const std::string& AutoFitType_Name(T value) {
    return AutoFit_AutoFitType_Name(value);
  }
  static inline bool AutoFitType_Parse(absl::string_view name, AutoFitType* value) {
    return AutoFit_AutoFitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNormalFieldNumber = 2,
    kShapeFieldNumber = 3,
    kBestFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.AutoFit.NormalAutoFit normal = 2;
  bool has_normal() const;
  void clear_normal() ;
  const ::com::zoho::shapes::AutoFit_NormalAutoFit& normal() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::AutoFit_NormalAutoFit* release_normal();
  ::com::zoho::shapes::AutoFit_NormalAutoFit* mutable_normal();
  void set_allocated_normal(::com::zoho::shapes::AutoFit_NormalAutoFit* value);
  void unsafe_arena_set_allocated_normal(::com::zoho::shapes::AutoFit_NormalAutoFit* value);
  ::com::zoho::shapes::AutoFit_NormalAutoFit* unsafe_arena_release_normal();

  private:
  const ::com::zoho::shapes::AutoFit_NormalAutoFit& _internal_normal() const;
  ::com::zoho::shapes::AutoFit_NormalAutoFit* _internal_mutable_normal();

  public:
  // optional .com.zoho.shapes.AutoFit.ShapeAutoFit shape = 3;
  bool has_shape() const;
  void clear_shape() ;
  const ::com::zoho::shapes::AutoFit_ShapeAutoFit& shape() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::AutoFit_ShapeAutoFit* release_shape();
  ::com::zoho::shapes::AutoFit_ShapeAutoFit* mutable_shape();
  void set_allocated_shape(::com::zoho::shapes::AutoFit_ShapeAutoFit* value);
  void unsafe_arena_set_allocated_shape(::com::zoho::shapes::AutoFit_ShapeAutoFit* value);
  ::com::zoho::shapes::AutoFit_ShapeAutoFit* unsafe_arena_release_shape();

  private:
  const ::com::zoho::shapes::AutoFit_ShapeAutoFit& _internal_shape() const;
  ::com::zoho::shapes::AutoFit_ShapeAutoFit* _internal_mutable_shape();

  public:
  // optional .com.zoho.shapes.AutoFit.BestAutoFit best = 4;
  bool has_best() const;
  void clear_best() ;
  const ::com::zoho::shapes::AutoFit_BestAutoFit& best() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::AutoFit_BestAutoFit* release_best();
  ::com::zoho::shapes::AutoFit_BestAutoFit* mutable_best();
  void set_allocated_best(::com::zoho::shapes::AutoFit_BestAutoFit* value);
  void unsafe_arena_set_allocated_best(::com::zoho::shapes::AutoFit_BestAutoFit* value);
  ::com::zoho::shapes::AutoFit_BestAutoFit* unsafe_arena_release_best();

  private:
  const ::com::zoho::shapes::AutoFit_BestAutoFit& _internal_best() const;
  ::com::zoho::shapes::AutoFit_BestAutoFit* _internal_mutable_best();

  public:
  // optional .com.zoho.shapes.AutoFit.AutoFitType type = 1 [(.com.zoho.common.customOptions) = {
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::AutoFit_AutoFitType type() const;
  void set_type(::com::zoho::shapes::AutoFit_AutoFitType value);

  private:
  ::com::zoho::shapes::AutoFit_AutoFitType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::AutoFit_AutoFitType value);

  public:
  void temp_setnormal(com::zoho::shapes::AutoFit_NormalAutoFit* normal) {
    if(&this->normal() != normal) {
      set_allocated_normal(normal);
    }
  }
  
  com::zoho::shapes::AutoFit_NormalAutoFit* temp_getnormal() const {
    if (has_normal()) 
      return (const_cast<com::zoho::shapes::AutoFit*>(this))->mutable_normal();
    return nullptr;
  }
  
  void temp_setshape(com::zoho::shapes::AutoFit_ShapeAutoFit* shape) {
    if(&this->shape() != shape) {
      set_allocated_shape(shape);
    }
  }
  
  com::zoho::shapes::AutoFit_ShapeAutoFit* temp_getshape() const {
    if (has_shape()) 
      return (const_cast<com::zoho::shapes::AutoFit*>(this))->mutable_shape();
    return nullptr;
  }
  
  void temp_setbest(com::zoho::shapes::AutoFit_BestAutoFit* best) {
    if(&this->best() != best) {
      set_allocated_best(best);
    }
  }
  
  com::zoho::shapes::AutoFit_BestAutoFit* temp_getbest() const {
    if (has_best()) 
      return (const_cast<com::zoho::shapes::AutoFit*>(this))->mutable_best();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.AutoFit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::AutoFit_NormalAutoFit* normal_;
    ::com::zoho::shapes::AutoFit_ShapeAutoFit* shape_;
    ::com::zoho::shapes::AutoFit_BestAutoFit* best_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_autofit_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AutoFit_NormalAutoFit

// optional float fontScale = 1;
inline bool AutoFit_NormalAutoFit::has_fontscale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AutoFit_NormalAutoFit::clear_fontscale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fontscale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float AutoFit_NormalAutoFit::fontscale() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.NormalAutoFit.fontScale)
  return _internal_fontscale();
}
inline void AutoFit_NormalAutoFit::set_fontscale(float value) {
  _internal_set_fontscale(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.NormalAutoFit.fontScale)
}
inline float AutoFit_NormalAutoFit::_internal_fontscale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fontscale_;
}
inline void AutoFit_NormalAutoFit::_internal_set_fontscale(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fontscale_ = value;
}

// optional float lineSpaceScale = 2;
inline bool AutoFit_NormalAutoFit::has_linespacescale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AutoFit_NormalAutoFit::clear_linespacescale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linespacescale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float AutoFit_NormalAutoFit::linespacescale() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.NormalAutoFit.lineSpaceScale)
  return _internal_linespacescale();
}
inline void AutoFit_NormalAutoFit::set_linespacescale(float value) {
  _internal_set_linespacescale(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.NormalAutoFit.lineSpaceScale)
}
inline float AutoFit_NormalAutoFit::_internal_linespacescale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linespacescale_;
}
inline void AutoFit_NormalAutoFit::_internal_set_linespacescale(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.linespacescale_ = value;
}

// -------------------------------------------------------------------

// AutoFit_ShapeAutoFit_DefinedBoundary

// optional .com.zoho.common.Dimension maxDim = 1;
inline bool AutoFit_ShapeAutoFit_DefinedBoundary::has_maxdim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maxdim_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Dimension& AutoFit_ShapeAutoFit_DefinedBoundary::_internal_maxdim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Dimension* p = _impl_.maxdim_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Dimension&>(::com::zoho::common::_Dimension_default_instance_);
}
inline const ::com::zoho::common::Dimension& AutoFit_ShapeAutoFit_DefinedBoundary::maxdim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.maxDim)
  return _internal_maxdim();
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::unsafe_arena_set_allocated_maxdim(::com::zoho::common::Dimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maxdim_);
  }
  _impl_.maxdim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.maxDim)
}
inline ::com::zoho::common::Dimension* AutoFit_ShapeAutoFit_DefinedBoundary::release_maxdim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* released = _impl_.maxdim_;
  _impl_.maxdim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Dimension* AutoFit_ShapeAutoFit_DefinedBoundary::unsafe_arena_release_maxdim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.maxDim)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* temp = _impl_.maxdim_;
  _impl_.maxdim_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Dimension* AutoFit_ShapeAutoFit_DefinedBoundary::_internal_mutable_maxdim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.maxdim_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Dimension>(GetArena());
    _impl_.maxdim_ = reinterpret_cast<::com::zoho::common::Dimension*>(p);
  }
  return _impl_.maxdim_;
}
inline ::com::zoho::common::Dimension* AutoFit_ShapeAutoFit_DefinedBoundary::mutable_maxdim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Dimension* _msg = _internal_mutable_maxdim();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.maxDim)
  return _msg;
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::set_allocated_maxdim(::com::zoho::common::Dimension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maxdim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.maxdim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.maxDim)
}

// optional float fontScale = 2;
inline bool AutoFit_ShapeAutoFit_DefinedBoundary::has_fontscale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::clear_fontscale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fontscale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float AutoFit_ShapeAutoFit_DefinedBoundary::fontscale() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.fontScale)
  return _internal_fontscale();
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::set_fontscale(float value) {
  _internal_set_fontscale(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.fontScale)
}
inline float AutoFit_ShapeAutoFit_DefinedBoundary::_internal_fontscale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fontscale_;
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::_internal_set_fontscale(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fontscale_ = value;
}

// optional float lineSpaceScale = 3;
inline bool AutoFit_ShapeAutoFit_DefinedBoundary::has_linespacescale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::clear_linespacescale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linespacescale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float AutoFit_ShapeAutoFit_DefinedBoundary::linespacescale() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.lineSpaceScale)
  return _internal_linespacescale();
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::set_linespacescale(float value) {
  _internal_set_linespacescale(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary.lineSpaceScale)
}
inline float AutoFit_ShapeAutoFit_DefinedBoundary::_internal_linespacescale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linespacescale_;
}
inline void AutoFit_ShapeAutoFit_DefinedBoundary::_internal_set_linespacescale(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.linespacescale_ = value;
}

// -------------------------------------------------------------------

// AutoFit_ShapeAutoFit

// optional .com.zoho.shapes.AutoFit.ShapeAutoFit.ShapeAutoFitType type = 1;
inline bool AutoFit_ShapeAutoFit::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AutoFit_ShapeAutoFit::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType AutoFit_ShapeAutoFit::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.ShapeAutoFit.type)
  return _internal_type();
}
inline void AutoFit_ShapeAutoFit::set_type(::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.ShapeAutoFit.type)
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType AutoFit_ShapeAutoFit::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType>(_impl_.type_);
}
inline void AutoFit_ShapeAutoFit::_internal_set_type(::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.AutoFit.ShapeAutoFit.DefinedBoundary definedBoundary = 2;
inline bool AutoFit_ShapeAutoFit::has_definedboundary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.definedboundary_ != nullptr);
  return value;
}
inline void AutoFit_ShapeAutoFit::clear_definedboundary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.definedboundary_ != nullptr) _impl_.definedboundary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary& AutoFit_ShapeAutoFit::_internal_definedboundary() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* p = _impl_.definedboundary_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary&>(::com::zoho::shapes::_AutoFit_ShapeAutoFit_DefinedBoundary_default_instance_);
}
inline const ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary& AutoFit_ShapeAutoFit::definedboundary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.ShapeAutoFit.definedBoundary)
  return _internal_definedboundary();
}
inline void AutoFit_ShapeAutoFit::unsafe_arena_set_allocated_definedboundary(::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.definedboundary_);
  }
  _impl_.definedboundary_ = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.AutoFit.ShapeAutoFit.definedBoundary)
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* AutoFit_ShapeAutoFit::release_definedboundary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* released = _impl_.definedboundary_;
  _impl_.definedboundary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* AutoFit_ShapeAutoFit::unsafe_arena_release_definedboundary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.AutoFit.ShapeAutoFit.definedBoundary)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* temp = _impl_.definedboundary_;
  _impl_.definedboundary_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* AutoFit_ShapeAutoFit::_internal_mutable_definedboundary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.definedboundary_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary>(GetArena());
    _impl_.definedboundary_ = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary*>(p);
  }
  return _impl_.definedboundary_;
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* AutoFit_ShapeAutoFit::mutable_definedboundary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* _msg = _internal_mutable_definedboundary();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.AutoFit.ShapeAutoFit.definedBoundary)
  return _msg;
}
inline void AutoFit_ShapeAutoFit::set_allocated_definedboundary(::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary*>(_impl_.definedboundary_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.definedboundary_ = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit_DefinedBoundary*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.AutoFit.ShapeAutoFit.definedBoundary)
}

// -------------------------------------------------------------------

// AutoFit_BestAutoFit

// optional float fontScale = 1;
inline bool AutoFit_BestAutoFit::has_fontscale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AutoFit_BestAutoFit::clear_fontscale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fontscale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float AutoFit_BestAutoFit::fontscale() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.BestAutoFit.fontScale)
  return _internal_fontscale();
}
inline void AutoFit_BestAutoFit::set_fontscale(float value) {
  _internal_set_fontscale(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.BestAutoFit.fontScale)
}
inline float AutoFit_BestAutoFit::_internal_fontscale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fontscale_;
}
inline void AutoFit_BestAutoFit::_internal_set_fontscale(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fontscale_ = value;
}

// optional float lineSpaceScale = 2;
inline bool AutoFit_BestAutoFit::has_linespacescale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AutoFit_BestAutoFit::clear_linespacescale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linespacescale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float AutoFit_BestAutoFit::linespacescale() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.BestAutoFit.lineSpaceScale)
  return _internal_linespacescale();
}
inline void AutoFit_BestAutoFit::set_linespacescale(float value) {
  _internal_set_linespacescale(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.BestAutoFit.lineSpaceScale)
}
inline float AutoFit_BestAutoFit::_internal_linespacescale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linespacescale_;
}
inline void AutoFit_BestAutoFit::_internal_set_linespacescale(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.linespacescale_ = value;
}

// -------------------------------------------------------------------

// AutoFit

// optional .com.zoho.shapes.AutoFit.AutoFitType type = 1 [(.com.zoho.common.customOptions) = {
inline bool AutoFit::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AutoFit::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::shapes::AutoFit_AutoFitType AutoFit::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.type)
  return _internal_type();
}
inline void AutoFit::set_type(::com::zoho::shapes::AutoFit_AutoFitType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.AutoFit.type)
}
inline ::com::zoho::shapes::AutoFit_AutoFitType AutoFit::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::AutoFit_AutoFitType>(_impl_.type_);
}
inline void AutoFit::_internal_set_type(::com::zoho::shapes::AutoFit_AutoFitType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.AutoFit.NormalAutoFit normal = 2;
inline bool AutoFit::has_normal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.normal_ != nullptr);
  return value;
}
inline void AutoFit::clear_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::AutoFit_NormalAutoFit& AutoFit::_internal_normal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::AutoFit_NormalAutoFit* p = _impl_.normal_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::AutoFit_NormalAutoFit&>(::com::zoho::shapes::_AutoFit_NormalAutoFit_default_instance_);
}
inline const ::com::zoho::shapes::AutoFit_NormalAutoFit& AutoFit::normal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.normal)
  return _internal_normal();
}
inline void AutoFit::unsafe_arena_set_allocated_normal(::com::zoho::shapes::AutoFit_NormalAutoFit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.normal_);
  }
  _impl_.normal_ = reinterpret_cast<::com::zoho::shapes::AutoFit_NormalAutoFit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.AutoFit.normal)
}
inline ::com::zoho::shapes::AutoFit_NormalAutoFit* AutoFit::release_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::AutoFit_NormalAutoFit* released = _impl_.normal_;
  _impl_.normal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::AutoFit_NormalAutoFit* AutoFit::unsafe_arena_release_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.AutoFit.normal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::AutoFit_NormalAutoFit* temp = _impl_.normal_;
  _impl_.normal_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::AutoFit_NormalAutoFit* AutoFit::_internal_mutable_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.normal_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::AutoFit_NormalAutoFit>(GetArena());
    _impl_.normal_ = reinterpret_cast<::com::zoho::shapes::AutoFit_NormalAutoFit*>(p);
  }
  return _impl_.normal_;
}
inline ::com::zoho::shapes::AutoFit_NormalAutoFit* AutoFit::mutable_normal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::AutoFit_NormalAutoFit* _msg = _internal_mutable_normal();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.AutoFit.normal)
  return _msg;
}
inline void AutoFit::set_allocated_normal(::com::zoho::shapes::AutoFit_NormalAutoFit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::AutoFit_NormalAutoFit*>(_impl_.normal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::AutoFit_NormalAutoFit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.normal_ = reinterpret_cast<::com::zoho::shapes::AutoFit_NormalAutoFit*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.AutoFit.normal)
}

// optional .com.zoho.shapes.AutoFit.ShapeAutoFit shape = 3;
inline bool AutoFit::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline void AutoFit::clear_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.shape_ != nullptr) _impl_.shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::AutoFit_ShapeAutoFit& AutoFit::_internal_shape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::AutoFit_ShapeAutoFit* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::AutoFit_ShapeAutoFit&>(::com::zoho::shapes::_AutoFit_ShapeAutoFit_default_instance_);
}
inline const ::com::zoho::shapes::AutoFit_ShapeAutoFit& AutoFit::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.shape)
  return _internal_shape();
}
inline void AutoFit::unsafe_arena_set_allocated_shape(::com::zoho::shapes::AutoFit_ShapeAutoFit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.AutoFit.shape)
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit* AutoFit::release_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::AutoFit_ShapeAutoFit* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit* AutoFit::unsafe_arena_release_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.AutoFit.shape)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::AutoFit_ShapeAutoFit* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit* AutoFit::_internal_mutable_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::AutoFit_ShapeAutoFit>(GetArena());
    _impl_.shape_ = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit*>(p);
  }
  return _impl_.shape_;
}
inline ::com::zoho::shapes::AutoFit_ShapeAutoFit* AutoFit::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::AutoFit_ShapeAutoFit* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.AutoFit.shape)
  return _msg;
}
inline void AutoFit::set_allocated_shape(::com::zoho::shapes::AutoFit_ShapeAutoFit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit*>(_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.shape_ = reinterpret_cast<::com::zoho::shapes::AutoFit_ShapeAutoFit*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.AutoFit.shape)
}

// optional .com.zoho.shapes.AutoFit.BestAutoFit best = 4;
inline bool AutoFit::has_best() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.best_ != nullptr);
  return value;
}
inline void AutoFit::clear_best() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.best_ != nullptr) _impl_.best_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::AutoFit_BestAutoFit& AutoFit::_internal_best() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::AutoFit_BestAutoFit* p = _impl_.best_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::AutoFit_BestAutoFit&>(::com::zoho::shapes::_AutoFit_BestAutoFit_default_instance_);
}
inline const ::com::zoho::shapes::AutoFit_BestAutoFit& AutoFit::best() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.AutoFit.best)
  return _internal_best();
}
inline void AutoFit::unsafe_arena_set_allocated_best(::com::zoho::shapes::AutoFit_BestAutoFit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.best_);
  }
  _impl_.best_ = reinterpret_cast<::com::zoho::shapes::AutoFit_BestAutoFit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.AutoFit.best)
}
inline ::com::zoho::shapes::AutoFit_BestAutoFit* AutoFit::release_best() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::AutoFit_BestAutoFit* released = _impl_.best_;
  _impl_.best_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::AutoFit_BestAutoFit* AutoFit::unsafe_arena_release_best() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.AutoFit.best)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::AutoFit_BestAutoFit* temp = _impl_.best_;
  _impl_.best_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::AutoFit_BestAutoFit* AutoFit::_internal_mutable_best() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.best_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::AutoFit_BestAutoFit>(GetArena());
    _impl_.best_ = reinterpret_cast<::com::zoho::shapes::AutoFit_BestAutoFit*>(p);
  }
  return _impl_.best_;
}
inline ::com::zoho::shapes::AutoFit_BestAutoFit* AutoFit::mutable_best() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::AutoFit_BestAutoFit* _msg = _internal_mutable_best();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.AutoFit.best)
  return _msg;
}
inline void AutoFit::set_allocated_best(::com::zoho::shapes::AutoFit_BestAutoFit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::AutoFit_BestAutoFit*>(_impl_.best_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::AutoFit_BestAutoFit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.best_ = reinterpret_cast<::com::zoho::shapes::AutoFit_BestAutoFit*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.AutoFit.best)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType>() {
  return ::com::zoho::shapes::AutoFit_ShapeAutoFit_ShapeAutoFitType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::AutoFit_AutoFitType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::AutoFit_AutoFitType>() {
  return ::com::zoho::shapes::AutoFit_AutoFitType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_autofit_2eproto_2epb_2eh
