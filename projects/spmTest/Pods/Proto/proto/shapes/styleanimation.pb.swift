// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: styleanimation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct StyleAnimation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 2D Transformation
  public var transform: Transform {
    get {return _storage._transform ?? Transform()}
    set {_uniqueStorage()._transform = newValue}
  }
  /// Returns true if `transform` has been explicitly set.
  public var hasTransform: Bool {return _storage._transform != nil}
  /// Clears the value of `transform`. Subsequent reads from it will return its default value.
  public mutating func clearTransform() {_uniqueStorage()._transform = nil}

  /// Fill
  public var fill: Fill {
    get {return _storage._fill ?? Fill()}
    set {_uniqueStorage()._fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  public var hasFill: Bool {return _storage._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  public mutating func clearFill() {_uniqueStorage()._fill = nil}

  /// Stroke
  public var stroke: Stroke {
    get {return _storage._stroke ?? Stroke()}
    set {_uniqueStorage()._stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  public var hasStroke: Bool {return _storage._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  public mutating func clearStroke() {_uniqueStorage()._stroke = nil}

  /// Effects list
  public var effects: Effects {
    get {return _storage._effects ?? Effects()}
    set {_uniqueStorage()._effects = newValue}
  }
  /// Returns true if `effects` has been explicitly set.
  public var hasEffects: Bool {return _storage._effects != nil}
  /// Clears the value of `effects`. Subsequent reads from it will return its default value.
  public mutating func clearEffects() {_uniqueStorage()._effects = nil}

  /// portion style
  public var props: PortionProps {
    get {return _storage._props ?? PortionProps()}
    set {_uniqueStorage()._props = newValue}
  }
  /// Returns true if `props` has been explicitly set.
  public var hasProps: Bool {return _storage._props != nil}
  /// Clears the value of `props`. Subsequent reads from it will return its default value.
  public mutating func clearProps() {_uniqueStorage()._props = nil}

  /// This one is only to select a particular animation type in the UI.
  public var type: StyleAnimation.StyleAnimationType {
    get {return _storage._type ?? .pulse}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var values: [StyleAnimation.StyleAnimationValues] {
    get {return _storage._values}
    set {_uniqueStorage()._values = newValue}
  }

  /// Boolean for indication of the animation to return to original state.	
  public var returnToStart: Bool {
    get {return _storage._returnToStart ?? false}
    set {_uniqueStorage()._returnToStart = newValue}
  }
  /// Returns true if `returnToStart` has been explicitly set.
  public var hasReturnToStart: Bool {return _storage._returnToStart != nil}
  /// Clears the value of `returnToStart`. Subsequent reads from it will return its default value.
  public mutating func clearReturnToStart() {_uniqueStorage()._returnToStart = nil}

  /// By default the order for animation is all i.e. if we have fill and stroke color modification both will happen together.
  /// If for some particular animation we need to follow an order , it will be mentioned here.
  public var order: [StyleAnimation.StyleAnimationProp] {
    get {return _storage._order}
    set {_uniqueStorage()._order = newValue}
  }

  public var path: PathAnimation {
    get {return _storage._path ?? PathAnimation()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {_uniqueStorage()._path = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum StyleAnimationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Contains both transparency (Fill - GRADUAL type) and dimension (transform - CYCLIC type)
    case pulse // = 0

    /// rotate the shape by some angle in both directions (basically , clockwise and anticlockwise) for said number of cycles. Say , a shape is of intial angle 0 , now for the starting point add the angle specified in the transform property (Say 12) and rotate. The number of animation cycles is 3 and the diff angle is 24 and toggle is true. The shape than rotates to -12 for the first cycle, than to +12 for the second cycle and finally to -12 for the third cycle and returns to the original position finally(here it is zero). 
    case teeter // = 1

    /// rotate the shape for some cycle. transform.rotate = 360.
    case spin // = 2

    /// grow the shape by some value. transform.dim.width = 15 , transform.dim.height = 15. If there is no diff value keep on adding the initial value for the number of cycles.
    case grow // = 3

    /// Apply color tweaks for fill and stroke color. Basically use fill.solid.color and stroke.fill.solid.color.
    /// All the animations are of type "Gradual"
    case desaturate // = 4

    /// Modify Saturation and luminance.
    case lighten // = 5

    /// Modify Saturation and luminance.
    case darken // = 6

    /// Modify Color transparency.
    case transparency // = 7

    /// Change object color to fill.solid.color = "accent2"
    case objectColor // = 8

    /// Modify hue for fill and stroke color.
    case complementaryColor // = 9

    /// Modify hue for fill and stroke color.
    case contrastColor // = 10

    /// Modify Fill color to "accent2"
    case fillColor // = 11

    /// Modify Stroke color to "accent2"	
    case strokeColor // = 12

    /// Modify Fill Color to "bg1"
    case colorpulse // = 13

    /// Fill Color to "accent2" in CYCLIC way , font color to "accent2" gradually
    case brush // = 14

    /// Change font color to "accent2" - GRADUAL
    case fontColor // = 15

    /// Underline text - GRADUAL - PER_LETTER.
    case underline // = 16

    /// Font weight - GRADUAL - PER_LETTER
    case boldReveal // = 17

    /// Font Weight - CYCLIC
    case boldFlash // = 18

    /// Fill and Stroke Color to accent2 - GRADUAL , Increase Font Size - Cyclic , "order" for animation will be updated.
    case growWithColor // = 19

    /// Display Block-None - CYCLIC.
    case flash // = 20

    /// Transform - Add/Subract left position (by some num) for said number of cycles i.e. A shape will be shaked Horizontally. 
    case shake // = 21

    /// CYCLIC -- KN
    case bounce // = 22

    /// CYCLIC -- Depends on height
    case wave // = 23

    /// GRADUAL - Font Strike.
    case strike // = 24

    /// Transform the shape in certain angle with pivot point to be 0,0 ( i.e. left top).
    case shimmer // = 25
    case path // = 26

    /// None animation type.
    case none // = 99

    public init() {
      self = .pulse
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pulse
      case 1: self = .teeter
      case 2: self = .spin
      case 3: self = .grow
      case 4: self = .desaturate
      case 5: self = .lighten
      case 6: self = .darken
      case 7: self = .transparency
      case 8: self = .objectColor
      case 9: self = .complementaryColor
      case 10: self = .contrastColor
      case 11: self = .fillColor
      case 12: self = .strokeColor
      case 13: self = .colorpulse
      case 14: self = .brush
      case 15: self = .fontColor
      case 16: self = .underline
      case 17: self = .boldReveal
      case 18: self = .boldFlash
      case 19: self = .growWithColor
      case 20: self = .flash
      case 21: self = .shake
      case 22: self = .bounce
      case 23: self = .wave
      case 24: self = .strike
      case 25: self = .shimmer
      case 26: self = .path
      case 99: self = .none
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .pulse: return 0
      case .teeter: return 1
      case .spin: return 2
      case .grow: return 3
      case .desaturate: return 4
      case .lighten: return 5
      case .darken: return 6
      case .transparency: return 7
      case .objectColor: return 8
      case .complementaryColor: return 9
      case .contrastColor: return 10
      case .fillColor: return 11
      case .strokeColor: return 12
      case .colorpulse: return 13
      case .brush: return 14
      case .fontColor: return 15
      case .underline: return 16
      case .boldReveal: return 17
      case .boldFlash: return 18
      case .growWithColor: return 19
      case .flash: return 20
      case .shake: return 21
      case .bounce: return 22
      case .wave: return 23
      case .strike: return 24
      case .shimmer: return 25
      case .path: return 26
      case .none: return 99
      }
    }

  }

  public enum StyleAnimationProp: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case transform // = 0
    case fill // = 1
    case stroke // = 2
    case effects // = 3
    case props // = 4

    public init() {
      self = .transform
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transform
      case 1: self = .fill
      case 2: self = .stroke
      case 3: self = .effects
      case 4: self = .props
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .transform: return 0
      case .fill: return 1
      case .stroke: return 2
      case .effects: return 3
      case .props: return 4
      }
    }

  }

  public struct StyleAnimationValues {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var propType: StyleAnimation.StyleAnimationProp {
      get {return _propType ?? .transform}
      set {_propType = newValue}
    }
    /// Returns true if `propType` has been explicitly set.
    public var hasPropType: Bool {return self._propType != nil}
    /// Clears the value of `propType`. Subsequent reads from it will return its default value.
    public mutating func clearPropType() {self._propType = nil}

    public var config: StyleAnimation.StyleAnimationValues.AnimationConfiguration {
      get {return _config ?? StyleAnimation.StyleAnimationValues.AnimationConfiguration()}
      set {_config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {return self._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {self._config = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct AnimationConfiguration {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var category: StyleAnimation.StyleAnimationValues.AnimationConfiguration.StyleAnimationCategory {
        get {return _category ?? .cyclic}
        set {_category = newValue}
      }
      /// Returns true if `category` has been explicitly set.
      public var hasCategory: Bool {return self._category != nil}
      /// Clears the value of `category`. Subsequent reads from it will return its default value.
      public mutating func clearCategory() {self._category = nil}

      public var cyclic: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic {
        get {return _cyclic ?? StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic()}
        set {_cyclic = newValue}
      }
      /// Returns true if `cyclic` has been explicitly set.
      public var hasCyclic: Bool {return self._cyclic != nil}
      /// Clears the value of `cyclic`. Subsequent reads from it will return its default value.
      public mutating func clearCyclic() {self._cyclic = nil}

      public var gradual: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Gradual {
        get {return _gradual ?? .untilProp}
        set {_gradual = newValue}
      }
      /// Returns true if `gradual` has been explicitly set.
      public var hasGradual: Bool {return self._gradual != nil}
      /// Clears the value of `gradual`. Subsequent reads from it will return its default value.
      public mutating func clearGradual() {self._gradual = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum StyleAnimationCategory: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Cyclic animation
        case cyclic // = 0

        /// Animate Gradually. 
        case gradual // = 1

        public init() {
          self = .cyclic
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .cyclic
          case 1: self = .gradual
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .cyclic: return 0
          case .gradual: return 1
          }
        }

      }

      public enum Gradual: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Move gradually towards the specified prop.
        case untilProp // = 0

        /// Move gradully till the end point i.e. till animation reaches the original state.i.e. Animation moves from original state to a specified prop which is gradual , the return to original state should also be gradual 
        case untilEnd // = 1

        public init() {
          self = .untilProp
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .untilProp
          case 1: self = .untilEnd
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .untilProp: return 0
          case .untilEnd: return 1
          }
        }

      }

      public struct Cyclic {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Number of animation cycles. 
        public var cycle: Int32 {
          get {return _cycle ?? 0}
          set {_cycle = newValue}
        }
        /// Returns true if `cycle` has been explicitly set.
        public var hasCycle: Bool {return self._cycle != nil}
        /// Clears the value of `cycle`. Subsequent reads from it will return its default value.
        public mutating func clearCycle() {self._cycle = nil}

        /// uniform difference between the initial property and the run time animation prop.
        public var diff: Float {
          get {return _diff ?? 0}
          set {_diff = newValue}
        }
        /// Returns true if `diff` has been explicitly set.
        public var hasDiff: Bool {return self._diff != nil}
        /// Clears the value of `diff`. Subsequent reads from it will return its default value.
        public mutating func clearDiff() {self._diff = nil}

        public var category: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic.CyclicCategory {
          get {return _category ?? .toggle}
          set {_category = newValue}
        }
        /// Returns true if `category` has been explicitly set.
        public var hasCategory: Bool {return self._category != nil}
        /// Clears the value of `category`. Subsequent reads from it will return its default value.
        public mutating func clearCategory() {self._category = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum CyclicCategory: SwiftProtobuf.Enum {
          public typealias RawValue = Int

          ///toggle between true/false or positive/negative values.
          case toggle // = 0

          /// Reach the peak value and than return. That is add the diff values upto a point and from there on subtract them.
          case peakAndReturn // = 1

          public init() {
            self = .toggle
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .toggle
            case 1: self = .peakAndReturn
            default: return nil
            }
          }

          public var rawValue: Int {
            switch self {
            case .toggle: return 0
            case .peakAndReturn: return 1
            }
          }

        }

        public init() {}

        fileprivate var _cycle: Int32? = nil
        fileprivate var _diff: Float? = nil
        fileprivate var _category: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic.CyclicCategory? = nil
      }

      public init() {}

      fileprivate var _category: StyleAnimation.StyleAnimationValues.AnimationConfiguration.StyleAnimationCategory? = nil
      fileprivate var _cyclic: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic? = nil
      fileprivate var _gradual: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Gradual? = nil
    }

    public init() {}

    fileprivate var _propType: StyleAnimation.StyleAnimationProp? = nil
    fileprivate var _config: StyleAnimation.StyleAnimationValues.AnimationConfiguration? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension StyleAnimation.StyleAnimationType: CaseIterable {
  // Support synthesized by the compiler.
}

extension StyleAnimation.StyleAnimationProp: CaseIterable {
  // Support synthesized by the compiler.
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.StyleAnimationCategory: CaseIterable {
  // Support synthesized by the compiler.
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Gradual: CaseIterable {
  // Support synthesized by the compiler.
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic.CyclicCategory: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension StyleAnimation: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationType: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationProp: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationValues: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationValues.AnimationConfiguration: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.StyleAnimationCategory: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Gradual: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic: @unchecked Sendable {}
extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic.CyclicCategory: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension StyleAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StyleAnimation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transform"),
    2: .same(proto: "fill"),
    3: .same(proto: "stroke"),
    4: .same(proto: "effects"),
    5: .same(proto: "props"),
    6: .same(proto: "type"),
    7: .same(proto: "values"),
    8: .same(proto: "returnToStart"),
    9: .same(proto: "order"),
    10: .same(proto: "path"),
  ]

  fileprivate class _StorageClass {
    var _transform: Transform? = nil
    var _fill: Fill? = nil
    var _stroke: Stroke? = nil
    var _effects: Effects? = nil
    var _props: PortionProps? = nil
    var _type: StyleAnimation.StyleAnimationType? = nil
    var _values: [StyleAnimation.StyleAnimationValues] = []
    var _returnToStart: Bool? = nil
    var _order: [StyleAnimation.StyleAnimationProp] = []
    var _path: PathAnimation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transform = source._transform
      _fill = source._fill
      _stroke = source._stroke
      _effects = source._effects
      _props = source._props
      _type = source._type
      _values = source._values
      _returnToStart = source._returnToStart
      _order = source._order
      _path = source._path
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fill, !v.isInitialized {return false}
      if let v = _storage._stroke, !v.isInitialized {return false}
      if let v = _storage._effects, !v.isInitialized {return false}
      if let v = _storage._props, !v.isInitialized {return false}
      if let v = _storage._path, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._transform) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._effects) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._props) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._values) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._returnToStart) }()
        case 9: try { try decoder.decodeRepeatedEnumField(value: &_storage._order) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._path) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._transform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._effects {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._props {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      if !_storage._values.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._values, fieldNumber: 7)
      }
      try { if let v = _storage._returnToStart {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      if !_storage._order.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._order, fieldNumber: 9)
      }
      try { if let v = _storage._path {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StyleAnimation, rhs: StyleAnimation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transform != rhs_storage._transform {return false}
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._props != rhs_storage._props {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._values != rhs_storage._values {return false}
        if _storage._returnToStart != rhs_storage._returnToStart {return false}
        if _storage._order != rhs_storage._order {return false}
        if _storage._path != rhs_storage._path {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StyleAnimation.StyleAnimationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PULSE"),
    1: .same(proto: "TEETER"),
    2: .same(proto: "SPIN"),
    3: .same(proto: "GROW"),
    4: .same(proto: "DESATURATE"),
    5: .same(proto: "LIGHTEN"),
    6: .same(proto: "DARKEN"),
    7: .same(proto: "TRANSPARENCY"),
    8: .same(proto: "OBJECT_COLOR"),
    9: .same(proto: "COMPLEMENTARY_COLOR"),
    10: .same(proto: "CONTRAST_COLOR"),
    11: .same(proto: "FILL_COLOR"),
    12: .same(proto: "STROKE_COLOR"),
    13: .same(proto: "COLORPULSE"),
    14: .same(proto: "BRUSH"),
    15: .same(proto: "FONT_COLOR"),
    16: .same(proto: "UNDERLINE"),
    17: .same(proto: "BOLD_REVEAL"),
    18: .same(proto: "BOLD_FLASH"),
    19: .same(proto: "GROW_WITH_COLOR"),
    20: .same(proto: "FLASH"),
    21: .same(proto: "SHAKE"),
    22: .same(proto: "BOUNCE"),
    23: .same(proto: "WAVE"),
    24: .same(proto: "STRIKE"),
    25: .same(proto: "SHIMMER"),
    26: .same(proto: "PATH"),
    99: .same(proto: "NONE"),
  ]
}

extension StyleAnimation.StyleAnimationProp: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFORM"),
    1: .same(proto: "FILL"),
    2: .same(proto: "STROKE"),
    3: .same(proto: "EFFECTS"),
    4: .same(proto: "PROPS"),
  ]
}

extension StyleAnimation.StyleAnimationValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = StyleAnimation.protoMessageName + ".StyleAnimationValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "propType"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._propType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._propType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StyleAnimation.StyleAnimationValues, rhs: StyleAnimation.StyleAnimationValues) -> Bool {
    if lhs._propType != rhs._propType {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = StyleAnimation.StyleAnimationValues.protoMessageName + ".AnimationConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "cyclic"),
    3: .same(proto: "gradual"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._category) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cyclic) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._gradual) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._category {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cyclic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gradual {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StyleAnimation.StyleAnimationValues.AnimationConfiguration, rhs: StyleAnimation.StyleAnimationValues.AnimationConfiguration) -> Bool {
    if lhs._category != rhs._category {return false}
    if lhs._cyclic != rhs._cyclic {return false}
    if lhs._gradual != rhs._gradual {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.StyleAnimationCategory: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CYCLIC"),
    1: .same(proto: "GRADUAL"),
  ]
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Gradual: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNTIL_PROP"),
    1: .same(proto: "UNTIL_END"),
  ]
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = StyleAnimation.StyleAnimationValues.AnimationConfiguration.protoMessageName + ".Cyclic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cycle"),
    2: .same(proto: "diff"),
    3: .same(proto: "category"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._cycle) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._diff) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._category) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cycle {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._diff {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._category {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic, rhs: StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic) -> Bool {
    if lhs._cycle != rhs._cycle {return false}
    if lhs._diff != rhs._diff {return false}
    if lhs._category != rhs._category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StyleAnimation.StyleAnimationValues.AnimationConfiguration.Cyclic.CyclicCategory: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOGGLE"),
    1: .same(proto: "PEAK_AND_RETURN"),
  ]
}
