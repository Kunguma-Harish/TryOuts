// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chartaxis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ChartAxis {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var category: ChartAxis.CategoryAxis {
    get {return _storage._category ?? ChartAxis.CategoryAxis()}
    set {_uniqueStorage()._category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  public var hasCategory: Bool {return _storage._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  public mutating func clearCategory() {_uniqueStorage()._category = nil}

  public var value: ChartAxis.ValueAxis {
    get {return _storage._value ?? ChartAxis.ValueAxis()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var date: ChartAxis.DateAxis {
    get {return _storage._date ?? ChartAxis.DateAxis()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var series: ChartAxis.SeriesAxis {
    get {return _storage._series ?? ChartAxis.SeriesAxis()}
    set {_uniqueStorage()._series = newValue}
  }
  /// Returns true if `series` has been explicitly set.
  public var hasSeries: Bool {return _storage._series != nil}
  /// Clears the value of `series`. Subsequent reads from it will return its default value.
  public mutating func clearSeries() {_uniqueStorage()._series = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct AxisDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Actual axis ID. Unique identifier.
    public var axisID: String {
      get {return _storage._axisID ?? String()}
      set {_uniqueStorage()._axisID = newValue}
    }
    /// Returns true if `axisID` has been explicitly set.
    public var hasAxisID: Bool {return _storage._axisID != nil}
    /// Clears the value of `axisID`. Subsequent reads from it will return its default value.
    public mutating func clearAxisID() {_uniqueStorage()._axisID = nil}

    /// Position of the axis , it could take any of the four side , a category Axis in a regular Bar-Chart would 
    /// take bottom side , in a column-chart it would be left-sde. 
    public var axPos: ChartField.PositionElement {
      get {return _storage._axPos ?? .t}
      set {_uniqueStorage()._axPos = newValue}
    }
    /// Returns true if `axPos` has been explicitly set.
    public var hasAxPos: Bool {return _storage._axPos != nil}
    /// Clears the value of `axPos`. Subsequent reads from it will return its default value.
    public mutating func clearAxPos() {_uniqueStorage()._axPos = nil}

    /// Id of the crossing axis
    public var crossAxisID: String {
      get {return _storage._crossAxisID ?? String()}
      set {_uniqueStorage()._crossAxisID = newValue}
    }
    /// Returns true if `crossAxisID` has been explicitly set.
    public var hasCrossAxisID: Bool {return _storage._crossAxisID != nil}
    /// Clears the value of `crossAxisID`. Subsequent reads from it will return its default value.
    public mutating func clearCrossAxisID() {_uniqueStorage()._crossAxisID = nil}

    public var scaling: ChartAxis.AxisDetails.Scaling {
      get {return _storage._scaling ?? ChartAxis.AxisDetails.Scaling()}
      set {_uniqueStorage()._scaling = newValue}
    }
    /// Returns true if `scaling` has been explicitly set.
    public var hasScaling: Bool {return _storage._scaling != nil}
    /// Clears the value of `scaling`. Subsequent reads from it will return its default value.
    public mutating func clearScaling() {_uniqueStorage()._scaling = nil}

    public var cross: ChartAxis.AxisDetails.Cross {
      get {return _storage._cross ?? ChartAxis.AxisDetails.Cross()}
      set {_uniqueStorage()._cross = newValue}
    }
    /// Returns true if `cross` has been explicitly set.
    public var hasCross: Bool {return _storage._cross != nil}
    /// Clears the value of `cross`. Subsequent reads from it will return its default value.
    public mutating func clearCross() {_uniqueStorage()._cross = nil}

    /// Title element for the axis.
    public var title: TitleElement {
      get {return _storage._title ?? TitleElement()}
      set {_uniqueStorage()._title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    public var hasTitle: Bool {return _storage._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    public mutating func clearTitle() {_uniqueStorage()._title = nil}

    /// Usually will contain only Stroke Value.	
    public var majorGrid: Properties {
      get {return _storage._majorGrid ?? Properties()}
      set {_uniqueStorage()._majorGrid = newValue}
    }
    /// Returns true if `majorGrid` has been explicitly set.
    public var hasMajorGrid: Bool {return _storage._majorGrid != nil}
    /// Clears the value of `majorGrid`. Subsequent reads from it will return its default value.
    public mutating func clearMajorGrid() {_uniqueStorage()._majorGrid = nil}

    public var minorGrid: Properties {
      get {return _storage._minorGrid ?? Properties()}
      set {_uniqueStorage()._minorGrid = newValue}
    }
    /// Returns true if `minorGrid` has been explicitly set.
    public var hasMinorGrid: Bool {return _storage._minorGrid != nil}
    /// Clears the value of `minorGrid`. Subsequent reads from it will return its default value.
    public mutating func clearMinorGrid() {_uniqueStorage()._minorGrid = nil}

    /// Small mark on the axis , both Major and Minor.
    public var majorTickMark: ChartField.TickMarkType {
      get {return _storage._majorTickMark ?? .none}
      set {_uniqueStorage()._majorTickMark = newValue}
    }
    /// Returns true if `majorTickMark` has been explicitly set.
    public var hasMajorTickMark: Bool {return _storage._majorTickMark != nil}
    /// Clears the value of `majorTickMark`. Subsequent reads from it will return its default value.
    public mutating func clearMajorTickMark() {_uniqueStorage()._majorTickMark = nil}

    public var minorTickMark: ChartField.TickMarkType {
      get {return _storage._minorTickMark ?? .none}
      set {_uniqueStorage()._minorTickMark = newValue}
    }
    /// Returns true if `minorTickMark` has been explicitly set.
    public var hasMinorTickMark: Bool {return _storage._minorTickMark != nil}
    /// Clears the value of `minorTickMark`. Subsequent reads from it will return its default value.
    public mutating func clearMinorTickMark() {_uniqueStorage()._minorTickMark = nil}

    ///Postion of the tick label 	
    public var labelPos: ChartField.LabelPos {
      get {return _storage._labelPos ?? .nil}
      set {_uniqueStorage()._labelPos = newValue}
    }
    /// Returns true if `labelPos` has been explicitly set.
    public var hasLabelPos: Bool {return _storage._labelPos != nil}
    /// Clears the value of `labelPos`. Subsequent reads from it will return its default value.
    public mutating func clearLabelPos() {_uniqueStorage()._labelPos = nil}

    public var props: Properties {
      get {return _storage._props ?? Properties()}
      set {_uniqueStorage()._props = newValue}
    }
    /// Returns true if `props` has been explicitly set.
    public var hasProps: Bool {return _storage._props != nil}
    /// Clears the value of `props`. Subsequent reads from it will return its default value.
    public mutating func clearProps() {_uniqueStorage()._props = nil}

    public var textBody: TextBody {
      get {return _storage._textBody ?? TextBody()}
      set {_uniqueStorage()._textBody = newValue}
    }
    /// Returns true if `textBody` has been explicitly set.
    public var hasTextBody: Bool {return _storage._textBody != nil}
    /// Clears the value of `textBody`. Subsequent reads from it will return its default value.
    public mutating func clearTextBody() {_uniqueStorage()._textBody = nil}

    public var hidden: Bool {
      get {return _storage._hidden ?? false}
      set {_uniqueStorage()._hidden = newValue}
    }
    /// Returns true if `hidden` has been explicitly set.
    public var hasHidden: Bool {return _storage._hidden != nil}
    /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
    public mutating func clearHidden() {_uniqueStorage()._hidden = nil}

    public var numberFormat: NumberFormat {
      get {return _storage._numberFormat ?? NumberFormat()}
      set {_uniqueStorage()._numberFormat = newValue}
    }
    /// Returns true if `numberFormat` has been explicitly set.
    public var hasNumberFormat: Bool {return _storage._numberFormat != nil}
    /// Clears the value of `numberFormat`. Subsequent reads from it will return its default value.
    public mutating func clearNumberFormat() {_uniqueStorage()._numberFormat = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Order of the axis i.e. start from first element or last element.
    public struct Scaling {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var orient: ChartAxis.AxisDetails.Scaling.Orientation {
        get {return _orient ?? .minmax}
        set {_orient = newValue}
      }
      /// Returns true if `orient` has been explicitly set.
      public var hasOrient: Bool {return self._orient != nil}
      /// Clears the value of `orient`. Subsequent reads from it will return its default value.
      public mutating func clearOrient() {self._orient = nil}

      public var min: Float {
        get {return _min ?? 0}
        set {_min = newValue}
      }
      /// Returns true if `min` has been explicitly set.
      public var hasMin: Bool {return self._min != nil}
      /// Clears the value of `min`. Subsequent reads from it will return its default value.
      public mutating func clearMin() {self._min = nil}

      public var max: Float {
        get {return _max ?? 0}
        set {_max = newValue}
      }
      /// Returns true if `max` has been explicitly set.
      public var hasMax: Bool {return self._max != nil}
      /// Clears the value of `max`. Subsequent reads from it will return its default value.
      public mutating func clearMax() {self._max = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Orientation: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// First To last
        case minmax // = 0

        /// Reverse the order.
        case maxmin // = 1

        public init() {
          self = .minmax
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .minmax
          case 1: self = .maxmin
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .minmax: return 0
          case .maxmin: return 1
          }
        }

      }

      public init() {}

      fileprivate var _orient: ChartAxis.AxisDetails.Scaling.Orientation? = nil
      fileprivate var _min: Float? = nil
      fileprivate var _max: Float? = nil
    }

    /// At what point does this axis cross its perpendicular axis.
    public struct Cross {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: ChartAxis.AxisDetails.Cross.CrossType {
        get {return _type ?? .autozero}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      /// If the cross point is definied manually. i.e. someother point other than the usual co-ordinates.
      public var value: Float {
        get {return _value ?? 0}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      public var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      public mutating func clearValue() {self._value = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum CrossType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case autozero // = 0
        case min // = 1
        case max // = 2
        case manual // = 3

        public init() {
          self = .autozero
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .autozero
          case 1: self = .min
          case 2: self = .max
          case 3: self = .manual
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .autozero: return 0
          case .min: return 1
          case .max: return 2
          case .manual: return 3
          }
        }

      }

      public init() {}

      fileprivate var _type: ChartAxis.AxisDetails.Cross.CrossType? = nil
      fileprivate var _value: Float? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct CategoryAxis {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: ChartAxis.AxisDetails {
      get {return _details ?? ChartAxis.AxisDetails()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {return self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// Allignment of each label text.
    public var lblAlign: HorizontalAlignType {
      get {return _lblAlign ?? .defHorizontalAlignType}
      set {_lblAlign = newValue}
    }
    /// Returns true if `lblAlign` has been explicitly set.
    public var hasLblAlign: Bool {return self._lblAlign != nil}
    /// Clears the value of `lblAlign`. Subsequent reads from it will return its default value.
    public mutating func clearLblAlign() {self._lblAlign = nil}

    /// Distance between axis and label in terms of chart values , with minimum of 0 and maximum of 1 (in value).
    public var lblOffset: Float {
      get {return _lblOffset ?? 0}
      set {_lblOffset = newValue}
    }
    /// Returns true if `lblOffset` has been explicitly set.
    public var hasLblOffset: Bool {return self._lblOffset != nil}
    /// Clears the value of `lblOffset`. Subsequent reads from it will return its default value.
    public mutating func clearLblOffset() {self._lblOffset = nil}

    /// Skip these many number of Tick labels, can contain one or more.
    public var skipTickLabel: Int32 {
      get {return _skipTickLabel ?? 0}
      set {_skipTickLabel = newValue}
    }
    /// Returns true if `skipTickLabel` has been explicitly set.
    public var hasSkipTickLabel: Bool {return self._skipTickLabel != nil}
    /// Clears the value of `skipTickLabel`. Subsequent reads from it will return its default value.
    public mutating func clearSkipTickLabel() {self._skipTickLabel = nil}

    /// Skip these many number of Tick Mark, can contain one or more.
    public var skipTickMark: Int32 {
      get {return _skipTickMark ?? 0}
      set {_skipTickMark = newValue}
    }
    /// Returns true if `skipTickMark` has been explicitly set.
    public var hasSkipTickMark: Bool {return self._skipTickMark != nil}
    /// Clears the value of `skipTickMark`. Subsequent reads from it will return its default value.
    public mutating func clearSkipTickMark() {self._skipTickMark = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: ChartAxis.AxisDetails? = nil
    fileprivate var _lblAlign: HorizontalAlignType? = nil
    fileprivate var _lblOffset: Float? = nil
    fileprivate var _skipTickLabel: Int32? = nil
    fileprivate var _skipTickMark: Int32? = nil
  }

  public struct ValueAxis {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: ChartAxis.AxisDetails {
      get {return _details ?? ChartAxis.AxisDetails()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {return self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    public var crossBetween: ChartAxis.ValueAxis.CrossBetween {
      get {return _crossBetween ?? .default}
      set {_crossBetween = newValue}
    }
    /// Returns true if `crossBetween` has been explicitly set.
    public var hasCrossBetween: Bool {return self._crossBetween != nil}
    /// Clears the value of `crossBetween`. Subsequent reads from it will return its default value.
    public mutating func clearCrossBetween() {self._crossBetween = nil}

    /// How to split the value axis , usually a value axis with a higher value of 5 will be split in 0.5 decimals for major and 0.1 will be the minor.
    /// distance between major tick
    public var major: Float {
      get {return _major ?? 0}
      set {_major = newValue}
    }
    /// Returns true if `major` has been explicitly set.
    public var hasMajor: Bool {return self._major != nil}
    /// Clears the value of `major`. Subsequent reads from it will return its default value.
    public mutating func clearMajor() {self._major = nil}

    /// distance between minor tick
    public var minor: Float {
      get {return _minor ?? 0}
      set {_minor = newValue}
    }
    /// Returns true if `minor` has been explicitly set.
    public var hasMinor: Bool {return self._minor != nil}
    /// Clears the value of `minor`. Subsequent reads from it will return its default value.
    public mutating func clearMinor() {self._minor = nil}

    public var displayUnit: ChartAxis.ValueAxis.DisplayUnit {
      get {return _displayUnit ?? ChartAxis.ValueAxis.DisplayUnit()}
      set {_displayUnit = newValue}
    }
    /// Returns true if `displayUnit` has been explicitly set.
    public var hasDisplayUnit: Bool {return self._displayUnit != nil}
    /// Clears the value of `displayUnit`. Subsequent reads from it will return its default value.
    public mutating func clearDisplayUnit() {self._displayUnit = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Value Axis to cross the other axis by default(i.e. from Start) or in the middle of a Category.
    public enum CrossBetween: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case `default` // = 0
      case midcat // = 1

      public init() {
        self = .default
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .midcat
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .default: return 0
        case .midcat: return 1
        }
      }

    }

    public struct DisplayUnit {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: ChartAxis.ValueAxis.DisplayUnit.DisplayUnitType {
        get {return _type ?? .none}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var custom: Float {
        get {return _custom ?? 0}
        set {_custom = newValue}
      }
      /// Returns true if `custom` has been explicitly set.
      public var hasCustom: Bool {return self._custom != nil}
      /// Clears the value of `custom`. Subsequent reads from it will return its default value.
      public mutating func clearCustom() {self._custom = nil}

      public var label: TitleElement {
        get {return _label ?? TitleElement()}
        set {_label = newValue}
      }
      /// Returns true if `label` has been explicitly set.
      public var hasLabel: Bool {return self._label != nil}
      /// Clears the value of `label`. Subsequent reads from it will return its default value.
      public mutating func clearLabel() {self._label = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum DisplayUnitType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case none // = 0
        case hundreds // = 1
        case thousands // = 2
        case tenthousands // = 3
        case hundredthousands // = 4
        case millions // = 5
        case tenmillions // = 6
        case hundredmillions // = 7
        case billions // = 8
        case trillions // = 9
        case custom // = 10

        public init() {
          self = .none
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .hundreds
          case 2: self = .thousands
          case 3: self = .tenthousands
          case 4: self = .hundredthousands
          case 5: self = .millions
          case 6: self = .tenmillions
          case 7: self = .hundredmillions
          case 8: self = .billions
          case 9: self = .trillions
          case 10: self = .custom
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .none: return 0
          case .hundreds: return 1
          case .thousands: return 2
          case .tenthousands: return 3
          case .hundredthousands: return 4
          case .millions: return 5
          case .tenmillions: return 6
          case .hundredmillions: return 7
          case .billions: return 8
          case .trillions: return 9
          case .custom: return 10
          }
        }

      }

      public init() {}

      fileprivate var _type: ChartAxis.ValueAxis.DisplayUnit.DisplayUnitType? = nil
      fileprivate var _custom: Float? = nil
      fileprivate var _label: TitleElement? = nil
    }

    public init() {}

    fileprivate var _details: ChartAxis.AxisDetails? = nil
    fileprivate var _crossBetween: ChartAxis.ValueAxis.CrossBetween? = nil
    fileprivate var _major: Float? = nil
    fileprivate var _minor: Float? = nil
    fileprivate var _displayUnit: ChartAxis.ValueAxis.DisplayUnit? = nil
  }

  public struct DateAxis {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: ChartAxis.AxisDetails {
      get {return _details ?? ChartAxis.AxisDetails()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {return self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// Distance between axis and label in terms of chart values , with minimum of 0 and maximum of 1. 
    public var lblOffset: Float {
      get {return _lblOffset ?? 0}
      set {_lblOffset = newValue}
    }
    /// Returns true if `lblOffset` has been explicitly set.
    public var hasLblOffset: Bool {return self._lblOffset != nil}
    /// Clears the value of `lblOffset`. Subsequent reads from it will return its default value.
    public mutating func clearLblOffset() {self._lblOffset = nil}

    /// How to split the value axis , usually a value axis with a higher value of 5 will be split in 0.5 decimals for major and 0.1 will be the minor.
    /// distance between major tick
    public var major: Float {
      get {return _major ?? 0}
      set {_major = newValue}
    }
    /// Returns true if `major` has been explicitly set.
    public var hasMajor: Bool {return self._major != nil}
    /// Clears the value of `major`. Subsequent reads from it will return its default value.
    public mutating func clearMajor() {self._major = nil}

    /// distance between minor tick
    public var minor: Float {
      get {return _minor ?? 0}
      set {_minor = newValue}
    }
    /// Returns true if `minor` has been explicitly set.
    public var hasMinor: Bool {return self._minor != nil}
    /// Clears the value of `minor`. Subsequent reads from it will return its default value.
    public mutating func clearMinor() {self._minor = nil}

    public var baseTimeUnit: ChartAxis.DateAxis.TimeUnit {
      get {return _baseTimeUnit ?? .days}
      set {_baseTimeUnit = newValue}
    }
    /// Returns true if `baseTimeUnit` has been explicitly set.
    public var hasBaseTimeUnit: Bool {return self._baseTimeUnit != nil}
    /// Clears the value of `baseTimeUnit`. Subsequent reads from it will return its default value.
    public mutating func clearBaseTimeUnit() {self._baseTimeUnit = nil}

    public var majorTimeUnit: ChartAxis.DateAxis.TimeUnit {
      get {return _majorTimeUnit ?? .days}
      set {_majorTimeUnit = newValue}
    }
    /// Returns true if `majorTimeUnit` has been explicitly set.
    public var hasMajorTimeUnit: Bool {return self._majorTimeUnit != nil}
    /// Clears the value of `majorTimeUnit`. Subsequent reads from it will return its default value.
    public mutating func clearMajorTimeUnit() {self._majorTimeUnit = nil}

    public var minorTimeUnit: ChartAxis.DateAxis.TimeUnit {
      get {return _minorTimeUnit ?? .days}
      set {_minorTimeUnit = newValue}
    }
    /// Returns true if `minorTimeUnit` has been explicitly set.
    public var hasMinorTimeUnit: Bool {return self._minorTimeUnit != nil}
    /// Clears the value of `minorTimeUnit`. Subsequent reads from it will return its default value.
    public mutating func clearMinorTimeUnit() {self._minorTimeUnit = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TimeUnit: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case days // = 0
      case months // = 1
      case years // = 2

      public init() {
        self = .days
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .days
        case 1: self = .months
        case 2: self = .years
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .days: return 0
        case .months: return 1
        case .years: return 2
        }
      }

    }

    public init() {}

    fileprivate var _details: ChartAxis.AxisDetails? = nil
    fileprivate var _lblOffset: Float? = nil
    fileprivate var _major: Float? = nil
    fileprivate var _minor: Float? = nil
    fileprivate var _baseTimeUnit: ChartAxis.DateAxis.TimeUnit? = nil
    fileprivate var _majorTimeUnit: ChartAxis.DateAxis.TimeUnit? = nil
    fileprivate var _minorTimeUnit: ChartAxis.DateAxis.TimeUnit? = nil
  }

  public struct SeriesAxis {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: ChartAxis.AxisDetails {
      get {return _details ?? ChartAxis.AxisDetails()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {return self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// Skip these many number of Tick labels, can contain one or more.
    public var skipTickLabel: Int32 {
      get {return _skipTickLabel ?? 0}
      set {_skipTickLabel = newValue}
    }
    /// Returns true if `skipTickLabel` has been explicitly set.
    public var hasSkipTickLabel: Bool {return self._skipTickLabel != nil}
    /// Clears the value of `skipTickLabel`. Subsequent reads from it will return its default value.
    public mutating func clearSkipTickLabel() {self._skipTickLabel = nil}

    /// Skip these many number of Tick Mark, can contain one or more.
    public var skipTickMark: Int32 {
      get {return _skipTickMark ?? 0}
      set {_skipTickMark = newValue}
    }
    /// Returns true if `skipTickMark` has been explicitly set.
    public var hasSkipTickMark: Bool {return self._skipTickMark != nil}
    /// Clears the value of `skipTickMark`. Subsequent reads from it will return its default value.
    public mutating func clearSkipTickMark() {self._skipTickMark = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: ChartAxis.AxisDetails? = nil
    fileprivate var _skipTickLabel: Int32? = nil
    fileprivate var _skipTickMark: Int32? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension ChartAxis.AxisDetails.Scaling.Orientation: CaseIterable {
  // Support synthesized by the compiler.
}

extension ChartAxis.AxisDetails.Cross.CrossType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ChartAxis.ValueAxis.CrossBetween: CaseIterable {
  // Support synthesized by the compiler.
}

extension ChartAxis.ValueAxis.DisplayUnit.DisplayUnitType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ChartAxis.DateAxis.TimeUnit: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension ChartAxis: @unchecked Sendable {}
extension ChartAxis.AxisDetails: @unchecked Sendable {}
extension ChartAxis.AxisDetails.Scaling: @unchecked Sendable {}
extension ChartAxis.AxisDetails.Scaling.Orientation: @unchecked Sendable {}
extension ChartAxis.AxisDetails.Cross: @unchecked Sendable {}
extension ChartAxis.AxisDetails.Cross.CrossType: @unchecked Sendable {}
extension ChartAxis.CategoryAxis: @unchecked Sendable {}
extension ChartAxis.ValueAxis: @unchecked Sendable {}
extension ChartAxis.ValueAxis.CrossBetween: @unchecked Sendable {}
extension ChartAxis.ValueAxis.DisplayUnit: @unchecked Sendable {}
extension ChartAxis.ValueAxis.DisplayUnit.DisplayUnitType: @unchecked Sendable {}
extension ChartAxis.DateAxis: @unchecked Sendable {}
extension ChartAxis.DateAxis.TimeUnit: @unchecked Sendable {}
extension ChartAxis.SeriesAxis: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.chart"

extension ChartAxis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChartAxis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "value"),
    3: .same(proto: "date"),
    4: .same(proto: "series"),
  ]

  fileprivate class _StorageClass {
    var _category: ChartAxis.CategoryAxis? = nil
    var _value: ChartAxis.ValueAxis? = nil
    var _date: ChartAxis.DateAxis? = nil
    var _series: ChartAxis.SeriesAxis? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _category = source._category
      _value = source._value
      _date = source._date
      _series = source._series
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._category, !v.isInitialized {return false}
      if let v = _storage._value, !v.isInitialized {return false}
      if let v = _storage._date, !v.isInitialized {return false}
      if let v = _storage._series, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._category) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._series) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._category {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._series {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis, rhs: ChartAxis) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._category != rhs_storage._category {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._series != rhs_storage._series {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.AxisDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.protoMessageName + ".AxisDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axisId"),
    2: .same(proto: "axPos"),
    3: .same(proto: "crossAxisId"),
    4: .same(proto: "scaling"),
    5: .same(proto: "cross"),
    6: .same(proto: "title"),
    7: .same(proto: "majorGrid"),
    8: .same(proto: "minorGrid"),
    9: .same(proto: "majorTickMark"),
    10: .same(proto: "minorTickMark"),
    11: .same(proto: "labelPos"),
    12: .same(proto: "props"),
    13: .same(proto: "textBody"),
    14: .same(proto: "hidden"),
    15: .same(proto: "numberFormat"),
  ]

  fileprivate class _StorageClass {
    var _axisID: String? = nil
    var _axPos: ChartField.PositionElement? = nil
    var _crossAxisID: String? = nil
    var _scaling: ChartAxis.AxisDetails.Scaling? = nil
    var _cross: ChartAxis.AxisDetails.Cross? = nil
    var _title: TitleElement? = nil
    var _majorGrid: Properties? = nil
    var _minorGrid: Properties? = nil
    var _majorTickMark: ChartField.TickMarkType? = nil
    var _minorTickMark: ChartField.TickMarkType? = nil
    var _labelPos: ChartField.LabelPos? = nil
    var _props: Properties? = nil
    var _textBody: TextBody? = nil
    var _hidden: Bool? = nil
    var _numberFormat: NumberFormat? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _axisID = source._axisID
      _axPos = source._axPos
      _crossAxisID = source._crossAxisID
      _scaling = source._scaling
      _cross = source._cross
      _title = source._title
      _majorGrid = source._majorGrid
      _minorGrid = source._minorGrid
      _majorTickMark = source._majorTickMark
      _minorTickMark = source._minorTickMark
      _labelPos = source._labelPos
      _props = source._props
      _textBody = source._textBody
      _hidden = source._hidden
      _numberFormat = source._numberFormat
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._axisID == nil {return false}
      if _storage._axPos == nil {return false}
      if _storage._crossAxisID == nil {return false}
      if let v = _storage._title, !v.isInitialized {return false}
      if let v = _storage._majorGrid, !v.isInitialized {return false}
      if let v = _storage._minorGrid, !v.isInitialized {return false}
      if let v = _storage._props, !v.isInitialized {return false}
      if let v = _storage._textBody, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._axisID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._axPos) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._crossAxisID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._scaling) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._cross) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._majorGrid) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._minorGrid) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._majorTickMark) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._minorTickMark) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._labelPos) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._props) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._textBody) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._hidden) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._numberFormat) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._axisID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._axPos {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._crossAxisID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._scaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._cross {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._majorGrid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._minorGrid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._majorTickMark {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._minorTickMark {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._labelPos {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._props {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._textBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._hidden {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._numberFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.AxisDetails, rhs: ChartAxis.AxisDetails) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._axisID != rhs_storage._axisID {return false}
        if _storage._axPos != rhs_storage._axPos {return false}
        if _storage._crossAxisID != rhs_storage._crossAxisID {return false}
        if _storage._scaling != rhs_storage._scaling {return false}
        if _storage._cross != rhs_storage._cross {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._majorGrid != rhs_storage._majorGrid {return false}
        if _storage._minorGrid != rhs_storage._minorGrid {return false}
        if _storage._majorTickMark != rhs_storage._majorTickMark {return false}
        if _storage._minorTickMark != rhs_storage._minorTickMark {return false}
        if _storage._labelPos != rhs_storage._labelPos {return false}
        if _storage._props != rhs_storage._props {return false}
        if _storage._textBody != rhs_storage._textBody {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        if _storage._numberFormat != rhs_storage._numberFormat {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.AxisDetails.Scaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.AxisDetails.protoMessageName + ".Scaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orient"),
    2: .same(proto: "min"),
    3: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._orient) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._min) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._max) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._orient {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._min {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._max {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.AxisDetails.Scaling, rhs: ChartAxis.AxisDetails.Scaling) -> Bool {
    if lhs._orient != rhs._orient {return false}
    if lhs._min != rhs._min {return false}
    if lhs._max != rhs._max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.AxisDetails.Scaling.Orientation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MINMAX"),
    1: .same(proto: "MAXMIN"),
  ]
}

extension ChartAxis.AxisDetails.Cross: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.AxisDetails.protoMessageName + ".Cross"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "type"),
    5: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.AxisDetails.Cross, rhs: ChartAxis.AxisDetails.Cross) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.AxisDetails.Cross.CrossType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTOZERO"),
    1: .same(proto: "MIN"),
    2: .same(proto: "MAX"),
    3: .same(proto: "MANUAL"),
  ]
}

extension ChartAxis.CategoryAxis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.protoMessageName + ".CategoryAxis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
    2: .same(proto: "lblAlign"),
    3: .same(proto: "lblOffset"),
    4: .same(proto: "skipTickLabel"),
    5: .same(proto: "skipTickMark"),
  ]

  public var isInitialized: Bool {
    if self._details == nil {return false}
    if let v = self._details, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._lblAlign) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._lblOffset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._skipTickLabel) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._skipTickMark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lblAlign {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lblOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._skipTickLabel {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._skipTickMark {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.CategoryAxis, rhs: ChartAxis.CategoryAxis) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs._lblAlign != rhs._lblAlign {return false}
    if lhs._lblOffset != rhs._lblOffset {return false}
    if lhs._skipTickLabel != rhs._skipTickLabel {return false}
    if lhs._skipTickMark != rhs._skipTickMark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.ValueAxis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.protoMessageName + ".ValueAxis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
    2: .same(proto: "crossBetween"),
    3: .same(proto: "major"),
    4: .same(proto: "minor"),
    5: .same(proto: "displayUnit"),
  ]

  public var isInitialized: Bool {
    if self._details == nil {return false}
    if let v = self._details, !v.isInitialized {return false}
    if let v = self._displayUnit, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._crossBetween) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._major) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._minor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._displayUnit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._crossBetween {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._major {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minor {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._displayUnit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.ValueAxis, rhs: ChartAxis.ValueAxis) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs._crossBetween != rhs._crossBetween {return false}
    if lhs._major != rhs._major {return false}
    if lhs._minor != rhs._minor {return false}
    if lhs._displayUnit != rhs._displayUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.ValueAxis.CrossBetween: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "MIDCAT"),
  ]
}

extension ChartAxis.ValueAxis.DisplayUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.ValueAxis.protoMessageName + ".DisplayUnit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "custom"),
    3: .same(proto: "label"),
  ]

  public var isInitialized: Bool {
    if let v = self._label, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._custom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._custom {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.ValueAxis.DisplayUnit, rhs: ChartAxis.ValueAxis.DisplayUnit) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.ValueAxis.DisplayUnit.DisplayUnitType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "HUNDREDS"),
    2: .same(proto: "THOUSANDS"),
    3: .same(proto: "TENTHOUSANDS"),
    4: .same(proto: "HUNDREDTHOUSANDS"),
    5: .same(proto: "MILLIONS"),
    6: .same(proto: "TENMILLIONS"),
    7: .same(proto: "HUNDREDMILLIONS"),
    8: .same(proto: "BILLIONS"),
    9: .same(proto: "TRILLIONS"),
    10: .same(proto: "CUSTOM"),
  ]
}

extension ChartAxis.DateAxis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.protoMessageName + ".DateAxis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
    2: .same(proto: "lblOffset"),
    3: .same(proto: "major"),
    4: .same(proto: "minor"),
    5: .same(proto: "baseTimeUnit"),
    6: .same(proto: "majorTimeUnit"),
    7: .same(proto: "minorTimeUnit"),
  ]

  public var isInitialized: Bool {
    if self._details == nil {return false}
    if let v = self._details, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._lblOffset) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._major) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._minor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._baseTimeUnit) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._majorTimeUnit) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._minorTimeUnit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lblOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._major {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minor {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._baseTimeUnit {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._majorTimeUnit {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._minorTimeUnit {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.DateAxis, rhs: ChartAxis.DateAxis) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs._lblOffset != rhs._lblOffset {return false}
    if lhs._major != rhs._major {return false}
    if lhs._minor != rhs._minor {return false}
    if lhs._baseTimeUnit != rhs._baseTimeUnit {return false}
    if lhs._majorTimeUnit != rhs._majorTimeUnit {return false}
    if lhs._minorTimeUnit != rhs._minorTimeUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartAxis.DateAxis.TimeUnit: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAYS"),
    1: .same(proto: "MONTHS"),
    2: .same(proto: "YEARS"),
  ]
}

extension ChartAxis.SeriesAxis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartAxis.protoMessageName + ".SeriesAxis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
    2: .same(proto: "skipTickLabel"),
    3: .same(proto: "skipTickMark"),
  ]

  public var isInitialized: Bool {
    if self._details == nil {return false}
    if let v = self._details, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._skipTickLabel) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._skipTickMark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._skipTickLabel {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._skipTickMark {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartAxis.SeriesAxis, rhs: ChartAxis.SeriesAxis) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs._skipTickLabel != rhs._skipTickLabel {return false}
    if lhs._skipTickMark != rhs._skipTickMark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
