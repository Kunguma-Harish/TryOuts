// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: textfield.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct TextField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: TextField.FieldType {
    get {return _type ?? .defTextFieldType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var datetime: PortionField.DateTimeField {
    get {return _datetime ?? .defDateTimeFieldFormat}
    set {_datetime = newValue}
  }
  /// Returns true if `datetime` has been explicitly set.
  public var hasDatetime: Bool {return self._datetime != nil}
  /// Clears the value of `datetime`. Subsequent reads from it will return its default value.
  public mutating func clearDatetime() {self._datetime = nil}

  public var slidenum: PortionField.SlideNumberField {
    get {return _slidenum ?? .num1}
    set {_slidenum = newValue}
  }
  /// Returns true if `slidenum` has been explicitly set.
  public var hasSlidenum: Bool {return self._slidenum != nil}
  /// Clears the value of `slidenum`. Subsequent reads from it will return its default value.
  public mutating func clearSlidenum() {self._slidenum = nil}

  public var user: UserField {
    get {return _user ?? UserField()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var tag: TagField {
    get {return _tag ?? TagField()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  public var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  public mutating func clearTag() {self._tag = nil}

  public var smart: SmartTextField {
    get {return _smart ?? SmartTextField()}
    set {_smart = newValue}
  }
  /// Returns true if `smart` has been explicitly set.
  public var hasSmart: Bool {return self._smart != nil}
  /// Clears the value of `smart`. Subsequent reads from it will return its default value.
  public mutating func clearSmart() {self._smart = nil}

  public var datafieldID: String {
    get {return _datafieldID ?? String()}
    set {_datafieldID = newValue}
  }
  /// Returns true if `datafieldID` has been explicitly set.
  public var hasDatafieldID: Bool {return self._datafieldID != nil}
  /// Clears the value of `datafieldID`. Subsequent reads from it will return its default value.
  public mutating func clearDatafieldID() {self._datafieldID = nil}

  public var emoji: TextField.EmojiField {
    get {return _emoji ?? TextField.EmojiField()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  public var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  public mutating func clearEmoji() {self._emoji = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FieldType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case defTextFieldType // = 0
    case datetime // = 1
    case slidenum // = 2

    /// Refers to a zoho user.
    case user // = 3

    /// Refers to a tag.
    case tag // = 4
    case smart // = 5
    case datafield // = 6
    case emoji // = 7

    public init() {
      self = .defTextFieldType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .defTextFieldType
      case 1: self = .datetime
      case 2: self = .slidenum
      case 3: self = .user
      case 4: self = .tag
      case 5: self = .smart
      case 6: self = .datafield
      case 7: self = .emoji
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .defTextFieldType: return 0
      case .datetime: return 1
      case .slidenum: return 2
      case .user: return 3
      case .tag: return 4
      case .smart: return 5
      case .datafield: return 6
      case .emoji: return 7
      }
    }

  }

  public struct EmojiField {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unicode: String {
      get {return _unicode ?? String()}
      set {_unicode = newValue}
    }
    /// Returns true if `unicode` has been explicitly set.
    public var hasUnicode: Bool {return self._unicode != nil}
    /// Clears the value of `unicode`. Subsequent reads from it will return its default value.
    public mutating func clearUnicode() {self._unicode = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _unicode: String? = nil
  }

  public init() {}

  fileprivate var _type: TextField.FieldType? = nil
  fileprivate var _datetime: PortionField.DateTimeField? = nil
  fileprivate var _slidenum: PortionField.SlideNumberField? = nil
  fileprivate var _user: UserField? = nil
  fileprivate var _tag: TagField? = nil
  fileprivate var _smart: SmartTextField? = nil
  fileprivate var _datafieldID: String? = nil
  fileprivate var _emoji: TextField.EmojiField? = nil
}

#if swift(>=4.2)

extension TextField.FieldType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension TextField: @unchecked Sendable {}
extension TextField.FieldType: @unchecked Sendable {}
extension TextField.EmojiField: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension TextField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "datetime"),
    3: .same(proto: "slidenum"),
    4: .same(proto: "user"),
    5: .same(proto: "tag"),
    6: .same(proto: "smart"),
    7: .same(proto: "datafieldId"),
    8: .same(proto: "emoji"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if let v = self._smart, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._datetime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._slidenum) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tag) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._smart) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._datafieldID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._emoji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._datetime {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._slidenum {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._tag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._smart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._datafieldID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TextField, rhs: TextField) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._datetime != rhs._datetime {return false}
    if lhs._slidenum != rhs._slidenum {return false}
    if lhs._user != rhs._user {return false}
    if lhs._tag != rhs._tag {return false}
    if lhs._smart != rhs._smart {return false}
    if lhs._datafieldID != rhs._datafieldID {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextField.FieldType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_TEXT_FIELD_TYPE"),
    1: .same(proto: "DATETIME"),
    2: .same(proto: "SLIDENUM"),
    3: .same(proto: "USER"),
    4: .same(proto: "TAG"),
    5: .same(proto: "SMART"),
    6: .same(proto: "DATAFIELD"),
    7: .same(proto: "EMOJI"),
  ]
}

extension TextField.EmojiField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TextField.protoMessageName + ".EmojiField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unicode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._unicode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unicode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TextField.EmojiField, rhs: TextField.EmojiField) -> Bool {
    if lhs._unicode != rhs._unicode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
