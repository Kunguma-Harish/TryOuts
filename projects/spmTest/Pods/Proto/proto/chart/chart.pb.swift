// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chart.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Root Node for Chart - similar to ChartSpace.
public struct Chart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// temporary workround for caching chart shapeobjects in show rendering
  public var chartShape: ChartShape {
    get {return _storage._chartShape ?? ChartShape()}
    set {_uniqueStorage()._chartShape = newValue}
  }
  /// Returns true if `chartShape` has been explicitly set.
  public var hasChartShape: Bool {return _storage._chartShape != nil}
  /// Clears the value of `chartShape`. Subsequent reads from it will return its default value.
  public mutating func clearChartShape() {_uniqueStorage()._chartShape = nil}

  public var obj: Chart.ChartObj {
    get {return _storage._obj ?? Chart.ChartObj()}
    set {_uniqueStorage()._obj = newValue}
  }
  /// Returns true if `obj` has been explicitly set.
  public var hasObj: Bool {return _storage._obj != nil}
  /// Clears the value of `obj`. Subsequent reads from it will return its default value.
  public mutating func clearObj() {_uniqueStorage()._obj = nil}

  /// Overriding Color Map.
  public var colorMap: ColorMap {
    get {return _storage._colorMap ?? ColorMap()}
    set {_uniqueStorage()._colorMap = newValue}
  }
  /// Returns true if `colorMap` has been explicitly set.
  public var hasColorMap: Bool {return _storage._colorMap != nil}
  /// Clears the value of `colorMap`. Subsequent reads from it will return its default value.
  public mutating func clearColorMap() {_uniqueStorage()._colorMap = nil}

  public var textBody: TextBody {
    get {return _storage._textBody ?? TextBody()}
    set {_uniqueStorage()._textBody = newValue}
  }
  /// Returns true if `textBody` has been explicitly set.
  public var hasTextBody: Bool {return _storage._textBody != nil}
  /// Clears the value of `textBody`. Subsequent reads from it will return its default value.
  public mutating func clearTextBody() {_uniqueStorage()._textBody = nil}

  public var props: Properties {
    get {return _storage._props ?? Properties()}
    set {_uniqueStorage()._props = newValue}
  }
  /// Returns true if `props` has been explicitly set.
  public var hasProps: Bool {return _storage._props != nil}
  /// Clears the value of `props`. Subsequent reads from it will return its default value.
  public mutating func clearProps() {_uniqueStorage()._props = nil}

  public var style: ChartStyle {
    get {return _storage._style ?? ChartStyle()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  public var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  public mutating func clearStyle() {_uniqueStorage()._style = nil}

  /// Added for compatability reasons, mainly for exporting.	
  public var styleNumber: Int32 {
    get {return _storage._styleNumber ?? 0}
    set {_uniqueStorage()._styleNumber = newValue}
  }
  /// Returns true if `styleNumber` has been explicitly set.
  public var hasStyleNumber: Bool {return _storage._styleNumber != nil}
  /// Clears the value of `styleNumber`. Subsequent reads from it will return its default value.
  public mutating func clearStyleNumber() {_uniqueStorage()._styleNumber = nil}

  /// Convert the chart as picture and store it here - It will be used by apps which are yet to support rendering.
  public var picture: PictureValue {
    get {return _storage._picture ?? PictureValue()}
    set {_uniqueStorage()._picture = newValue}
  }
  /// Returns true if `picture` has been explicitly set.
  public var hasPicture: Bool {return _storage._picture != nil}
  /// Clears the value of `picture`. Subsequent reads from it will return its default value.
  public mutating func clearPicture() {_uniqueStorage()._picture = nil}

  public var layout: ChartLayout {
    get {return _storage._layout ?? ChartLayout()}
    set {_uniqueStorage()._layout = newValue}
  }
  /// Returns true if `layout` has been explicitly set.
  public var hasLayout: Bool {return _storage._layout != nil}
  /// Clears the value of `layout`. Subsequent reads from it will return its default value.
  public mutating func clearLayout() {_uniqueStorage()._layout = nil}

  /// This datafieldId should ideally map to matrix data type and will create a chart dynamically as per matrix terms.	
  public var datafieldID: String {
    get {return _storage._datafieldID ?? String()}
    set {_uniqueStorage()._datafieldID = newValue}
  }
  /// Returns true if `datafieldID` has been explicitly set.
  public var hasDatafieldID: Bool {return _storage._datafieldID != nil}
  /// Clears the value of `datafieldID`. Subsequent reads from it will return its default value.
  public mutating func clearDatafieldID() {_uniqueStorage()._datafieldID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ChartObj {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var title: TitleElement {
      get {return _storage._title ?? TitleElement()}
      set {_uniqueStorage()._title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    public var hasTitle: Bool {return _storage._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    public mutating func clearTitle() {_uniqueStorage()._title = nil}

    public var legend: Chart.ChartObj.Legend {
      get {return _storage._legend ?? Chart.ChartObj.Legend()}
      set {_uniqueStorage()._legend = newValue}
    }
    /// Returns true if `legend` has been explicitly set.
    public var hasLegend: Bool {return _storage._legend != nil}
    /// Clears the value of `legend`. Subsequent reads from it will return its default value.
    public mutating func clearLegend() {_uniqueStorage()._legend = nil}

    public var plotArea: PlotArea {
      get {return _storage._plotArea ?? PlotArea()}
      set {_uniqueStorage()._plotArea = newValue}
    }
    /// Returns true if `plotArea` has been explicitly set.
    public var hasPlotArea: Bool {return _storage._plotArea != nil}
    /// Clears the value of `plotArea`. Subsequent reads from it will return its default value.
    public mutating func clearPlotArea() {_uniqueStorage()._plotArea = nil}

    /// How to display blank values.
    public var dispBlankAs: Chart.ChartObj.DisplayBlank {
      get {return _storage._dispBlankAs ?? .span}
      set {_uniqueStorage()._dispBlankAs = newValue}
    }
    /// Returns true if `dispBlankAs` has been explicitly set.
    public var hasDispBlankAs: Bool {return _storage._dispBlankAs != nil}
    /// Clears the value of `dispBlankAs`. Subsequent reads from it will return its default value.
    public mutating func clearDispBlankAs() {_uniqueStorage()._dispBlankAs = nil}

    /// Should we plot only visible points or not. 	
    public var plotVisible: Bool {
      get {return _storage._plotVisible ?? false}
      set {_uniqueStorage()._plotVisible = newValue}
    }
    /// Returns true if `plotVisible` has been explicitly set.
    public var hasPlotVisible: Bool {return _storage._plotVisible != nil}
    /// Clears the value of `plotVisible`. Subsequent reads from it will return its default value.
    public mutating func clearPlotVisible() {_uniqueStorage()._plotVisible = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum DisplayBlank: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case span // = 0
      case gap // = 1
      case zero // = 2

      public init() {
        self = .span
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .span
        case 1: self = .gap
        case 2: self = .zero
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .span: return 0
        case .gap: return 1
        case .zero: return 2
        }
      }

    }

    public struct Legend {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var pos: ChartField.PositionElement {
        get {return _pos ?? .t}
        set {_pos = newValue}
      }
      /// Returns true if `pos` has been explicitly set.
      public var hasPos: Bool {return self._pos != nil}
      /// Clears the value of `pos`. Subsequent reads from it will return its default value.
      public mutating func clearPos() {self._pos = nil}

      /// Only Fill, Stroke and effects are supported. 
      public var props: Properties {
        get {return _props ?? Properties()}
        set {_props = newValue}
      }
      /// Returns true if `props` has been explicitly set.
      public var hasProps: Bool {return self._props != nil}
      /// Clears the value of `props`. Subsequent reads from it will return its default value.
      public mutating func clearProps() {self._props = nil}

      /// Specified whether this element shall overlap the other elements.
      public var overlay: Bool {
        get {return _overlay ?? false}
        set {_overlay = newValue}
      }
      /// Returns true if `overlay` has been explicitly set.
      public var hasOverlay: Bool {return self._overlay != nil}
      /// Clears the value of `overlay`. Subsequent reads from it will return its default value.
      public mutating func clearOverlay() {self._overlay = nil}

      /// If the legend is manually placed , we will have this entry.
      public var layout: ManualLayout {
        get {return _layout ?? ManualLayout()}
        set {_layout = newValue}
      }
      /// Returns true if `layout` has been explicitly set.
      public var hasLayout: Bool {return self._layout != nil}
      /// Clears the value of `layout`. Subsequent reads from it will return its default value.
      public mutating func clearLayout() {self._layout = nil}

      public var textBody: TextBody {
        get {return _textBody ?? TextBody()}
        set {_textBody = newValue}
      }
      /// Returns true if `textBody` has been explicitly set.
      public var hasTextBody: Bool {return self._textBody != nil}
      /// Clears the value of `textBody`. Subsequent reads from it will return its default value.
      public mutating func clearTextBody() {self._textBody = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _pos: ChartField.PositionElement? = nil
      fileprivate var _props: Properties? = nil
      fileprivate var _overlay: Bool? = nil
      fileprivate var _layout: ManualLayout? = nil
      fileprivate var _textBody: TextBody? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Chart.ChartObj.DisplayBlank: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Chart: @unchecked Sendable {}
extension Chart.ChartObj: @unchecked Sendable {}
extension Chart.ChartObj.DisplayBlank: @unchecked Sendable {}
extension Chart.ChartObj.Legend: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.chart"

extension Chart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Chart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "chartShape"),
    1: .same(proto: "obj"),
    2: .same(proto: "colorMap"),
    3: .same(proto: "textBody"),
    4: .same(proto: "props"),
    5: .same(proto: "style"),
    6: .same(proto: "styleNumber"),
    7: .same(proto: "picture"),
    8: .same(proto: "layout"),
    9: .same(proto: "datafieldId"),
  ]

  fileprivate class _StorageClass {
    var _chartShape: ChartShape? = nil
    var _obj: Chart.ChartObj? = nil
    var _colorMap: ColorMap? = nil
    var _textBody: TextBody? = nil
    var _props: Properties? = nil
    var _style: ChartStyle? = nil
    var _styleNumber: Int32? = nil
    var _picture: PictureValue? = nil
    var _layout: ChartLayout? = nil
    var _datafieldID: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chartShape = source._chartShape
      _obj = source._obj
      _colorMap = source._colorMap
      _textBody = source._textBody
      _props = source._props
      _style = source._style
      _styleNumber = source._styleNumber
      _picture = source._picture
      _layout = source._layout
      _datafieldID = source._datafieldID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._obj == nil {return false}
      if let v = _storage._chartShape, !v.isInitialized {return false}
      if let v = _storage._obj, !v.isInitialized {return false}
      if let v = _storage._colorMap, !v.isInitialized {return false}
      if let v = _storage._textBody, !v.isInitialized {return false}
      if let v = _storage._props, !v.isInitialized {return false}
      if let v = _storage._style, !v.isInitialized {return false}
      if let v = _storage._picture, !v.isInitialized {return false}
      if let v = _storage._layout, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._obj) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._colorMap) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._textBody) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._props) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._styleNumber) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._picture) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._layout) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._datafieldID) }()
        case 99: try { try decoder.decodeSingularMessageField(value: &_storage._chartShape) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._obj {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._colorMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._textBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._props {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._styleNumber {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._picture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._layout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._datafieldID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._chartShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chart, rhs: Chart) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chartShape != rhs_storage._chartShape {return false}
        if _storage._obj != rhs_storage._obj {return false}
        if _storage._colorMap != rhs_storage._colorMap {return false}
        if _storage._textBody != rhs_storage._textBody {return false}
        if _storage._props != rhs_storage._props {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._styleNumber != rhs_storage._styleNumber {return false}
        if _storage._picture != rhs_storage._picture {return false}
        if _storage._layout != rhs_storage._layout {return false}
        if _storage._datafieldID != rhs_storage._datafieldID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chart.ChartObj: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Chart.protoMessageName + ".ChartObj"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "legend"),
    3: .same(proto: "plotArea"),
    4: .same(proto: "dispBlankAs"),
    5: .same(proto: "plotVisible"),
  ]

  fileprivate class _StorageClass {
    var _title: TitleElement? = nil
    var _legend: Chart.ChartObj.Legend? = nil
    var _plotArea: PlotArea? = nil
    var _dispBlankAs: Chart.ChartObj.DisplayBlank? = nil
    var _plotVisible: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _legend = source._legend
      _plotArea = source._plotArea
      _dispBlankAs = source._dispBlankAs
      _plotVisible = source._plotVisible
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._title, !v.isInitialized {return false}
      if let v = _storage._legend, !v.isInitialized {return false}
      if let v = _storage._plotArea, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._legend) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._plotArea) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._dispBlankAs) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._plotVisible) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._legend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._plotArea {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dispBlankAs {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._plotVisible {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chart.ChartObj, rhs: Chart.ChartObj) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._legend != rhs_storage._legend {return false}
        if _storage._plotArea != rhs_storage._plotArea {return false}
        if _storage._dispBlankAs != rhs_storage._dispBlankAs {return false}
        if _storage._plotVisible != rhs_storage._plotVisible {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chart.ChartObj.DisplayBlank: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAN"),
    1: .same(proto: "GAP"),
    2: .same(proto: "ZERO"),
  ]
}

extension Chart.ChartObj.Legend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Chart.ChartObj.protoMessageName + ".Legend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "props"),
    3: .same(proto: "overlay"),
    4: .same(proto: "layout"),
    5: .same(proto: "textBody"),
  ]

  public var isInitialized: Bool {
    if let v = self._props, !v.isInitialized {return false}
    if let v = self._textBody, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._props) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._overlay) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._layout) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._textBody) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._props {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._overlay {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._layout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._textBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chart.ChartObj.Legend, rhs: Chart.ChartObj.Legend) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs._props != rhs._props {return false}
    if lhs._overlay != rhs._overlay {return false}
    if lhs._layout != rhs._layout {return false}
    if lhs._textBody != rhs._textBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
