// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: plotarea.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PlotArea {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chart: [PlotArea.ChartDetails] {
    get {return _storage._chart}
    set {_uniqueStorage()._chart = newValue}
  }

  /// Category , Value, Date , Series Axis details.
  public var axis: [ChartAxis] {
    get {return _storage._axis}
    set {_uniqueStorage()._axis = newValue}
  }

  public var layout: ManualLayout {
    get {return _storage._layout ?? ManualLayout()}
    set {_uniqueStorage()._layout = newValue}
  }
  /// Returns true if `layout` has been explicitly set.
  public var hasLayout: Bool {return _storage._layout != nil}
  /// Clears the value of `layout`. Subsequent reads from it will return its default value.
  public mutating func clearLayout() {_uniqueStorage()._layout = nil}

  public var dataTable: PlotArea.DataTable {
    get {return _storage._dataTable ?? PlotArea.DataTable()}
    set {_uniqueStorage()._dataTable = newValue}
  }
  /// Returns true if `dataTable` has been explicitly set.
  public var hasDataTable: Bool {return _storage._dataTable != nil}
  /// Clears the value of `dataTable`. Subsequent reads from it will return its default value.
  public mutating func clearDataTable() {_uniqueStorage()._dataTable = nil}

  public var props: Properties {
    get {return _storage._props ?? Properties()}
    set {_uniqueStorage()._props = newValue}
  }
  /// Returns true if `props` has been explicitly set.
  public var hasProps: Bool {return _storage._props != nil}
  /// Clears the value of `props`. Subsequent reads from it will return its default value.
  public mutating func clearProps() {_uniqueStorage()._props = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ChartDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: ChartField.ChartType {
      get {return _storage._type ?? .bar}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    /// Unique Identifier for each axis. We will have two entries in this for x and y axis. 
    /// The ids will basically map itself with the catAx and valAx Ids present in plotarea.	
    public var axisID: [String] {
      get {return _storage._axisID}
      set {_uniqueStorage()._axisID = newValue}
    }

    /// To determine if each data-point has a different color or not.	
    public var varyColors: Bool {
      get {return _storage._varyColors ?? false}
      set {_uniqueStorage()._varyColors = newValue}
    }
    /// Returns true if `varyColors` has been explicitly set.
    public var hasVaryColors: Bool {return _storage._varyColors != nil}
    /// Clears the value of `varyColors`. Subsequent reads from it will return its default value.
    public mutating func clearVaryColors() {_uniqueStorage()._varyColors = nil}

    /// Data Label details for entire series.			
    public var dataLabel: DataLabels {
      get {return _storage._dataLabel ?? DataLabels()}
      set {_uniqueStorage()._dataLabel = newValue}
    }
    /// Returns true if `dataLabel` has been explicitly set.
    public var hasDataLabel: Bool {return _storage._dataLabel != nil}
    /// Clears the value of `dataLabel`. Subsequent reads from it will return its default value.
    public mutating func clearDataLabel() {_uniqueStorage()._dataLabel = nil}

    public var grouping: ChartField.Grouping {
      get {return _storage._grouping ?? .standard}
      set {_uniqueStorage()._grouping = newValue}
    }
    /// Returns true if `grouping` has been explicitly set.
    public var hasGrouping: Bool {return _storage._grouping != nil}
    /// Clears the value of `grouping`. Subsequent reads from it will return its default value.
    public mutating func clearGrouping() {_uniqueStorage()._grouping = nil}

    public var bar: BarChart {
      get {return _storage._bar ?? BarChart()}
      set {_uniqueStorage()._bar = newValue}
    }
    /// Returns true if `bar` has been explicitly set.
    public var hasBar: Bool {return _storage._bar != nil}
    /// Clears the value of `bar`. Subsequent reads from it will return its default value.
    public mutating func clearBar() {_uniqueStorage()._bar = nil}

    public var bar3D: Bar3DChart {
      get {return _storage._bar3D ?? Bar3DChart()}
      set {_uniqueStorage()._bar3D = newValue}
    }
    /// Returns true if `bar3D` has been explicitly set.
    public var hasBar3D: Bool {return _storage._bar3D != nil}
    /// Clears the value of `bar3D`. Subsequent reads from it will return its default value.
    public mutating func clearBar3D() {_uniqueStorage()._bar3D = nil}

    public var line: LineChart {
      get {return _storage._line ?? LineChart()}
      set {_uniqueStorage()._line = newValue}
    }
    /// Returns true if `line` has been explicitly set.
    public var hasLine: Bool {return _storage._line != nil}
    /// Clears the value of `line`. Subsequent reads from it will return its default value.
    public mutating func clearLine() {_uniqueStorage()._line = nil}

    public var line3D: Line3DChart {
      get {return _storage._line3D ?? Line3DChart()}
      set {_uniqueStorage()._line3D = newValue}
    }
    /// Returns true if `line3D` has been explicitly set.
    public var hasLine3D: Bool {return _storage._line3D != nil}
    /// Clears the value of `line3D`. Subsequent reads from it will return its default value.
    public mutating func clearLine3D() {_uniqueStorage()._line3D = nil}

    public var area: AreaChart {
      get {return _storage._area ?? AreaChart()}
      set {_uniqueStorage()._area = newValue}
    }
    /// Returns true if `area` has been explicitly set.
    public var hasArea: Bool {return _storage._area != nil}
    /// Clears the value of `area`. Subsequent reads from it will return its default value.
    public mutating func clearArea() {_uniqueStorage()._area = nil}

    public var pie: PieChart {
      get {return _storage._pie ?? PieChart()}
      set {_uniqueStorage()._pie = newValue}
    }
    /// Returns true if `pie` has been explicitly set.
    public var hasPie: Bool {return _storage._pie != nil}
    /// Clears the value of `pie`. Subsequent reads from it will return its default value.
    public mutating func clearPie() {_uniqueStorage()._pie = nil}

    public var pie3D: Pie3DChart {
      get {return _storage._pie3D ?? Pie3DChart()}
      set {_uniqueStorage()._pie3D = newValue}
    }
    /// Returns true if `pie3D` has been explicitly set.
    public var hasPie3D: Bool {return _storage._pie3D != nil}
    /// Clears the value of `pie3D`. Subsequent reads from it will return its default value.
    public mutating func clearPie3D() {_uniqueStorage()._pie3D = nil}

    public var reppie: RepresentivePieChart {
      get {return _storage._reppie ?? RepresentivePieChart()}
      set {_uniqueStorage()._reppie = newValue}
    }
    /// Returns true if `reppie` has been explicitly set.
    public var hasReppie: Bool {return _storage._reppie != nil}
    /// Clears the value of `reppie`. Subsequent reads from it will return its default value.
    public mutating func clearReppie() {_uniqueStorage()._reppie = nil}

    public var doughnut: DoughnutChart {
      get {return _storage._doughnut ?? DoughnutChart()}
      set {_uniqueStorage()._doughnut = newValue}
    }
    /// Returns true if `doughnut` has been explicitly set.
    public var hasDoughnut: Bool {return _storage._doughnut != nil}
    /// Clears the value of `doughnut`. Subsequent reads from it will return its default value.
    public mutating func clearDoughnut() {_uniqueStorage()._doughnut = nil}

    public var scatter: ScatterChart {
      get {return _storage._scatter ?? ScatterChart()}
      set {_uniqueStorage()._scatter = newValue}
    }
    /// Returns true if `scatter` has been explicitly set.
    public var hasScatter: Bool {return _storage._scatter != nil}
    /// Clears the value of `scatter`. Subsequent reads from it will return its default value.
    public mutating func clearScatter() {_uniqueStorage()._scatter = nil}

    public var bubble: BubbleChart {
      get {return _storage._bubble ?? BubbleChart()}
      set {_uniqueStorage()._bubble = newValue}
    }
    /// Returns true if `bubble` has been explicitly set.
    public var hasBubble: Bool {return _storage._bubble != nil}
    /// Clears the value of `bubble`. Subsequent reads from it will return its default value.
    public mutating func clearBubble() {_uniqueStorage()._bubble = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Values for DataTable. 
  /// DataTable will be drawn if we this entry.	
  public struct DataTable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Display Horizontal Border or not.
    public var horizontalBorder: Bool {
      get {return _horizontalBorder ?? false}
      set {_horizontalBorder = newValue}
    }
    /// Returns true if `horizontalBorder` has been explicitly set.
    public var hasHorizontalBorder: Bool {return self._horizontalBorder != nil}
    /// Clears the value of `horizontalBorder`. Subsequent reads from it will return its default value.
    public mutating func clearHorizontalBorder() {self._horizontalBorder = nil}

    /// Display Vertical Border or not.
    public var verticalBorder: Bool {
      get {return _verticalBorder ?? false}
      set {_verticalBorder = newValue}
    }
    /// Returns true if `verticalBorder` has been explicitly set.
    public var hasVerticalBorder: Bool {return self._verticalBorder != nil}
    /// Clears the value of `verticalBorder`. Subsequent reads from it will return its default value.
    public mutating func clearVerticalBorder() {self._verticalBorder = nil}

    /// Display outline or not.
    public var outline: Bool {
      get {return _outline ?? false}
      set {_outline = newValue}
    }
    /// Returns true if `outline` has been explicitly set.
    public var hasOutline: Bool {return self._outline != nil}
    /// Clears the value of `outline`. Subsequent reads from it will return its default value.
    public mutating func clearOutline() {self._outline = nil}

    /// Display legend keys or not.
    public var legendKeys: Bool {
      get {return _legendKeys ?? false}
      set {_legendKeys = newValue}
    }
    /// Returns true if `legendKeys` has been explicitly set.
    public var hasLegendKeys: Bool {return self._legendKeys != nil}
    /// Clears the value of `legendKeys`. Subsequent reads from it will return its default value.
    public mutating func clearLegendKeys() {self._legendKeys = nil}

    public var props: Properties {
      get {return _props ?? Properties()}
      set {_props = newValue}
    }
    /// Returns true if `props` has been explicitly set.
    public var hasProps: Bool {return self._props != nil}
    /// Clears the value of `props`. Subsequent reads from it will return its default value.
    public mutating func clearProps() {self._props = nil}

    public var textBody: TextBody {
      get {return _textBody ?? TextBody()}
      set {_textBody = newValue}
    }
    /// Returns true if `textBody` has been explicitly set.
    public var hasTextBody: Bool {return self._textBody != nil}
    /// Clears the value of `textBody`. Subsequent reads from it will return its default value.
    public mutating func clearTextBody() {self._textBody = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _horizontalBorder: Bool? = nil
    fileprivate var _verticalBorder: Bool? = nil
    fileprivate var _outline: Bool? = nil
    fileprivate var _legendKeys: Bool? = nil
    fileprivate var _props: Properties? = nil
    fileprivate var _textBody: TextBody? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PlotArea: @unchecked Sendable {}
extension PlotArea.ChartDetails: @unchecked Sendable {}
extension PlotArea.DataTable: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.chart"

extension PlotArea: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlotArea"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chart"),
    2: .same(proto: "axis"),
    3: .same(proto: "layout"),
    4: .same(proto: "dataTable"),
    5: .same(proto: "props"),
  ]

  fileprivate class _StorageClass {
    var _chart: [PlotArea.ChartDetails] = []
    var _axis: [ChartAxis] = []
    var _layout: ManualLayout? = nil
    var _dataTable: PlotArea.DataTable? = nil
    var _props: Properties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chart = source._chart
      _axis = source._axis
      _layout = source._layout
      _dataTable = source._dataTable
      _props = source._props
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chart) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._axis) {return false}
      if let v = _storage._dataTable, !v.isInitialized {return false}
      if let v = _storage._props, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._chart) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._axis) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._layout) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dataTable) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._props) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._chart.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chart, fieldNumber: 1)
      }
      if !_storage._axis.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._axis, fieldNumber: 2)
      }
      try { if let v = _storage._layout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dataTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._props {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PlotArea, rhs: PlotArea) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chart != rhs_storage._chart {return false}
        if _storage._axis != rhs_storage._axis {return false}
        if _storage._layout != rhs_storage._layout {return false}
        if _storage._dataTable != rhs_storage._dataTable {return false}
        if _storage._props != rhs_storage._props {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PlotArea.ChartDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PlotArea.protoMessageName + ".ChartDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "axisId"),
    3: .same(proto: "varyColors"),
    4: .same(proto: "dataLabel"),
    5: .same(proto: "grouping"),
    6: .same(proto: "bar"),
    7: .same(proto: "bar3d"),
    8: .same(proto: "line"),
    9: .same(proto: "line3d"),
    10: .same(proto: "area"),
    11: .same(proto: "pie"),
    12: .same(proto: "pie3d"),
    13: .same(proto: "reppie"),
    14: .same(proto: "doughnut"),
    15: .same(proto: "scatter"),
    16: .same(proto: "bubble"),
  ]

  fileprivate class _StorageClass {
    var _type: ChartField.ChartType? = nil
    var _axisID: [String] = []
    var _varyColors: Bool? = nil
    var _dataLabel: DataLabels? = nil
    var _grouping: ChartField.Grouping? = nil
    var _bar: BarChart? = nil
    var _bar3D: Bar3DChart? = nil
    var _line: LineChart? = nil
    var _line3D: Line3DChart? = nil
    var _area: AreaChart? = nil
    var _pie: PieChart? = nil
    var _pie3D: Pie3DChart? = nil
    var _reppie: RepresentivePieChart? = nil
    var _doughnut: DoughnutChart? = nil
    var _scatter: ScatterChart? = nil
    var _bubble: BubbleChart? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _axisID = source._axisID
      _varyColors = source._varyColors
      _dataLabel = source._dataLabel
      _grouping = source._grouping
      _bar = source._bar
      _bar3D = source._bar3D
      _line = source._line
      _line3D = source._line3D
      _area = source._area
      _pie = source._pie
      _pie3D = source._pie3D
      _reppie = source._reppie
      _doughnut = source._doughnut
      _scatter = source._scatter
      _bubble = source._bubble
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._dataLabel, !v.isInitialized {return false}
      if let v = _storage._bar, !v.isInitialized {return false}
      if let v = _storage._bar3D, !v.isInitialized {return false}
      if let v = _storage._line, !v.isInitialized {return false}
      if let v = _storage._line3D, !v.isInitialized {return false}
      if let v = _storage._area, !v.isInitialized {return false}
      if let v = _storage._pie, !v.isInitialized {return false}
      if let v = _storage._pie3D, !v.isInitialized {return false}
      if let v = _storage._reppie, !v.isInitialized {return false}
      if let v = _storage._doughnut, !v.isInitialized {return false}
      if let v = _storage._scatter, !v.isInitialized {return false}
      if let v = _storage._bubble, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._axisID) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._varyColors) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dataLabel) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._grouping) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._bar) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._bar3D) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._line) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._line3D) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._area) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._pie) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._pie3D) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._reppie) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._doughnut) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._scatter) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._bubble) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      if !_storage._axisID.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._axisID, fieldNumber: 2)
      }
      try { if let v = _storage._varyColors {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dataLabel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._grouping {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._bar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._bar3D {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._line {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._line3D {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._area {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._pie {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._pie3D {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._reppie {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._doughnut {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._scatter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._bubble {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PlotArea.ChartDetails, rhs: PlotArea.ChartDetails) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._axisID != rhs_storage._axisID {return false}
        if _storage._varyColors != rhs_storage._varyColors {return false}
        if _storage._dataLabel != rhs_storage._dataLabel {return false}
        if _storage._grouping != rhs_storage._grouping {return false}
        if _storage._bar != rhs_storage._bar {return false}
        if _storage._bar3D != rhs_storage._bar3D {return false}
        if _storage._line != rhs_storage._line {return false}
        if _storage._line3D != rhs_storage._line3D {return false}
        if _storage._area != rhs_storage._area {return false}
        if _storage._pie != rhs_storage._pie {return false}
        if _storage._pie3D != rhs_storage._pie3D {return false}
        if _storage._reppie != rhs_storage._reppie {return false}
        if _storage._doughnut != rhs_storage._doughnut {return false}
        if _storage._scatter != rhs_storage._scatter {return false}
        if _storage._bubble != rhs_storage._bubble {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PlotArea.DataTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PlotArea.protoMessageName + ".DataTable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "horizontalBorder"),
    2: .same(proto: "verticalBorder"),
    3: .same(proto: "outline"),
    4: .same(proto: "legendKeys"),
    5: .same(proto: "props"),
    6: .same(proto: "textBody"),
  ]

  public var isInitialized: Bool {
    if let v = self._props, !v.isInitialized {return false}
    if let v = self._textBody, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._horizontalBorder) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._verticalBorder) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._outline) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._legendKeys) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._props) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._textBody) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._horizontalBorder {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._verticalBorder {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._outline {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._legendKeys {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._props {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._textBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PlotArea.DataTable, rhs: PlotArea.DataTable) -> Bool {
    if lhs._horizontalBorder != rhs._horizontalBorder {return false}
    if lhs._verticalBorder != rhs._verticalBorder {return false}
    if lhs._outline != rhs._outline {return false}
    if lhs._legendKeys != rhs._legendKeys {return false}
    if lhs._props != rhs._props {return false}
    if lhs._textBody != rhs._textBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
