// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: databasetablecolumn.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_databasetablecolumn_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_databasetablecolumn_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "compositevalue.pb.h"
#include "fields.pb.h"
#include "columnidentifier.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_databasetablecolumn_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_databasetablecolumn_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_databasetablecolumn_2eproto;
namespace com {
namespace zoho {
namespace database {
class DatabaseTableColumn;
struct DatabaseTableColumnDefaultTypeInternal;
extern DatabaseTableColumnDefaultTypeInternal _DatabaseTableColumn_default_instance_;
class DatabaseTableColumn_ChildColumn;
struct DatabaseTableColumn_ChildColumnDefaultTypeInternal;
extern DatabaseTableColumn_ChildColumnDefaultTypeInternal _DatabaseTableColumn_ChildColumn_default_instance_;
class DatabaseTableColumn_Lock;
struct DatabaseTableColumn_LockDefaultTypeInternal;
extern DatabaseTableColumn_LockDefaultTypeInternal _DatabaseTableColumn_Lock_default_instance_;
class DatabaseTableColumn_ParentColumn;
struct DatabaseTableColumn_ParentColumnDefaultTypeInternal;
extern DatabaseTableColumn_ParentColumnDefaultTypeInternal _DatabaseTableColumn_ParentColumn_default_instance_;
class DatabaseTableColumn_SystemManage;
struct DatabaseTableColumn_SystemManageDefaultTypeInternal;
extern DatabaseTableColumn_SystemManageDefaultTypeInternal _DatabaseTableColumn_SystemManage_default_instance_;
}  // namespace database
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace database {
enum DatabaseTableColumn_Lock_LockType : int {
  DatabaseTableColumn_Lock_LockType_DEFAULT_LOCK = 0,
  DatabaseTableColumn_Lock_LockType_NONE = 1,
  DatabaseTableColumn_Lock_LockType_USER = 2,
  DatabaseTableColumn_Lock_LockType_DatabaseTableColumn_Lock_LockType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseTableColumn_Lock_LockType_DatabaseTableColumn_Lock_LockType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseTableColumn_Lock_LockType_IsValid(int value);
extern const uint32_t DatabaseTableColumn_Lock_LockType_internal_data_[];
constexpr DatabaseTableColumn_Lock_LockType DatabaseTableColumn_Lock_LockType_LockType_MIN = static_cast<DatabaseTableColumn_Lock_LockType>(0);
constexpr DatabaseTableColumn_Lock_LockType DatabaseTableColumn_Lock_LockType_LockType_MAX = static_cast<DatabaseTableColumn_Lock_LockType>(2);
constexpr int DatabaseTableColumn_Lock_LockType_LockType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseTableColumn_Lock_LockType_descriptor();
template <typename T>
const std::string& DatabaseTableColumn_Lock_LockType_Name(T value) {
  static_assert(std::is_same<T, DatabaseTableColumn_Lock_LockType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LockType_Name().");
  return DatabaseTableColumn_Lock_LockType_Name(static_cast<DatabaseTableColumn_Lock_LockType>(value));
}
template <>
inline const std::string& DatabaseTableColumn_Lock_LockType_Name(DatabaseTableColumn_Lock_LockType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseTableColumn_Lock_LockType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DatabaseTableColumn_Lock_LockType_Parse(absl::string_view name, DatabaseTableColumn_Lock_LockType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseTableColumn_Lock_LockType>(
      DatabaseTableColumn_Lock_LockType_descriptor(), name, value);
}
enum DatabaseTableColumn_SystemManage_AuditType : int {
  DatabaseTableColumn_SystemManage_AuditType_DEFAULT_AUDIT_TYPE = 0,
  DatabaseTableColumn_SystemManage_AuditType_CREATED_TIME = 1,
  DatabaseTableColumn_SystemManage_AuditType_CREATED_BY = 2,
  DatabaseTableColumn_SystemManage_AuditType_LAST_MODIFIED_TIME = 3,
  DatabaseTableColumn_SystemManage_AuditType_LAST_MODIFIED_BY = 4,
  DatabaseTableColumn_SystemManage_AuditType_DatabaseTableColumn_SystemManage_AuditType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseTableColumn_SystemManage_AuditType_DatabaseTableColumn_SystemManage_AuditType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseTableColumn_SystemManage_AuditType_IsValid(int value);
extern const uint32_t DatabaseTableColumn_SystemManage_AuditType_internal_data_[];
constexpr DatabaseTableColumn_SystemManage_AuditType DatabaseTableColumn_SystemManage_AuditType_AuditType_MIN = static_cast<DatabaseTableColumn_SystemManage_AuditType>(0);
constexpr DatabaseTableColumn_SystemManage_AuditType DatabaseTableColumn_SystemManage_AuditType_AuditType_MAX = static_cast<DatabaseTableColumn_SystemManage_AuditType>(4);
constexpr int DatabaseTableColumn_SystemManage_AuditType_AuditType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseTableColumn_SystemManage_AuditType_descriptor();
template <typename T>
const std::string& DatabaseTableColumn_SystemManage_AuditType_Name(T value) {
  static_assert(std::is_same<T, DatabaseTableColumn_SystemManage_AuditType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AuditType_Name().");
  return DatabaseTableColumn_SystemManage_AuditType_Name(static_cast<DatabaseTableColumn_SystemManage_AuditType>(value));
}
template <>
inline const std::string& DatabaseTableColumn_SystemManage_AuditType_Name(DatabaseTableColumn_SystemManage_AuditType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseTableColumn_SystemManage_AuditType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DatabaseTableColumn_SystemManage_AuditType_Parse(absl::string_view name, DatabaseTableColumn_SystemManage_AuditType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseTableColumn_SystemManage_AuditType>(
      DatabaseTableColumn_SystemManage_AuditType_descriptor(), name, value);
}
enum DatabaseTableColumn_ColumnConstraint : int {
  DatabaseTableColumn_ColumnConstraint_DEFAULT_CONSTRAINT = 0,
  DatabaseTableColumn_ColumnConstraint_PRIMARY_KEY = 1,
  DatabaseTableColumn_ColumnConstraint_UNIQUE = 2,
  DatabaseTableColumn_ColumnConstraint_NOT_NULL = 3,
  DatabaseTableColumn_ColumnConstraint_AUTO_INCREMENT = 4,
  DatabaseTableColumn_ColumnConstraint_DatabaseTableColumn_ColumnConstraint_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseTableColumn_ColumnConstraint_DatabaseTableColumn_ColumnConstraint_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseTableColumn_ColumnConstraint_IsValid(int value);
extern const uint32_t DatabaseTableColumn_ColumnConstraint_internal_data_[];
constexpr DatabaseTableColumn_ColumnConstraint DatabaseTableColumn_ColumnConstraint_ColumnConstraint_MIN = static_cast<DatabaseTableColumn_ColumnConstraint>(0);
constexpr DatabaseTableColumn_ColumnConstraint DatabaseTableColumn_ColumnConstraint_ColumnConstraint_MAX = static_cast<DatabaseTableColumn_ColumnConstraint>(4);
constexpr int DatabaseTableColumn_ColumnConstraint_ColumnConstraint_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseTableColumn_ColumnConstraint_descriptor();
template <typename T>
const std::string& DatabaseTableColumn_ColumnConstraint_Name(T value) {
  static_assert(std::is_same<T, DatabaseTableColumn_ColumnConstraint>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ColumnConstraint_Name().");
  return DatabaseTableColumn_ColumnConstraint_Name(static_cast<DatabaseTableColumn_ColumnConstraint>(value));
}
template <>
inline const std::string& DatabaseTableColumn_ColumnConstraint_Name(DatabaseTableColumn_ColumnConstraint value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseTableColumn_ColumnConstraint_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DatabaseTableColumn_ColumnConstraint_Parse(absl::string_view name, DatabaseTableColumn_ColumnConstraint* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseTableColumn_ColumnConstraint>(
      DatabaseTableColumn_ColumnConstraint_descriptor(), name, value);
}
enum DatabaseTableColumn_ColumnType : int {
  DatabaseTableColumn_ColumnType_DEFAULT_COLUMN_TYPE = 0,
  DatabaseTableColumn_ColumnType_USER = 1,
  DatabaseTableColumn_ColumnType_SYSTEM = 2,
  DatabaseTableColumn_ColumnType_DatabaseTableColumn_ColumnType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseTableColumn_ColumnType_DatabaseTableColumn_ColumnType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseTableColumn_ColumnType_IsValid(int value);
extern const uint32_t DatabaseTableColumn_ColumnType_internal_data_[];
constexpr DatabaseTableColumn_ColumnType DatabaseTableColumn_ColumnType_ColumnType_MIN = static_cast<DatabaseTableColumn_ColumnType>(0);
constexpr DatabaseTableColumn_ColumnType DatabaseTableColumn_ColumnType_ColumnType_MAX = static_cast<DatabaseTableColumn_ColumnType>(2);
constexpr int DatabaseTableColumn_ColumnType_ColumnType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseTableColumn_ColumnType_descriptor();
template <typename T>
const std::string& DatabaseTableColumn_ColumnType_Name(T value) {
  static_assert(std::is_same<T, DatabaseTableColumn_ColumnType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ColumnType_Name().");
  return DatabaseTableColumn_ColumnType_Name(static_cast<DatabaseTableColumn_ColumnType>(value));
}
template <>
inline const std::string& DatabaseTableColumn_ColumnType_Name(DatabaseTableColumn_ColumnType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseTableColumn_ColumnType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DatabaseTableColumn_ColumnType_Parse(absl::string_view name, DatabaseTableColumn_ColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseTableColumn_ColumnType>(
      DatabaseTableColumn_ColumnType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class DatabaseTableColumn_SystemManage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.database.DatabaseTableColumn.SystemManage) */ {
 public:
  inline DatabaseTableColumn_SystemManage() : DatabaseTableColumn_SystemManage(nullptr) {}
  ~DatabaseTableColumn_SystemManage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DatabaseTableColumn_SystemManage(::google::protobuf::internal::ConstantInitialized);

  inline DatabaseTableColumn_SystemManage(const DatabaseTableColumn_SystemManage& from)
      : DatabaseTableColumn_SystemManage(nullptr, from) {}
  DatabaseTableColumn_SystemManage(DatabaseTableColumn_SystemManage&& from) noexcept
    : DatabaseTableColumn_SystemManage() {
    *this = ::std::move(from);
  }

  inline DatabaseTableColumn_SystemManage& operator=(const DatabaseTableColumn_SystemManage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseTableColumn_SystemManage& operator=(DatabaseTableColumn_SystemManage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseTableColumn_SystemManage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseTableColumn_SystemManage* internal_default_instance() {
    return reinterpret_cast<const DatabaseTableColumn_SystemManage*>(
               &_DatabaseTableColumn_SystemManage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DatabaseTableColumn_SystemManage& a, DatabaseTableColumn_SystemManage& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseTableColumn_SystemManage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseTableColumn_SystemManage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseTableColumn_SystemManage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseTableColumn_SystemManage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatabaseTableColumn_SystemManage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DatabaseTableColumn_SystemManage& from) {
    DatabaseTableColumn_SystemManage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DatabaseTableColumn_SystemManage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.database.DatabaseTableColumn.SystemManage";
  }
  protected:
  explicit DatabaseTableColumn_SystemManage(::google::protobuf::Arena* arena);
  DatabaseTableColumn_SystemManage(::google::protobuf::Arena* arena, const DatabaseTableColumn_SystemManage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AuditType = DatabaseTableColumn_SystemManage_AuditType;
  static constexpr AuditType DEFAULT_AUDIT_TYPE = DatabaseTableColumn_SystemManage_AuditType_DEFAULT_AUDIT_TYPE;
  static constexpr AuditType CREATED_TIME = DatabaseTableColumn_SystemManage_AuditType_CREATED_TIME;
  static constexpr AuditType CREATED_BY = DatabaseTableColumn_SystemManage_AuditType_CREATED_BY;
  static constexpr AuditType LAST_MODIFIED_TIME = DatabaseTableColumn_SystemManage_AuditType_LAST_MODIFIED_TIME;
  static constexpr AuditType LAST_MODIFIED_BY = DatabaseTableColumn_SystemManage_AuditType_LAST_MODIFIED_BY;
  static inline bool AuditType_IsValid(int value) {
    return DatabaseTableColumn_SystemManage_AuditType_IsValid(value);
  }
  static constexpr AuditType AuditType_MIN = DatabaseTableColumn_SystemManage_AuditType_AuditType_MIN;
  static constexpr AuditType AuditType_MAX = DatabaseTableColumn_SystemManage_AuditType_AuditType_MAX;
  static constexpr int AuditType_ARRAYSIZE = DatabaseTableColumn_SystemManage_AuditType_AuditType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AuditType_descriptor() {
    return DatabaseTableColumn_SystemManage_AuditType_descriptor();
  }
  template <typename T>
  static inline const std::string& AuditType_Name(T value) {
    return DatabaseTableColumn_SystemManage_AuditType_Name(value);
  }
  static inline bool AuditType_Parse(absl::string_view name, AuditType* value) {
    return DatabaseTableColumn_SystemManage_AuditType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAuditTypeFieldNumber = 1,
  };
  // optional .com.zoho.database.DatabaseTableColumn.SystemManage.AuditType auditType = 1;
  bool has_audittype() const;
  void clear_audittype() ;
  ::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType audittype() const;
  void set_audittype(::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType value);

  private:
  ::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType _internal_audittype() const;
  void _internal_set_audittype(::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.database.DatabaseTableColumn.SystemManage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int audittype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_databasetablecolumn_2eproto;
};// -------------------------------------------------------------------

class DatabaseTableColumn_Lock final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.database.DatabaseTableColumn.Lock) */ {
 public:
  inline DatabaseTableColumn_Lock() : DatabaseTableColumn_Lock(nullptr) {}
  ~DatabaseTableColumn_Lock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DatabaseTableColumn_Lock(::google::protobuf::internal::ConstantInitialized);

  inline DatabaseTableColumn_Lock(const DatabaseTableColumn_Lock& from)
      : DatabaseTableColumn_Lock(nullptr, from) {}
  DatabaseTableColumn_Lock(DatabaseTableColumn_Lock&& from) noexcept
    : DatabaseTableColumn_Lock() {
    *this = ::std::move(from);
  }

  inline DatabaseTableColumn_Lock& operator=(const DatabaseTableColumn_Lock& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseTableColumn_Lock& operator=(DatabaseTableColumn_Lock&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseTableColumn_Lock& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseTableColumn_Lock* internal_default_instance() {
    return reinterpret_cast<const DatabaseTableColumn_Lock*>(
               &_DatabaseTableColumn_Lock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DatabaseTableColumn_Lock& a, DatabaseTableColumn_Lock& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseTableColumn_Lock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseTableColumn_Lock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseTableColumn_Lock* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseTableColumn_Lock>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatabaseTableColumn_Lock& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DatabaseTableColumn_Lock& from) {
    DatabaseTableColumn_Lock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DatabaseTableColumn_Lock* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.database.DatabaseTableColumn.Lock";
  }
  protected:
  explicit DatabaseTableColumn_Lock(::google::protobuf::Arena* arena);
  DatabaseTableColumn_Lock(::google::protobuf::Arena* arena, const DatabaseTableColumn_Lock& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LockType = DatabaseTableColumn_Lock_LockType;
  static constexpr LockType DEFAULT_LOCK = DatabaseTableColumn_Lock_LockType_DEFAULT_LOCK;
  static constexpr LockType NONE = DatabaseTableColumn_Lock_LockType_NONE;
  static constexpr LockType USER = DatabaseTableColumn_Lock_LockType_USER;
  static inline bool LockType_IsValid(int value) {
    return DatabaseTableColumn_Lock_LockType_IsValid(value);
  }
  static constexpr LockType LockType_MIN = DatabaseTableColumn_Lock_LockType_LockType_MIN;
  static constexpr LockType LockType_MAX = DatabaseTableColumn_Lock_LockType_LockType_MAX;
  static constexpr int LockType_ARRAYSIZE = DatabaseTableColumn_Lock_LockType_LockType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LockType_descriptor() {
    return DatabaseTableColumn_Lock_LockType_descriptor();
  }
  template <typename T>
  static inline const std::string& LockType_Name(T value) {
    return DatabaseTableColumn_Lock_LockType_Name(value);
  }
  static inline bool LockType_Parse(absl::string_view name, LockType* value) {
    return DatabaseTableColumn_Lock_LockType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kZuidFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string zuid = 2;
  bool has_zuid() const;
  void clear_zuid() ;
  const std::string& zuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zuid(Arg_&& arg, Args_... args);
  std::string* mutable_zuid();
  PROTOBUF_NODISCARD std::string* release_zuid();
  void set_allocated_zuid(std::string* value);

  private:
  const std::string& _internal_zuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zuid(
      const std::string& value);
  std::string* _internal_mutable_zuid();

  public:
  // optional .com.zoho.database.DatabaseTableColumn.Lock.LockType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::database::DatabaseTableColumn_Lock_LockType type() const;
  void set_type(::com::zoho::database::DatabaseTableColumn_Lock_LockType value);

  private:
  ::com::zoho::database::DatabaseTableColumn_Lock_LockType _internal_type() const;
  void _internal_set_type(::com::zoho::database::DatabaseTableColumn_Lock_LockType value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.database.DatabaseTableColumn.Lock)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr zuid_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_databasetablecolumn_2eproto;
};// -------------------------------------------------------------------

class DatabaseTableColumn_ChildColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.database.DatabaseTableColumn.ChildColumn) */ {
 public:
  inline DatabaseTableColumn_ChildColumn() : DatabaseTableColumn_ChildColumn(nullptr) {}
  ~DatabaseTableColumn_ChildColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DatabaseTableColumn_ChildColumn(::google::protobuf::internal::ConstantInitialized);

  inline DatabaseTableColumn_ChildColumn(const DatabaseTableColumn_ChildColumn& from)
      : DatabaseTableColumn_ChildColumn(nullptr, from) {}
  DatabaseTableColumn_ChildColumn(DatabaseTableColumn_ChildColumn&& from) noexcept
    : DatabaseTableColumn_ChildColumn() {
    *this = ::std::move(from);
  }

  inline DatabaseTableColumn_ChildColumn& operator=(const DatabaseTableColumn_ChildColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseTableColumn_ChildColumn& operator=(DatabaseTableColumn_ChildColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseTableColumn_ChildColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseTableColumn_ChildColumn* internal_default_instance() {
    return reinterpret_cast<const DatabaseTableColumn_ChildColumn*>(
               &_DatabaseTableColumn_ChildColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatabaseTableColumn_ChildColumn& a, DatabaseTableColumn_ChildColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseTableColumn_ChildColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseTableColumn_ChildColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseTableColumn_ChildColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseTableColumn_ChildColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatabaseTableColumn_ChildColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DatabaseTableColumn_ChildColumn& from) {
    DatabaseTableColumn_ChildColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DatabaseTableColumn_ChildColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.database.DatabaseTableColumn.ChildColumn";
  }
  protected:
  explicit DatabaseTableColumn_ChildColumn(::google::protobuf::Arena* arena);
  DatabaseTableColumn_ChildColumn(::google::protobuf::Arena* arena, const DatabaseTableColumn_ChildColumn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kColumnIdFieldNumber = 2,
  };
  // optional string tableId = 1;
  bool has_tableid() const;
  void clear_tableid() ;
  const std::string& tableid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tableid(Arg_&& arg, Args_... args);
  std::string* mutable_tableid();
  PROTOBUF_NODISCARD std::string* release_tableid();
  void set_allocated_tableid(std::string* value);

  private:
  const std::string& _internal_tableid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tableid(
      const std::string& value);
  std::string* _internal_mutable_tableid();

  public:
  // optional string columnId = 2;
  bool has_columnid() const;
  void clear_columnid() ;
  const std::string& columnid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_columnid(Arg_&& arg, Args_... args);
  std::string* mutable_columnid();
  PROTOBUF_NODISCARD std::string* release_columnid();
  void set_allocated_columnid(std::string* value);

  private:
  const std::string& _internal_columnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_columnid(
      const std::string& value);
  std::string* _internal_mutable_columnid();

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.database.DatabaseTableColumn.ChildColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr tableid_;
    ::google::protobuf::internal::ArenaStringPtr columnid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_databasetablecolumn_2eproto;
};// -------------------------------------------------------------------

class DatabaseTableColumn_ParentColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.database.DatabaseTableColumn.ParentColumn) */ {
 public:
  inline DatabaseTableColumn_ParentColumn() : DatabaseTableColumn_ParentColumn(nullptr) {}
  ~DatabaseTableColumn_ParentColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DatabaseTableColumn_ParentColumn(::google::protobuf::internal::ConstantInitialized);

  inline DatabaseTableColumn_ParentColumn(const DatabaseTableColumn_ParentColumn& from)
      : DatabaseTableColumn_ParentColumn(nullptr, from) {}
  DatabaseTableColumn_ParentColumn(DatabaseTableColumn_ParentColumn&& from) noexcept
    : DatabaseTableColumn_ParentColumn() {
    *this = ::std::move(from);
  }

  inline DatabaseTableColumn_ParentColumn& operator=(const DatabaseTableColumn_ParentColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseTableColumn_ParentColumn& operator=(DatabaseTableColumn_ParentColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseTableColumn_ParentColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseTableColumn_ParentColumn* internal_default_instance() {
    return reinterpret_cast<const DatabaseTableColumn_ParentColumn*>(
               &_DatabaseTableColumn_ParentColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DatabaseTableColumn_ParentColumn& a, DatabaseTableColumn_ParentColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseTableColumn_ParentColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseTableColumn_ParentColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseTableColumn_ParentColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseTableColumn_ParentColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatabaseTableColumn_ParentColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DatabaseTableColumn_ParentColumn& from) {
    DatabaseTableColumn_ParentColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DatabaseTableColumn_ParentColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.database.DatabaseTableColumn.ParentColumn";
  }
  protected:
  explicit DatabaseTableColumn_ParentColumn(::google::protobuf::Arena* arena);
  DatabaseTableColumn_ParentColumn(::google::protobuf::Arena* arena, const DatabaseTableColumn_ParentColumn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomRendererIdFieldNumber = 2,
    kColumnValueFieldNumber = 1,
  };
  // optional string customRendererId = 2;
  bool has_customrendererid() const;
  void clear_customrendererid() ;
  const std::string& customrendererid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_customrendererid(Arg_&& arg, Args_... args);
  std::string* mutable_customrendererid();
  PROTOBUF_NODISCARD std::string* release_customrendererid();
  void set_allocated_customrendererid(std::string* value);

  private:
  const std::string& _internal_customrendererid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customrendererid(
      const std::string& value);
  std::string* _internal_mutable_customrendererid();

  public:
  // optional .com.zoho.common.CompositeValue columnValue = 1;
  bool has_columnvalue() const;
  void clear_columnvalue() ;
  const ::com::zoho::common::CompositeValue& columnvalue() const;
  PROTOBUF_NODISCARD ::com::zoho::common::CompositeValue* release_columnvalue();
  ::com::zoho::common::CompositeValue* mutable_columnvalue();
  void set_allocated_columnvalue(::com::zoho::common::CompositeValue* value);
  void unsafe_arena_set_allocated_columnvalue(::com::zoho::common::CompositeValue* value);
  ::com::zoho::common::CompositeValue* unsafe_arena_release_columnvalue();

  private:
  const ::com::zoho::common::CompositeValue& _internal_columnvalue() const;
  ::com::zoho::common::CompositeValue* _internal_mutable_columnvalue();

  public:
  void temp_setcolumnValue(com::zoho::common::CompositeValue* columnValue) {
    if(&this->columnvalue() != columnValue) {
      set_allocated_columnvalue(columnValue);
    }
  }
  
  com::zoho::common::CompositeValue* temp_getcolumnValue() const {
    if (has_columnvalue()) 
      return (const_cast<com::zoho::database::DatabaseTableColumn_ParentColumn*>(this))->mutable_columnvalue();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.database.DatabaseTableColumn.ParentColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr customrendererid_;
    ::com::zoho::common::CompositeValue* columnvalue_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_databasetablecolumn_2eproto;
};// -------------------------------------------------------------------

class DatabaseTableColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.database.DatabaseTableColumn) */ {
 public:
  inline DatabaseTableColumn() : DatabaseTableColumn(nullptr) {}
  ~DatabaseTableColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DatabaseTableColumn(::google::protobuf::internal::ConstantInitialized);

  inline DatabaseTableColumn(const DatabaseTableColumn& from)
      : DatabaseTableColumn(nullptr, from) {}
  DatabaseTableColumn(DatabaseTableColumn&& from) noexcept
    : DatabaseTableColumn() {
    *this = ::std::move(from);
  }

  inline DatabaseTableColumn& operator=(const DatabaseTableColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseTableColumn& operator=(DatabaseTableColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseTableColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseTableColumn* internal_default_instance() {
    return reinterpret_cast<const DatabaseTableColumn*>(
               &_DatabaseTableColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DatabaseTableColumn& a, DatabaseTableColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseTableColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseTableColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseTableColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseTableColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DatabaseTableColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DatabaseTableColumn& from) {
    DatabaseTableColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DatabaseTableColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.database.DatabaseTableColumn";
  }
  protected:
  explicit DatabaseTableColumn(::google::protobuf::Arena* arena);
  DatabaseTableColumn(::google::protobuf::Arena* arena, const DatabaseTableColumn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ParentColumn = DatabaseTableColumn_ParentColumn;
  using ChildColumn = DatabaseTableColumn_ChildColumn;
  using Lock = DatabaseTableColumn_Lock;
  using SystemManage = DatabaseTableColumn_SystemManage;

  using ColumnConstraint = DatabaseTableColumn_ColumnConstraint;
  static constexpr ColumnConstraint DEFAULT_CONSTRAINT = DatabaseTableColumn_ColumnConstraint_DEFAULT_CONSTRAINT;
  static constexpr ColumnConstraint PRIMARY_KEY = DatabaseTableColumn_ColumnConstraint_PRIMARY_KEY;
  static constexpr ColumnConstraint UNIQUE = DatabaseTableColumn_ColumnConstraint_UNIQUE;
  static constexpr ColumnConstraint NOT_NULL = DatabaseTableColumn_ColumnConstraint_NOT_NULL;
  static constexpr ColumnConstraint AUTO_INCREMENT = DatabaseTableColumn_ColumnConstraint_AUTO_INCREMENT;
  static inline bool ColumnConstraint_IsValid(int value) {
    return DatabaseTableColumn_ColumnConstraint_IsValid(value);
  }
  static constexpr ColumnConstraint ColumnConstraint_MIN = DatabaseTableColumn_ColumnConstraint_ColumnConstraint_MIN;
  static constexpr ColumnConstraint ColumnConstraint_MAX = DatabaseTableColumn_ColumnConstraint_ColumnConstraint_MAX;
  static constexpr int ColumnConstraint_ARRAYSIZE = DatabaseTableColumn_ColumnConstraint_ColumnConstraint_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ColumnConstraint_descriptor() {
    return DatabaseTableColumn_ColumnConstraint_descriptor();
  }
  template <typename T>
  static inline const std::string& ColumnConstraint_Name(T value) {
    return DatabaseTableColumn_ColumnConstraint_Name(value);
  }
  static inline bool ColumnConstraint_Parse(absl::string_view name, ColumnConstraint* value) {
    return DatabaseTableColumn_ColumnConstraint_Parse(name, value);
  }

  using ColumnType = DatabaseTableColumn_ColumnType;
  static constexpr ColumnType DEFAULT_COLUMN_TYPE = DatabaseTableColumn_ColumnType_DEFAULT_COLUMN_TYPE;
  static constexpr ColumnType USER = DatabaseTableColumn_ColumnType_USER;
  static constexpr ColumnType SYSTEM = DatabaseTableColumn_ColumnType_SYSTEM;
  static inline bool ColumnType_IsValid(int value) {
    return DatabaseTableColumn_ColumnType_IsValid(value);
  }
  static constexpr ColumnType ColumnType_MIN = DatabaseTableColumn_ColumnType_ColumnType_MIN;
  static constexpr ColumnType ColumnType_MAX = DatabaseTableColumn_ColumnType_ColumnType_MAX;
  static constexpr int ColumnType_ARRAYSIZE = DatabaseTableColumn_ColumnType_ColumnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ColumnType_descriptor() {
    return DatabaseTableColumn_ColumnType_descriptor();
  }
  template <typename T>
  static inline const std::string& ColumnType_Name(T value) {
    return DatabaseTableColumn_ColumnType_Name(value);
  }
  static inline bool ColumnType_Parse(absl::string_view name, ColumnType* value) {
    return DatabaseTableColumn_ColumnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDbColumnIdFieldNumber = 7,
    kColumnFieldNumber = 1,
    kParentFieldNumber = 4,
    kChildFieldNumber = 5,
    kLockFieldNumber = 9,
    kSystemFieldNumber = 11,
    kCategoryFieldNumber = 3,
    kHideFieldNumber = 6,
    kConstraintFieldNumber = 8,
    kTypeFieldNumber = 10,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string dbColumnId = 7;
  bool has_dbcolumnid() const;
  void clear_dbcolumnid() ;
  const std::string& dbcolumnid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dbcolumnid(Arg_&& arg, Args_... args);
  std::string* mutable_dbcolumnid();
  PROTOBUF_NODISCARD std::string* release_dbcolumnid();
  void set_allocated_dbcolumnid(std::string* value);

  private:
  const std::string& _internal_dbcolumnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbcolumnid(
      const std::string& value);
  std::string* _internal_mutable_dbcolumnid();

  public:
  // optional .com.zoho.database.ColumnIdentifier column = 1;
  bool has_column() const;
  void clear_column() ;
  const ::com::zoho::database::ColumnIdentifier& column() const;
  PROTOBUF_NODISCARD ::com::zoho::database::ColumnIdentifier* release_column();
  ::com::zoho::database::ColumnIdentifier* mutable_column();
  void set_allocated_column(::com::zoho::database::ColumnIdentifier* value);
  void unsafe_arena_set_allocated_column(::com::zoho::database::ColumnIdentifier* value);
  ::com::zoho::database::ColumnIdentifier* unsafe_arena_release_column();

  private:
  const ::com::zoho::database::ColumnIdentifier& _internal_column() const;
  ::com::zoho::database::ColumnIdentifier* _internal_mutable_column();

  public:
  // optional .com.zoho.database.DatabaseTableColumn.ParentColumn parent = 4;
  bool has_parent() const;
  void clear_parent() ;
  const ::com::zoho::database::DatabaseTableColumn_ParentColumn& parent() const;
  PROTOBUF_NODISCARD ::com::zoho::database::DatabaseTableColumn_ParentColumn* release_parent();
  ::com::zoho::database::DatabaseTableColumn_ParentColumn* mutable_parent();
  void set_allocated_parent(::com::zoho::database::DatabaseTableColumn_ParentColumn* value);
  void unsafe_arena_set_allocated_parent(::com::zoho::database::DatabaseTableColumn_ParentColumn* value);
  ::com::zoho::database::DatabaseTableColumn_ParentColumn* unsafe_arena_release_parent();

  private:
  const ::com::zoho::database::DatabaseTableColumn_ParentColumn& _internal_parent() const;
  ::com::zoho::database::DatabaseTableColumn_ParentColumn* _internal_mutable_parent();

  public:
  // optional .com.zoho.database.DatabaseTableColumn.ChildColumn child = 5;
  bool has_child() const;
  void clear_child() ;
  const ::com::zoho::database::DatabaseTableColumn_ChildColumn& child() const;
  PROTOBUF_NODISCARD ::com::zoho::database::DatabaseTableColumn_ChildColumn* release_child();
  ::com::zoho::database::DatabaseTableColumn_ChildColumn* mutable_child();
  void set_allocated_child(::com::zoho::database::DatabaseTableColumn_ChildColumn* value);
  void unsafe_arena_set_allocated_child(::com::zoho::database::DatabaseTableColumn_ChildColumn* value);
  ::com::zoho::database::DatabaseTableColumn_ChildColumn* unsafe_arena_release_child();

  private:
  const ::com::zoho::database::DatabaseTableColumn_ChildColumn& _internal_child() const;
  ::com::zoho::database::DatabaseTableColumn_ChildColumn* _internal_mutable_child();

  public:
  // optional .com.zoho.database.DatabaseTableColumn.Lock lock = 9;
  bool has_lock() const;
  void clear_lock() ;
  const ::com::zoho::database::DatabaseTableColumn_Lock& lock() const;
  PROTOBUF_NODISCARD ::com::zoho::database::DatabaseTableColumn_Lock* release_lock();
  ::com::zoho::database::DatabaseTableColumn_Lock* mutable_lock();
  void set_allocated_lock(::com::zoho::database::DatabaseTableColumn_Lock* value);
  void unsafe_arena_set_allocated_lock(::com::zoho::database::DatabaseTableColumn_Lock* value);
  ::com::zoho::database::DatabaseTableColumn_Lock* unsafe_arena_release_lock();

  private:
  const ::com::zoho::database::DatabaseTableColumn_Lock& _internal_lock() const;
  ::com::zoho::database::DatabaseTableColumn_Lock* _internal_mutable_lock();

  public:
  // optional .com.zoho.database.DatabaseTableColumn.SystemManage system = 11;
  bool has_system() const;
  void clear_system() ;
  const ::com::zoho::database::DatabaseTableColumn_SystemManage& system() const;
  PROTOBUF_NODISCARD ::com::zoho::database::DatabaseTableColumn_SystemManage* release_system();
  ::com::zoho::database::DatabaseTableColumn_SystemManage* mutable_system();
  void set_allocated_system(::com::zoho::database::DatabaseTableColumn_SystemManage* value);
  void unsafe_arena_set_allocated_system(::com::zoho::database::DatabaseTableColumn_SystemManage* value);
  ::com::zoho::database::DatabaseTableColumn_SystemManage* unsafe_arena_release_system();

  private:
  const ::com::zoho::database::DatabaseTableColumn_SystemManage& _internal_system() const;
  ::com::zoho::database::DatabaseTableColumn_SystemManage* _internal_mutable_system();

  public:
  // optional .Show.DatabaseField.TableOrColumnCategory category = 3;
  bool has_category() const;
  void clear_category() ;
  ::Show::DatabaseField_TableOrColumnCategory category() const;
  void set_category(::Show::DatabaseField_TableOrColumnCategory value);

  private:
  ::Show::DatabaseField_TableOrColumnCategory _internal_category() const;
  void _internal_set_category(::Show::DatabaseField_TableOrColumnCategory value);

  public:
  // optional bool hide = 6;
  bool has_hide() const;
  void clear_hide() ;
  bool hide() const;
  void set_hide(bool value);

  private:
  bool _internal_hide() const;
  void _internal_set_hide(bool value);

  public:
  // optional .com.zoho.database.DatabaseTableColumn.ColumnConstraint constraint = 8;
  bool has_constraint() const;
  void clear_constraint() ;
  ::com::zoho::database::DatabaseTableColumn_ColumnConstraint constraint() const;
  void set_constraint(::com::zoho::database::DatabaseTableColumn_ColumnConstraint value);

  private:
  ::com::zoho::database::DatabaseTableColumn_ColumnConstraint _internal_constraint() const;
  void _internal_set_constraint(::com::zoho::database::DatabaseTableColumn_ColumnConstraint value);

  public:
  // optional .com.zoho.database.DatabaseTableColumn.ColumnType type = 10;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::database::DatabaseTableColumn_ColumnType type() const;
  void set_type(::com::zoho::database::DatabaseTableColumn_ColumnType value);

  private:
  ::com::zoho::database::DatabaseTableColumn_ColumnType _internal_type() const;
  void _internal_set_type(::com::zoho::database::DatabaseTableColumn_ColumnType value);

  public:
  void temp_setcolumn(com::zoho::database::ColumnIdentifier* column) {
    if(&this->column() != column) {
      set_allocated_column(column);
    }
  }
  
  com::zoho::database::ColumnIdentifier* temp_getcolumn() const {
    if (has_column()) 
      return (const_cast<com::zoho::database::DatabaseTableColumn*>(this))->mutable_column();
    return nullptr;
  }
  
  void temp_setparent(com::zoho::database::DatabaseTableColumn_ParentColumn* parent) {
    if(&this->parent() != parent) {
      set_allocated_parent(parent);
    }
  }
  
  com::zoho::database::DatabaseTableColumn_ParentColumn* temp_getparent() const {
    if (has_parent()) 
      return (const_cast<com::zoho::database::DatabaseTableColumn*>(this))->mutable_parent();
    return nullptr;
  }
  
  void temp_setchild(com::zoho::database::DatabaseTableColumn_ChildColumn* child) {
    if(&this->child() != child) {
      set_allocated_child(child);
    }
  }
  
  com::zoho::database::DatabaseTableColumn_ChildColumn* temp_getchild() const {
    if (has_child()) 
      return (const_cast<com::zoho::database::DatabaseTableColumn*>(this))->mutable_child();
    return nullptr;
  }
  
  void temp_setlock(com::zoho::database::DatabaseTableColumn_Lock* lock) {
    if(&this->lock() != lock) {
      set_allocated_lock(lock);
    }
  }
  
  com::zoho::database::DatabaseTableColumn_Lock* temp_getlock() const {
    if (has_lock()) 
      return (const_cast<com::zoho::database::DatabaseTableColumn*>(this))->mutable_lock();
    return nullptr;
  }
  
  void temp_setsystem(com::zoho::database::DatabaseTableColumn_SystemManage* system) {
    if(&this->system() != system) {
      set_allocated_system(system);
    }
  }
  
  com::zoho::database::DatabaseTableColumn_SystemManage* temp_getsystem() const {
    if (has_system()) 
      return (const_cast<com::zoho::database::DatabaseTableColumn*>(this))->mutable_system();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.database.DatabaseTableColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 5,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr dbcolumnid_;
    ::com::zoho::database::ColumnIdentifier* column_;
    ::com::zoho::database::DatabaseTableColumn_ParentColumn* parent_;
    ::com::zoho::database::DatabaseTableColumn_ChildColumn* child_;
    ::com::zoho::database::DatabaseTableColumn_Lock* lock_;
    ::com::zoho::database::DatabaseTableColumn_SystemManage* system_;
    int category_;
    bool hide_;
    int constraint_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_databasetablecolumn_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DatabaseTableColumn_ParentColumn

// optional .com.zoho.common.CompositeValue columnValue = 1;
inline bool DatabaseTableColumn_ParentColumn::has_columnvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.columnvalue_ != nullptr);
  return value;
}
inline const ::com::zoho::common::CompositeValue& DatabaseTableColumn_ParentColumn::_internal_columnvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::CompositeValue* p = _impl_.columnvalue_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::CompositeValue&>(::com::zoho::common::_CompositeValue_default_instance_);
}
inline const ::com::zoho::common::CompositeValue& DatabaseTableColumn_ParentColumn::columnvalue() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.ParentColumn.columnValue)
  return _internal_columnvalue();
}
inline void DatabaseTableColumn_ParentColumn::unsafe_arena_set_allocated_columnvalue(::com::zoho::common::CompositeValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.columnvalue_);
  }
  _impl_.columnvalue_ = reinterpret_cast<::com::zoho::common::CompositeValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.database.DatabaseTableColumn.ParentColumn.columnValue)
}
inline ::com::zoho::common::CompositeValue* DatabaseTableColumn_ParentColumn::release_columnvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::CompositeValue* released = _impl_.columnvalue_;
  _impl_.columnvalue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::CompositeValue* DatabaseTableColumn_ParentColumn::unsafe_arena_release_columnvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.ParentColumn.columnValue)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::CompositeValue* temp = _impl_.columnvalue_;
  _impl_.columnvalue_ = nullptr;
  return temp;
}
inline ::com::zoho::common::CompositeValue* DatabaseTableColumn_ParentColumn::_internal_mutable_columnvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.columnvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::CompositeValue>(GetArena());
    _impl_.columnvalue_ = reinterpret_cast<::com::zoho::common::CompositeValue*>(p);
  }
  return _impl_.columnvalue_;
}
inline ::com::zoho::common::CompositeValue* DatabaseTableColumn_ParentColumn::mutable_columnvalue() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::CompositeValue* _msg = _internal_mutable_columnvalue();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.ParentColumn.columnValue)
  return _msg;
}
inline void DatabaseTableColumn_ParentColumn::set_allocated_columnvalue(::com::zoho::common::CompositeValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.columnvalue_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.columnvalue_ = reinterpret_cast<::com::zoho::common::CompositeValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.ParentColumn.columnValue)
}

// optional string customRendererId = 2;
inline bool DatabaseTableColumn_ParentColumn::has_customrendererid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DatabaseTableColumn_ParentColumn::clear_customrendererid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.customrendererid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DatabaseTableColumn_ParentColumn::customrendererid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.ParentColumn.customRendererId)
  return _internal_customrendererid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DatabaseTableColumn_ParentColumn::set_customrendererid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.customrendererid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.ParentColumn.customRendererId)
}
inline std::string* DatabaseTableColumn_ParentColumn::mutable_customrendererid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_customrendererid();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.ParentColumn.customRendererId)
  return _s;
}
inline const std::string& DatabaseTableColumn_ParentColumn::_internal_customrendererid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.customrendererid_.Get();
}
inline void DatabaseTableColumn_ParentColumn::_internal_set_customrendererid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.customrendererid_.Set(value, GetArena());
}
inline std::string* DatabaseTableColumn_ParentColumn::_internal_mutable_customrendererid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.customrendererid_.Mutable( GetArena());
}
inline std::string* DatabaseTableColumn_ParentColumn::release_customrendererid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.ParentColumn.customRendererId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.customrendererid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.customrendererid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DatabaseTableColumn_ParentColumn::set_allocated_customrendererid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.customrendererid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.customrendererid_.IsDefault()) {
          _impl_.customrendererid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.ParentColumn.customRendererId)
}

// -------------------------------------------------------------------

// DatabaseTableColumn_ChildColumn

// optional string tableId = 1;
inline bool DatabaseTableColumn_ChildColumn::has_tableid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DatabaseTableColumn_ChildColumn::clear_tableid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tableid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DatabaseTableColumn_ChildColumn::tableid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.ChildColumn.tableId)
  return _internal_tableid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DatabaseTableColumn_ChildColumn::set_tableid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tableid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.ChildColumn.tableId)
}
inline std::string* DatabaseTableColumn_ChildColumn::mutable_tableid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tableid();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.ChildColumn.tableId)
  return _s;
}
inline const std::string& DatabaseTableColumn_ChildColumn::_internal_tableid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tableid_.Get();
}
inline void DatabaseTableColumn_ChildColumn::_internal_set_tableid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tableid_.Set(value, GetArena());
}
inline std::string* DatabaseTableColumn_ChildColumn::_internal_mutable_tableid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tableid_.Mutable( GetArena());
}
inline std::string* DatabaseTableColumn_ChildColumn::release_tableid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.ChildColumn.tableId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.tableid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tableid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DatabaseTableColumn_ChildColumn::set_allocated_tableid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tableid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tableid_.IsDefault()) {
          _impl_.tableid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.ChildColumn.tableId)
}

// optional string columnId = 2;
inline bool DatabaseTableColumn_ChildColumn::has_columnid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DatabaseTableColumn_ChildColumn::clear_columnid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columnid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DatabaseTableColumn_ChildColumn::columnid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.ChildColumn.columnId)
  return _internal_columnid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DatabaseTableColumn_ChildColumn::set_columnid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.columnid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.ChildColumn.columnId)
}
inline std::string* DatabaseTableColumn_ChildColumn::mutable_columnid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_columnid();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.ChildColumn.columnId)
  return _s;
}
inline const std::string& DatabaseTableColumn_ChildColumn::_internal_columnid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columnid_.Get();
}
inline void DatabaseTableColumn_ChildColumn::_internal_set_columnid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.columnid_.Set(value, GetArena());
}
inline std::string* DatabaseTableColumn_ChildColumn::_internal_mutable_columnid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.columnid_.Mutable( GetArena());
}
inline std::string* DatabaseTableColumn_ChildColumn::release_columnid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.ChildColumn.columnId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.columnid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.columnid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DatabaseTableColumn_ChildColumn::set_allocated_columnid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.columnid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.columnid_.IsDefault()) {
          _impl_.columnid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.ChildColumn.columnId)
}

// -------------------------------------------------------------------

// DatabaseTableColumn_Lock

// optional .com.zoho.database.DatabaseTableColumn.Lock.LockType type = 1;
inline bool DatabaseTableColumn_Lock::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DatabaseTableColumn_Lock::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::database::DatabaseTableColumn_Lock_LockType DatabaseTableColumn_Lock::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.Lock.type)
  return _internal_type();
}
inline void DatabaseTableColumn_Lock::set_type(::com::zoho::database::DatabaseTableColumn_Lock_LockType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.Lock.type)
}
inline ::com::zoho::database::DatabaseTableColumn_Lock_LockType DatabaseTableColumn_Lock::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::database::DatabaseTableColumn_Lock_LockType>(_impl_.type_);
}
inline void DatabaseTableColumn_Lock::_internal_set_type(::com::zoho::database::DatabaseTableColumn_Lock_LockType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string zuid = 2;
inline bool DatabaseTableColumn_Lock::has_zuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DatabaseTableColumn_Lock::clear_zuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DatabaseTableColumn_Lock::zuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.Lock.zuid)
  return _internal_zuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DatabaseTableColumn_Lock::set_zuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.zuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.Lock.zuid)
}
inline std::string* DatabaseTableColumn_Lock::mutable_zuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_zuid();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.Lock.zuid)
  return _s;
}
inline const std::string& DatabaseTableColumn_Lock::_internal_zuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zuid_.Get();
}
inline void DatabaseTableColumn_Lock::_internal_set_zuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.zuid_.Set(value, GetArena());
}
inline std::string* DatabaseTableColumn_Lock::_internal_mutable_zuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.zuid_.Mutable( GetArena());
}
inline std::string* DatabaseTableColumn_Lock::release_zuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.Lock.zuid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.zuid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.zuid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DatabaseTableColumn_Lock::set_allocated_zuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.zuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.zuid_.IsDefault()) {
          _impl_.zuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.Lock.zuid)
}

// -------------------------------------------------------------------

// DatabaseTableColumn_SystemManage

// optional .com.zoho.database.DatabaseTableColumn.SystemManage.AuditType auditType = 1;
inline bool DatabaseTableColumn_SystemManage::has_audittype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DatabaseTableColumn_SystemManage::clear_audittype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audittype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType DatabaseTableColumn_SystemManage::audittype() const {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.SystemManage.auditType)
  return _internal_audittype();
}
inline void DatabaseTableColumn_SystemManage::set_audittype(::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType value) {
  _internal_set_audittype(value);
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.SystemManage.auditType)
}
inline ::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType DatabaseTableColumn_SystemManage::_internal_audittype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType>(_impl_.audittype_);
}
inline void DatabaseTableColumn_SystemManage::_internal_set_audittype(::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.audittype_ = value;
}

// -------------------------------------------------------------------

// DatabaseTableColumn

// optional .com.zoho.database.ColumnIdentifier column = 1;
inline bool DatabaseTableColumn::has_column() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_ != nullptr);
  return value;
}
inline const ::com::zoho::database::ColumnIdentifier& DatabaseTableColumn::_internal_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::database::ColumnIdentifier* p = _impl_.column_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::database::ColumnIdentifier&>(::com::zoho::database::_ColumnIdentifier_default_instance_);
}
inline const ::com::zoho::database::ColumnIdentifier& DatabaseTableColumn::column() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.column)
  return _internal_column();
}
inline void DatabaseTableColumn::unsafe_arena_set_allocated_column(::com::zoho::database::ColumnIdentifier* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_);
  }
  _impl_.column_ = reinterpret_cast<::com::zoho::database::ColumnIdentifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.database.DatabaseTableColumn.column)
}
inline ::com::zoho::database::ColumnIdentifier* DatabaseTableColumn::release_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::database::ColumnIdentifier* released = _impl_.column_;
  _impl_.column_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::database::ColumnIdentifier* DatabaseTableColumn::unsafe_arena_release_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.column)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::database::ColumnIdentifier* temp = _impl_.column_;
  _impl_.column_ = nullptr;
  return temp;
}
inline ::com::zoho::database::ColumnIdentifier* DatabaseTableColumn::_internal_mutable_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.column_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::database::ColumnIdentifier>(GetArena());
    _impl_.column_ = reinterpret_cast<::com::zoho::database::ColumnIdentifier*>(p);
  }
  return _impl_.column_;
}
inline ::com::zoho::database::ColumnIdentifier* DatabaseTableColumn::mutable_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::database::ColumnIdentifier* _msg = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.column)
  return _msg;
}
inline void DatabaseTableColumn::set_allocated_column(::com::zoho::database::ColumnIdentifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.column_ = reinterpret_cast<::com::zoho::database::ColumnIdentifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.column)
}

// optional string name = 2;
inline bool DatabaseTableColumn::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DatabaseTableColumn::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DatabaseTableColumn::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DatabaseTableColumn::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.name)
}
inline std::string* DatabaseTableColumn::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.name)
  return _s;
}
inline const std::string& DatabaseTableColumn::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DatabaseTableColumn::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DatabaseTableColumn::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DatabaseTableColumn::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DatabaseTableColumn::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.name)
}

// optional .Show.DatabaseField.TableOrColumnCategory category = 3;
inline bool DatabaseTableColumn::has_category() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void DatabaseTableColumn::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.category_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::Show::DatabaseField_TableOrColumnCategory DatabaseTableColumn::category() const {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.category)
  return _internal_category();
}
inline void DatabaseTableColumn::set_category(::Show::DatabaseField_TableOrColumnCategory value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.category)
}
inline ::Show::DatabaseField_TableOrColumnCategory DatabaseTableColumn::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::DatabaseField_TableOrColumnCategory>(_impl_.category_);
}
inline void DatabaseTableColumn::_internal_set_category(::Show::DatabaseField_TableOrColumnCategory value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.category_ = value;
}

// optional .com.zoho.database.DatabaseTableColumn.ParentColumn parent = 4;
inline bool DatabaseTableColumn::has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline void DatabaseTableColumn::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::com::zoho::database::DatabaseTableColumn_ParentColumn& DatabaseTableColumn::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::database::DatabaseTableColumn_ParentColumn* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::database::DatabaseTableColumn_ParentColumn&>(::com::zoho::database::_DatabaseTableColumn_ParentColumn_default_instance_);
}
inline const ::com::zoho::database::DatabaseTableColumn_ParentColumn& DatabaseTableColumn::parent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.parent)
  return _internal_parent();
}
inline void DatabaseTableColumn::unsafe_arena_set_allocated_parent(::com::zoho::database::DatabaseTableColumn_ParentColumn* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ParentColumn*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.database.DatabaseTableColumn.parent)
}
inline ::com::zoho::database::DatabaseTableColumn_ParentColumn* DatabaseTableColumn::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::database::DatabaseTableColumn_ParentColumn* released = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::database::DatabaseTableColumn_ParentColumn* DatabaseTableColumn::unsafe_arena_release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.parent)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::database::DatabaseTableColumn_ParentColumn* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::com::zoho::database::DatabaseTableColumn_ParentColumn* DatabaseTableColumn::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::database::DatabaseTableColumn_ParentColumn>(GetArena());
    _impl_.parent_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ParentColumn*>(p);
  }
  return _impl_.parent_;
}
inline ::com::zoho::database::DatabaseTableColumn_ParentColumn* DatabaseTableColumn::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::database::DatabaseTableColumn_ParentColumn* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.parent)
  return _msg;
}
inline void DatabaseTableColumn::set_allocated_parent(::com::zoho::database::DatabaseTableColumn_ParentColumn* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ParentColumn*>(_impl_.parent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ParentColumn*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.parent_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ParentColumn*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.parent)
}

// optional .com.zoho.database.DatabaseTableColumn.ChildColumn child = 5;
inline bool DatabaseTableColumn::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void DatabaseTableColumn::clear_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::com::zoho::database::DatabaseTableColumn_ChildColumn& DatabaseTableColumn::_internal_child() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::database::DatabaseTableColumn_ChildColumn* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::database::DatabaseTableColumn_ChildColumn&>(::com::zoho::database::_DatabaseTableColumn_ChildColumn_default_instance_);
}
inline const ::com::zoho::database::DatabaseTableColumn_ChildColumn& DatabaseTableColumn::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.child)
  return _internal_child();
}
inline void DatabaseTableColumn::unsafe_arena_set_allocated_child(::com::zoho::database::DatabaseTableColumn_ChildColumn* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ChildColumn*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.database.DatabaseTableColumn.child)
}
inline ::com::zoho::database::DatabaseTableColumn_ChildColumn* DatabaseTableColumn::release_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::database::DatabaseTableColumn_ChildColumn* released = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::database::DatabaseTableColumn_ChildColumn* DatabaseTableColumn::unsafe_arena_release_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.child)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::database::DatabaseTableColumn_ChildColumn* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::com::zoho::database::DatabaseTableColumn_ChildColumn* DatabaseTableColumn::_internal_mutable_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::database::DatabaseTableColumn_ChildColumn>(GetArena());
    _impl_.child_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ChildColumn*>(p);
  }
  return _impl_.child_;
}
inline ::com::zoho::database::DatabaseTableColumn_ChildColumn* DatabaseTableColumn::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::database::DatabaseTableColumn_ChildColumn* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.child)
  return _msg;
}
inline void DatabaseTableColumn::set_allocated_child(::com::zoho::database::DatabaseTableColumn_ChildColumn* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ChildColumn*>(_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ChildColumn*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.child_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_ChildColumn*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.child)
}

// optional bool hide = 6;
inline bool DatabaseTableColumn::has_hide() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void DatabaseTableColumn::clear_hide() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hide_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool DatabaseTableColumn::hide() const {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.hide)
  return _internal_hide();
}
inline void DatabaseTableColumn::set_hide(bool value) {
  _internal_set_hide(value);
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.hide)
}
inline bool DatabaseTableColumn::_internal_hide() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hide_;
}
inline void DatabaseTableColumn::_internal_set_hide(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.hide_ = value;
}

// optional string dbColumnId = 7;
inline bool DatabaseTableColumn::has_dbcolumnid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DatabaseTableColumn::clear_dbcolumnid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbcolumnid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DatabaseTableColumn::dbcolumnid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.dbColumnId)
  return _internal_dbcolumnid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DatabaseTableColumn::set_dbcolumnid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dbcolumnid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.dbColumnId)
}
inline std::string* DatabaseTableColumn::mutable_dbcolumnid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dbcolumnid();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.dbColumnId)
  return _s;
}
inline const std::string& DatabaseTableColumn::_internal_dbcolumnid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dbcolumnid_.Get();
}
inline void DatabaseTableColumn::_internal_set_dbcolumnid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dbcolumnid_.Set(value, GetArena());
}
inline std::string* DatabaseTableColumn::_internal_mutable_dbcolumnid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dbcolumnid_.Mutable( GetArena());
}
inline std::string* DatabaseTableColumn::release_dbcolumnid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.dbColumnId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dbcolumnid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dbcolumnid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DatabaseTableColumn::set_allocated_dbcolumnid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dbcolumnid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dbcolumnid_.IsDefault()) {
          _impl_.dbcolumnid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.dbColumnId)
}

// optional .com.zoho.database.DatabaseTableColumn.ColumnConstraint constraint = 8;
inline bool DatabaseTableColumn::has_constraint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void DatabaseTableColumn::clear_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.constraint_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::com::zoho::database::DatabaseTableColumn_ColumnConstraint DatabaseTableColumn::constraint() const {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.constraint)
  return _internal_constraint();
}
inline void DatabaseTableColumn::set_constraint(::com::zoho::database::DatabaseTableColumn_ColumnConstraint value) {
  _internal_set_constraint(value);
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.constraint)
}
inline ::com::zoho::database::DatabaseTableColumn_ColumnConstraint DatabaseTableColumn::_internal_constraint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::database::DatabaseTableColumn_ColumnConstraint>(_impl_.constraint_);
}
inline void DatabaseTableColumn::_internal_set_constraint(::com::zoho::database::DatabaseTableColumn_ColumnConstraint value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.constraint_ = value;
}

// optional .com.zoho.database.DatabaseTableColumn.Lock lock = 9;
inline bool DatabaseTableColumn::has_lock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lock_ != nullptr);
  return value;
}
inline void DatabaseTableColumn::clear_lock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lock_ != nullptr) _impl_.lock_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::com::zoho::database::DatabaseTableColumn_Lock& DatabaseTableColumn::_internal_lock() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::database::DatabaseTableColumn_Lock* p = _impl_.lock_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::database::DatabaseTableColumn_Lock&>(::com::zoho::database::_DatabaseTableColumn_Lock_default_instance_);
}
inline const ::com::zoho::database::DatabaseTableColumn_Lock& DatabaseTableColumn::lock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.lock)
  return _internal_lock();
}
inline void DatabaseTableColumn::unsafe_arena_set_allocated_lock(::com::zoho::database::DatabaseTableColumn_Lock* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lock_);
  }
  _impl_.lock_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_Lock*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.database.DatabaseTableColumn.lock)
}
inline ::com::zoho::database::DatabaseTableColumn_Lock* DatabaseTableColumn::release_lock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::database::DatabaseTableColumn_Lock* released = _impl_.lock_;
  _impl_.lock_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::database::DatabaseTableColumn_Lock* DatabaseTableColumn::unsafe_arena_release_lock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.lock)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::database::DatabaseTableColumn_Lock* temp = _impl_.lock_;
  _impl_.lock_ = nullptr;
  return temp;
}
inline ::com::zoho::database::DatabaseTableColumn_Lock* DatabaseTableColumn::_internal_mutable_lock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.lock_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::database::DatabaseTableColumn_Lock>(GetArena());
    _impl_.lock_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_Lock*>(p);
  }
  return _impl_.lock_;
}
inline ::com::zoho::database::DatabaseTableColumn_Lock* DatabaseTableColumn::mutable_lock() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::database::DatabaseTableColumn_Lock* _msg = _internal_mutable_lock();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.lock)
  return _msg;
}
inline void DatabaseTableColumn::set_allocated_lock(::com::zoho::database::DatabaseTableColumn_Lock* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::database::DatabaseTableColumn_Lock*>(_impl_.lock_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_Lock*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.lock_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_Lock*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.lock)
}

// optional .com.zoho.database.DatabaseTableColumn.ColumnType type = 10;
inline bool DatabaseTableColumn::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void DatabaseTableColumn::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::com::zoho::database::DatabaseTableColumn_ColumnType DatabaseTableColumn::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.type)
  return _internal_type();
}
inline void DatabaseTableColumn::set_type(::com::zoho::database::DatabaseTableColumn_ColumnType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.database.DatabaseTableColumn.type)
}
inline ::com::zoho::database::DatabaseTableColumn_ColumnType DatabaseTableColumn::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::database::DatabaseTableColumn_ColumnType>(_impl_.type_);
}
inline void DatabaseTableColumn::_internal_set_type(::com::zoho::database::DatabaseTableColumn_ColumnType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.type_ = value;
}

// optional .com.zoho.database.DatabaseTableColumn.SystemManage system = 11;
inline bool DatabaseTableColumn::has_system() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_ != nullptr);
  return value;
}
inline void DatabaseTableColumn::clear_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.system_ != nullptr) _impl_.system_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::com::zoho::database::DatabaseTableColumn_SystemManage& DatabaseTableColumn::_internal_system() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::database::DatabaseTableColumn_SystemManage* p = _impl_.system_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::database::DatabaseTableColumn_SystemManage&>(::com::zoho::database::_DatabaseTableColumn_SystemManage_default_instance_);
}
inline const ::com::zoho::database::DatabaseTableColumn_SystemManage& DatabaseTableColumn::system() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.database.DatabaseTableColumn.system)
  return _internal_system();
}
inline void DatabaseTableColumn::unsafe_arena_set_allocated_system(::com::zoho::database::DatabaseTableColumn_SystemManage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.system_);
  }
  _impl_.system_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_SystemManage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.database.DatabaseTableColumn.system)
}
inline ::com::zoho::database::DatabaseTableColumn_SystemManage* DatabaseTableColumn::release_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::database::DatabaseTableColumn_SystemManage* released = _impl_.system_;
  _impl_.system_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::database::DatabaseTableColumn_SystemManage* DatabaseTableColumn::unsafe_arena_release_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.database.DatabaseTableColumn.system)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::database::DatabaseTableColumn_SystemManage* temp = _impl_.system_;
  _impl_.system_ = nullptr;
  return temp;
}
inline ::com::zoho::database::DatabaseTableColumn_SystemManage* DatabaseTableColumn::_internal_mutable_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.system_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::database::DatabaseTableColumn_SystemManage>(GetArena());
    _impl_.system_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_SystemManage*>(p);
  }
  return _impl_.system_;
}
inline ::com::zoho::database::DatabaseTableColumn_SystemManage* DatabaseTableColumn::mutable_system() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::database::DatabaseTableColumn_SystemManage* _msg = _internal_mutable_system();
  // @@protoc_insertion_point(field_mutable:com.zoho.database.DatabaseTableColumn.system)
  return _msg;
}
inline void DatabaseTableColumn::set_allocated_system(::com::zoho::database::DatabaseTableColumn_SystemManage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::database::DatabaseTableColumn_SystemManage*>(_impl_.system_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_SystemManage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.system_ = reinterpret_cast<::com::zoho::database::DatabaseTableColumn_SystemManage*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.database.DatabaseTableColumn.system)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace database
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::database::DatabaseTableColumn_Lock_LockType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::database::DatabaseTableColumn_Lock_LockType>() {
  return ::com::zoho::database::DatabaseTableColumn_Lock_LockType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType>() {
  return ::com::zoho::database::DatabaseTableColumn_SystemManage_AuditType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::database::DatabaseTableColumn_ColumnConstraint> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::database::DatabaseTableColumn_ColumnConstraint>() {
  return ::com::zoho::database::DatabaseTableColumn_ColumnConstraint_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::database::DatabaseTableColumn_ColumnType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::database::DatabaseTableColumn_ColumnType>() {
  return ::com::zoho::database::DatabaseTableColumn_ColumnType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_databasetablecolumn_2eproto_2epb_2eh
