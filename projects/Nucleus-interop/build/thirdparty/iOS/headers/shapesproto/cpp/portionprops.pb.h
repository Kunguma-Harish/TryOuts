// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: portionprops.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_portionprops_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_portionprops_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "fill.pb.h"
#include "stroke.pb.h"
#include "font.pb.h"
#include "hyperlink.pb.h"
#include "linetype.pb.h"
#include "effects.pb.h"
#include "stylereferencedetails.pb.h"
#include "textlayerproperties.pb.h"
#include "fields.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_portionprops_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_portionprops_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_portionprops_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class PortionProps;
struct PortionPropsDefaultTypeInternal;
extern PortionPropsDefaultTypeInternal _PortionProps_default_instance_;
class PortionProps_ReviewCheck;
struct PortionProps_ReviewCheckDefaultTypeInternal;
extern PortionProps_ReviewCheckDefaultTypeInternal _PortionProps_ReviewCheck_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {
enum PortionProps_ReviewCheck_ReviewState : int {
  PortionProps_ReviewCheck_ReviewState_ERROR = 0,
  PortionProps_ReviewCheck_ReviewState_PROCESSED = 1,
  PortionProps_ReviewCheck_ReviewState_IGNORED = 2,
  PortionProps_ReviewCheck_ReviewState_PortionProps_ReviewCheck_ReviewState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PortionProps_ReviewCheck_ReviewState_PortionProps_ReviewCheck_ReviewState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PortionProps_ReviewCheck_ReviewState_IsValid(int value);
extern const uint32_t PortionProps_ReviewCheck_ReviewState_internal_data_[];
constexpr PortionProps_ReviewCheck_ReviewState PortionProps_ReviewCheck_ReviewState_ReviewState_MIN = static_cast<PortionProps_ReviewCheck_ReviewState>(0);
constexpr PortionProps_ReviewCheck_ReviewState PortionProps_ReviewCheck_ReviewState_ReviewState_MAX = static_cast<PortionProps_ReviewCheck_ReviewState>(2);
constexpr int PortionProps_ReviewCheck_ReviewState_ReviewState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
PortionProps_ReviewCheck_ReviewState_descriptor();
template <typename T>
const std::string& PortionProps_ReviewCheck_ReviewState_Name(T value) {
  static_assert(std::is_same<T, PortionProps_ReviewCheck_ReviewState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReviewState_Name().");
  return PortionProps_ReviewCheck_ReviewState_Name(static_cast<PortionProps_ReviewCheck_ReviewState>(value));
}
template <>
inline const std::string& PortionProps_ReviewCheck_ReviewState_Name(PortionProps_ReviewCheck_ReviewState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PortionProps_ReviewCheck_ReviewState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PortionProps_ReviewCheck_ReviewState_Parse(absl::string_view name, PortionProps_ReviewCheck_ReviewState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortionProps_ReviewCheck_ReviewState>(
      PortionProps_ReviewCheck_ReviewState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PortionProps_ReviewCheck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PortionProps.ReviewCheck) */ {
 public:
  inline PortionProps_ReviewCheck() : PortionProps_ReviewCheck(nullptr) {}
  ~PortionProps_ReviewCheck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PortionProps_ReviewCheck(::google::protobuf::internal::ConstantInitialized);

  inline PortionProps_ReviewCheck(const PortionProps_ReviewCheck& from)
      : PortionProps_ReviewCheck(nullptr, from) {}
  PortionProps_ReviewCheck(PortionProps_ReviewCheck&& from) noexcept
    : PortionProps_ReviewCheck() {
    *this = ::std::move(from);
  }

  inline PortionProps_ReviewCheck& operator=(const PortionProps_ReviewCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortionProps_ReviewCheck& operator=(PortionProps_ReviewCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortionProps_ReviewCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortionProps_ReviewCheck* internal_default_instance() {
    return reinterpret_cast<const PortionProps_ReviewCheck*>(
               &_PortionProps_ReviewCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PortionProps_ReviewCheck& a, PortionProps_ReviewCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(PortionProps_ReviewCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortionProps_ReviewCheck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortionProps_ReviewCheck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortionProps_ReviewCheck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortionProps_ReviewCheck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PortionProps_ReviewCheck& from) {
    PortionProps_ReviewCheck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortionProps_ReviewCheck* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PortionProps.ReviewCheck";
  }
  protected:
  explicit PortionProps_ReviewCheck(::google::protobuf::Arena* arena);
  PortionProps_ReviewCheck(::google::protobuf::Arena* arena, const PortionProps_ReviewCheck& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ReviewState = PortionProps_ReviewCheck_ReviewState;
  static constexpr ReviewState ERROR = PortionProps_ReviewCheck_ReviewState_ERROR;
  static constexpr ReviewState PROCESSED = PortionProps_ReviewCheck_ReviewState_PROCESSED;
  static constexpr ReviewState IGNORED = PortionProps_ReviewCheck_ReviewState_IGNORED;
  static inline bool ReviewState_IsValid(int value) {
    return PortionProps_ReviewCheck_ReviewState_IsValid(value);
  }
  static constexpr ReviewState ReviewState_MIN = PortionProps_ReviewCheck_ReviewState_ReviewState_MIN;
  static constexpr ReviewState ReviewState_MAX = PortionProps_ReviewCheck_ReviewState_ReviewState_MAX;
  static constexpr int ReviewState_ARRAYSIZE = PortionProps_ReviewCheck_ReviewState_ReviewState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ReviewState_descriptor() {
    return PortionProps_ReviewCheck_ReviewState_descriptor();
  }
  template <typename T>
  static inline const std::string& ReviewState_Name(T value) {
    return PortionProps_ReviewCheck_ReviewState_Name(value);
  }
  static inline bool ReviewState_Parse(absl::string_view name, ReviewState* value) {
    return PortionProps_ReviewCheck_ReviewState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLangFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // optional string lang = 2;
  bool has_lang() const;
  void clear_lang() ;
  const std::string& lang() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lang(Arg_&& arg, Args_... args);
  std::string* mutable_lang();
  PROTOBUF_NODISCARD std::string* release_lang();
  void set_allocated_lang(std::string* value);

  private:
  const std::string& _internal_lang() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lang(
      const std::string& value);
  std::string* _internal_mutable_lang();

  public:
  // optional .com.zoho.shapes.PortionProps.ReviewCheck.ReviewState state = 1;
  bool has_state() const;
  void clear_state() ;
  ::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState state() const;
  void set_state(::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState value);

  private:
  ::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState _internal_state() const;
  void _internal_set_state(::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PortionProps.ReviewCheck)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr lang_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_portionprops_2eproto;
};// -------------------------------------------------------------------

class PortionProps final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.PortionProps) */ {
 public:
  inline PortionProps() : PortionProps(nullptr) {}
  ~PortionProps() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PortionProps(::google::protobuf::internal::ConstantInitialized);

  inline PortionProps(const PortionProps& from)
      : PortionProps(nullptr, from) {}
  PortionProps(PortionProps&& from) noexcept
    : PortionProps() {
    *this = ::std::move(from);
  }

  inline PortionProps& operator=(const PortionProps& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortionProps& operator=(PortionProps&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortionProps& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortionProps* internal_default_instance() {
    return reinterpret_cast<const PortionProps*>(
               &_PortionProps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PortionProps& a, PortionProps& b) {
    a.Swap(&b);
  }
  inline void Swap(PortionProps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortionProps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortionProps* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortionProps>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortionProps& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PortionProps& from) {
    PortionProps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortionProps* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.PortionProps";
  }
  protected:
  explicit PortionProps(::google::protobuf::Arena* arena);
  PortionProps(::google::protobuf::Arena* arena, const PortionProps& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ReviewCheck = PortionProps_ReviewCheck;

  // accessors -------------------------------------------------------

  enum : int {
    kCommentIdsFieldNumber = 16,
    kPostScriptNameFieldNumber = 18,
    kFontFieldNumber = 1,
    kFillFieldNumber = 2,
    kStrokeFieldNumber = 3,
    kClickFieldNumber = 12,
    kHoverFieldNumber = 13,
    kChkFieldNumber = 15,
    kEffectsFieldNumber = 17,
    kTextLayerPropsFieldNumber = 19,
    kStyleRefFieldNumber = 20,
    kHighlightFieldNumber = 21,
    kSizeFieldNumber = 4,
    kBoldFieldNumber = 5,
    kItalicFieldNumber = 6,
    kUnderlineFieldNumber = 7,
    kStrikeFieldNumber = 8,
    kBaselineFieldNumber = 9,
    kCapFieldNumber = 10,
    kSpaceFieldNumber = 11,
    kFontweightFieldNumber = 14,
  };
  // repeated string commentIds = 16;
  int commentids_size() const;
  private:
  int _internal_commentids_size() const;

  public:
  void clear_commentids() ;
  const std::string& commentids(int index) const;
  std::string* mutable_commentids(int index);
  void set_commentids(int index, const std::string& value);
  void set_commentids(int index, std::string&& value);
  void set_commentids(int index, const char* value);
  void set_commentids(int index, const char* value, std::size_t size);
  void set_commentids(int index, absl::string_view value);
  std::string* add_commentids();
  void add_commentids(const std::string& value);
  void add_commentids(std::string&& value);
  void add_commentids(const char* value);
  void add_commentids(const char* value, std::size_t size);
  void add_commentids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& commentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_commentids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_commentids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_commentids();

  public:
  // optional string postScriptName = 18;
  bool has_postscriptname() const;
  void clear_postscriptname() ;
  const std::string& postscriptname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_postscriptname(Arg_&& arg, Args_... args);
  std::string* mutable_postscriptname();
  PROTOBUF_NODISCARD std::string* release_postscriptname();
  void set_allocated_postscriptname(std::string* value);

  private:
  const std::string& _internal_postscriptname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postscriptname(
      const std::string& value);
  std::string* _internal_mutable_postscriptname();

  public:
  // optional .com.zoho.shapes.Font font = 1;
  bool has_font() const;
  void clear_font() ;
  const ::com::zoho::shapes::Font& font() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Font* release_font();
  ::com::zoho::shapes::Font* mutable_font();
  void set_allocated_font(::com::zoho::shapes::Font* value);
  void unsafe_arena_set_allocated_font(::com::zoho::shapes::Font* value);
  ::com::zoho::shapes::Font* unsafe_arena_release_font();

  private:
  const ::com::zoho::shapes::Font& _internal_font() const;
  ::com::zoho::shapes::Font* _internal_mutable_font();

  public:
  // optional .com.zoho.shapes.Fill fill = 2;
  bool has_fill() const;
  void clear_fill() ;
  const ::com::zoho::shapes::Fill& fill() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Fill* release_fill();
  ::com::zoho::shapes::Fill* mutable_fill();
  void set_allocated_fill(::com::zoho::shapes::Fill* value);
  void unsafe_arena_set_allocated_fill(::com::zoho::shapes::Fill* value);
  ::com::zoho::shapes::Fill* unsafe_arena_release_fill();

  private:
  const ::com::zoho::shapes::Fill& _internal_fill() const;
  ::com::zoho::shapes::Fill* _internal_mutable_fill();

  public:
  // optional .com.zoho.shapes.Stroke stroke = 3;
  bool has_stroke() const;
  void clear_stroke() ;
  const ::com::zoho::shapes::Stroke& stroke() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Stroke* release_stroke();
  ::com::zoho::shapes::Stroke* mutable_stroke();
  void set_allocated_stroke(::com::zoho::shapes::Stroke* value);
  void unsafe_arena_set_allocated_stroke(::com::zoho::shapes::Stroke* value);
  ::com::zoho::shapes::Stroke* unsafe_arena_release_stroke();

  private:
  const ::com::zoho::shapes::Stroke& _internal_stroke() const;
  ::com::zoho::shapes::Stroke* _internal_mutable_stroke();

  public:
  // optional .com.zoho.shapes.HyperLink click = 12;
  bool has_click() const;
  void clear_click() ;
  const ::com::zoho::shapes::HyperLink& click() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::HyperLink* release_click();
  ::com::zoho::shapes::HyperLink* mutable_click();
  void set_allocated_click(::com::zoho::shapes::HyperLink* value);
  void unsafe_arena_set_allocated_click(::com::zoho::shapes::HyperLink* value);
  ::com::zoho::shapes::HyperLink* unsafe_arena_release_click();

  private:
  const ::com::zoho::shapes::HyperLink& _internal_click() const;
  ::com::zoho::shapes::HyperLink* _internal_mutable_click();

  public:
  // optional .com.zoho.shapes.HyperLink hover = 13;
  bool has_hover() const;
  void clear_hover() ;
  const ::com::zoho::shapes::HyperLink& hover() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::HyperLink* release_hover();
  ::com::zoho::shapes::HyperLink* mutable_hover();
  void set_allocated_hover(::com::zoho::shapes::HyperLink* value);
  void unsafe_arena_set_allocated_hover(::com::zoho::shapes::HyperLink* value);
  ::com::zoho::shapes::HyperLink* unsafe_arena_release_hover();

  private:
  const ::com::zoho::shapes::HyperLink& _internal_hover() const;
  ::com::zoho::shapes::HyperLink* _internal_mutable_hover();

  public:
  // optional .com.zoho.shapes.PortionProps.ReviewCheck chk = 15;
  bool has_chk() const;
  void clear_chk() ;
  const ::com::zoho::shapes::PortionProps_ReviewCheck& chk() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PortionProps_ReviewCheck* release_chk();
  ::com::zoho::shapes::PortionProps_ReviewCheck* mutable_chk();
  void set_allocated_chk(::com::zoho::shapes::PortionProps_ReviewCheck* value);
  void unsafe_arena_set_allocated_chk(::com::zoho::shapes::PortionProps_ReviewCheck* value);
  ::com::zoho::shapes::PortionProps_ReviewCheck* unsafe_arena_release_chk();

  private:
  const ::com::zoho::shapes::PortionProps_ReviewCheck& _internal_chk() const;
  ::com::zoho::shapes::PortionProps_ReviewCheck* _internal_mutable_chk();

  public:
  // optional .com.zoho.shapes.Effects effects = 17;
  bool has_effects() const;
  void clear_effects() ;
  const ::com::zoho::shapes::Effects& effects() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Effects* release_effects();
  ::com::zoho::shapes::Effects* mutable_effects();
  void set_allocated_effects(::com::zoho::shapes::Effects* value);
  void unsafe_arena_set_allocated_effects(::com::zoho::shapes::Effects* value);
  ::com::zoho::shapes::Effects* unsafe_arena_release_effects();

  private:
  const ::com::zoho::shapes::Effects& _internal_effects() const;
  ::com::zoho::shapes::Effects* _internal_mutable_effects();

  public:
  // optional .com.zoho.shapes.TextLayerProperties textLayerProps = 19;
  bool has_textlayerprops() const;
  void clear_textlayerprops() ;
  const ::com::zoho::shapes::TextLayerProperties& textlayerprops() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::TextLayerProperties* release_textlayerprops();
  ::com::zoho::shapes::TextLayerProperties* mutable_textlayerprops();
  void set_allocated_textlayerprops(::com::zoho::shapes::TextLayerProperties* value);
  void unsafe_arena_set_allocated_textlayerprops(::com::zoho::shapes::TextLayerProperties* value);
  ::com::zoho::shapes::TextLayerProperties* unsafe_arena_release_textlayerprops();

  private:
  const ::com::zoho::shapes::TextLayerProperties& _internal_textlayerprops() const;
  ::com::zoho::shapes::TextLayerProperties* _internal_mutable_textlayerprops();

  public:
  // optional .com.zoho.shapes.StyleReferenceDetails styleRef = 20;
  bool has_styleref() const;
  void clear_styleref() ;
  const ::com::zoho::shapes::StyleReferenceDetails& styleref() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::StyleReferenceDetails* release_styleref();
  ::com::zoho::shapes::StyleReferenceDetails* mutable_styleref();
  void set_allocated_styleref(::com::zoho::shapes::StyleReferenceDetails* value);
  void unsafe_arena_set_allocated_styleref(::com::zoho::shapes::StyleReferenceDetails* value);
  ::com::zoho::shapes::StyleReferenceDetails* unsafe_arena_release_styleref();

  private:
  const ::com::zoho::shapes::StyleReferenceDetails& _internal_styleref() const;
  ::com::zoho::shapes::StyleReferenceDetails* _internal_mutable_styleref();

  public:
  // optional .com.zoho.shapes.Fill highlight = 21;
  bool has_highlight() const;
  void clear_highlight() ;
  const ::com::zoho::shapes::Fill& highlight() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Fill* release_highlight();
  ::com::zoho::shapes::Fill* mutable_highlight();
  void set_allocated_highlight(::com::zoho::shapes::Fill* value);
  void unsafe_arena_set_allocated_highlight(::com::zoho::shapes::Fill* value);
  ::com::zoho::shapes::Fill* unsafe_arena_release_highlight();

  private:
  const ::com::zoho::shapes::Fill& _internal_highlight() const;
  ::com::zoho::shapes::Fill* _internal_mutable_highlight();

  public:
  // optional float size = 4;
  bool has_size() const;
  void clear_size() ;
  float size() const;
  void set_size(float value);

  private:
  float _internal_size() const;
  void _internal_set_size(float value);

  public:
  // optional bool bold = 5;
  bool has_bold() const;
  void clear_bold() ;
  bool bold() const;
  void set_bold(bool value);

  private:
  bool _internal_bold() const;
  void _internal_set_bold(bool value);

  public:
  // optional bool italic = 6;
  bool has_italic() const;
  void clear_italic() ;
  bool italic() const;
  void set_italic(bool value);

  private:
  bool _internal_italic() const;
  void _internal_set_italic(bool value);

  public:
  // optional .com.zoho.shapes.LineType underline = 7;
  bool has_underline() const;
  void clear_underline() ;
  ::com::zoho::shapes::LineType underline() const;
  void set_underline(::com::zoho::shapes::LineType value);

  private:
  ::com::zoho::shapes::LineType _internal_underline() const;
  void _internal_set_underline(::com::zoho::shapes::LineType value);

  public:
  // optional .com.zoho.shapes.LineType strike = 8;
  bool has_strike() const;
  void clear_strike() ;
  ::com::zoho::shapes::LineType strike() const;
  void set_strike(::com::zoho::shapes::LineType value);

  private:
  ::com::zoho::shapes::LineType _internal_strike() const;
  void _internal_set_strike(::com::zoho::shapes::LineType value);

  public:
  // optional float baseline = 9;
  bool has_baseline() const;
  void clear_baseline() ;
  float baseline() const;
  void set_baseline(float value);

  private:
  float _internal_baseline() const;
  void _internal_set_baseline(float value);

  public:
  // optional .Show.PortionField.FontVariant cap = 10;
  bool has_cap() const;
  void clear_cap() ;
  ::Show::PortionField_FontVariant cap() const;
  void set_cap(::Show::PortionField_FontVariant value);

  private:
  ::Show::PortionField_FontVariant _internal_cap() const;
  void _internal_set_cap(::Show::PortionField_FontVariant value);

  public:
  // optional float space = 11;
  bool has_space() const;
  void clear_space() ;
  float space() const;
  void set_space(float value);

  private:
  float _internal_space() const;
  void _internal_set_space(float value);

  public:
  // optional .Show.PortionField.FontWeight fontweight = 14;
  bool has_fontweight() const;
  void clear_fontweight() ;
  ::Show::PortionField_FontWeight fontweight() const;
  void set_fontweight(::Show::PortionField_FontWeight value);

  private:
  ::Show::PortionField_FontWeight _internal_fontweight() const;
  void _internal_set_fontweight(::Show::PortionField_FontWeight value);

  public:
  void temp_setfont(com::zoho::shapes::Font* font) {
    if(&this->font() != font) {
      set_allocated_font(font);
    }
  }
  
  com::zoho::shapes::Font* temp_getfont() const {
    if (has_font()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_font();
    return nullptr;
  }
  
  void temp_setfill(com::zoho::shapes::Fill* fill) {
    if(&this->fill() != fill) {
      set_allocated_fill(fill);
    }
  }
  
  com::zoho::shapes::Fill* temp_getfill() const {
    if (has_fill()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_fill();
    return nullptr;
  }
  
  void temp_setstroke(com::zoho::shapes::Stroke* stroke) {
    if(&this->stroke() != stroke) {
      set_allocated_stroke(stroke);
    }
  }
  
  com::zoho::shapes::Stroke* temp_getstroke() const {
    if (has_stroke()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_stroke();
    return nullptr;
  }
  
  void temp_setclick(com::zoho::shapes::HyperLink* click) {
    if(&this->click() != click) {
      set_allocated_click(click);
    }
  }
  
  com::zoho::shapes::HyperLink* temp_getclick() const {
    if (has_click()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_click();
    return nullptr;
  }
  
  void temp_sethover(com::zoho::shapes::HyperLink* hover) {
    if(&this->hover() != hover) {
      set_allocated_hover(hover);
    }
  }
  
  com::zoho::shapes::HyperLink* temp_gethover() const {
    if (has_hover()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_hover();
    return nullptr;
  }
  
  void temp_setchk(com::zoho::shapes::PortionProps_ReviewCheck* chk) {
    if(&this->chk() != chk) {
      set_allocated_chk(chk);
    }
  }
  
  com::zoho::shapes::PortionProps_ReviewCheck* temp_getchk() const {
    if (has_chk()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_chk();
    return nullptr;
  }
  
  google::protobuf::RepeatedPtrField<std::string>* temp_getcommentIds() const {
    return const_cast<com::zoho::shapes::PortionProps*>(this)->mutable_commentids();
  }
  
  void temp_setcommentIds(const google::protobuf::RepeatedPtrField<std::string>* commentIds) {
    if(this->mutable_commentids() != commentIds) {
      const_cast<com::zoho::shapes::PortionProps*>(this)->mutable_commentids()->CopyFrom(*commentIds);
    }}
  
  void temp_seteffects(com::zoho::shapes::Effects* effects) {
    if(&this->effects() != effects) {
      set_allocated_effects(effects);
    }
  }
  
  com::zoho::shapes::Effects* temp_geteffects() const {
    if (has_effects()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_effects();
    return nullptr;
  }
  
  void temp_settextLayerProps(com::zoho::shapes::TextLayerProperties* textLayerProps) {
    if(&this->textlayerprops() != textLayerProps) {
      set_allocated_textlayerprops(textLayerProps);
    }
  }
  
  com::zoho::shapes::TextLayerProperties* temp_gettextLayerProps() const {
    if (has_textlayerprops()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_textlayerprops();
    return nullptr;
  }
  
  void temp_setstyleRef(com::zoho::shapes::StyleReferenceDetails* styleRef) {
    if(&this->styleref() != styleRef) {
      set_allocated_styleref(styleRef);
    }
  }
  
  com::zoho::shapes::StyleReferenceDetails* temp_getstyleRef() const {
    if (has_styleref()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_styleref();
    return nullptr;
  }
  
  void temp_sethighlight(com::zoho::shapes::Fill* highlight) {
    if(&this->highlight() != highlight) {
      set_allocated_highlight(highlight);
    }
  }
  
  com::zoho::shapes::Fill* temp_gethighlight() const {
    if (has_highlight()) 
      return (const_cast<com::zoho::shapes::PortionProps*>(this))->mutable_highlight();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.PortionProps)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 21, 10,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> commentids_;
    ::google::protobuf::internal::ArenaStringPtr postscriptname_;
    ::com::zoho::shapes::Font* font_;
    ::com::zoho::shapes::Fill* fill_;
    ::com::zoho::shapes::Stroke* stroke_;
    ::com::zoho::shapes::HyperLink* click_;
    ::com::zoho::shapes::HyperLink* hover_;
    ::com::zoho::shapes::PortionProps_ReviewCheck* chk_;
    ::com::zoho::shapes::Effects* effects_;
    ::com::zoho::shapes::TextLayerProperties* textlayerprops_;
    ::com::zoho::shapes::StyleReferenceDetails* styleref_;
    ::com::zoho::shapes::Fill* highlight_;
    float size_;
    bool bold_;
    bool italic_;
    int underline_;
    int strike_;
    float baseline_;
    int cap_;
    float space_;
    int fontweight_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_portionprops_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PortionProps_ReviewCheck

// optional .com.zoho.shapes.PortionProps.ReviewCheck.ReviewState state = 1;
inline bool PortionProps_ReviewCheck::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PortionProps_ReviewCheck::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState PortionProps_ReviewCheck::state() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.ReviewCheck.state)
  return _internal_state();
}
inline void PortionProps_ReviewCheck::set_state(::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.ReviewCheck.state)
}
inline ::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState PortionProps_ReviewCheck::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState>(_impl_.state_);
}
inline void PortionProps_ReviewCheck::_internal_set_state(::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_ = value;
}

// optional string lang = 2;
inline bool PortionProps_ReviewCheck::has_lang() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PortionProps_ReviewCheck::clear_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lang_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PortionProps_ReviewCheck::lang() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.ReviewCheck.lang)
  return _internal_lang();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortionProps_ReviewCheck::set_lang(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lang_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.ReviewCheck.lang)
}
inline std::string* PortionProps_ReviewCheck::mutable_lang() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lang();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.ReviewCheck.lang)
  return _s;
}
inline const std::string& PortionProps_ReviewCheck::_internal_lang() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lang_.Get();
}
inline void PortionProps_ReviewCheck::_internal_set_lang(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lang_.Set(value, GetArena());
}
inline std::string* PortionProps_ReviewCheck::_internal_mutable_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.lang_.Mutable( GetArena());
}
inline std::string* PortionProps_ReviewCheck::release_lang() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.ReviewCheck.lang)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.lang_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lang_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PortionProps_ReviewCheck::set_allocated_lang(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lang_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.lang_.IsDefault()) {
          _impl_.lang_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.ReviewCheck.lang)
}

// -------------------------------------------------------------------

// PortionProps

// optional .com.zoho.shapes.Font font = 1;
inline bool PortionProps::has_font() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.font_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Font& PortionProps::_internal_font() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Font* p = _impl_.font_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Font&>(::com::zoho::shapes::_Font_default_instance_);
}
inline const ::com::zoho::shapes::Font& PortionProps::font() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.font)
  return _internal_font();
}
inline void PortionProps::unsafe_arena_set_allocated_font(::com::zoho::shapes::Font* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.font_);
  }
  _impl_.font_ = reinterpret_cast<::com::zoho::shapes::Font*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.font)
}
inline ::com::zoho::shapes::Font* PortionProps::release_font() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Font* released = _impl_.font_;
  _impl_.font_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Font* PortionProps::unsafe_arena_release_font() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.font)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Font* temp = _impl_.font_;
  _impl_.font_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Font* PortionProps::_internal_mutable_font() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.font_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Font>(GetArena());
    _impl_.font_ = reinterpret_cast<::com::zoho::shapes::Font*>(p);
  }
  return _impl_.font_;
}
inline ::com::zoho::shapes::Font* PortionProps::mutable_font() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Font* _msg = _internal_mutable_font();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.font)
  return _msg;
}
inline void PortionProps::set_allocated_font(::com::zoho::shapes::Font* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.font_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.font_ = reinterpret_cast<::com::zoho::shapes::Font*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.font)
}

// optional .com.zoho.shapes.Fill fill = 2;
inline bool PortionProps::has_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Fill& PortionProps::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Fill* p = _impl_.fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Fill&>(::com::zoho::shapes::_Fill_default_instance_);
}
inline const ::com::zoho::shapes::Fill& PortionProps::fill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.fill)
  return _internal_fill();
}
inline void PortionProps::unsafe_arena_set_allocated_fill(::com::zoho::shapes::Fill* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_);
  }
  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::Fill*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.fill)
}
inline ::com::zoho::shapes::Fill* PortionProps::release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Fill* released = _impl_.fill_;
  _impl_.fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Fill* PortionProps::unsafe_arena_release_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.fill)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Fill* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Fill* PortionProps::_internal_mutable_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Fill>(GetArena());
    _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::Fill*>(p);
  }
  return _impl_.fill_;
}
inline ::com::zoho::shapes::Fill* PortionProps::mutable_fill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Fill* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.fill)
  return _msg;
}
inline void PortionProps::set_allocated_fill(::com::zoho::shapes::Fill* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fill_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.fill_ = reinterpret_cast<::com::zoho::shapes::Fill*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.fill)
}

// optional .com.zoho.shapes.Stroke stroke = 3;
inline bool PortionProps::has_stroke() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stroke_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Stroke& PortionProps::_internal_stroke() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Stroke* p = _impl_.stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Stroke&>(::com::zoho::shapes::_Stroke_default_instance_);
}
inline const ::com::zoho::shapes::Stroke& PortionProps::stroke() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.stroke)
  return _internal_stroke();
}
inline void PortionProps::unsafe_arena_set_allocated_stroke(::com::zoho::shapes::Stroke* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stroke_);
  }
  _impl_.stroke_ = reinterpret_cast<::com::zoho::shapes::Stroke*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.stroke)
}
inline ::com::zoho::shapes::Stroke* PortionProps::release_stroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Stroke* released = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Stroke* PortionProps::unsafe_arena_release_stroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.stroke)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Stroke* temp = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Stroke* PortionProps::_internal_mutable_stroke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Stroke>(GetArena());
    _impl_.stroke_ = reinterpret_cast<::com::zoho::shapes::Stroke*>(p);
  }
  return _impl_.stroke_;
}
inline ::com::zoho::shapes::Stroke* PortionProps::mutable_stroke() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Stroke* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.stroke)
  return _msg;
}
inline void PortionProps::set_allocated_stroke(::com::zoho::shapes::Stroke* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stroke_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.stroke_ = reinterpret_cast<::com::zoho::shapes::Stroke*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.stroke)
}

// optional float size = 4;
inline bool PortionProps::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void PortionProps::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float PortionProps::size() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.size)
  return _internal_size();
}
inline void PortionProps::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.size)
}
inline float PortionProps::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void PortionProps::_internal_set_size(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.size_ = value;
}

// optional bool bold = 5;
inline bool PortionProps::has_bold() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void PortionProps::clear_bold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bold_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool PortionProps::bold() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.bold)
  return _internal_bold();
}
inline void PortionProps::set_bold(bool value) {
  _internal_set_bold(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.bold)
}
inline bool PortionProps::_internal_bold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bold_;
}
inline void PortionProps::_internal_set_bold(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.bold_ = value;
}

// optional bool italic = 6;
inline bool PortionProps::has_italic() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void PortionProps::clear_italic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.italic_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool PortionProps::italic() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.italic)
  return _internal_italic();
}
inline void PortionProps::set_italic(bool value) {
  _internal_set_italic(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.italic)
}
inline bool PortionProps::_internal_italic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.italic_;
}
inline void PortionProps::_internal_set_italic(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.italic_ = value;
}

// optional .com.zoho.shapes.LineType underline = 7;
inline bool PortionProps::has_underline() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void PortionProps::clear_underline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.underline_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::com::zoho::shapes::LineType PortionProps::underline() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.underline)
  return _internal_underline();
}
inline void PortionProps::set_underline(::com::zoho::shapes::LineType value) {
  _internal_set_underline(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.underline)
}
inline ::com::zoho::shapes::LineType PortionProps::_internal_underline() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::LineType>(_impl_.underline_);
}
inline void PortionProps::_internal_set_underline(::com::zoho::shapes::LineType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.underline_ = value;
}

// optional .com.zoho.shapes.LineType strike = 8;
inline bool PortionProps::has_strike() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void PortionProps::clear_strike() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strike_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::com::zoho::shapes::LineType PortionProps::strike() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.strike)
  return _internal_strike();
}
inline void PortionProps::set_strike(::com::zoho::shapes::LineType value) {
  _internal_set_strike(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.strike)
}
inline ::com::zoho::shapes::LineType PortionProps::_internal_strike() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::LineType>(_impl_.strike_);
}
inline void PortionProps::_internal_set_strike(::com::zoho::shapes::LineType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.strike_ = value;
}

// optional float baseline = 9;
inline bool PortionProps::has_baseline() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void PortionProps::clear_baseline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.baseline_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float PortionProps::baseline() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.baseline)
  return _internal_baseline();
}
inline void PortionProps::set_baseline(float value) {
  _internal_set_baseline(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.baseline)
}
inline float PortionProps::_internal_baseline() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.baseline_;
}
inline void PortionProps::_internal_set_baseline(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.baseline_ = value;
}

// optional .Show.PortionField.FontVariant cap = 10;
inline bool PortionProps::has_cap() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void PortionProps::clear_cap() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cap_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::Show::PortionField_FontVariant PortionProps::cap() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.cap)
  return _internal_cap();
}
inline void PortionProps::set_cap(::Show::PortionField_FontVariant value) {
  _internal_set_cap(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.cap)
}
inline ::Show::PortionField_FontVariant PortionProps::_internal_cap() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::PortionField_FontVariant>(_impl_.cap_);
}
inline void PortionProps::_internal_set_cap(::Show::PortionField_FontVariant value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.cap_ = value;
}

// optional float space = 11;
inline bool PortionProps::has_space() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void PortionProps::clear_space() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.space_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline float PortionProps::space() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.space)
  return _internal_space();
}
inline void PortionProps::set_space(float value) {
  _internal_set_space(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.space)
}
inline float PortionProps::_internal_space() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.space_;
}
inline void PortionProps::_internal_set_space(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.space_ = value;
}

// optional .com.zoho.shapes.HyperLink click = 12;
inline bool PortionProps::has_click() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.click_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::HyperLink& PortionProps::_internal_click() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::HyperLink* p = _impl_.click_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::HyperLink&>(::com::zoho::shapes::_HyperLink_default_instance_);
}
inline const ::com::zoho::shapes::HyperLink& PortionProps::click() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.click)
  return _internal_click();
}
inline void PortionProps::unsafe_arena_set_allocated_click(::com::zoho::shapes::HyperLink* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.click_);
  }
  _impl_.click_ = reinterpret_cast<::com::zoho::shapes::HyperLink*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.click)
}
inline ::com::zoho::shapes::HyperLink* PortionProps::release_click() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::HyperLink* released = _impl_.click_;
  _impl_.click_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::HyperLink* PortionProps::unsafe_arena_release_click() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.click)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::HyperLink* temp = _impl_.click_;
  _impl_.click_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::HyperLink* PortionProps::_internal_mutable_click() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.click_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::HyperLink>(GetArena());
    _impl_.click_ = reinterpret_cast<::com::zoho::shapes::HyperLink*>(p);
  }
  return _impl_.click_;
}
inline ::com::zoho::shapes::HyperLink* PortionProps::mutable_click() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::HyperLink* _msg = _internal_mutable_click();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.click)
  return _msg;
}
inline void PortionProps::set_allocated_click(::com::zoho::shapes::HyperLink* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.click_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.click_ = reinterpret_cast<::com::zoho::shapes::HyperLink*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.click)
}

// optional .com.zoho.shapes.HyperLink hover = 13;
inline bool PortionProps::has_hover() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hover_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::HyperLink& PortionProps::_internal_hover() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::HyperLink* p = _impl_.hover_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::HyperLink&>(::com::zoho::shapes::_HyperLink_default_instance_);
}
inline const ::com::zoho::shapes::HyperLink& PortionProps::hover() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.hover)
  return _internal_hover();
}
inline void PortionProps::unsafe_arena_set_allocated_hover(::com::zoho::shapes::HyperLink* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hover_);
  }
  _impl_.hover_ = reinterpret_cast<::com::zoho::shapes::HyperLink*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.hover)
}
inline ::com::zoho::shapes::HyperLink* PortionProps::release_hover() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::HyperLink* released = _impl_.hover_;
  _impl_.hover_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::HyperLink* PortionProps::unsafe_arena_release_hover() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.hover)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::HyperLink* temp = _impl_.hover_;
  _impl_.hover_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::HyperLink* PortionProps::_internal_mutable_hover() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.hover_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::HyperLink>(GetArena());
    _impl_.hover_ = reinterpret_cast<::com::zoho::shapes::HyperLink*>(p);
  }
  return _impl_.hover_;
}
inline ::com::zoho::shapes::HyperLink* PortionProps::mutable_hover() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::HyperLink* _msg = _internal_mutable_hover();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.hover)
  return _msg;
}
inline void PortionProps::set_allocated_hover(::com::zoho::shapes::HyperLink* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hover_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.hover_ = reinterpret_cast<::com::zoho::shapes::HyperLink*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.hover)
}

// optional .Show.PortionField.FontWeight fontweight = 14;
inline bool PortionProps::has_fontweight() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void PortionProps::clear_fontweight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fontweight_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::Show::PortionField_FontWeight PortionProps::fontweight() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.fontweight)
  return _internal_fontweight();
}
inline void PortionProps::set_fontweight(::Show::PortionField_FontWeight value) {
  _internal_set_fontweight(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.fontweight)
}
inline ::Show::PortionField_FontWeight PortionProps::_internal_fontweight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::PortionField_FontWeight>(_impl_.fontweight_);
}
inline void PortionProps::_internal_set_fontweight(::Show::PortionField_FontWeight value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.fontweight_ = value;
}

// optional .com.zoho.shapes.PortionProps.ReviewCheck chk = 15;
inline bool PortionProps::has_chk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chk_ != nullptr);
  return value;
}
inline void PortionProps::clear_chk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.chk_ != nullptr) _impl_.chk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::com::zoho::shapes::PortionProps_ReviewCheck& PortionProps::_internal_chk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PortionProps_ReviewCheck* p = _impl_.chk_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PortionProps_ReviewCheck&>(::com::zoho::shapes::_PortionProps_ReviewCheck_default_instance_);
}
inline const ::com::zoho::shapes::PortionProps_ReviewCheck& PortionProps::chk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.chk)
  return _internal_chk();
}
inline void PortionProps::unsafe_arena_set_allocated_chk(::com::zoho::shapes::PortionProps_ReviewCheck* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chk_);
  }
  _impl_.chk_ = reinterpret_cast<::com::zoho::shapes::PortionProps_ReviewCheck*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.chk)
}
inline ::com::zoho::shapes::PortionProps_ReviewCheck* PortionProps::release_chk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::shapes::PortionProps_ReviewCheck* released = _impl_.chk_;
  _impl_.chk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PortionProps_ReviewCheck* PortionProps::unsafe_arena_release_chk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.chk)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::shapes::PortionProps_ReviewCheck* temp = _impl_.chk_;
  _impl_.chk_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PortionProps_ReviewCheck* PortionProps::_internal_mutable_chk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.chk_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PortionProps_ReviewCheck>(GetArena());
    _impl_.chk_ = reinterpret_cast<::com::zoho::shapes::PortionProps_ReviewCheck*>(p);
  }
  return _impl_.chk_;
}
inline ::com::zoho::shapes::PortionProps_ReviewCheck* PortionProps::mutable_chk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PortionProps_ReviewCheck* _msg = _internal_mutable_chk();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.chk)
  return _msg;
}
inline void PortionProps::set_allocated_chk(::com::zoho::shapes::PortionProps_ReviewCheck* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::PortionProps_ReviewCheck*>(_impl_.chk_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::PortionProps_ReviewCheck*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.chk_ = reinterpret_cast<::com::zoho::shapes::PortionProps_ReviewCheck*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.chk)
}

// repeated string commentIds = 16;
inline int PortionProps::_internal_commentids_size() const {
  return _internal_commentids().size();
}
inline int PortionProps::commentids_size() const {
  return _internal_commentids_size();
}
inline void PortionProps::clear_commentids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commentids_.Clear();
}
inline std::string* PortionProps::add_commentids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_commentids()->Add();
  // @@protoc_insertion_point(field_add_mutable:com.zoho.shapes.PortionProps.commentIds)
  return _s;
}
inline const std::string& PortionProps::commentids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.commentIds)
  return _internal_commentids().Get(index);
}
inline std::string* PortionProps::mutable_commentids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.commentIds)
  return _internal_mutable_commentids()->Mutable(index);
}
inline void PortionProps::set_commentids(int index, const std::string& value) {
  _internal_mutable_commentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::set_commentids(int index, std::string&& value) {
  _internal_mutable_commentids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::set_commentids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_commentids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::set_commentids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_commentids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::set_commentids(int index, absl::string_view value) {
  _internal_mutable_commentids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::add_commentids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::add_commentids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commentids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::add_commentids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commentids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::add_commentids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commentids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.zoho.shapes.PortionProps.commentIds)
}
inline void PortionProps::add_commentids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commentids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:com.zoho.shapes.PortionProps.commentIds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PortionProps::commentids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.PortionProps.commentIds)
  return _internal_commentids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PortionProps::mutable_commentids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.PortionProps.commentIds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_commentids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PortionProps::_internal_commentids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commentids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PortionProps::_internal_mutable_commentids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.commentids_;
}

// optional .com.zoho.shapes.Effects effects = 17;
inline bool PortionProps::has_effects() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.effects_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Effects& PortionProps::_internal_effects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Effects* p = _impl_.effects_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Effects&>(::com::zoho::shapes::_Effects_default_instance_);
}
inline const ::com::zoho::shapes::Effects& PortionProps::effects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.effects)
  return _internal_effects();
}
inline void PortionProps::unsafe_arena_set_allocated_effects(::com::zoho::shapes::Effects* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.effects_);
  }
  _impl_.effects_ = reinterpret_cast<::com::zoho::shapes::Effects*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.effects)
}
inline ::com::zoho::shapes::Effects* PortionProps::release_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::shapes::Effects* released = _impl_.effects_;
  _impl_.effects_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Effects* PortionProps::unsafe_arena_release_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.effects)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::shapes::Effects* temp = _impl_.effects_;
  _impl_.effects_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Effects* PortionProps::_internal_mutable_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.effects_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Effects>(GetArena());
    _impl_.effects_ = reinterpret_cast<::com::zoho::shapes::Effects*>(p);
  }
  return _impl_.effects_;
}
inline ::com::zoho::shapes::Effects* PortionProps::mutable_effects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Effects* _msg = _internal_mutable_effects();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.effects)
  return _msg;
}
inline void PortionProps::set_allocated_effects(::com::zoho::shapes::Effects* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.effects_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.effects_ = reinterpret_cast<::com::zoho::shapes::Effects*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.effects)
}

// optional string postScriptName = 18;
inline bool PortionProps::has_postscriptname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PortionProps::clear_postscriptname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.postscriptname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PortionProps::postscriptname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.postScriptName)
  return _internal_postscriptname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortionProps::set_postscriptname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.postscriptname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.PortionProps.postScriptName)
}
inline std::string* PortionProps::mutable_postscriptname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_postscriptname();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.postScriptName)
  return _s;
}
inline const std::string& PortionProps::_internal_postscriptname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.postscriptname_.Get();
}
inline void PortionProps::_internal_set_postscriptname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.postscriptname_.Set(value, GetArena());
}
inline std::string* PortionProps::_internal_mutable_postscriptname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.postscriptname_.Mutable( GetArena());
}
inline std::string* PortionProps::release_postscriptname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.postScriptName)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.postscriptname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.postscriptname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PortionProps::set_allocated_postscriptname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.postscriptname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.postscriptname_.IsDefault()) {
          _impl_.postscriptname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.postScriptName)
}

// optional .com.zoho.shapes.TextLayerProperties textLayerProps = 19;
inline bool PortionProps::has_textlayerprops() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.textlayerprops_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::TextLayerProperties& PortionProps::_internal_textlayerprops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::TextLayerProperties* p = _impl_.textlayerprops_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::TextLayerProperties&>(::com::zoho::shapes::_TextLayerProperties_default_instance_);
}
inline const ::com::zoho::shapes::TextLayerProperties& PortionProps::textlayerprops() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.textLayerProps)
  return _internal_textlayerprops();
}
inline void PortionProps::unsafe_arena_set_allocated_textlayerprops(::com::zoho::shapes::TextLayerProperties* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textlayerprops_);
  }
  _impl_.textlayerprops_ = reinterpret_cast<::com::zoho::shapes::TextLayerProperties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.textLayerProps)
}
inline ::com::zoho::shapes::TextLayerProperties* PortionProps::release_textlayerprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::com::zoho::shapes::TextLayerProperties* released = _impl_.textlayerprops_;
  _impl_.textlayerprops_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::TextLayerProperties* PortionProps::unsafe_arena_release_textlayerprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.textLayerProps)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::com::zoho::shapes::TextLayerProperties* temp = _impl_.textlayerprops_;
  _impl_.textlayerprops_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::TextLayerProperties* PortionProps::_internal_mutable_textlayerprops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.textlayerprops_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::TextLayerProperties>(GetArena());
    _impl_.textlayerprops_ = reinterpret_cast<::com::zoho::shapes::TextLayerProperties*>(p);
  }
  return _impl_.textlayerprops_;
}
inline ::com::zoho::shapes::TextLayerProperties* PortionProps::mutable_textlayerprops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::TextLayerProperties* _msg = _internal_mutable_textlayerprops();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.textLayerProps)
  return _msg;
}
inline void PortionProps::set_allocated_textlayerprops(::com::zoho::shapes::TextLayerProperties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textlayerprops_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.textlayerprops_ = reinterpret_cast<::com::zoho::shapes::TextLayerProperties*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.textLayerProps)
}

// optional .com.zoho.shapes.StyleReferenceDetails styleRef = 20;
inline bool PortionProps::has_styleref() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.styleref_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::StyleReferenceDetails& PortionProps::_internal_styleref() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::StyleReferenceDetails* p = _impl_.styleref_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::StyleReferenceDetails&>(::com::zoho::shapes::_StyleReferenceDetails_default_instance_);
}
inline const ::com::zoho::shapes::StyleReferenceDetails& PortionProps::styleref() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.styleRef)
  return _internal_styleref();
}
inline void PortionProps::unsafe_arena_set_allocated_styleref(::com::zoho::shapes::StyleReferenceDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.styleref_);
  }
  _impl_.styleref_ = reinterpret_cast<::com::zoho::shapes::StyleReferenceDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.styleRef)
}
inline ::com::zoho::shapes::StyleReferenceDetails* PortionProps::release_styleref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::com::zoho::shapes::StyleReferenceDetails* released = _impl_.styleref_;
  _impl_.styleref_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::StyleReferenceDetails* PortionProps::unsafe_arena_release_styleref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.styleRef)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::com::zoho::shapes::StyleReferenceDetails* temp = _impl_.styleref_;
  _impl_.styleref_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::StyleReferenceDetails* PortionProps::_internal_mutable_styleref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.styleref_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::StyleReferenceDetails>(GetArena());
    _impl_.styleref_ = reinterpret_cast<::com::zoho::shapes::StyleReferenceDetails*>(p);
  }
  return _impl_.styleref_;
}
inline ::com::zoho::shapes::StyleReferenceDetails* PortionProps::mutable_styleref() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::StyleReferenceDetails* _msg = _internal_mutable_styleref();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.styleRef)
  return _msg;
}
inline void PortionProps::set_allocated_styleref(::com::zoho::shapes::StyleReferenceDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.styleref_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.styleref_ = reinterpret_cast<::com::zoho::shapes::StyleReferenceDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.styleRef)
}

// optional .com.zoho.shapes.Fill highlight = 21;
inline bool PortionProps::has_highlight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.highlight_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Fill& PortionProps::_internal_highlight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Fill* p = _impl_.highlight_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Fill&>(::com::zoho::shapes::_Fill_default_instance_);
}
inline const ::com::zoho::shapes::Fill& PortionProps::highlight() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.PortionProps.highlight)
  return _internal_highlight();
}
inline void PortionProps::unsafe_arena_set_allocated_highlight(::com::zoho::shapes::Fill* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.highlight_);
  }
  _impl_.highlight_ = reinterpret_cast<::com::zoho::shapes::Fill*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.PortionProps.highlight)
}
inline ::com::zoho::shapes::Fill* PortionProps::release_highlight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::com::zoho::shapes::Fill* released = _impl_.highlight_;
  _impl_.highlight_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Fill* PortionProps::unsafe_arena_release_highlight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.PortionProps.highlight)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::com::zoho::shapes::Fill* temp = _impl_.highlight_;
  _impl_.highlight_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Fill* PortionProps::_internal_mutable_highlight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.highlight_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Fill>(GetArena());
    _impl_.highlight_ = reinterpret_cast<::com::zoho::shapes::Fill*>(p);
  }
  return _impl_.highlight_;
}
inline ::com::zoho::shapes::Fill* PortionProps::mutable_highlight() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Fill* _msg = _internal_mutable_highlight();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.PortionProps.highlight)
  return _msg;
}
inline void PortionProps::set_allocated_highlight(::com::zoho::shapes::Fill* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.highlight_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.highlight_ = reinterpret_cast<::com::zoho::shapes::Fill*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.PortionProps.highlight)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState>() {
  return ::com::zoho::shapes::PortionProps_ReviewCheck_ReviewState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_portionprops_2eproto_2epb_2eh
