// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: picturefill.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PictureFill {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: PictureValue {
    get {return _storage._value ?? PictureValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  /// Contains properties like Color-Correction , Transparency etc...
  public var props: PictureProperties {
    get {return _storage._props ?? PictureProperties()}
    set {_uniqueStorage()._props = newValue}
  }
  /// Returns true if `props` has been explicitly set.
  public var hasProps: Bool {return _storage._props != nil}
  /// Clears the value of `props`. Subsequent reads from it will return its default value.
  public mutating func clearProps() {_uniqueStorage()._props = nil}

  /// This value has been moved to "pictureproperties.proto" as variable "alpha" 
  /// So that we shall use it both For Picture and PictureFill. We will not use this any further for rendering.
  public var transparency: Float {
    get {return _storage._transparency ?? 0}
    set {_uniqueStorage()._transparency = newValue}
  }
  /// Returns true if `transparency` has been explicitly set.
  public var hasTransparency: Bool {return _storage._transparency != nil}
  /// Clears the value of `transparency`. Subsequent reads from it will return its default value.
  public mutating func clearTransparency() {_uniqueStorage()._transparency = nil}

  /// type of picture fill		
  public var type: PictureFill.PictureFillType {
    get {return _storage._type ?? PictureFill.PictureFillType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PictureFillType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: PictureFill.PictureFillType.FillPictureAs {
      get {return _type ?? .frame}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var frame: Offset {
      get {return _frame ?? Offset()}
      set {_frame = newValue}
    }
    /// Returns true if `frame` has been explicitly set.
    public var hasFrame: Bool {return self._frame != nil}
    /// Clears the value of `frame`. Subsequent reads from it will return its default value.
    public mutating func clearFrame() {self._frame = nil}

    /// Tile properties.
    public var tile: PictureFill.PictureFillType.Tile {
      get {return _tile ?? PictureFill.PictureFillType.Tile()}
      set {_tile = newValue}
    }
    /// Returns true if `tile` has been explicitly set.
    public var hasTile: Bool {return self._tile != nil}
    /// Clears the value of `tile`. Subsequent reads from it will return its default value.
    public mutating func clearTile() {self._tile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum FillPictureAs: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case frame // = 0
      case tile // = 1
      case fill // = 2
      case fit // = 3

      public init() {
        self = .frame
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .frame
        case 1: self = .tile
        case 2: self = .fill
        case 3: self = .fit
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .frame: return 0
        case .tile: return 1
        case .fill: return 2
        case .fit: return 3
        }
      }

    }

    public struct Tile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// x offset in px.
      public var offsetX: Float {
        get {return _offsetX ?? 0}
        set {_offsetX = newValue}
      }
      /// Returns true if `offsetX` has been explicitly set.
      public var hasOffsetX: Bool {return self._offsetX != nil}
      /// Clears the value of `offsetX`. Subsequent reads from it will return its default value.
      public mutating func clearOffsetX() {self._offsetX = nil}

      /// y offset in px.
      public var offsetY: Float {
        get {return _offsetY ?? 0}
        set {_offsetY = newValue}
      }
      /// Returns true if `offsetY` has been explicitly set.
      public var hasOffsetY: Bool {return self._offsetY != nil}
      /// Clears the value of `offsetY`. Subsequent reads from it will return its default value.
      public mutating func clearOffsetY() {self._offsetY = nil}

      /// To scale the image.
      public var scale: Scale {
        get {return _scale ?? Scale()}
        set {_scale = newValue}
      }
      /// Returns true if `scale` has been explicitly set.
      public var hasScale: Bool {return self._scale != nil}
      /// Clears the value of `scale`. Subsequent reads from it will return its default value.
      public mutating func clearScale() {self._scale = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _offsetX: Float? = nil
      fileprivate var _offsetY: Float? = nil
      fileprivate var _scale: Scale? = nil
    }

    public init() {}

    fileprivate var _type: PictureFill.PictureFillType.FillPictureAs? = nil
    fileprivate var _frame: Offset? = nil
    fileprivate var _tile: PictureFill.PictureFillType.Tile? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension PictureFill.PictureFillType.FillPictureAs: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension PictureFill: @unchecked Sendable {}
extension PictureFill.PictureFillType: @unchecked Sendable {}
extension PictureFill.PictureFillType.FillPictureAs: @unchecked Sendable {}
extension PictureFill.PictureFillType.Tile: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension PictureFill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureFill"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "props"),
    3: .same(proto: "transparency"),
    4: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _value: PictureValue? = nil
    var _props: PictureProperties? = nil
    var _transparency: Float? = nil
    var _type: PictureFill.PictureFillType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _props = source._props
      _transparency = source._transparency
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._value == nil {return false}
      if _storage._type == nil {return false}
      if let v = _storage._value, !v.isInitialized {return false}
      if let v = _storage._props, !v.isInitialized {return false}
      if let v = _storage._type, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._props) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._transparency) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._type) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._props {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._transparency {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureFill, rhs: PictureFill) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._props != rhs_storage._props {return false}
        if _storage._transparency != rhs_storage._transparency {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureFill.PictureFillType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PictureFill.protoMessageName + ".PictureFillType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "frame"),
    3: .same(proto: "tile"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._frame) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._frame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureFill.PictureFillType, rhs: PictureFill.PictureFillType) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._frame != rhs._frame {return false}
    if lhs._tile != rhs._tile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureFill.PictureFillType.FillPictureAs: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRAME"),
    1: .same(proto: "TILE"),
    2: .same(proto: "FILL"),
    3: .same(proto: "FIT"),
  ]
}

extension PictureFill.PictureFillType.Tile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PictureFill.PictureFillType.protoMessageName + ".Tile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offsetX"),
    2: .same(proto: "offsetY"),
    3: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._offsetX) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._offsetY) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._scale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offsetX {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offsetY {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._scale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureFill.PictureFillType.Tile, rhs: PictureFill.PictureFillType.Tile) -> Bool {
    if lhs._offsetX != rhs._offsetX {return false}
    if lhs._offsetY != rhs._offsetY {return false}
    if lhs._scale != rhs._scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
