// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blur.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_blur_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_blur_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "position.pb.h"
#include "google/protobuf/protoextensions.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_blur_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_blur_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_blur_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class Blur;
struct BlurDefaultTypeInternal;
extern BlurDefaultTypeInternal _Blur_default_instance_;
class Blur_BaseBlur;
struct Blur_BaseBlurDefaultTypeInternal;
extern Blur_BaseBlurDefaultTypeInternal _Blur_BaseBlur_default_instance_;
class Blur_MotionBlur;
struct Blur_MotionBlurDefaultTypeInternal;
extern Blur_MotionBlurDefaultTypeInternal _Blur_MotionBlur_default_instance_;
class Blur_ZoomBlur;
struct Blur_ZoomBlurDefaultTypeInternal;
extern Blur_ZoomBlurDefaultTypeInternal _Blur_ZoomBlur_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {
enum Blur_BlurType : int {
  Blur_BlurType_UNKNOWN_TYPE = 0,
  Blur_BlurType_BOX = 1,
  Blur_BlurType_DISC = 2,
  Blur_BlurType_GAUSSIAN = 3,
  Blur_BlurType_MOTION = 4,
  Blur_BlurType_ZOOM = 5,
  Blur_BlurType_MASKED = 6,
  Blur_BlurType_Blur_BlurType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Blur_BlurType_Blur_BlurType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Blur_BlurType_IsValid(int value);
extern const uint32_t Blur_BlurType_internal_data_[];
constexpr Blur_BlurType Blur_BlurType_BlurType_MIN = static_cast<Blur_BlurType>(0);
constexpr Blur_BlurType Blur_BlurType_BlurType_MAX = static_cast<Blur_BlurType>(6);
constexpr int Blur_BlurType_BlurType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
Blur_BlurType_descriptor();
template <typename T>
const std::string& Blur_BlurType_Name(T value) {
  static_assert(std::is_same<T, Blur_BlurType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BlurType_Name().");
  return Blur_BlurType_Name(static_cast<Blur_BlurType>(value));
}
template <>
inline const std::string& Blur_BlurType_Name(Blur_BlurType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Blur_BlurType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool Blur_BlurType_Parse(absl::string_view name, Blur_BlurType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Blur_BlurType>(
      Blur_BlurType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Blur_MotionBlur final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Blur.MotionBlur) */ {
 public:
  inline Blur_MotionBlur() : Blur_MotionBlur(nullptr) {}
  ~Blur_MotionBlur() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Blur_MotionBlur(::google::protobuf::internal::ConstantInitialized);

  inline Blur_MotionBlur(const Blur_MotionBlur& from)
      : Blur_MotionBlur(nullptr, from) {}
  Blur_MotionBlur(Blur_MotionBlur&& from) noexcept
    : Blur_MotionBlur() {
    *this = ::std::move(from);
  }

  inline Blur_MotionBlur& operator=(const Blur_MotionBlur& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blur_MotionBlur& operator=(Blur_MotionBlur&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blur_MotionBlur& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blur_MotionBlur* internal_default_instance() {
    return reinterpret_cast<const Blur_MotionBlur*>(
               &_Blur_MotionBlur_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Blur_MotionBlur& a, Blur_MotionBlur& b) {
    a.Swap(&b);
  }
  inline void Swap(Blur_MotionBlur* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blur_MotionBlur* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Blur_MotionBlur* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Blur_MotionBlur>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Blur_MotionBlur& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Blur_MotionBlur& from) {
    Blur_MotionBlur::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Blur_MotionBlur* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Blur.MotionBlur";
  }
  protected:
  explicit Blur_MotionBlur(::google::protobuf::Arena* arena);
  Blur_MotionBlur(::google::protobuf::Arena* arena, const Blur_MotionBlur& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
    kAngleFieldNumber = 2,
  };
  // optional float radius = 1;
  bool has_radius() const;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // optional float angle = 2;
  bool has_angle() const;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Blur.MotionBlur)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float radius_;
    float angle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_blur_2eproto;
};// -------------------------------------------------------------------

class Blur_BaseBlur final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Blur.BaseBlur) */ {
 public:
  inline Blur_BaseBlur() : Blur_BaseBlur(nullptr) {}
  ~Blur_BaseBlur() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Blur_BaseBlur(::google::protobuf::internal::ConstantInitialized);

  inline Blur_BaseBlur(const Blur_BaseBlur& from)
      : Blur_BaseBlur(nullptr, from) {}
  Blur_BaseBlur(Blur_BaseBlur&& from) noexcept
    : Blur_BaseBlur() {
    *this = ::std::move(from);
  }

  inline Blur_BaseBlur& operator=(const Blur_BaseBlur& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blur_BaseBlur& operator=(Blur_BaseBlur&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blur_BaseBlur& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blur_BaseBlur* internal_default_instance() {
    return reinterpret_cast<const Blur_BaseBlur*>(
               &_Blur_BaseBlur_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Blur_BaseBlur& a, Blur_BaseBlur& b) {
    a.Swap(&b);
  }
  inline void Swap(Blur_BaseBlur* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blur_BaseBlur* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Blur_BaseBlur* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Blur_BaseBlur>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Blur_BaseBlur& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Blur_BaseBlur& from) {
    Blur_BaseBlur::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Blur_BaseBlur* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Blur.BaseBlur";
  }
  protected:
  explicit Blur_BaseBlur(::google::protobuf::Arena* arena);
  Blur_BaseBlur(::google::protobuf::Arena* arena, const Blur_BaseBlur& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
  };
  // optional float radius = 1;
  bool has_radius() const;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Blur.BaseBlur)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float radius_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_blur_2eproto;
};// -------------------------------------------------------------------

class Blur_ZoomBlur final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Blur.ZoomBlur) */ {
 public:
  inline Blur_ZoomBlur() : Blur_ZoomBlur(nullptr) {}
  ~Blur_ZoomBlur() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Blur_ZoomBlur(::google::protobuf::internal::ConstantInitialized);

  inline Blur_ZoomBlur(const Blur_ZoomBlur& from)
      : Blur_ZoomBlur(nullptr, from) {}
  Blur_ZoomBlur(Blur_ZoomBlur&& from) noexcept
    : Blur_ZoomBlur() {
    *this = ::std::move(from);
  }

  inline Blur_ZoomBlur& operator=(const Blur_ZoomBlur& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blur_ZoomBlur& operator=(Blur_ZoomBlur&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blur_ZoomBlur& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blur_ZoomBlur* internal_default_instance() {
    return reinterpret_cast<const Blur_ZoomBlur*>(
               &_Blur_ZoomBlur_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Blur_ZoomBlur& a, Blur_ZoomBlur& b) {
    a.Swap(&b);
  }
  inline void Swap(Blur_ZoomBlur* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blur_ZoomBlur* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Blur_ZoomBlur* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Blur_ZoomBlur>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Blur_ZoomBlur& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Blur_ZoomBlur& from) {
    Blur_ZoomBlur::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Blur_ZoomBlur* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Blur.ZoomBlur";
  }
  protected:
  explicit Blur_ZoomBlur(::google::protobuf::Arena* arena);
  Blur_ZoomBlur(::google::protobuf::Arena* arena, const Blur_ZoomBlur& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 1,
    kDistanceFieldNumber = 2,
  };
  // optional .com.zoho.common.Position center = 1;
  bool has_center() const;
  void clear_center() ;
  const ::com::zoho::common::Position& center() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Position* release_center();
  ::com::zoho::common::Position* mutable_center();
  void set_allocated_center(::com::zoho::common::Position* value);
  void unsafe_arena_set_allocated_center(::com::zoho::common::Position* value);
  ::com::zoho::common::Position* unsafe_arena_release_center();

  private:
  const ::com::zoho::common::Position& _internal_center() const;
  ::com::zoho::common::Position* _internal_mutable_center();

  public:
  // optional float distance = 2;
  bool has_distance() const;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  void temp_setcenter(com::zoho::common::Position* center) {
    if(&this->center() != center) {
      set_allocated_center(center);
    }
  }
  
  com::zoho::common::Position* temp_getcenter() const {
    if (has_center()) 
      return (const_cast<com::zoho::shapes::Blur_ZoomBlur*>(this))->mutable_center();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Blur.ZoomBlur)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::Position* center_;
    float distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_blur_2eproto;
};// -------------------------------------------------------------------

class Blur final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.Blur) */ {
 public:
  inline Blur() : Blur(nullptr) {}
  ~Blur() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Blur(::google::protobuf::internal::ConstantInitialized);

  inline Blur(const Blur& from)
      : Blur(nullptr, from) {}
  Blur(Blur&& from) noexcept
    : Blur() {
    *this = ::std::move(from);
  }

  inline Blur& operator=(const Blur& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blur& operator=(Blur&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blur& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blur* internal_default_instance() {
    return reinterpret_cast<const Blur*>(
               &_Blur_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Blur& a, Blur& b) {
    a.Swap(&b);
  }
  inline void Swap(Blur* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blur* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Blur* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Blur>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Blur& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Blur& from) {
    Blur::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Blur* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.Blur";
  }
  protected:
  explicit Blur(::google::protobuf::Arena* arena);
  Blur(::google::protobuf::Arena* arena, const Blur& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using BaseBlur = Blur_BaseBlur;
  using MotionBlur = Blur_MotionBlur;
  using ZoomBlur = Blur_ZoomBlur;

  using BlurType = Blur_BlurType;
  static constexpr BlurType UNKNOWN_TYPE = Blur_BlurType_UNKNOWN_TYPE;
  static constexpr BlurType BOX = Blur_BlurType_BOX;
  static constexpr BlurType DISC = Blur_BlurType_DISC;
  static constexpr BlurType GAUSSIAN = Blur_BlurType_GAUSSIAN;
  static constexpr BlurType MOTION = Blur_BlurType_MOTION;
  static constexpr BlurType ZOOM = Blur_BlurType_ZOOM;
  static constexpr BlurType MASKED = Blur_BlurType_MASKED;
  static inline bool BlurType_IsValid(int value) {
    return Blur_BlurType_IsValid(value);
  }
  static constexpr BlurType BlurType_MIN = Blur_BlurType_BlurType_MIN;
  static constexpr BlurType BlurType_MAX = Blur_BlurType_BlurType_MAX;
  static constexpr int BlurType_ARRAYSIZE = Blur_BlurType_BlurType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BlurType_descriptor() {
    return Blur_BlurType_descriptor();
  }
  template <typename T>
  static inline const std::string& BlurType_Name(T value) {
    return Blur_BlurType_Name(value);
  }
  static inline bool BlurType_Parse(absl::string_view name, BlurType* value) {
    return Blur_BlurType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBoxFieldNumber = 2,
    kDiscFieldNumber = 3,
    kGaussianFieldNumber = 4,
    kMotionFieldNumber = 5,
    kZoomFieldNumber = 6,
    kMaskedFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.Blur.BaseBlur box = 2;
  bool has_box() const;
  void clear_box() ;
  const ::com::zoho::shapes::Blur_BaseBlur& box() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Blur_BaseBlur* release_box();
  ::com::zoho::shapes::Blur_BaseBlur* mutable_box();
  void set_allocated_box(::com::zoho::shapes::Blur_BaseBlur* value);
  void unsafe_arena_set_allocated_box(::com::zoho::shapes::Blur_BaseBlur* value);
  ::com::zoho::shapes::Blur_BaseBlur* unsafe_arena_release_box();

  private:
  const ::com::zoho::shapes::Blur_BaseBlur& _internal_box() const;
  ::com::zoho::shapes::Blur_BaseBlur* _internal_mutable_box();

  public:
  // optional .com.zoho.shapes.Blur.BaseBlur disc = 3;
  bool has_disc() const;
  void clear_disc() ;
  const ::com::zoho::shapes::Blur_BaseBlur& disc() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Blur_BaseBlur* release_disc();
  ::com::zoho::shapes::Blur_BaseBlur* mutable_disc();
  void set_allocated_disc(::com::zoho::shapes::Blur_BaseBlur* value);
  void unsafe_arena_set_allocated_disc(::com::zoho::shapes::Blur_BaseBlur* value);
  ::com::zoho::shapes::Blur_BaseBlur* unsafe_arena_release_disc();

  private:
  const ::com::zoho::shapes::Blur_BaseBlur& _internal_disc() const;
  ::com::zoho::shapes::Blur_BaseBlur* _internal_mutable_disc();

  public:
  // optional .com.zoho.shapes.Blur.BaseBlur gaussian = 4;
  bool has_gaussian() const;
  void clear_gaussian() ;
  const ::com::zoho::shapes::Blur_BaseBlur& gaussian() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Blur_BaseBlur* release_gaussian();
  ::com::zoho::shapes::Blur_BaseBlur* mutable_gaussian();
  void set_allocated_gaussian(::com::zoho::shapes::Blur_BaseBlur* value);
  void unsafe_arena_set_allocated_gaussian(::com::zoho::shapes::Blur_BaseBlur* value);
  ::com::zoho::shapes::Blur_BaseBlur* unsafe_arena_release_gaussian();

  private:
  const ::com::zoho::shapes::Blur_BaseBlur& _internal_gaussian() const;
  ::com::zoho::shapes::Blur_BaseBlur* _internal_mutable_gaussian();

  public:
  // optional .com.zoho.shapes.Blur.MotionBlur motion = 5;
  bool has_motion() const;
  void clear_motion() ;
  const ::com::zoho::shapes::Blur_MotionBlur& motion() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Blur_MotionBlur* release_motion();
  ::com::zoho::shapes::Blur_MotionBlur* mutable_motion();
  void set_allocated_motion(::com::zoho::shapes::Blur_MotionBlur* value);
  void unsafe_arena_set_allocated_motion(::com::zoho::shapes::Blur_MotionBlur* value);
  ::com::zoho::shapes::Blur_MotionBlur* unsafe_arena_release_motion();

  private:
  const ::com::zoho::shapes::Blur_MotionBlur& _internal_motion() const;
  ::com::zoho::shapes::Blur_MotionBlur* _internal_mutable_motion();

  public:
  // optional .com.zoho.shapes.Blur.ZoomBlur zoom = 6;
  bool has_zoom() const;
  void clear_zoom() ;
  const ::com::zoho::shapes::Blur_ZoomBlur& zoom() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Blur_ZoomBlur* release_zoom();
  ::com::zoho::shapes::Blur_ZoomBlur* mutable_zoom();
  void set_allocated_zoom(::com::zoho::shapes::Blur_ZoomBlur* value);
  void unsafe_arena_set_allocated_zoom(::com::zoho::shapes::Blur_ZoomBlur* value);
  ::com::zoho::shapes::Blur_ZoomBlur* unsafe_arena_release_zoom();

  private:
  const ::com::zoho::shapes::Blur_ZoomBlur& _internal_zoom() const;
  ::com::zoho::shapes::Blur_ZoomBlur* _internal_mutable_zoom();

  public:
  // optional .com.zoho.shapes.Blur.BaseBlur masked = 7;
  bool has_masked() const;
  void clear_masked() ;
  const ::com::zoho::shapes::Blur_BaseBlur& masked() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Blur_BaseBlur* release_masked();
  ::com::zoho::shapes::Blur_BaseBlur* mutable_masked();
  void set_allocated_masked(::com::zoho::shapes::Blur_BaseBlur* value);
  void unsafe_arena_set_allocated_masked(::com::zoho::shapes::Blur_BaseBlur* value);
  ::com::zoho::shapes::Blur_BaseBlur* unsafe_arena_release_masked();

  private:
  const ::com::zoho::shapes::Blur_BaseBlur& _internal_masked() const;
  ::com::zoho::shapes::Blur_BaseBlur* _internal_mutable_masked();

  public:
  // optional .com.zoho.shapes.Blur.BlurType type = 1 [(.com.zoho.common.customOptions) = {
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::Blur_BlurType type() const;
  void set_type(::com::zoho::shapes::Blur_BlurType value);

  private:
  ::com::zoho::shapes::Blur_BlurType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::Blur_BlurType value);

  public:
  void temp_setbox(com::zoho::shapes::Blur_BaseBlur* box) {
    if(&this->box() != box) {
      set_allocated_box(box);
    }
  }
  
  com::zoho::shapes::Blur_BaseBlur* temp_getbox() const {
    if (has_box()) 
      return (const_cast<com::zoho::shapes::Blur*>(this))->mutable_box();
    return nullptr;
  }
  
  void temp_setdisc(com::zoho::shapes::Blur_BaseBlur* disc) {
    if(&this->disc() != disc) {
      set_allocated_disc(disc);
    }
  }
  
  com::zoho::shapes::Blur_BaseBlur* temp_getdisc() const {
    if (has_disc()) 
      return (const_cast<com::zoho::shapes::Blur*>(this))->mutable_disc();
    return nullptr;
  }
  
  void temp_setgaussian(com::zoho::shapes::Blur_BaseBlur* gaussian) {
    if(&this->gaussian() != gaussian) {
      set_allocated_gaussian(gaussian);
    }
  }
  
  com::zoho::shapes::Blur_BaseBlur* temp_getgaussian() const {
    if (has_gaussian()) 
      return (const_cast<com::zoho::shapes::Blur*>(this))->mutable_gaussian();
    return nullptr;
  }
  
  void temp_setmotion(com::zoho::shapes::Blur_MotionBlur* motion) {
    if(&this->motion() != motion) {
      set_allocated_motion(motion);
    }
  }
  
  com::zoho::shapes::Blur_MotionBlur* temp_getmotion() const {
    if (has_motion()) 
      return (const_cast<com::zoho::shapes::Blur*>(this))->mutable_motion();
    return nullptr;
  }
  
  void temp_setzoom(com::zoho::shapes::Blur_ZoomBlur* zoom) {
    if(&this->zoom() != zoom) {
      set_allocated_zoom(zoom);
    }
  }
  
  com::zoho::shapes::Blur_ZoomBlur* temp_getzoom() const {
    if (has_zoom()) 
      return (const_cast<com::zoho::shapes::Blur*>(this))->mutable_zoom();
    return nullptr;
  }
  
  void temp_setmasked(com::zoho::shapes::Blur_BaseBlur* masked) {
    if(&this->masked() != masked) {
      set_allocated_masked(masked);
    }
  }
  
  com::zoho::shapes::Blur_BaseBlur* temp_getmasked() const {
    if (has_masked()) 
      return (const_cast<com::zoho::shapes::Blur*>(this))->mutable_masked();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.Blur)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::Blur_BaseBlur* box_;
    ::com::zoho::shapes::Blur_BaseBlur* disc_;
    ::com::zoho::shapes::Blur_BaseBlur* gaussian_;
    ::com::zoho::shapes::Blur_MotionBlur* motion_;
    ::com::zoho::shapes::Blur_ZoomBlur* zoom_;
    ::com::zoho::shapes::Blur_BaseBlur* masked_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_blur_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Blur_BaseBlur

// optional float radius = 1;
inline bool Blur_BaseBlur::has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Blur_BaseBlur::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Blur_BaseBlur::radius() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.BaseBlur.radius)
  return _internal_radius();
}
inline void Blur_BaseBlur::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Blur.BaseBlur.radius)
}
inline float Blur_BaseBlur::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void Blur_BaseBlur::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// Blur_MotionBlur

// optional float radius = 1;
inline bool Blur_MotionBlur::has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Blur_MotionBlur::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Blur_MotionBlur::radius() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.MotionBlur.radius)
  return _internal_radius();
}
inline void Blur_MotionBlur::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Blur.MotionBlur.radius)
}
inline float Blur_MotionBlur::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void Blur_MotionBlur::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.radius_ = value;
}

// optional float angle = 2;
inline bool Blur_MotionBlur::has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Blur_MotionBlur::clear_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Blur_MotionBlur::angle() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.MotionBlur.angle)
  return _internal_angle();
}
inline void Blur_MotionBlur::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Blur.MotionBlur.angle)
}
inline float Blur_MotionBlur::_internal_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_;
}
inline void Blur_MotionBlur::_internal_set_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// Blur_ZoomBlur

// optional .com.zoho.common.Position center = 1;
inline bool Blur_ZoomBlur::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Position& Blur_ZoomBlur::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Position* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Position&>(::com::zoho::common::_Position_default_instance_);
}
inline const ::com::zoho::common::Position& Blur_ZoomBlur::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.ZoomBlur.center)
  return _internal_center();
}
inline void Blur_ZoomBlur::unsafe_arena_set_allocated_center(::com::zoho::common::Position* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::com::zoho::common::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Blur.ZoomBlur.center)
}
inline ::com::zoho::common::Position* Blur_ZoomBlur::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Position* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Position* Blur_ZoomBlur::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Blur.ZoomBlur.center)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Position* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Position* Blur_ZoomBlur::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Position>(GetArena());
    _impl_.center_ = reinterpret_cast<::com::zoho::common::Position*>(p);
  }
  return _impl_.center_;
}
inline ::com::zoho::common::Position* Blur_ZoomBlur::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Position* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Blur.ZoomBlur.center)
  return _msg;
}
inline void Blur_ZoomBlur::set_allocated_center(::com::zoho::common::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_ = reinterpret_cast<::com::zoho::common::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Blur.ZoomBlur.center)
}

// optional float distance = 2;
inline bool Blur_ZoomBlur::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Blur_ZoomBlur::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Blur_ZoomBlur::distance() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.ZoomBlur.distance)
  return _internal_distance();
}
inline void Blur_ZoomBlur::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Blur.ZoomBlur.distance)
}
inline float Blur_ZoomBlur::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void Blur_ZoomBlur::_internal_set_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.distance_ = value;
}

// -------------------------------------------------------------------

// Blur

// optional .com.zoho.shapes.Blur.BlurType type = 1 [(.com.zoho.common.customOptions) = {
inline bool Blur::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Blur::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::com::zoho::shapes::Blur_BlurType Blur::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.type)
  return _internal_type();
}
inline void Blur::set_type(::com::zoho::shapes::Blur_BlurType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.Blur.type)
}
inline ::com::zoho::shapes::Blur_BlurType Blur::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::Blur_BlurType>(_impl_.type_);
}
inline void Blur::_internal_set_type(::com::zoho::shapes::Blur_BlurType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.Blur.BaseBlur box = 2;
inline bool Blur::has_box() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.box_ != nullptr);
  return value;
}
inline void Blur::clear_box() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.box_ != nullptr) _impl_.box_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::_internal_box() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Blur_BaseBlur* p = _impl_.box_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Blur_BaseBlur&>(::com::zoho::shapes::_Blur_BaseBlur_default_instance_);
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::box() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.box)
  return _internal_box();
}
inline void Blur::unsafe_arena_set_allocated_box(::com::zoho::shapes::Blur_BaseBlur* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.box_);
  }
  _impl_.box_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Blur.box)
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::release_box() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::Blur_BaseBlur* released = _impl_.box_;
  _impl_.box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::unsafe_arena_release_box() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Blur.box)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::Blur_BaseBlur* temp = _impl_.box_;
  _impl_.box_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::_internal_mutable_box() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.box_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Blur_BaseBlur>(GetArena());
    _impl_.box_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(p);
  }
  return _impl_.box_;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::mutable_box() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Blur_BaseBlur* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Blur.box)
  return _msg;
}
inline void Blur::set_allocated_box(::com::zoho::shapes::Blur_BaseBlur* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(_impl_.box_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.box_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Blur.box)
}

// optional .com.zoho.shapes.Blur.BaseBlur disc = 3;
inline bool Blur::has_disc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.disc_ != nullptr);
  return value;
}
inline void Blur::clear_disc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.disc_ != nullptr) _impl_.disc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::_internal_disc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Blur_BaseBlur* p = _impl_.disc_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Blur_BaseBlur&>(::com::zoho::shapes::_Blur_BaseBlur_default_instance_);
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::disc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.disc)
  return _internal_disc();
}
inline void Blur::unsafe_arena_set_allocated_disc(::com::zoho::shapes::Blur_BaseBlur* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.disc_);
  }
  _impl_.disc_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Blur.disc)
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::release_disc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Blur_BaseBlur* released = _impl_.disc_;
  _impl_.disc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::unsafe_arena_release_disc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Blur.disc)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::Blur_BaseBlur* temp = _impl_.disc_;
  _impl_.disc_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::_internal_mutable_disc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.disc_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Blur_BaseBlur>(GetArena());
    _impl_.disc_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(p);
  }
  return _impl_.disc_;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::mutable_disc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Blur_BaseBlur* _msg = _internal_mutable_disc();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Blur.disc)
  return _msg;
}
inline void Blur::set_allocated_disc(::com::zoho::shapes::Blur_BaseBlur* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(_impl_.disc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.disc_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Blur.disc)
}

// optional .com.zoho.shapes.Blur.BaseBlur gaussian = 4;
inline bool Blur::has_gaussian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gaussian_ != nullptr);
  return value;
}
inline void Blur::clear_gaussian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.gaussian_ != nullptr) _impl_.gaussian_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::_internal_gaussian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Blur_BaseBlur* p = _impl_.gaussian_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Blur_BaseBlur&>(::com::zoho::shapes::_Blur_BaseBlur_default_instance_);
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::gaussian() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.gaussian)
  return _internal_gaussian();
}
inline void Blur::unsafe_arena_set_allocated_gaussian(::com::zoho::shapes::Blur_BaseBlur* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gaussian_);
  }
  _impl_.gaussian_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Blur.gaussian)
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::release_gaussian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Blur_BaseBlur* released = _impl_.gaussian_;
  _impl_.gaussian_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::unsafe_arena_release_gaussian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Blur.gaussian)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::Blur_BaseBlur* temp = _impl_.gaussian_;
  _impl_.gaussian_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::_internal_mutable_gaussian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.gaussian_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Blur_BaseBlur>(GetArena());
    _impl_.gaussian_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(p);
  }
  return _impl_.gaussian_;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::mutable_gaussian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Blur_BaseBlur* _msg = _internal_mutable_gaussian();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Blur.gaussian)
  return _msg;
}
inline void Blur::set_allocated_gaussian(::com::zoho::shapes::Blur_BaseBlur* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(_impl_.gaussian_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.gaussian_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Blur.gaussian)
}

// optional .com.zoho.shapes.Blur.MotionBlur motion = 5;
inline bool Blur::has_motion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.motion_ != nullptr);
  return value;
}
inline void Blur::clear_motion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.motion_ != nullptr) _impl_.motion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::com::zoho::shapes::Blur_MotionBlur& Blur::_internal_motion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Blur_MotionBlur* p = _impl_.motion_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Blur_MotionBlur&>(::com::zoho::shapes::_Blur_MotionBlur_default_instance_);
}
inline const ::com::zoho::shapes::Blur_MotionBlur& Blur::motion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.motion)
  return _internal_motion();
}
inline void Blur::unsafe_arena_set_allocated_motion(::com::zoho::shapes::Blur_MotionBlur* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.motion_);
  }
  _impl_.motion_ = reinterpret_cast<::com::zoho::shapes::Blur_MotionBlur*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Blur.motion)
}
inline ::com::zoho::shapes::Blur_MotionBlur* Blur::release_motion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Blur_MotionBlur* released = _impl_.motion_;
  _impl_.motion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Blur_MotionBlur* Blur::unsafe_arena_release_motion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Blur.motion)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::Blur_MotionBlur* temp = _impl_.motion_;
  _impl_.motion_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Blur_MotionBlur* Blur::_internal_mutable_motion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.motion_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Blur_MotionBlur>(GetArena());
    _impl_.motion_ = reinterpret_cast<::com::zoho::shapes::Blur_MotionBlur*>(p);
  }
  return _impl_.motion_;
}
inline ::com::zoho::shapes::Blur_MotionBlur* Blur::mutable_motion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Blur_MotionBlur* _msg = _internal_mutable_motion();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Blur.motion)
  return _msg;
}
inline void Blur::set_allocated_motion(::com::zoho::shapes::Blur_MotionBlur* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Blur_MotionBlur*>(_impl_.motion_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Blur_MotionBlur*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.motion_ = reinterpret_cast<::com::zoho::shapes::Blur_MotionBlur*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Blur.motion)
}

// optional .com.zoho.shapes.Blur.ZoomBlur zoom = 6;
inline bool Blur::has_zoom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.zoom_ != nullptr);
  return value;
}
inline void Blur::clear_zoom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.zoom_ != nullptr) _impl_.zoom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::com::zoho::shapes::Blur_ZoomBlur& Blur::_internal_zoom() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Blur_ZoomBlur* p = _impl_.zoom_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Blur_ZoomBlur&>(::com::zoho::shapes::_Blur_ZoomBlur_default_instance_);
}
inline const ::com::zoho::shapes::Blur_ZoomBlur& Blur::zoom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.zoom)
  return _internal_zoom();
}
inline void Blur::unsafe_arena_set_allocated_zoom(::com::zoho::shapes::Blur_ZoomBlur* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.zoom_);
  }
  _impl_.zoom_ = reinterpret_cast<::com::zoho::shapes::Blur_ZoomBlur*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Blur.zoom)
}
inline ::com::zoho::shapes::Blur_ZoomBlur* Blur::release_zoom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::Blur_ZoomBlur* released = _impl_.zoom_;
  _impl_.zoom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Blur_ZoomBlur* Blur::unsafe_arena_release_zoom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Blur.zoom)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::Blur_ZoomBlur* temp = _impl_.zoom_;
  _impl_.zoom_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Blur_ZoomBlur* Blur::_internal_mutable_zoom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.zoom_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Blur_ZoomBlur>(GetArena());
    _impl_.zoom_ = reinterpret_cast<::com::zoho::shapes::Blur_ZoomBlur*>(p);
  }
  return _impl_.zoom_;
}
inline ::com::zoho::shapes::Blur_ZoomBlur* Blur::mutable_zoom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Blur_ZoomBlur* _msg = _internal_mutable_zoom();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Blur.zoom)
  return _msg;
}
inline void Blur::set_allocated_zoom(::com::zoho::shapes::Blur_ZoomBlur* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Blur_ZoomBlur*>(_impl_.zoom_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Blur_ZoomBlur*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.zoom_ = reinterpret_cast<::com::zoho::shapes::Blur_ZoomBlur*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Blur.zoom)
}

// optional .com.zoho.shapes.Blur.BaseBlur masked = 7;
inline bool Blur::has_masked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.masked_ != nullptr);
  return value;
}
inline void Blur::clear_masked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.masked_ != nullptr) _impl_.masked_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::_internal_masked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Blur_BaseBlur* p = _impl_.masked_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Blur_BaseBlur&>(::com::zoho::shapes::_Blur_BaseBlur_default_instance_);
}
inline const ::com::zoho::shapes::Blur_BaseBlur& Blur::masked() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.Blur.masked)
  return _internal_masked();
}
inline void Blur::unsafe_arena_set_allocated_masked(::com::zoho::shapes::Blur_BaseBlur* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.masked_);
  }
  _impl_.masked_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.Blur.masked)
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::release_masked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::Blur_BaseBlur* released = _impl_.masked_;
  _impl_.masked_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::unsafe_arena_release_masked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.Blur.masked)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::Blur_BaseBlur* temp = _impl_.masked_;
  _impl_.masked_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::_internal_mutable_masked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.masked_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Blur_BaseBlur>(GetArena());
    _impl_.masked_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(p);
  }
  return _impl_.masked_;
}
inline ::com::zoho::shapes::Blur_BaseBlur* Blur::mutable_masked() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Blur_BaseBlur* _msg = _internal_mutable_masked();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.Blur.masked)
  return _msg;
}
inline void Blur::set_allocated_masked(::com::zoho::shapes::Blur_BaseBlur* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(_impl_.masked_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.masked_ = reinterpret_cast<::com::zoho::shapes::Blur_BaseBlur*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.Blur.masked)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::shapes::Blur_BlurType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::Blur_BlurType>() {
  return ::com::zoho::shapes::Blur_BlurType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_blur_2eproto_2epb_2eh
