// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: numberformat.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_numberformat_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_numberformat_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_numberformat_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_numberformat_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_numberformat_2eproto;
namespace com {
namespace zoho {
namespace common {
class NumberFormat;
struct NumberFormatDefaultTypeInternal;
extern NumberFormatDefaultTypeInternal _NumberFormat_default_instance_;
class NumberFormat_Currency;
struct NumberFormat_CurrencyDefaultTypeInternal;
extern NumberFormat_CurrencyDefaultTypeInternal _NumberFormat_Currency_default_instance_;
class NumberFormat_FractionFormat;
struct NumberFormat_FractionFormatDefaultTypeInternal;
extern NumberFormat_FractionFormatDefaultTypeInternal _NumberFormat_FractionFormat_default_instance_;
class NumberFormat_NumberSeparator;
struct NumberFormat_NumberSeparatorDefaultTypeInternal;
extern NumberFormat_NumberSeparatorDefaultTypeInternal _NumberFormat_NumberSeparator_default_instance_;
}  // namespace common
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace common {
enum NumberFormat_NumberSeparator_NumberSeparatorType : int {
  NumberFormat_NumberSeparator_NumberSeparatorType_UNKNOWN_NUMBERSEPARATOR_TYPE = 0,
  NumberFormat_NumberSeparator_NumberSeparatorType_COMMA = 1,
  NumberFormat_NumberSeparator_NumberSeparatorType_PERIOD = 2,
  NumberFormat_NumberSeparator_NumberSeparatorType_SPACE = 3,
  NumberFormat_NumberSeparator_NumberSeparatorType_NumberFormat_NumberSeparator_NumberSeparatorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NumberFormat_NumberSeparator_NumberSeparatorType_NumberFormat_NumberSeparator_NumberSeparatorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NumberFormat_NumberSeparator_NumberSeparatorType_IsValid(int value);
extern const uint32_t NumberFormat_NumberSeparator_NumberSeparatorType_internal_data_[];
constexpr NumberFormat_NumberSeparator_NumberSeparatorType NumberFormat_NumberSeparator_NumberSeparatorType_NumberSeparatorType_MIN = static_cast<NumberFormat_NumberSeparator_NumberSeparatorType>(0);
constexpr NumberFormat_NumberSeparator_NumberSeparatorType NumberFormat_NumberSeparator_NumberSeparatorType_NumberSeparatorType_MAX = static_cast<NumberFormat_NumberSeparator_NumberSeparatorType>(3);
constexpr int NumberFormat_NumberSeparator_NumberSeparatorType_NumberSeparatorType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
NumberFormat_NumberSeparator_NumberSeparatorType_descriptor();
template <typename T>
const std::string& NumberFormat_NumberSeparator_NumberSeparatorType_Name(T value) {
  static_assert(std::is_same<T, NumberFormat_NumberSeparator_NumberSeparatorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NumberSeparatorType_Name().");
  return NumberFormat_NumberSeparator_NumberSeparatorType_Name(static_cast<NumberFormat_NumberSeparator_NumberSeparatorType>(value));
}
template <>
inline const std::string& NumberFormat_NumberSeparator_NumberSeparatorType_Name(NumberFormat_NumberSeparator_NumberSeparatorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NumberFormat_NumberSeparator_NumberSeparatorType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool NumberFormat_NumberSeparator_NumberSeparatorType_Parse(absl::string_view name, NumberFormat_NumberSeparator_NumberSeparatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumberFormat_NumberSeparator_NumberSeparatorType>(
      NumberFormat_NumberSeparator_NumberSeparatorType_descriptor(), name, value);
}
enum NumberFormat_Currency_CurrencyOfCountry : int {
  NumberFormat_Currency_CurrencyOfCountry_UNKNOWN_COUNTRY = 0,
  NumberFormat_Currency_CurrencyOfCountry_INDIA = 1,
  NumberFormat_Currency_CurrencyOfCountry_UNITED_STATES = 2,
  NumberFormat_Currency_CurrencyOfCountry_EUROPE = 3,
  NumberFormat_Currency_CurrencyOfCountry_UNITED_KINGDOM = 4,
  NumberFormat_Currency_CurrencyOfCountry_NumberFormat_Currency_CurrencyOfCountry_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NumberFormat_Currency_CurrencyOfCountry_NumberFormat_Currency_CurrencyOfCountry_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NumberFormat_Currency_CurrencyOfCountry_IsValid(int value);
extern const uint32_t NumberFormat_Currency_CurrencyOfCountry_internal_data_[];
constexpr NumberFormat_Currency_CurrencyOfCountry NumberFormat_Currency_CurrencyOfCountry_CurrencyOfCountry_MIN = static_cast<NumberFormat_Currency_CurrencyOfCountry>(0);
constexpr NumberFormat_Currency_CurrencyOfCountry NumberFormat_Currency_CurrencyOfCountry_CurrencyOfCountry_MAX = static_cast<NumberFormat_Currency_CurrencyOfCountry>(4);
constexpr int NumberFormat_Currency_CurrencyOfCountry_CurrencyOfCountry_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
NumberFormat_Currency_CurrencyOfCountry_descriptor();
template <typename T>
const std::string& NumberFormat_Currency_CurrencyOfCountry_Name(T value) {
  static_assert(std::is_same<T, NumberFormat_Currency_CurrencyOfCountry>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CurrencyOfCountry_Name().");
  return NumberFormat_Currency_CurrencyOfCountry_Name(static_cast<NumberFormat_Currency_CurrencyOfCountry>(value));
}
template <>
inline const std::string& NumberFormat_Currency_CurrencyOfCountry_Name(NumberFormat_Currency_CurrencyOfCountry value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NumberFormat_Currency_CurrencyOfCountry_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool NumberFormat_Currency_CurrencyOfCountry_Parse(absl::string_view name, NumberFormat_Currency_CurrencyOfCountry* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumberFormat_Currency_CurrencyOfCountry>(
      NumberFormat_Currency_CurrencyOfCountry_descriptor(), name, value);
}
enum NumberFormat_Currency_CurrencyRepresentation : int {
  NumberFormat_Currency_CurrencyRepresentation_UNKNOWN_CURRENCY_REPRESENTATION = 0,
  NumberFormat_Currency_CurrencyRepresentation_CURRENCY_CODE = 1,
  NumberFormat_Currency_CurrencyRepresentation_SYMBOL = 2,
  NumberFormat_Currency_CurrencyRepresentation_NumberFormat_Currency_CurrencyRepresentation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NumberFormat_Currency_CurrencyRepresentation_NumberFormat_Currency_CurrencyRepresentation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NumberFormat_Currency_CurrencyRepresentation_IsValid(int value);
extern const uint32_t NumberFormat_Currency_CurrencyRepresentation_internal_data_[];
constexpr NumberFormat_Currency_CurrencyRepresentation NumberFormat_Currency_CurrencyRepresentation_CurrencyRepresentation_MIN = static_cast<NumberFormat_Currency_CurrencyRepresentation>(0);
constexpr NumberFormat_Currency_CurrencyRepresentation NumberFormat_Currency_CurrencyRepresentation_CurrencyRepresentation_MAX = static_cast<NumberFormat_Currency_CurrencyRepresentation>(2);
constexpr int NumberFormat_Currency_CurrencyRepresentation_CurrencyRepresentation_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NumberFormat_Currency_CurrencyRepresentation_descriptor();
template <typename T>
const std::string& NumberFormat_Currency_CurrencyRepresentation_Name(T value) {
  static_assert(std::is_same<T, NumberFormat_Currency_CurrencyRepresentation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CurrencyRepresentation_Name().");
  return NumberFormat_Currency_CurrencyRepresentation_Name(static_cast<NumberFormat_Currency_CurrencyRepresentation>(value));
}
template <>
inline const std::string& NumberFormat_Currency_CurrencyRepresentation_Name(NumberFormat_Currency_CurrencyRepresentation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NumberFormat_Currency_CurrencyRepresentation_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NumberFormat_Currency_CurrencyRepresentation_Parse(absl::string_view name, NumberFormat_Currency_CurrencyRepresentation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumberFormat_Currency_CurrencyRepresentation>(
      NumberFormat_Currency_CurrencyRepresentation_descriptor(), name, value);
}
enum NumberFormat_FractionFormat_FractionFormatType : int {
  NumberFormat_FractionFormat_FractionFormatType_UNKNOWN_FRACTIONFORMAT_TYPE = 0,
  NumberFormat_FractionFormat_FractionFormatType_ONE_DIGIT = 1,
  NumberFormat_FractionFormat_FractionFormatType_TWO_DIGITS = 2,
  NumberFormat_FractionFormat_FractionFormatType_THREE_DIGITS = 3,
  NumberFormat_FractionFormat_FractionFormatType_NumberFormat_FractionFormat_FractionFormatType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NumberFormat_FractionFormat_FractionFormatType_NumberFormat_FractionFormat_FractionFormatType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NumberFormat_FractionFormat_FractionFormatType_IsValid(int value);
extern const uint32_t NumberFormat_FractionFormat_FractionFormatType_internal_data_[];
constexpr NumberFormat_FractionFormat_FractionFormatType NumberFormat_FractionFormat_FractionFormatType_FractionFormatType_MIN = static_cast<NumberFormat_FractionFormat_FractionFormatType>(0);
constexpr NumberFormat_FractionFormat_FractionFormatType NumberFormat_FractionFormat_FractionFormatType_FractionFormatType_MAX = static_cast<NumberFormat_FractionFormat_FractionFormatType>(3);
constexpr int NumberFormat_FractionFormat_FractionFormatType_FractionFormatType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
NumberFormat_FractionFormat_FractionFormatType_descriptor();
template <typename T>
const std::string& NumberFormat_FractionFormat_FractionFormatType_Name(T value) {
  static_assert(std::is_same<T, NumberFormat_FractionFormat_FractionFormatType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FractionFormatType_Name().");
  return NumberFormat_FractionFormat_FractionFormatType_Name(static_cast<NumberFormat_FractionFormat_FractionFormatType>(value));
}
template <>
inline const std::string& NumberFormat_FractionFormat_FractionFormatType_Name(NumberFormat_FractionFormat_FractionFormatType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NumberFormat_FractionFormat_FractionFormatType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool NumberFormat_FractionFormat_FractionFormatType_Parse(absl::string_view name, NumberFormat_FractionFormat_FractionFormatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumberFormat_FractionFormat_FractionFormatType>(
      NumberFormat_FractionFormat_FractionFormatType_descriptor(), name, value);
}
enum NumberFormat_NumberFormatType : int {
  NumberFormat_NumberFormatType_UNKNOWN_NUMBERFORMAT_TYPE = 0,
  NumberFormat_NumberFormatType_REGULAR = 1,
  NumberFormat_NumberFormatType_DECIMAL_NUMBER = 2,
  NumberFormat_NumberFormatType_FRACTION = 3,
  NumberFormat_NumberFormatType_PERCENTAGE = 4,
  NumberFormat_NumberFormatType_NumberFormat_NumberFormatType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NumberFormat_NumberFormatType_NumberFormat_NumberFormatType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NumberFormat_NumberFormatType_IsValid(int value);
extern const uint32_t NumberFormat_NumberFormatType_internal_data_[];
constexpr NumberFormat_NumberFormatType NumberFormat_NumberFormatType_NumberFormatType_MIN = static_cast<NumberFormat_NumberFormatType>(0);
constexpr NumberFormat_NumberFormatType NumberFormat_NumberFormatType_NumberFormatType_MAX = static_cast<NumberFormat_NumberFormatType>(4);
constexpr int NumberFormat_NumberFormatType_NumberFormatType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
NumberFormat_NumberFormatType_descriptor();
template <typename T>
const std::string& NumberFormat_NumberFormatType_Name(T value) {
  static_assert(std::is_same<T, NumberFormat_NumberFormatType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NumberFormatType_Name().");
  return NumberFormat_NumberFormatType_Name(static_cast<NumberFormat_NumberFormatType>(value));
}
template <>
inline const std::string& NumberFormat_NumberFormatType_Name(NumberFormat_NumberFormatType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NumberFormat_NumberFormatType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool NumberFormat_NumberFormatType_Parse(absl::string_view name, NumberFormat_NumberFormatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumberFormat_NumberFormatType>(
      NumberFormat_NumberFormatType_descriptor(), name, value);
}
enum NumberFormat_ThousandSeparatorType : int {
  NumberFormat_ThousandSeparatorType_UNKNOWN_THOUSANDSEPARATOR_TYPE = 0,
  NumberFormat_ThousandSeparatorType_INDIAN = 1,
  NumberFormat_ThousandSeparatorType_INTERNATIONAL = 2,
  NumberFormat_ThousandSeparatorType_NumberFormat_ThousandSeparatorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NumberFormat_ThousandSeparatorType_NumberFormat_ThousandSeparatorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NumberFormat_ThousandSeparatorType_IsValid(int value);
extern const uint32_t NumberFormat_ThousandSeparatorType_internal_data_[];
constexpr NumberFormat_ThousandSeparatorType NumberFormat_ThousandSeparatorType_ThousandSeparatorType_MIN = static_cast<NumberFormat_ThousandSeparatorType>(0);
constexpr NumberFormat_ThousandSeparatorType NumberFormat_ThousandSeparatorType_ThousandSeparatorType_MAX = static_cast<NumberFormat_ThousandSeparatorType>(2);
constexpr int NumberFormat_ThousandSeparatorType_ThousandSeparatorType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NumberFormat_ThousandSeparatorType_descriptor();
template <typename T>
const std::string& NumberFormat_ThousandSeparatorType_Name(T value) {
  static_assert(std::is_same<T, NumberFormat_ThousandSeparatorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ThousandSeparatorType_Name().");
  return NumberFormat_ThousandSeparatorType_Name(static_cast<NumberFormat_ThousandSeparatorType>(value));
}
template <>
inline const std::string& NumberFormat_ThousandSeparatorType_Name(NumberFormat_ThousandSeparatorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NumberFormat_ThousandSeparatorType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NumberFormat_ThousandSeparatorType_Parse(absl::string_view name, NumberFormat_ThousandSeparatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumberFormat_ThousandSeparatorType>(
      NumberFormat_ThousandSeparatorType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class NumberFormat_NumberSeparator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.common.NumberFormat.NumberSeparator) */ {
 public:
  inline NumberFormat_NumberSeparator() : NumberFormat_NumberSeparator(nullptr) {}
  ~NumberFormat_NumberSeparator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NumberFormat_NumberSeparator(::google::protobuf::internal::ConstantInitialized);

  inline NumberFormat_NumberSeparator(const NumberFormat_NumberSeparator& from)
      : NumberFormat_NumberSeparator(nullptr, from) {}
  NumberFormat_NumberSeparator(NumberFormat_NumberSeparator&& from) noexcept
    : NumberFormat_NumberSeparator() {
    *this = ::std::move(from);
  }

  inline NumberFormat_NumberSeparator& operator=(const NumberFormat_NumberSeparator& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberFormat_NumberSeparator& operator=(NumberFormat_NumberSeparator&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberFormat_NumberSeparator& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumberFormat_NumberSeparator* internal_default_instance() {
    return reinterpret_cast<const NumberFormat_NumberSeparator*>(
               &_NumberFormat_NumberSeparator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NumberFormat_NumberSeparator& a, NumberFormat_NumberSeparator& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberFormat_NumberSeparator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberFormat_NumberSeparator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumberFormat_NumberSeparator* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NumberFormat_NumberSeparator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumberFormat_NumberSeparator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NumberFormat_NumberSeparator& from) {
    NumberFormat_NumberSeparator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NumberFormat_NumberSeparator* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.common.NumberFormat.NumberSeparator";
  }
  protected:
  explicit NumberFormat_NumberSeparator(::google::protobuf::Arena* arena);
  NumberFormat_NumberSeparator(::google::protobuf::Arena* arena, const NumberFormat_NumberSeparator& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using NumberSeparatorType = NumberFormat_NumberSeparator_NumberSeparatorType;
  static constexpr NumberSeparatorType UNKNOWN_NUMBERSEPARATOR_TYPE = NumberFormat_NumberSeparator_NumberSeparatorType_UNKNOWN_NUMBERSEPARATOR_TYPE;
  static constexpr NumberSeparatorType COMMA = NumberFormat_NumberSeparator_NumberSeparatorType_COMMA;
  static constexpr NumberSeparatorType PERIOD = NumberFormat_NumberSeparator_NumberSeparatorType_PERIOD;
  static constexpr NumberSeparatorType SPACE = NumberFormat_NumberSeparator_NumberSeparatorType_SPACE;
  static inline bool NumberSeparatorType_IsValid(int value) {
    return NumberFormat_NumberSeparator_NumberSeparatorType_IsValid(value);
  }
  static constexpr NumberSeparatorType NumberSeparatorType_MIN = NumberFormat_NumberSeparator_NumberSeparatorType_NumberSeparatorType_MIN;
  static constexpr NumberSeparatorType NumberSeparatorType_MAX = NumberFormat_NumberSeparator_NumberSeparatorType_NumberSeparatorType_MAX;
  static constexpr int NumberSeparatorType_ARRAYSIZE = NumberFormat_NumberSeparator_NumberSeparatorType_NumberSeparatorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NumberSeparatorType_descriptor() {
    return NumberFormat_NumberSeparator_NumberSeparatorType_descriptor();
  }
  template <typename T>
  static inline const std::string& NumberSeparatorType_Name(T value) {
    return NumberFormat_NumberSeparator_NumberSeparatorType_Name(value);
  }
  static inline bool NumberSeparatorType_Parse(absl::string_view name, NumberSeparatorType* value) {
    return NumberFormat_NumberSeparator_NumberSeparatorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kThousandFieldNumber = 1,
    kDecimalFieldNumber = 2,
  };
  // optional .com.zoho.common.NumberFormat.NumberSeparator.NumberSeparatorType thousand = 1;
  bool has_thousand() const;
  void clear_thousand() ;
  ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType thousand() const;
  void set_thousand(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value);

  private:
  ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType _internal_thousand() const;
  void _internal_set_thousand(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value);

  public:
  // optional .com.zoho.common.NumberFormat.NumberSeparator.NumberSeparatorType decimal = 2;
  bool has_decimal() const;
  void clear_decimal() ;
  ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType decimal() const;
  void set_decimal(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value);

  private:
  ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType _internal_decimal() const;
  void _internal_set_decimal(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.common.NumberFormat.NumberSeparator)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int thousand_;
    int decimal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_numberformat_2eproto;
};// -------------------------------------------------------------------

class NumberFormat_FractionFormat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.common.NumberFormat.FractionFormat) */ {
 public:
  inline NumberFormat_FractionFormat() : NumberFormat_FractionFormat(nullptr) {}
  ~NumberFormat_FractionFormat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NumberFormat_FractionFormat(::google::protobuf::internal::ConstantInitialized);

  inline NumberFormat_FractionFormat(const NumberFormat_FractionFormat& from)
      : NumberFormat_FractionFormat(nullptr, from) {}
  NumberFormat_FractionFormat(NumberFormat_FractionFormat&& from) noexcept
    : NumberFormat_FractionFormat() {
    *this = ::std::move(from);
  }

  inline NumberFormat_FractionFormat& operator=(const NumberFormat_FractionFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberFormat_FractionFormat& operator=(NumberFormat_FractionFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberFormat_FractionFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumberFormat_FractionFormat* internal_default_instance() {
    return reinterpret_cast<const NumberFormat_FractionFormat*>(
               &_NumberFormat_FractionFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NumberFormat_FractionFormat& a, NumberFormat_FractionFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberFormat_FractionFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberFormat_FractionFormat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumberFormat_FractionFormat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NumberFormat_FractionFormat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumberFormat_FractionFormat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NumberFormat_FractionFormat& from) {
    NumberFormat_FractionFormat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NumberFormat_FractionFormat* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.common.NumberFormat.FractionFormat";
  }
  protected:
  explicit NumberFormat_FractionFormat(::google::protobuf::Arena* arena);
  NumberFormat_FractionFormat(::google::protobuf::Arena* arena, const NumberFormat_FractionFormat& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using FractionFormatType = NumberFormat_FractionFormat_FractionFormatType;
  static constexpr FractionFormatType UNKNOWN_FRACTIONFORMAT_TYPE = NumberFormat_FractionFormat_FractionFormatType_UNKNOWN_FRACTIONFORMAT_TYPE;
  static constexpr FractionFormatType ONE_DIGIT = NumberFormat_FractionFormat_FractionFormatType_ONE_DIGIT;
  static constexpr FractionFormatType TWO_DIGITS = NumberFormat_FractionFormat_FractionFormatType_TWO_DIGITS;
  static constexpr FractionFormatType THREE_DIGITS = NumberFormat_FractionFormat_FractionFormatType_THREE_DIGITS;
  static inline bool FractionFormatType_IsValid(int value) {
    return NumberFormat_FractionFormat_FractionFormatType_IsValid(value);
  }
  static constexpr FractionFormatType FractionFormatType_MIN = NumberFormat_FractionFormat_FractionFormatType_FractionFormatType_MIN;
  static constexpr FractionFormatType FractionFormatType_MAX = NumberFormat_FractionFormat_FractionFormatType_FractionFormatType_MAX;
  static constexpr int FractionFormatType_ARRAYSIZE = NumberFormat_FractionFormat_FractionFormatType_FractionFormatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FractionFormatType_descriptor() {
    return NumberFormat_FractionFormat_FractionFormatType_descriptor();
  }
  template <typename T>
  static inline const std::string& FractionFormatType_Name(T value) {
    return NumberFormat_FractionFormat_FractionFormatType_Name(value);
  }
  static inline bool FractionFormatType_Parse(absl::string_view name, FractionFormatType* value) {
    return NumberFormat_FractionFormat_FractionFormatType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 5,
  };
  // optional .com.zoho.common.NumberFormat.FractionFormat.FractionFormatType type = 5;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType type() const;
  void set_type(::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType value);

  private:
  ::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType _internal_type() const;
  void _internal_set_type(::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.common.NumberFormat.FractionFormat)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_numberformat_2eproto;
};// -------------------------------------------------------------------

class NumberFormat_Currency final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.common.NumberFormat.Currency) */ {
 public:
  inline NumberFormat_Currency() : NumberFormat_Currency(nullptr) {}
  ~NumberFormat_Currency() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NumberFormat_Currency(::google::protobuf::internal::ConstantInitialized);

  inline NumberFormat_Currency(const NumberFormat_Currency& from)
      : NumberFormat_Currency(nullptr, from) {}
  NumberFormat_Currency(NumberFormat_Currency&& from) noexcept
    : NumberFormat_Currency() {
    *this = ::std::move(from);
  }

  inline NumberFormat_Currency& operator=(const NumberFormat_Currency& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberFormat_Currency& operator=(NumberFormat_Currency&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberFormat_Currency& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumberFormat_Currency* internal_default_instance() {
    return reinterpret_cast<const NumberFormat_Currency*>(
               &_NumberFormat_Currency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NumberFormat_Currency& a, NumberFormat_Currency& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberFormat_Currency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberFormat_Currency* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumberFormat_Currency* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NumberFormat_Currency>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumberFormat_Currency& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NumberFormat_Currency& from) {
    NumberFormat_Currency::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NumberFormat_Currency* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.common.NumberFormat.Currency";
  }
  protected:
  explicit NumberFormat_Currency(::google::protobuf::Arena* arena);
  NumberFormat_Currency(::google::protobuf::Arena* arena, const NumberFormat_Currency& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CurrencyOfCountry = NumberFormat_Currency_CurrencyOfCountry;
  static constexpr CurrencyOfCountry UNKNOWN_COUNTRY = NumberFormat_Currency_CurrencyOfCountry_UNKNOWN_COUNTRY;
  static constexpr CurrencyOfCountry INDIA = NumberFormat_Currency_CurrencyOfCountry_INDIA;
  static constexpr CurrencyOfCountry UNITED_STATES = NumberFormat_Currency_CurrencyOfCountry_UNITED_STATES;
  static constexpr CurrencyOfCountry EUROPE = NumberFormat_Currency_CurrencyOfCountry_EUROPE;
  static constexpr CurrencyOfCountry UNITED_KINGDOM = NumberFormat_Currency_CurrencyOfCountry_UNITED_KINGDOM;
  static inline bool CurrencyOfCountry_IsValid(int value) {
    return NumberFormat_Currency_CurrencyOfCountry_IsValid(value);
  }
  static constexpr CurrencyOfCountry CurrencyOfCountry_MIN = NumberFormat_Currency_CurrencyOfCountry_CurrencyOfCountry_MIN;
  static constexpr CurrencyOfCountry CurrencyOfCountry_MAX = NumberFormat_Currency_CurrencyOfCountry_CurrencyOfCountry_MAX;
  static constexpr int CurrencyOfCountry_ARRAYSIZE = NumberFormat_Currency_CurrencyOfCountry_CurrencyOfCountry_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CurrencyOfCountry_descriptor() {
    return NumberFormat_Currency_CurrencyOfCountry_descriptor();
  }
  template <typename T>
  static inline const std::string& CurrencyOfCountry_Name(T value) {
    return NumberFormat_Currency_CurrencyOfCountry_Name(value);
  }
  static inline bool CurrencyOfCountry_Parse(absl::string_view name, CurrencyOfCountry* value) {
    return NumberFormat_Currency_CurrencyOfCountry_Parse(name, value);
  }

  using CurrencyRepresentation = NumberFormat_Currency_CurrencyRepresentation;
  static constexpr CurrencyRepresentation UNKNOWN_CURRENCY_REPRESENTATION = NumberFormat_Currency_CurrencyRepresentation_UNKNOWN_CURRENCY_REPRESENTATION;
  static constexpr CurrencyRepresentation CURRENCY_CODE = NumberFormat_Currency_CurrencyRepresentation_CURRENCY_CODE;
  static constexpr CurrencyRepresentation SYMBOL = NumberFormat_Currency_CurrencyRepresentation_SYMBOL;
  static inline bool CurrencyRepresentation_IsValid(int value) {
    return NumberFormat_Currency_CurrencyRepresentation_IsValid(value);
  }
  static constexpr CurrencyRepresentation CurrencyRepresentation_MIN = NumberFormat_Currency_CurrencyRepresentation_CurrencyRepresentation_MIN;
  static constexpr CurrencyRepresentation CurrencyRepresentation_MAX = NumberFormat_Currency_CurrencyRepresentation_CurrencyRepresentation_MAX;
  static constexpr int CurrencyRepresentation_ARRAYSIZE = NumberFormat_Currency_CurrencyRepresentation_CurrencyRepresentation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CurrencyRepresentation_descriptor() {
    return NumberFormat_Currency_CurrencyRepresentation_descriptor();
  }
  template <typename T>
  static inline const std::string& CurrencyRepresentation_Name(T value) {
    return NumberFormat_Currency_CurrencyRepresentation_Name(value);
  }
  static inline bool CurrencyRepresentation_Parse(absl::string_view name, CurrencyRepresentation* value) {
    return NumberFormat_Currency_CurrencyRepresentation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyOfCountryFieldNumber = 1,
    kBeforeValueFieldNumber = 2,
    kAfterValueFieldNumber = 3,
  };
  // optional .com.zoho.common.NumberFormat.Currency.CurrencyOfCountry currencyOfCountry = 1;
  bool has_currencyofcountry() const;
  void clear_currencyofcountry() ;
  ::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry currencyofcountry() const;
  void set_currencyofcountry(::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry value);

  private:
  ::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry _internal_currencyofcountry() const;
  void _internal_set_currencyofcountry(::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry value);

  public:
  // optional .com.zoho.common.NumberFormat.Currency.CurrencyRepresentation beforeValue = 2;
  bool has_beforevalue() const;
  void clear_beforevalue() ;
  ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation beforevalue() const;
  void set_beforevalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value);

  private:
  ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation _internal_beforevalue() const;
  void _internal_set_beforevalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value);

  public:
  // optional .com.zoho.common.NumberFormat.Currency.CurrencyRepresentation afterValue = 3;
  bool has_aftervalue() const;
  void clear_aftervalue() ;
  ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation aftervalue() const;
  void set_aftervalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value);

  private:
  ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation _internal_aftervalue() const;
  void _internal_set_aftervalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.common.NumberFormat.Currency)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int currencyofcountry_;
    int beforevalue_;
    int aftervalue_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_numberformat_2eproto;
};// -------------------------------------------------------------------

class NumberFormat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.common.NumberFormat) */ {
 public:
  inline NumberFormat() : NumberFormat(nullptr) {}
  ~NumberFormat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NumberFormat(::google::protobuf::internal::ConstantInitialized);

  inline NumberFormat(const NumberFormat& from)
      : NumberFormat(nullptr, from) {}
  NumberFormat(NumberFormat&& from) noexcept
    : NumberFormat() {
    *this = ::std::move(from);
  }

  inline NumberFormat& operator=(const NumberFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberFormat& operator=(NumberFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumberFormat* internal_default_instance() {
    return reinterpret_cast<const NumberFormat*>(
               &_NumberFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NumberFormat& a, NumberFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberFormat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumberFormat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NumberFormat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NumberFormat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NumberFormat& from) {
    NumberFormat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NumberFormat* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.common.NumberFormat";
  }
  protected:
  explicit NumberFormat(::google::protobuf::Arena* arena);
  NumberFormat(::google::protobuf::Arena* arena, const NumberFormat& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using NumberSeparator = NumberFormat_NumberSeparator;
  using Currency = NumberFormat_Currency;
  using FractionFormat = NumberFormat_FractionFormat;

  using NumberFormatType = NumberFormat_NumberFormatType;
  static constexpr NumberFormatType UNKNOWN_NUMBERFORMAT_TYPE = NumberFormat_NumberFormatType_UNKNOWN_NUMBERFORMAT_TYPE;
  static constexpr NumberFormatType REGULAR = NumberFormat_NumberFormatType_REGULAR;
  static constexpr NumberFormatType DECIMAL_NUMBER = NumberFormat_NumberFormatType_DECIMAL_NUMBER;
  static constexpr NumberFormatType FRACTION = NumberFormat_NumberFormatType_FRACTION;
  static constexpr NumberFormatType PERCENTAGE = NumberFormat_NumberFormatType_PERCENTAGE;
  static inline bool NumberFormatType_IsValid(int value) {
    return NumberFormat_NumberFormatType_IsValid(value);
  }
  static constexpr NumberFormatType NumberFormatType_MIN = NumberFormat_NumberFormatType_NumberFormatType_MIN;
  static constexpr NumberFormatType NumberFormatType_MAX = NumberFormat_NumberFormatType_NumberFormatType_MAX;
  static constexpr int NumberFormatType_ARRAYSIZE = NumberFormat_NumberFormatType_NumberFormatType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NumberFormatType_descriptor() {
    return NumberFormat_NumberFormatType_descriptor();
  }
  template <typename T>
  static inline const std::string& NumberFormatType_Name(T value) {
    return NumberFormat_NumberFormatType_Name(value);
  }
  static inline bool NumberFormatType_Parse(absl::string_view name, NumberFormatType* value) {
    return NumberFormat_NumberFormatType_Parse(name, value);
  }

  using ThousandSeparatorType = NumberFormat_ThousandSeparatorType;
  static constexpr ThousandSeparatorType UNKNOWN_THOUSANDSEPARATOR_TYPE = NumberFormat_ThousandSeparatorType_UNKNOWN_THOUSANDSEPARATOR_TYPE;
  static constexpr ThousandSeparatorType INDIAN = NumberFormat_ThousandSeparatorType_INDIAN;
  static constexpr ThousandSeparatorType INTERNATIONAL = NumberFormat_ThousandSeparatorType_INTERNATIONAL;
  static inline bool ThousandSeparatorType_IsValid(int value) {
    return NumberFormat_ThousandSeparatorType_IsValid(value);
  }
  static constexpr ThousandSeparatorType ThousandSeparatorType_MIN = NumberFormat_ThousandSeparatorType_ThousandSeparatorType_MIN;
  static constexpr ThousandSeparatorType ThousandSeparatorType_MAX = NumberFormat_ThousandSeparatorType_ThousandSeparatorType_MAX;
  static constexpr int ThousandSeparatorType_ARRAYSIZE = NumberFormat_ThousandSeparatorType_ThousandSeparatorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ThousandSeparatorType_descriptor() {
    return NumberFormat_ThousandSeparatorType_descriptor();
  }
  template <typename T>
  static inline const std::string& ThousandSeparatorType_Name(T value) {
    return NumberFormat_ThousandSeparatorType_Name(value);
  }
  static inline bool ThousandSeparatorType_Parse(absl::string_view name, ThousandSeparatorType* value) {
    return NumberFormat_ThousandSeparatorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyFieldNumber = 5,
    kFractionFormatFieldNumber = 6,
    kNumberSeparatorFieldNumber = 7,
    kTypeFieldNumber = 1,
    kThousandSeperatorTypeFieldNumber = 2,
    kSeparateByThousandFieldNumber = 3,
    kDecimalPlacesFieldNumber = 4,
  };
  // optional .com.zoho.common.NumberFormat.Currency currency = 5;
  bool has_currency() const;
  void clear_currency() ;
  const ::com::zoho::common::NumberFormat_Currency& currency() const;
  PROTOBUF_NODISCARD ::com::zoho::common::NumberFormat_Currency* release_currency();
  ::com::zoho::common::NumberFormat_Currency* mutable_currency();
  void set_allocated_currency(::com::zoho::common::NumberFormat_Currency* value);
  void unsafe_arena_set_allocated_currency(::com::zoho::common::NumberFormat_Currency* value);
  ::com::zoho::common::NumberFormat_Currency* unsafe_arena_release_currency();

  private:
  const ::com::zoho::common::NumberFormat_Currency& _internal_currency() const;
  ::com::zoho::common::NumberFormat_Currency* _internal_mutable_currency();

  public:
  // optional .com.zoho.common.NumberFormat.FractionFormat fractionFormat = 6;
  bool has_fractionformat() const;
  void clear_fractionformat() ;
  const ::com::zoho::common::NumberFormat_FractionFormat& fractionformat() const;
  PROTOBUF_NODISCARD ::com::zoho::common::NumberFormat_FractionFormat* release_fractionformat();
  ::com::zoho::common::NumberFormat_FractionFormat* mutable_fractionformat();
  void set_allocated_fractionformat(::com::zoho::common::NumberFormat_FractionFormat* value);
  void unsafe_arena_set_allocated_fractionformat(::com::zoho::common::NumberFormat_FractionFormat* value);
  ::com::zoho::common::NumberFormat_FractionFormat* unsafe_arena_release_fractionformat();

  private:
  const ::com::zoho::common::NumberFormat_FractionFormat& _internal_fractionformat() const;
  ::com::zoho::common::NumberFormat_FractionFormat* _internal_mutable_fractionformat();

  public:
  // optional .com.zoho.common.NumberFormat.NumberSeparator numberSeparator = 7;
  bool has_numberseparator() const;
  void clear_numberseparator() ;
  const ::com::zoho::common::NumberFormat_NumberSeparator& numberseparator() const;
  PROTOBUF_NODISCARD ::com::zoho::common::NumberFormat_NumberSeparator* release_numberseparator();
  ::com::zoho::common::NumberFormat_NumberSeparator* mutable_numberseparator();
  void set_allocated_numberseparator(::com::zoho::common::NumberFormat_NumberSeparator* value);
  void unsafe_arena_set_allocated_numberseparator(::com::zoho::common::NumberFormat_NumberSeparator* value);
  ::com::zoho::common::NumberFormat_NumberSeparator* unsafe_arena_release_numberseparator();

  private:
  const ::com::zoho::common::NumberFormat_NumberSeparator& _internal_numberseparator() const;
  ::com::zoho::common::NumberFormat_NumberSeparator* _internal_mutable_numberseparator();

  public:
  // optional .com.zoho.common.NumberFormat.NumberFormatType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::common::NumberFormat_NumberFormatType type() const;
  void set_type(::com::zoho::common::NumberFormat_NumberFormatType value);

  private:
  ::com::zoho::common::NumberFormat_NumberFormatType _internal_type() const;
  void _internal_set_type(::com::zoho::common::NumberFormat_NumberFormatType value);

  public:
  // optional .com.zoho.common.NumberFormat.ThousandSeparatorType thousandSeperatorType = 2;
  bool has_thousandseperatortype() const;
  void clear_thousandseperatortype() ;
  ::com::zoho::common::NumberFormat_ThousandSeparatorType thousandseperatortype() const;
  void set_thousandseperatortype(::com::zoho::common::NumberFormat_ThousandSeparatorType value);

  private:
  ::com::zoho::common::NumberFormat_ThousandSeparatorType _internal_thousandseperatortype() const;
  void _internal_set_thousandseperatortype(::com::zoho::common::NumberFormat_ThousandSeparatorType value);

  public:
  // optional bool separateByThousand = 3;
  bool has_separatebythousand() const;
  void clear_separatebythousand() ;
  bool separatebythousand() const;
  void set_separatebythousand(bool value);

  private:
  bool _internal_separatebythousand() const;
  void _internal_set_separatebythousand(bool value);

  public:
  // optional int32 decimalPlaces = 4;
  bool has_decimalplaces() const;
  void clear_decimalplaces() ;
  ::int32_t decimalplaces() const;
  void set_decimalplaces(::int32_t value);

  private:
  ::int32_t _internal_decimalplaces() const;
  void _internal_set_decimalplaces(::int32_t value);

  public:
  void temp_setnumberSeparator(com::zoho::common::NumberFormat_NumberSeparator* numberSeparator) {
    if(&this->numberseparator() != numberSeparator) {
      set_allocated_numberseparator(numberSeparator);
    }
  }
  
  com::zoho::common::NumberFormat_NumberSeparator* temp_getnumberSeparator() const {
    if (has_numberseparator()) 
      return (const_cast<com::zoho::common::NumberFormat*>(this))->mutable_numberseparator();
    return nullptr;
  }
  
  void temp_setcurrency(com::zoho::common::NumberFormat_Currency* currency) {
    if(&this->currency() != currency) {
      set_allocated_currency(currency);
    }
  }
  
  com::zoho::common::NumberFormat_Currency* temp_getcurrency() const {
    if (has_currency()) 
      return (const_cast<com::zoho::common::NumberFormat*>(this))->mutable_currency();
    return nullptr;
  }
  
  void temp_setfractionFormat(com::zoho::common::NumberFormat_FractionFormat* fractionFormat) {
    if(&this->fractionformat() != fractionFormat) {
      set_allocated_fractionformat(fractionFormat);
    }
  }
  
  com::zoho::common::NumberFormat_FractionFormat* temp_getfractionFormat() const {
    if (has_fractionformat()) 
      return (const_cast<com::zoho::common::NumberFormat*>(this))->mutable_fractionformat();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.common.NumberFormat)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::NumberFormat_Currency* currency_;
    ::com::zoho::common::NumberFormat_FractionFormat* fractionformat_;
    ::com::zoho::common::NumberFormat_NumberSeparator* numberseparator_;
    int type_;
    int thousandseperatortype_;
    bool separatebythousand_;
    ::int32_t decimalplaces_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_numberformat_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NumberFormat_NumberSeparator

// optional .com.zoho.common.NumberFormat.NumberSeparator.NumberSeparatorType thousand = 1;
inline bool NumberFormat_NumberSeparator::has_thousand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NumberFormat_NumberSeparator::clear_thousand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thousand_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType NumberFormat_NumberSeparator::thousand() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.NumberSeparator.thousand)
  return _internal_thousand();
}
inline void NumberFormat_NumberSeparator::set_thousand(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value) {
  _internal_set_thousand(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.NumberSeparator.thousand)
}
inline ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType NumberFormat_NumberSeparator::_internal_thousand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType>(_impl_.thousand_);
}
inline void NumberFormat_NumberSeparator::_internal_set_thousand(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.thousand_ = value;
}

// optional .com.zoho.common.NumberFormat.NumberSeparator.NumberSeparatorType decimal = 2;
inline bool NumberFormat_NumberSeparator::has_decimal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NumberFormat_NumberSeparator::clear_decimal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decimal_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType NumberFormat_NumberSeparator::decimal() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.NumberSeparator.decimal)
  return _internal_decimal();
}
inline void NumberFormat_NumberSeparator::set_decimal(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value) {
  _internal_set_decimal(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.NumberSeparator.decimal)
}
inline ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType NumberFormat_NumberSeparator::_internal_decimal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType>(_impl_.decimal_);
}
inline void NumberFormat_NumberSeparator::_internal_set_decimal(::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.decimal_ = value;
}

// -------------------------------------------------------------------

// NumberFormat_Currency

// optional .com.zoho.common.NumberFormat.Currency.CurrencyOfCountry currencyOfCountry = 1;
inline bool NumberFormat_Currency::has_currencyofcountry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NumberFormat_Currency::clear_currencyofcountry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.currencyofcountry_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry NumberFormat_Currency::currencyofcountry() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.Currency.currencyOfCountry)
  return _internal_currencyofcountry();
}
inline void NumberFormat_Currency::set_currencyofcountry(::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry value) {
  _internal_set_currencyofcountry(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.Currency.currencyOfCountry)
}
inline ::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry NumberFormat_Currency::_internal_currencyofcountry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry>(_impl_.currencyofcountry_);
}
inline void NumberFormat_Currency::_internal_set_currencyofcountry(::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencyofcountry_ = value;
}

// optional .com.zoho.common.NumberFormat.Currency.CurrencyRepresentation beforeValue = 2;
inline bool NumberFormat_Currency::has_beforevalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NumberFormat_Currency::clear_beforevalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.beforevalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation NumberFormat_Currency::beforevalue() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.Currency.beforeValue)
  return _internal_beforevalue();
}
inline void NumberFormat_Currency::set_beforevalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value) {
  _internal_set_beforevalue(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.Currency.beforeValue)
}
inline ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation NumberFormat_Currency::_internal_beforevalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation>(_impl_.beforevalue_);
}
inline void NumberFormat_Currency::_internal_set_beforevalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.beforevalue_ = value;
}

// optional .com.zoho.common.NumberFormat.Currency.CurrencyRepresentation afterValue = 3;
inline bool NumberFormat_Currency::has_aftervalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NumberFormat_Currency::clear_aftervalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aftervalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation NumberFormat_Currency::aftervalue() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.Currency.afterValue)
  return _internal_aftervalue();
}
inline void NumberFormat_Currency::set_aftervalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value) {
  _internal_set_aftervalue(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.Currency.afterValue)
}
inline ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation NumberFormat_Currency::_internal_aftervalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation>(_impl_.aftervalue_);
}
inline void NumberFormat_Currency::_internal_set_aftervalue(::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.aftervalue_ = value;
}

// -------------------------------------------------------------------

// NumberFormat_FractionFormat

// optional .com.zoho.common.NumberFormat.FractionFormat.FractionFormatType type = 5;
inline bool NumberFormat_FractionFormat::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NumberFormat_FractionFormat::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType NumberFormat_FractionFormat::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.FractionFormat.type)
  return _internal_type();
}
inline void NumberFormat_FractionFormat::set_type(::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.FractionFormat.type)
}
inline ::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType NumberFormat_FractionFormat::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType>(_impl_.type_);
}
inline void NumberFormat_FractionFormat::_internal_set_type(::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// NumberFormat

// optional .com.zoho.common.NumberFormat.NumberFormatType type = 1;
inline bool NumberFormat::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NumberFormat::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::common::NumberFormat_NumberFormatType NumberFormat::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.type)
  return _internal_type();
}
inline void NumberFormat::set_type(::com::zoho::common::NumberFormat_NumberFormatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.type)
}
inline ::com::zoho::common::NumberFormat_NumberFormatType NumberFormat::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_NumberFormatType>(_impl_.type_);
}
inline void NumberFormat::_internal_set_type(::com::zoho::common::NumberFormat_NumberFormatType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional .com.zoho.common.NumberFormat.ThousandSeparatorType thousandSeperatorType = 2;
inline bool NumberFormat::has_thousandseperatortype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NumberFormat::clear_thousandseperatortype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thousandseperatortype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::com::zoho::common::NumberFormat_ThousandSeparatorType NumberFormat::thousandseperatortype() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.thousandSeperatorType)
  return _internal_thousandseperatortype();
}
inline void NumberFormat::set_thousandseperatortype(::com::zoho::common::NumberFormat_ThousandSeparatorType value) {
  _internal_set_thousandseperatortype(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.thousandSeperatorType)
}
inline ::com::zoho::common::NumberFormat_ThousandSeparatorType NumberFormat::_internal_thousandseperatortype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::NumberFormat_ThousandSeparatorType>(_impl_.thousandseperatortype_);
}
inline void NumberFormat::_internal_set_thousandseperatortype(::com::zoho::common::NumberFormat_ThousandSeparatorType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.thousandseperatortype_ = value;
}

// optional .com.zoho.common.NumberFormat.NumberSeparator numberSeparator = 7;
inline bool NumberFormat::has_numberseparator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.numberseparator_ != nullptr);
  return value;
}
inline void NumberFormat::clear_numberseparator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.numberseparator_ != nullptr) _impl_.numberseparator_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::common::NumberFormat_NumberSeparator& NumberFormat::_internal_numberseparator() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::NumberFormat_NumberSeparator* p = _impl_.numberseparator_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::NumberFormat_NumberSeparator&>(::com::zoho::common::_NumberFormat_NumberSeparator_default_instance_);
}
inline const ::com::zoho::common::NumberFormat_NumberSeparator& NumberFormat::numberseparator() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.numberSeparator)
  return _internal_numberseparator();
}
inline void NumberFormat::unsafe_arena_set_allocated_numberseparator(::com::zoho::common::NumberFormat_NumberSeparator* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.numberseparator_);
  }
  _impl_.numberseparator_ = reinterpret_cast<::com::zoho::common::NumberFormat_NumberSeparator*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.common.NumberFormat.numberSeparator)
}
inline ::com::zoho::common::NumberFormat_NumberSeparator* NumberFormat::release_numberseparator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::common::NumberFormat_NumberSeparator* released = _impl_.numberseparator_;
  _impl_.numberseparator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::NumberFormat_NumberSeparator* NumberFormat::unsafe_arena_release_numberseparator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.common.NumberFormat.numberSeparator)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::common::NumberFormat_NumberSeparator* temp = _impl_.numberseparator_;
  _impl_.numberseparator_ = nullptr;
  return temp;
}
inline ::com::zoho::common::NumberFormat_NumberSeparator* NumberFormat::_internal_mutable_numberseparator() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.numberseparator_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::NumberFormat_NumberSeparator>(GetArena());
    _impl_.numberseparator_ = reinterpret_cast<::com::zoho::common::NumberFormat_NumberSeparator*>(p);
  }
  return _impl_.numberseparator_;
}
inline ::com::zoho::common::NumberFormat_NumberSeparator* NumberFormat::mutable_numberseparator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::NumberFormat_NumberSeparator* _msg = _internal_mutable_numberseparator();
  // @@protoc_insertion_point(field_mutable:com.zoho.common.NumberFormat.numberSeparator)
  return _msg;
}
inline void NumberFormat::set_allocated_numberseparator(::com::zoho::common::NumberFormat_NumberSeparator* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::common::NumberFormat_NumberSeparator*>(_impl_.numberseparator_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::common::NumberFormat_NumberSeparator*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.numberseparator_ = reinterpret_cast<::com::zoho::common::NumberFormat_NumberSeparator*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.common.NumberFormat.numberSeparator)
}

// optional bool separateByThousand = 3;
inline bool NumberFormat::has_separatebythousand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NumberFormat::clear_separatebythousand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.separatebythousand_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool NumberFormat::separatebythousand() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.separateByThousand)
  return _internal_separatebythousand();
}
inline void NumberFormat::set_separatebythousand(bool value) {
  _internal_set_separatebythousand(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.separateByThousand)
}
inline bool NumberFormat::_internal_separatebythousand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.separatebythousand_;
}
inline void NumberFormat::_internal_set_separatebythousand(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.separatebythousand_ = value;
}

// optional int32 decimalPlaces = 4;
inline bool NumberFormat::has_decimalplaces() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void NumberFormat::clear_decimalplaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decimalplaces_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t NumberFormat::decimalplaces() const {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.decimalPlaces)
  return _internal_decimalplaces();
}
inline void NumberFormat::set_decimalplaces(::int32_t value) {
  _internal_set_decimalplaces(value);
  // @@protoc_insertion_point(field_set:com.zoho.common.NumberFormat.decimalPlaces)
}
inline ::int32_t NumberFormat::_internal_decimalplaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decimalplaces_;
}
inline void NumberFormat::_internal_set_decimalplaces(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.decimalplaces_ = value;
}

// optional .com.zoho.common.NumberFormat.Currency currency = 5;
inline bool NumberFormat::has_currency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.currency_ != nullptr);
  return value;
}
inline void NumberFormat::clear_currency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.currency_ != nullptr) _impl_.currency_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::common::NumberFormat_Currency& NumberFormat::_internal_currency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::NumberFormat_Currency* p = _impl_.currency_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::NumberFormat_Currency&>(::com::zoho::common::_NumberFormat_Currency_default_instance_);
}
inline const ::com::zoho::common::NumberFormat_Currency& NumberFormat::currency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.currency)
  return _internal_currency();
}
inline void NumberFormat::unsafe_arena_set_allocated_currency(::com::zoho::common::NumberFormat_Currency* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.currency_);
  }
  _impl_.currency_ = reinterpret_cast<::com::zoho::common::NumberFormat_Currency*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.common.NumberFormat.currency)
}
inline ::com::zoho::common::NumberFormat_Currency* NumberFormat::release_currency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::NumberFormat_Currency* released = _impl_.currency_;
  _impl_.currency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::NumberFormat_Currency* NumberFormat::unsafe_arena_release_currency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.common.NumberFormat.currency)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::NumberFormat_Currency* temp = _impl_.currency_;
  _impl_.currency_ = nullptr;
  return temp;
}
inline ::com::zoho::common::NumberFormat_Currency* NumberFormat::_internal_mutable_currency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.currency_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::NumberFormat_Currency>(GetArena());
    _impl_.currency_ = reinterpret_cast<::com::zoho::common::NumberFormat_Currency*>(p);
  }
  return _impl_.currency_;
}
inline ::com::zoho::common::NumberFormat_Currency* NumberFormat::mutable_currency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::NumberFormat_Currency* _msg = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:com.zoho.common.NumberFormat.currency)
  return _msg;
}
inline void NumberFormat::set_allocated_currency(::com::zoho::common::NumberFormat_Currency* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::common::NumberFormat_Currency*>(_impl_.currency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::common::NumberFormat_Currency*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.currency_ = reinterpret_cast<::com::zoho::common::NumberFormat_Currency*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.common.NumberFormat.currency)
}

// optional .com.zoho.common.NumberFormat.FractionFormat fractionFormat = 6;
inline bool NumberFormat::has_fractionformat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fractionformat_ != nullptr);
  return value;
}
inline void NumberFormat::clear_fractionformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fractionformat_ != nullptr) _impl_.fractionformat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::common::NumberFormat_FractionFormat& NumberFormat::_internal_fractionformat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::NumberFormat_FractionFormat* p = _impl_.fractionformat_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::NumberFormat_FractionFormat&>(::com::zoho::common::_NumberFormat_FractionFormat_default_instance_);
}
inline const ::com::zoho::common::NumberFormat_FractionFormat& NumberFormat::fractionformat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.common.NumberFormat.fractionFormat)
  return _internal_fractionformat();
}
inline void NumberFormat::unsafe_arena_set_allocated_fractionformat(::com::zoho::common::NumberFormat_FractionFormat* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fractionformat_);
  }
  _impl_.fractionformat_ = reinterpret_cast<::com::zoho::common::NumberFormat_FractionFormat*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.common.NumberFormat.fractionFormat)
}
inline ::com::zoho::common::NumberFormat_FractionFormat* NumberFormat::release_fractionformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::NumberFormat_FractionFormat* released = _impl_.fractionformat_;
  _impl_.fractionformat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::NumberFormat_FractionFormat* NumberFormat::unsafe_arena_release_fractionformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.common.NumberFormat.fractionFormat)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::NumberFormat_FractionFormat* temp = _impl_.fractionformat_;
  _impl_.fractionformat_ = nullptr;
  return temp;
}
inline ::com::zoho::common::NumberFormat_FractionFormat* NumberFormat::_internal_mutable_fractionformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.fractionformat_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::NumberFormat_FractionFormat>(GetArena());
    _impl_.fractionformat_ = reinterpret_cast<::com::zoho::common::NumberFormat_FractionFormat*>(p);
  }
  return _impl_.fractionformat_;
}
inline ::com::zoho::common::NumberFormat_FractionFormat* NumberFormat::mutable_fractionformat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::NumberFormat_FractionFormat* _msg = _internal_mutable_fractionformat();
  // @@protoc_insertion_point(field_mutable:com.zoho.common.NumberFormat.fractionFormat)
  return _msg;
}
inline void NumberFormat::set_allocated_fractionformat(::com::zoho::common::NumberFormat_FractionFormat* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::common::NumberFormat_FractionFormat*>(_impl_.fractionformat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::common::NumberFormat_FractionFormat*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.fractionformat_ = reinterpret_cast<::com::zoho::common::NumberFormat_FractionFormat*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.common.NumberFormat.fractionFormat)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType>() {
  return ::com::zoho::common::NumberFormat_NumberSeparator_NumberSeparatorType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry>() {
  return ::com::zoho::common::NumberFormat_Currency_CurrencyOfCountry_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation>() {
  return ::com::zoho::common::NumberFormat_Currency_CurrencyRepresentation_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType>() {
  return ::com::zoho::common::NumberFormat_FractionFormat_FractionFormatType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::common::NumberFormat_NumberFormatType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::common::NumberFormat_NumberFormatType>() {
  return ::com::zoho::common::NumberFormat_NumberFormatType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::common::NumberFormat_ThousandSeparatorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::common::NumberFormat_ThousandSeparatorType>() {
  return ::com::zoho::common::NumberFormat_ThousandSeparatorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_numberformat_2eproto_2epb_2eh
