// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tablestyle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct TableStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique Identifier.
  public var id: String {
    get {return _storage._id ?? String()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// Name.
  public var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  public var table: TableStyle.TablePartStyle {
    get {return _storage._table ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._table = newValue}
  }
  /// Returns true if `table` has been explicitly set.
  public var hasTable: Bool {return _storage._table != nil}
  /// Clears the value of `table`. Subsequent reads from it will return its default value.
  public mutating func clearTable() {_uniqueStorage()._table = nil}

  /// Odd numbered Rows i.e. 1,3,5
  public var band1H: TableStyle.TablePartStyle {
    get {return _storage._band1H ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._band1H = newValue}
  }
  /// Returns true if `band1H` has been explicitly set.
  public var hasBand1H: Bool {return _storage._band1H != nil}
  /// Clears the value of `band1H`. Subsequent reads from it will return its default value.
  public mutating func clearBand1H() {_uniqueStorage()._band1H = nil}

  /// Odd numbered Columns i.e. 1,3,5
  public var band1V: TableStyle.TablePartStyle {
    get {return _storage._band1V ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._band1V = newValue}
  }
  /// Returns true if `band1V` has been explicitly set.
  public var hasBand1V: Bool {return _storage._band1V != nil}
  /// Clears the value of `band1V`. Subsequent reads from it will return its default value.
  public mutating func clearBand1V() {_uniqueStorage()._band1V = nil}

  /// Even numbered Rows i.e. 2,4,6
  public var band2H: TableStyle.TablePartStyle {
    get {return _storage._band2H ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._band2H = newValue}
  }
  /// Returns true if `band2H` has been explicitly set.
  public var hasBand2H: Bool {return _storage._band2H != nil}
  /// Clears the value of `band2H`. Subsequent reads from it will return its default value.
  public mutating func clearBand2H() {_uniqueStorage()._band2H = nil}

  /// Even numbered Columns i.e. 2,4,6
  public var band2V: TableStyle.TablePartStyle {
    get {return _storage._band2V ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._band2V = newValue}
  }
  /// Returns true if `band2V` has been explicitly set.
  public var hasBand2V: Bool {return _storage._band2V != nil}
  /// Clears the value of `band2V`. Subsequent reads from it will return its default value.
  public mutating func clearBand2V() {_uniqueStorage()._band2V = nil}

  /// Last Column
  public var lastCol: TableStyle.TablePartStyle {
    get {return _storage._lastCol ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._lastCol = newValue}
  }
  /// Returns true if `lastCol` has been explicitly set.
  public var hasLastCol: Bool {return _storage._lastCol != nil}
  /// Clears the value of `lastCol`. Subsequent reads from it will return its default value.
  public mutating func clearLastCol() {_uniqueStorage()._lastCol = nil}

  /// First Column.
  public var firstCol: TableStyle.TablePartStyle {
    get {return _storage._firstCol ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._firstCol = newValue}
  }
  /// Returns true if `firstCol` has been explicitly set.
  public var hasFirstCol: Bool {return _storage._firstCol != nil}
  /// Clears the value of `firstCol`. Subsequent reads from it will return its default value.
  public mutating func clearFirstCol() {_uniqueStorage()._firstCol = nil}

  /// Last Row
  public var lastRow: TableStyle.TablePartStyle {
    get {return _storage._lastRow ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._lastRow = newValue}
  }
  /// Returns true if `lastRow` has been explicitly set.
  public var hasLastRow: Bool {return _storage._lastRow != nil}
  /// Clears the value of `lastRow`. Subsequent reads from it will return its default value.
  public mutating func clearLastRow() {_uniqueStorage()._lastRow = nil}

  /// First Row
  public var firstRow: TableStyle.TablePartStyle {
    get {return _storage._firstRow ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._firstRow = newValue}
  }
  /// Returns true if `firstRow` has been explicitly set.
  public var hasFirstRow: Bool {return _storage._firstRow != nil}
  /// Clears the value of `firstRow`. Subsequent reads from it will return its default value.
  public mutating func clearFirstRow() {_uniqueStorage()._firstRow = nil}

  /// South East Cell
  public var seCell: TableStyle.TablePartStyle {
    get {return _storage._seCell ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._seCell = newValue}
  }
  /// Returns true if `seCell` has been explicitly set.
  public var hasSeCell: Bool {return _storage._seCell != nil}
  /// Clears the value of `seCell`. Subsequent reads from it will return its default value.
  public mutating func clearSeCell() {_uniqueStorage()._seCell = nil}

  /// South West Cell
  public var swCell: TableStyle.TablePartStyle {
    get {return _storage._swCell ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._swCell = newValue}
  }
  /// Returns true if `swCell` has been explicitly set.
  public var hasSwCell: Bool {return _storage._swCell != nil}
  /// Clears the value of `swCell`. Subsequent reads from it will return its default value.
  public mutating func clearSwCell() {_uniqueStorage()._swCell = nil}

  /// North East Cell
  public var neCell: TableStyle.TablePartStyle {
    get {return _storage._neCell ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._neCell = newValue}
  }
  /// Returns true if `neCell` has been explicitly set.
  public var hasNeCell: Bool {return _storage._neCell != nil}
  /// Clears the value of `neCell`. Subsequent reads from it will return its default value.
  public mutating func clearNeCell() {_uniqueStorage()._neCell = nil}

  /// North West Cell
  public var nwCell: TableStyle.TablePartStyle {
    get {return _storage._nwCell ?? TableStyle.TablePartStyle()}
    set {_uniqueStorage()._nwCell = newValue}
  }
  /// Returns true if `nwCell` has been explicitly set.
  public var hasNwCell: Bool {return _storage._nwCell != nil}
  /// Clears the value of `nwCell`. Subsequent reads from it will return its default value.
  public mutating func clearNwCell() {_uniqueStorage()._nwCell = nil}

  public var bg: TableStyle.TableBackground {
    get {return _storage._bg ?? TableStyle.TableBackground()}
    set {_uniqueStorage()._bg = newValue}
  }
  /// Returns true if `bg` has been explicitly set.
  public var hasBg: Bool {return _storage._bg != nil}
  /// Clears the value of `bg`. Subsequent reads from it will return its default value.
  public mutating func clearBg() {_uniqueStorage()._bg = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TableCellTextStyle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fontRef: FontReference {
      get {return _storage._fontRef ?? FontReference()}
      set {_uniqueStorage()._fontRef = newValue}
    }
    /// Returns true if `fontRef` has been explicitly set.
    public var hasFontRef: Bool {return _storage._fontRef != nil}
    /// Clears the value of `fontRef`. Subsequent reads from it will return its default value.
    public mutating func clearFontRef() {_uniqueStorage()._fontRef = nil}

    public var font: Font {
      get {return _storage._font ?? Font()}
      set {_uniqueStorage()._font = newValue}
    }
    /// Returns true if `font` has been explicitly set.
    public var hasFont: Bool {return _storage._font != nil}
    /// Clears the value of `font`. Subsequent reads from it will return its default value.
    public mutating func clearFont() {_uniqueStorage()._font = nil}

    /// overwrite the fontRef Color with this color i.e. Color of the font.
    public var color: Color {
      get {return _storage._color ?? Color()}
      set {_uniqueStorage()._color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    public var hasColor: Bool {return _storage._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    public mutating func clearColor() {_uniqueStorage()._color = nil}

    public var bold: Bool {
      get {return _storage._bold ?? false}
      set {_uniqueStorage()._bold = newValue}
    }
    /// Returns true if `bold` has been explicitly set.
    public var hasBold: Bool {return _storage._bold != nil}
    /// Clears the value of `bold`. Subsequent reads from it will return its default value.
    public mutating func clearBold() {_uniqueStorage()._bold = nil}

    public var italic: Bool {
      get {return _storage._italic ?? false}
      set {_uniqueStorage()._italic = newValue}
    }
    /// Returns true if `italic` has been explicitly set.
    public var hasItalic: Bool {return _storage._italic != nil}
    /// Clears the value of `italic`. Subsequent reads from it will return its default value.
    public mutating func clearItalic() {_uniqueStorage()._italic = nil}

    /// font size , in pt. Font Size alone is stored in Pt instead of pixel , as there are rendering differences in the browser between pixel and point. The font size will change accoring to the slide size and will be handled by Rendering engine. 
    public var size: Float {
      get {return _storage._size ?? 0}
      set {_uniqueStorage()._size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    public var hasSize: Bool {return _storage._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    public mutating func clearSize() {_uniqueStorage()._size = nil}

    public var paraStyle: ParaStyle {
      get {return _storage._paraStyle ?? ParaStyle()}
      set {_uniqueStorage()._paraStyle = newValue}
    }
    /// Returns true if `paraStyle` has been explicitly set.
    public var hasParaStyle: Bool {return _storage._paraStyle != nil}
    /// Clears the value of `paraStyle`. Subsequent reads from it will return its default value.
    public mutating func clearParaStyle() {_uniqueStorage()._paraStyle = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct TablePartStyle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var cellStyle: TableCellStyle {
      get {return _cellStyle ?? TableCellStyle()}
      set {_cellStyle = newValue}
    }
    /// Returns true if `cellStyle` has been explicitly set.
    public var hasCellStyle: Bool {return self._cellStyle != nil}
    /// Clears the value of `cellStyle`. Subsequent reads from it will return its default value.
    public mutating func clearCellStyle() {self._cellStyle = nil}

    public var cellTextStyle: TableStyle.TableCellTextStyle {
      get {return _cellTextStyle ?? TableStyle.TableCellTextStyle()}
      set {_cellTextStyle = newValue}
    }
    /// Returns true if `cellTextStyle` has been explicitly set.
    public var hasCellTextStyle: Bool {return self._cellTextStyle != nil}
    /// Clears the value of `cellTextStyle`. Subsequent reads from it will return its default value.
    public mutating func clearCellTextStyle() {self._cellTextStyle = nil}

    public var valign: VerticalAlignType {
      get {return _valign ?? .top}
      set {_valign = newValue}
    }
    /// Returns true if `valign` has been explicitly set.
    public var hasValign: Bool {return self._valign != nil}
    /// Clears the value of `valign`. Subsequent reads from it will return its default value.
    public mutating func clearValign() {self._valign = nil}

    public var textDir: TableField.TextDirection {
      get {return _textDir ?? .horizontal}
      set {_textDir = newValue}
    }
    /// Returns true if `textDir` has been explicitly set.
    public var hasTextDir: Bool {return self._textDir != nil}
    /// Clears the value of `textDir`. Subsequent reads from it will return its default value.
    public mutating func clearTextDir() {self._textDir = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _cellStyle: TableCellStyle? = nil
    fileprivate var _cellTextStyle: TableStyle.TableCellTextStyle? = nil
    fileprivate var _valign: VerticalAlignType? = nil
    fileprivate var _textDir: TableField.TextDirection? = nil
  }

  public struct TableBackground {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fill: Fill {
      get {return _fill ?? Fill()}
      set {_fill = newValue}
    }
    /// Returns true if `fill` has been explicitly set.
    public var hasFill: Bool {return self._fill != nil}
    /// Clears the value of `fill`. Subsequent reads from it will return its default value.
    public mutating func clearFill() {self._fill = nil}

    public var fillRef: Reference {
      get {return _fillRef ?? Reference()}
      set {_fillRef = newValue}
    }
    /// Returns true if `fillRef` has been explicitly set.
    public var hasFillRef: Bool {return self._fillRef != nil}
    /// Clears the value of `fillRef`. Subsequent reads from it will return its default value.
    public mutating func clearFillRef() {self._fillRef = nil}

    public var effects: Effects {
      get {return _effects ?? Effects()}
      set {_effects = newValue}
    }
    /// Returns true if `effects` has been explicitly set.
    public var hasEffects: Bool {return self._effects != nil}
    /// Clears the value of `effects`. Subsequent reads from it will return its default value.
    public mutating func clearEffects() {self._effects = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _fill: Fill? = nil
    fileprivate var _fillRef: Reference? = nil
    fileprivate var _effects: Effects? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension TableStyle: @unchecked Sendable {}
extension TableStyle.TableCellTextStyle: @unchecked Sendable {}
extension TableStyle.TablePartStyle: @unchecked Sendable {}
extension TableStyle.TableBackground: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension TableStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableStyle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "table"),
    4: .same(proto: "band1H"),
    5: .same(proto: "band1V"),
    6: .same(proto: "band2H"),
    7: .same(proto: "band2V"),
    8: .same(proto: "lastCol"),
    9: .same(proto: "firstCol"),
    10: .same(proto: "lastRow"),
    11: .same(proto: "firstRow"),
    12: .same(proto: "seCell"),
    13: .same(proto: "swCell"),
    14: .same(proto: "neCell"),
    15: .same(proto: "nwCell"),
    16: .same(proto: "bg"),
  ]

  fileprivate class _StorageClass {
    var _id: String? = nil
    var _name: String? = nil
    var _table: TableStyle.TablePartStyle? = nil
    var _band1H: TableStyle.TablePartStyle? = nil
    var _band1V: TableStyle.TablePartStyle? = nil
    var _band2H: TableStyle.TablePartStyle? = nil
    var _band2V: TableStyle.TablePartStyle? = nil
    var _lastCol: TableStyle.TablePartStyle? = nil
    var _firstCol: TableStyle.TablePartStyle? = nil
    var _lastRow: TableStyle.TablePartStyle? = nil
    var _firstRow: TableStyle.TablePartStyle? = nil
    var _seCell: TableStyle.TablePartStyle? = nil
    var _swCell: TableStyle.TablePartStyle? = nil
    var _neCell: TableStyle.TablePartStyle? = nil
    var _nwCell: TableStyle.TablePartStyle? = nil
    var _bg: TableStyle.TableBackground? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _table = source._table
      _band1H = source._band1H
      _band1V = source._band1V
      _band2H = source._band2H
      _band2V = source._band2V
      _lastCol = source._lastCol
      _firstCol = source._firstCol
      _lastRow = source._lastRow
      _firstRow = source._firstRow
      _seCell = source._seCell
      _swCell = source._swCell
      _neCell = source._neCell
      _nwCell = source._nwCell
      _bg = source._bg
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id == nil {return false}
      if let v = _storage._table, !v.isInitialized {return false}
      if let v = _storage._band1H, !v.isInitialized {return false}
      if let v = _storage._band1V, !v.isInitialized {return false}
      if let v = _storage._band2H, !v.isInitialized {return false}
      if let v = _storage._band2V, !v.isInitialized {return false}
      if let v = _storage._lastCol, !v.isInitialized {return false}
      if let v = _storage._firstCol, !v.isInitialized {return false}
      if let v = _storage._lastRow, !v.isInitialized {return false}
      if let v = _storage._firstRow, !v.isInitialized {return false}
      if let v = _storage._seCell, !v.isInitialized {return false}
      if let v = _storage._swCell, !v.isInitialized {return false}
      if let v = _storage._neCell, !v.isInitialized {return false}
      if let v = _storage._nwCell, !v.isInitialized {return false}
      if let v = _storage._bg, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._table) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._band1H) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._band1V) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._band2H) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._band2V) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastCol) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._firstCol) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastRow) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._firstRow) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._seCell) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._swCell) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._neCell) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._nwCell) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._bg) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._table {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._band1H {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._band1V {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._band2H {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._band2V {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastCol {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._firstCol {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lastRow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._firstRow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._seCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._swCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._neCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._nwCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._bg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TableStyle, rhs: TableStyle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._table != rhs_storage._table {return false}
        if _storage._band1H != rhs_storage._band1H {return false}
        if _storage._band1V != rhs_storage._band1V {return false}
        if _storage._band2H != rhs_storage._band2H {return false}
        if _storage._band2V != rhs_storage._band2V {return false}
        if _storage._lastCol != rhs_storage._lastCol {return false}
        if _storage._firstCol != rhs_storage._firstCol {return false}
        if _storage._lastRow != rhs_storage._lastRow {return false}
        if _storage._firstRow != rhs_storage._firstRow {return false}
        if _storage._seCell != rhs_storage._seCell {return false}
        if _storage._swCell != rhs_storage._swCell {return false}
        if _storage._neCell != rhs_storage._neCell {return false}
        if _storage._nwCell != rhs_storage._nwCell {return false}
        if _storage._bg != rhs_storage._bg {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TableStyle.TableCellTextStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TableStyle.protoMessageName + ".TableCellTextStyle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fontRef"),
    2: .same(proto: "font"),
    3: .same(proto: "color"),
    4: .same(proto: "bold"),
    5: .same(proto: "italic"),
    6: .same(proto: "size"),
    7: .same(proto: "paraStyle"),
  ]

  fileprivate class _StorageClass {
    var _fontRef: FontReference? = nil
    var _font: Font? = nil
    var _color: Color? = nil
    var _bold: Bool? = nil
    var _italic: Bool? = nil
    var _size: Float? = nil
    var _paraStyle: ParaStyle? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fontRef = source._fontRef
      _font = source._font
      _color = source._color
      _bold = source._bold
      _italic = source._italic
      _size = source._size
      _paraStyle = source._paraStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fontRef, !v.isInitialized {return false}
      if let v = _storage._font, !v.isInitialized {return false}
      if let v = _storage._color, !v.isInitialized {return false}
      if let v = _storage._paraStyle, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._fontRef) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._font) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._bold) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._italic) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._size) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._paraStyle) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._fontRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._font {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._bold {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._italic {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._paraStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TableStyle.TableCellTextStyle, rhs: TableStyle.TableCellTextStyle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fontRef != rhs_storage._fontRef {return false}
        if _storage._font != rhs_storage._font {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._bold != rhs_storage._bold {return false}
        if _storage._italic != rhs_storage._italic {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._paraStyle != rhs_storage._paraStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TableStyle.TablePartStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TableStyle.protoMessageName + ".TablePartStyle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cellStyle"),
    2: .same(proto: "cellTextStyle"),
    3: .same(proto: "valign"),
    4: .same(proto: "textDir"),
  ]

  public var isInitialized: Bool {
    if let v = self._cellStyle, !v.isInitialized {return false}
    if let v = self._cellTextStyle, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellStyle) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellTextStyle) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._valign) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._textDir) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellTextStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._valign {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._textDir {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TableStyle.TablePartStyle, rhs: TableStyle.TablePartStyle) -> Bool {
    if lhs._cellStyle != rhs._cellStyle {return false}
    if lhs._cellTextStyle != rhs._cellTextStyle {return false}
    if lhs._valign != rhs._valign {return false}
    if lhs._textDir != rhs._textDir {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TableStyle.TableBackground: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TableStyle.protoMessageName + ".TableBackground"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fill"),
    2: .same(proto: "fillRef"),
    3: .same(proto: "effects"),
  ]

  public var isInitialized: Bool {
    if let v = self._fill, !v.isInitialized {return false}
    if let v = self._fillRef, !v.isInitialized {return false}
    if let v = self._effects, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fillRef) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._effects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fillRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._effects {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TableStyle.TableBackground, rhs: TableStyle.TableBackground) -> Bool {
    if lhs._fill != rhs._fill {return false}
    if lhs._fillRef != rhs._fillRef {return false}
    if lhs._effects != rhs._effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
