// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: animationeasing.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct AnimationEasing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var base: AnimationEasing.EasingBase {
    get {return _base ?? .none}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {self._base = nil}

  public var curve: AnimationEasing.EasingCurve {
    get {return _curve ?? .defAnimationEasingCurve}
    set {_curve = newValue}
  }
  /// Returns true if `curve` has been explicitly set.
  public var hasCurve: Bool {return self._curve != nil}
  /// Clears the value of `curve`. Subsequent reads from it will return its default value.
  public mutating func clearCurve() {self._curve = nil}

  public var bounce: AnimationEasing.BounceOrElasticCurve {
    get {return _bounce ?? AnimationEasing.BounceOrElasticCurve()}
    set {_bounce = newValue}
  }
  /// Returns true if `bounce` has been explicitly set.
  public var hasBounce: Bool {return self._bounce != nil}
  /// Clears the value of `bounce`. Subsequent reads from it will return its default value.
  public mutating func clearBounce() {self._bounce = nil}

  public var elastic: AnimationEasing.BounceOrElasticCurve {
    get {return _elastic ?? AnimationEasing.BounceOrElasticCurve()}
    set {_elastic = newValue}
  }
  /// Returns true if `elastic` has been explicitly set.
  public var hasElastic: Bool {return self._elastic != nil}
  /// Clears the value of `elastic`. Subsequent reads from it will return its default value.
  public mutating func clearElastic() {self._elastic = nil}

  public var power: AnimationEasing.PowerCurve {
    get {return _power ?? AnimationEasing.PowerCurve()}
    set {_power = newValue}
  }
  /// Returns true if `power` has been explicitly set.
  public var hasPower: Bool {return self._power != nil}
  /// Clears the value of `power`. Subsequent reads from it will return its default value.
  public mutating func clearPower() {self._power = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum EasingBase: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No Easing , follows linear motion.
    case none // = 0
    case easeIn // = 1
    case easeOut // = 2
    case easeInOut // = 3

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .easeIn
      case 2: self = .easeOut
      case 3: self = .easeInOut
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .easeIn: return 1
      case .easeOut: return 2
      case .easeInOut: return 3
      }
    }

  }

  /// Each easing curve is based on a formula. Check the following web pages to understand in detail. 
  /// http://easings.net/ , https://docs.microsoft.com/en-us/dotnet/framework/wpf/graphics-multimedia/easing-functions , 
  /// http://gizma.com/easing/
  public enum EasingCurve: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case defAnimationEasingCurve // = 0

    /// f(t) = 1 - (Sin(1-t) * PI/2)
    case sine // = 1

    /// f(t) = t^3
    case cubic // = 2

    /// f(t) = t^5
    case quintic // = 3

    /// f(t) = 1 - sqrt(1-t^2)
    case circle // = 4

    /// f(t) = t^2
    case quadratic // = 5

    /// f(t) = t^4
    case quartic // = 6

    /// f(t) = (e(at) - 1) / (e(a) - 1)
    case exponential // = 7

    /// f(t) = t^3 - t * a * Sin(t * PI)
    case back // = 8
    case bounce // = 9
    case elastic // = 10

    /// f(t) = t^n	
    case power // = 11

    public init() {
      self = .defAnimationEasingCurve
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .defAnimationEasingCurve
      case 1: self = .sine
      case 2: self = .cubic
      case 3: self = .quintic
      case 4: self = .circle
      case 5: self = .quadratic
      case 6: self = .quartic
      case 7: self = .exponential
      case 8: self = .back
      case 9: self = .bounce
      case 10: self = .elastic
      case 11: self = .power
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .defAnimationEasingCurve: return 0
      case .sine: return 1
      case .cubic: return 2
      case .quintic: return 3
      case .circle: return 4
      case .quadratic: return 5
      case .quartic: return 6
      case .exponential: return 7
      case .back: return 8
      case .bounce: return 9
      case .elastic: return 10
      case .power: return 11
      }
    }

  }

  public struct BounceOrElasticCurve {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var num: Int32 {
      get {return _num ?? 0}
      set {_num = newValue}
    }
    /// Returns true if `num` has been explicitly set.
    public var hasNum: Bool {return self._num != nil}
    /// Clears the value of `num`. Subsequent reads from it will return its default value.
    public mutating func clearNum() {self._num = nil}

    public var factor: Float {
      get {return _factor ?? 0}
      set {_factor = newValue}
    }
    /// Returns true if `factor` has been explicitly set.
    public var hasFactor: Bool {return self._factor != nil}
    /// Clears the value of `factor`. Subsequent reads from it will return its default value.
    public mutating func clearFactor() {self._factor = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _num: Int32? = nil
    fileprivate var _factor: Float? = nil
  }

  public struct PowerCurve {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: Float {
      get {return _value ?? 0}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _value: Float? = nil
  }

  public init() {}

  fileprivate var _base: AnimationEasing.EasingBase? = nil
  fileprivate var _curve: AnimationEasing.EasingCurve? = nil
  fileprivate var _bounce: AnimationEasing.BounceOrElasticCurve? = nil
  fileprivate var _elastic: AnimationEasing.BounceOrElasticCurve? = nil
  fileprivate var _power: AnimationEasing.PowerCurve? = nil
}

#if swift(>=4.2)

extension AnimationEasing.EasingBase: CaseIterable {
  // Support synthesized by the compiler.
}

extension AnimationEasing.EasingCurve: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension AnimationEasing: @unchecked Sendable {}
extension AnimationEasing.EasingBase: @unchecked Sendable {}
extension AnimationEasing.EasingCurve: @unchecked Sendable {}
extension AnimationEasing.BounceOrElasticCurve: @unchecked Sendable {}
extension AnimationEasing.PowerCurve: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension AnimationEasing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnimationEasing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "curve"),
    3: .same(proto: "bounce"),
    4: .same(proto: "elastic"),
    5: .same(proto: "power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._base) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._curve) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bounce) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._elastic) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._power) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._curve {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bounce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._elastic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._power {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AnimationEasing, rhs: AnimationEasing) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs._curve != rhs._curve {return false}
    if lhs._bounce != rhs._bounce {return false}
    if lhs._elastic != rhs._elastic {return false}
    if lhs._power != rhs._power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AnimationEasing.EasingBase: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "EASE_IN"),
    2: .same(proto: "EASE_OUT"),
    3: .same(proto: "EASE_IN_OUT"),
  ]
}

extension AnimationEasing.EasingCurve: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_ANIMATION_EASING_CURVE"),
    1: .same(proto: "SINE"),
    2: .same(proto: "CUBIC"),
    3: .same(proto: "QUINTIC"),
    4: .same(proto: "CIRCLE"),
    5: .same(proto: "QUADRATIC"),
    6: .same(proto: "QUARTIC"),
    7: .same(proto: "EXPONENTIAL"),
    8: .same(proto: "BACK"),
    9: .same(proto: "BOUNCE"),
    10: .same(proto: "ELASTIC"),
    11: .same(proto: "POWER"),
  ]
}

extension AnimationEasing.BounceOrElasticCurve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AnimationEasing.protoMessageName + ".BounceOrElasticCurve"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "factor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._num) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._factor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._num {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._factor {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AnimationEasing.BounceOrElasticCurve, rhs: AnimationEasing.BounceOrElasticCurve) -> Bool {
    if lhs._num != rhs._num {return false}
    if lhs._factor != rhs._factor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AnimationEasing.PowerCurve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = AnimationEasing.protoMessageName + ".PowerCurve"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AnimationEasing.PowerCurve, rhs: AnimationEasing.PowerCurve) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
