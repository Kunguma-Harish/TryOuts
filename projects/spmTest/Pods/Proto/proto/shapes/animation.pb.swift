// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: animation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Animation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var obj: Animation.AnimationObject {
    get {return _obj ?? .shape}
    set {_obj = newValue}
  }
  /// Returns true if `obj` has been explicitly set.
  public var hasObj: Bool {return self._obj != nil}
  /// Clears the value of `obj`. Subsequent reads from it will return its default value.
  public mutating func clearObj() {self._obj = nil}

  /// Animation ID is present inside this data.
  public var data: AnimationData {
    get {return _data ?? AnimationData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// Shape Animation
  public var shapeAnim: Animation.ShapeAnimation {
    get {return _shapeAnim ?? Animation.ShapeAnimation()}
    set {_shapeAnim = newValue}
  }
  /// Returns true if `shapeAnim` has been explicitly set.
  public var hasShapeAnim: Bool {return self._shapeAnim != nil}
  /// Clears the value of `shapeAnim`. Subsequent reads from it will return its default value.
  public mutating func clearShapeAnim() {self._shapeAnim = nil}

  public var chartAnim: Animation.ChartAnimation {
    get {return _chartAnim ?? Animation.ChartAnimation()}
    set {_chartAnim = newValue}
  }
  /// Returns true if `chartAnim` has been explicitly set.
  public var hasChartAnim: Bool {return self._chartAnim != nil}
  /// Clears the value of `chartAnim`. Subsequent reads from it will return its default value.
  public mutating func clearChartAnim() {self._chartAnim = nil}

  public var tableAnim: Animation.TableAnimation {
    get {return _tableAnim ?? Animation.TableAnimation()}
    set {_tableAnim = newValue}
  }
  /// Returns true if `tableAnim` has been explicitly set.
  public var hasTableAnim: Bool {return self._tableAnim != nil}
  /// Clears the value of `tableAnim`. Subsequent reads from it will return its default value.
  public mutating func clearTableAnim() {self._tableAnim = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AnimationObject: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Shape.
    case shape // = 0

    /// Chart. You will have a separate ChartAnimation message for this.
    case chart // = 1
    case table // = 2

    public init() {
      self = .shape
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .shape
      case 1: self = .chart
      case 2: self = .table
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .shape: return 0
      case .chart: return 1
      case .table: return 2
      }
    }

  }

  /// If an animation has to be overridden for a paragraph
  /// it is available inside the paragraph proto. 
  public struct ShapeAnimation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var text: Animation.ShapeAnimation.TextAnimation {
      get {return _text ?? Animation.ShapeAnimation.TextAnimation()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    public var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    public mutating func clearText() {self._text = nil}

    /// Animate the attached Shape. 	
    public var animShape: Bool {
      get {return _animShape ?? false}
      set {_animShape = newValue}
    }
    /// Returns true if `animShape` has been explicitly set.
    public var hasAnimShape: Bool {return self._animShape != nil}
    /// Clears the value of `animShape`. Subsequent reads from it will return its default value.
    public mutating func clearAnimShape() {self._animShape = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct TextAnimation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: Animation.ShapeAnimation.TextAnimation.TextAnimationType {
        get {return _type ?? .box}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      /// Bullet Level Animation
      public var level: Animation.ShapeAnimation.TextAnimation.LevelAnimation {
        get {return _level ?? Animation.ShapeAnimation.TextAnimation.LevelAnimation()}
        set {_level = newValue}
      }
      /// Returns true if `level` has been explicitly set.
      public var hasLevel: Bool {return self._level != nil}
      /// Clears the value of `level`. Subsequent reads from it will return its default value.
      public mutating func clearLevel() {self._level = nil}

      /// Reverse the text animation.	
      public var reverse: Bool {
        get {return _reverse ?? false}
        set {_reverse = newValue}
      }
      /// Returns true if `reverse` has been explicitly set.
      public var hasReverse: Bool {return self._reverse != nil}
      /// Clears the value of `reverse`. Subsequent reads from it will return its default value.
      public mutating func clearReverse() {self._reverse = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum TextAnimationType: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// whole box.
        case box // = 0

        /// All Paras at the same time.	
        case para // = 1

        /// Animate every para one by one till the indicated PARA level.
        case level // = 2

        public init() {
          self = .box
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .box
          case 1: self = .para
          case 2: self = .level
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .box: return 0
          case .para: return 1
          case .level: return 2
          }
        }

      }

      public struct LevelAnimation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Bullet Num (from 1-9).
        public var num: Int32 {
          get {return _num ?? 0}
          set {_num = newValue}
        }
        /// Returns true if `num` has been explicitly set.
        public var hasNum: Bool {return self._num != nil}
        /// Clears the value of `num`. Subsequent reads from it will return its default value.
        public mutating func clearNum() {self._num = nil}

        /// Delay every para animation by a few seconds.
        public var delay: Float {
          get {return _delay ?? 0}
          set {_delay = newValue}
        }
        /// Returns true if `delay` has been explicitly set.
        public var hasDelay: Bool {return self._delay != nil}
        /// Clears the value of `delay`. Subsequent reads from it will return its default value.
        public mutating func clearDelay() {self._delay = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _num: Int32? = nil
        fileprivate var _delay: Float? = nil
      }

      public init() {}

      fileprivate var _type: Animation.ShapeAnimation.TextAnimation.TextAnimationType? = nil
      fileprivate var _level: Animation.ShapeAnimation.TextAnimation.LevelAnimation? = nil
      fileprivate var _reverse: Bool? = nil
    }

    public init() {}

    fileprivate var _text: Animation.ShapeAnimation.TextAnimation? = nil
    fileprivate var _animShape: Bool? = nil
  }

  public struct ChartAnimation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Animation.ChartAnimation.ChartAnimationDeliveryModel {
      get {return _type ?? .whole}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ChartAnimationDeliveryModel: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// All elements in a chart
      case whole // = 0

      /// One Series at a time.
      case seriesValue // = 1

      /// One Category at a time.
      case category // = 2

      /// Each element in the series
      case perSeriesValue // = 3

      /// Each element in category.
      case perCategory // = 4

      public init() {
        self = .whole
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .whole
        case 1: self = .seriesValue
        case 2: self = .category
        case 3: self = .perSeriesValue
        case 4: self = .perCategory
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .whole: return 0
        case .seriesValue: return 1
        case .category: return 2
        case .perSeriesValue: return 3
        case .perCategory: return 4
        }
      }

    }

    public init() {}

    fileprivate var _type: Animation.ChartAnimation.ChartAnimationDeliveryModel? = nil
  }

  public struct TableAnimation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Animation.TableAnimation.TableAnimationDeliveryModel {
      get {return _type ?? .whole}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var cell: Animation.TableAnimation.CellDeliveryModel {
      get {return _cell ?? .defTablecellDeliveryModel}
      set {_cell = newValue}
    }
    /// Returns true if `cell` has been explicitly set.
    public var hasCell: Bool {return self._cell != nil}
    /// Clears the value of `cell`. Subsequent reads from it will return its default value.
    public mutating func clearCell() {self._cell = nil}

    public var bandedFirst: Bool {
      get {return _bandedFirst ?? false}
      set {_bandedFirst = newValue}
    }
    /// Returns true if `bandedFirst` has been explicitly set.
    public var hasBandedFirst: Bool {return self._bandedFirst != nil}
    /// Clears the value of `bandedFirst`. Subsequent reads from it will return its default value.
    public mutating func clearBandedFirst() {self._bandedFirst = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TableAnimationDeliveryModel: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case whole // = 0
      case row // = 1
      case column // = 3
      case cell // = 4

      public init() {
        self = .whole
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .whole
        case 1: self = .row
        case 3: self = .column
        case 4: self = .cell
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .whole: return 0
        case .row: return 1
        case .column: return 3
        case .cell: return 4
        }
      }

    }

    public enum CellDeliveryModel: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case defTablecellDeliveryModel // = 0
      case rowWise // = 1
      case columnWise // = 2

      public init() {
        self = .defTablecellDeliveryModel
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .defTablecellDeliveryModel
        case 1: self = .rowWise
        case 2: self = .columnWise
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .defTablecellDeliveryModel: return 0
        case .rowWise: return 1
        case .columnWise: return 2
        }
      }

    }

    public init() {}

    fileprivate var _type: Animation.TableAnimation.TableAnimationDeliveryModel? = nil
    fileprivate var _cell: Animation.TableAnimation.CellDeliveryModel? = nil
    fileprivate var _bandedFirst: Bool? = nil
  }

  public init() {}

  fileprivate var _obj: Animation.AnimationObject? = nil
  fileprivate var _data: AnimationData? = nil
  fileprivate var _shapeAnim: Animation.ShapeAnimation? = nil
  fileprivate var _chartAnim: Animation.ChartAnimation? = nil
  fileprivate var _tableAnim: Animation.TableAnimation? = nil
}

#if swift(>=4.2)

extension Animation.AnimationObject: CaseIterable {
  // Support synthesized by the compiler.
}

extension Animation.ShapeAnimation.TextAnimation.TextAnimationType: CaseIterable {
  // Support synthesized by the compiler.
}

extension Animation.ChartAnimation.ChartAnimationDeliveryModel: CaseIterable {
  // Support synthesized by the compiler.
}

extension Animation.TableAnimation.TableAnimationDeliveryModel: CaseIterable {
  // Support synthesized by the compiler.
}

extension Animation.TableAnimation.CellDeliveryModel: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Animation: @unchecked Sendable {}
extension Animation.AnimationObject: @unchecked Sendable {}
extension Animation.ShapeAnimation: @unchecked Sendable {}
extension Animation.ShapeAnimation.TextAnimation: @unchecked Sendable {}
extension Animation.ShapeAnimation.TextAnimation.TextAnimationType: @unchecked Sendable {}
extension Animation.ShapeAnimation.TextAnimation.LevelAnimation: @unchecked Sendable {}
extension Animation.ChartAnimation: @unchecked Sendable {}
extension Animation.ChartAnimation.ChartAnimationDeliveryModel: @unchecked Sendable {}
extension Animation.TableAnimation: @unchecked Sendable {}
extension Animation.TableAnimation.TableAnimationDeliveryModel: @unchecked Sendable {}
extension Animation.TableAnimation.CellDeliveryModel: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension Animation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Animation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "obj"),
    2: .same(proto: "data"),
    3: .same(proto: "shapeAnim"),
    4: .same(proto: "chartAnim"),
    5: .same(proto: "tableAnim"),
  ]

  public var isInitialized: Bool {
    if self._obj == nil {return false}
    if self._data == nil {return false}
    if let v = self._data, !v.isInitialized {return false}
    if let v = self._shapeAnim, !v.isInitialized {return false}
    if let v = self._chartAnim, !v.isInitialized {return false}
    if let v = self._tableAnim, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._obj) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shapeAnim) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._chartAnim) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tableAnim) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._obj {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shapeAnim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._chartAnim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._tableAnim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Animation, rhs: Animation) -> Bool {
    if lhs._obj != rhs._obj {return false}
    if lhs._data != rhs._data {return false}
    if lhs._shapeAnim != rhs._shapeAnim {return false}
    if lhs._chartAnim != rhs._chartAnim {return false}
    if lhs._tableAnim != rhs._tableAnim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Animation.AnimationObject: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHAPE"),
    1: .same(proto: "CHART"),
    2: .same(proto: "TABLE"),
  ]
}

extension Animation.ShapeAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Animation.protoMessageName + ".ShapeAnimation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "animShape"),
  ]

  public var isInitialized: Bool {
    if self._text == nil {return false}
    if let v = self._text, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._animShape) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._animShape {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Animation.ShapeAnimation, rhs: Animation.ShapeAnimation) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._animShape != rhs._animShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Animation.ShapeAnimation.TextAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Animation.ShapeAnimation.protoMessageName + ".TextAnimation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "level"),
    3: .same(proto: "reverse"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._level) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._reverse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._level {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reverse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Animation.ShapeAnimation.TextAnimation, rhs: Animation.ShapeAnimation.TextAnimation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._level != rhs._level {return false}
    if lhs._reverse != rhs._reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Animation.ShapeAnimation.TextAnimation.TextAnimationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOX"),
    1: .same(proto: "PARA"),
    2: .same(proto: "LEVEL"),
  ]
}

extension Animation.ShapeAnimation.TextAnimation.LevelAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Animation.ShapeAnimation.TextAnimation.protoMessageName + ".LevelAnimation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "delay"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._num) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._delay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._num {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._delay {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Animation.ShapeAnimation.TextAnimation.LevelAnimation, rhs: Animation.ShapeAnimation.TextAnimation.LevelAnimation) -> Bool {
    if lhs._num != rhs._num {return false}
    if lhs._delay != rhs._delay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Animation.ChartAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Animation.protoMessageName + ".ChartAnimation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Animation.ChartAnimation, rhs: Animation.ChartAnimation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Animation.ChartAnimation.ChartAnimationDeliveryModel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHOLE"),
    1: .same(proto: "SERIES_VALUE"),
    2: .same(proto: "CATEGORY"),
    3: .same(proto: "PER_SERIES_VALUE"),
    4: .same(proto: "PER_CATEGORY"),
  ]
}

extension Animation.TableAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Animation.protoMessageName + ".TableAnimation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "cell"),
    3: .same(proto: "bandedFirst"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._cell) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._bandedFirst) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cell {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bandedFirst {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Animation.TableAnimation, rhs: Animation.TableAnimation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._cell != rhs._cell {return false}
    if lhs._bandedFirst != rhs._bandedFirst {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Animation.TableAnimation.TableAnimationDeliveryModel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHOLE"),
    1: .same(proto: "ROW"),
    3: .same(proto: "COLUMN"),
    4: .same(proto: "CELL"),
  ]
}

extension Animation.TableAnimation.CellDeliveryModel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_TABLECELL_DELIVERY_MODEL"),
    1: .same(proto: "ROW_WISE"),
    2: .same(proto: "COLUMN_WISE"),
  ]
}
