// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: datasourceapi.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct DataSourceAPI {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var externalSource: DataSourceAPI.DataSourceService {
    get {return _externalSource ?? .unknownService}
    set {_externalSource = newValue}
  }
  /// Returns true if `externalSource` has been explicitly set.
  public var hasExternalSource: Bool {return self._externalSource != nil}
  /// Clears the value of `externalSource`. Subsequent reads from it will return its default value.
  public mutating func clearExternalSource() {self._externalSource = nil}

  public var endPoint: DataSourceAPI.EndPoint {
    get {return _endPoint ?? DataSourceAPI.EndPoint()}
    set {_endPoint = newValue}
  }
  /// Returns true if `endPoint` has been explicitly set.
  public var hasEndPoint: Bool {return self._endPoint != nil}
  /// Clears the value of `endPoint`. Subsequent reads from it will return its default value.
  public mutating func clearEndPoint() {self._endPoint = nil}

  public var request: DataSourceAPI.Request {
    get {return _request ?? DataSourceAPI.Request()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var successResponse: DataSourceAPI.Response {
    get {return _successResponse ?? DataSourceAPI.Response()}
    set {_successResponse = newValue}
  }
  /// Returns true if `successResponse` has been explicitly set.
  public var hasSuccessResponse: Bool {return self._successResponse != nil}
  /// Clears the value of `successResponse`. Subsequent reads from it will return its default value.
  public mutating func clearSuccessResponse() {self._successResponse = nil}

  public var errorResponse: DataSourceAPI.Response {
    get {return _errorResponse ?? DataSourceAPI.Response()}
    set {_errorResponse = newValue}
  }
  /// Returns true if `errorResponse` has been explicitly set.
  public var hasErrorResponse: Bool {return self._errorResponse != nil}
  /// Clears the value of `errorResponse`. Subsequent reads from it will return its default value.
  public mutating func clearErrorResponse() {self._errorResponse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DataSourceService: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownService // = 0
    case zohoSheet // = 1

    public init() {
      self = .unknownService
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownService
      case 1: self = .zohoSheet
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownService: return 0
      case .zohoSheet: return 1
      }
    }

  }

  public struct EndPoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var modules: [DataSourceAPI.EndPoint.EndPointModule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct EndPointModule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: DataSourceAPI.EndPoint.EndPointModule.ModuleType {
        get {return _type ?? .unknownModuleType}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var str: String {
        get {return _str ?? String()}
        set {_str = newValue}
      }
      /// Returns true if `str` has been explicitly set.
      public var hasStr: Bool {return self._str != nil}
      /// Clears the value of `str`. Subsequent reads from it will return its default value.
      public mutating func clearStr() {self._str = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      ///Some module keys are variable ex. api/sheet/<workbookid>.
      public enum ModuleType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknownModuleType // = 0

        ///get from str
        case constant // = 1

        ///Client will pass it from datafield arguements
        case argument // = 2

        public init() {
          self = .unknownModuleType
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownModuleType
          case 1: self = .constant
          case 2: self = .argument
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknownModuleType: return 0
          case .constant: return 1
          case .argument: return 2
          }
        }

      }

      public init() {}

      fileprivate var _type: DataSourceAPI.EndPoint.EndPointModule.ModuleType? = nil
      fileprivate var _str: String? = nil
    }

    public init() {}
  }

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var keys: [DataSourceAPI.Request.RequestKey] = []

    public var method: DataSourceAPI.Request.RequestMethod {
      get {return _method ?? .unknownRequestMethod}
      set {_method = newValue}
    }
    /// Returns true if `method` has been explicitly set.
    public var hasMethod: Bool {return self._method != nil}
    /// Clears the value of `method`. Subsequent reads from it will return its default value.
    public mutating func clearMethod() {self._method = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum RequestMethod: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownRequestMethod // = 0
      case get // = 1
      case post // = 2

      public init() {
        self = .unknownRequestMethod
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownRequestMethod
        case 1: self = .get
        case 2: self = .post
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownRequestMethod: return 0
        case .get: return 1
        case .post: return 2
        }
      }

    }

    public struct RequestKey {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var str: String {
        get {return _str ?? String()}
        set {_str = newValue}
      }
      /// Returns true if `str` has been explicitly set.
      public var hasStr: Bool {return self._str != nil}
      /// Clears the value of `str`. Subsequent reads from it will return its default value.
      public mutating func clearStr() {self._str = nil}

      ///Certain param value remains same and client wont pass this. So keeping it here.
      public var value: String {
        get {return _value ?? String()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      public var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      public mutating func clearValue() {self._value = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _str: String? = nil
      fileprivate var _value: String? = nil
    }

    public init() {}

    fileprivate var _method: DataSourceAPI.Request.RequestMethod? = nil
  }

  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var params: [DataSourceAPI.Response.ResponseParams] = []

    public var type: DataSourceAPI.Response.ResponseType {
      get {return _type ?? .unknownReponseType}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ResponseType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownReponseType // = 0
      case json // = 1
      case xml // = 2

      public init() {
        self = .unknownReponseType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownReponseType
        case 1: self = .json
        case 2: self = .xml
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownReponseType: return 0
        case .json: return 1
        case .xml: return 2
        }
      }

    }

    public struct ResponseParams {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var str: String {
        get {return _str ?? String()}
        set {_str = newValue}
      }
      /// Returns true if `str` has been explicitly set.
      public var hasStr: Bool {return self._str != nil}
      /// Clears the value of `str`. Subsequent reads from it will return its default value.
      public mutating func clearStr() {self._str = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _str: String? = nil
    }

    public init() {}

    fileprivate var _type: DataSourceAPI.Response.ResponseType? = nil
  }

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _externalSource: DataSourceAPI.DataSourceService? = nil
  fileprivate var _endPoint: DataSourceAPI.EndPoint? = nil
  fileprivate var _request: DataSourceAPI.Request? = nil
  fileprivate var _successResponse: DataSourceAPI.Response? = nil
  fileprivate var _errorResponse: DataSourceAPI.Response? = nil
}

#if swift(>=4.2)

extension DataSourceAPI.DataSourceService: CaseIterable {
  // Support synthesized by the compiler.
}

extension DataSourceAPI.EndPoint.EndPointModule.ModuleType: CaseIterable {
  // Support synthesized by the compiler.
}

extension DataSourceAPI.Request.RequestMethod: CaseIterable {
  // Support synthesized by the compiler.
}

extension DataSourceAPI.Response.ResponseType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension DataSourceAPI: @unchecked Sendable {}
extension DataSourceAPI.DataSourceService: @unchecked Sendable {}
extension DataSourceAPI.EndPoint: @unchecked Sendable {}
extension DataSourceAPI.EndPoint.EndPointModule: @unchecked Sendable {}
extension DataSourceAPI.EndPoint.EndPointModule.ModuleType: @unchecked Sendable {}
extension DataSourceAPI.Request: @unchecked Sendable {}
extension DataSourceAPI.Request.RequestMethod: @unchecked Sendable {}
extension DataSourceAPI.Request.RequestKey: @unchecked Sendable {}
extension DataSourceAPI.Response: @unchecked Sendable {}
extension DataSourceAPI.Response.ResponseType: @unchecked Sendable {}
extension DataSourceAPI.Response.ResponseParams: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.common"

extension DataSourceAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataSourceAPI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "externalSource"),
    3: .same(proto: "endPoint"),
    4: .same(proto: "request"),
    5: .same(proto: "successResponse"),
    6: .same(proto: "errorResponse"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._externalSource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endPoint) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._successResponse) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._errorResponse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._externalSource {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._successResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._errorResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataSourceAPI, rhs: DataSourceAPI) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._externalSource != rhs._externalSource {return false}
    if lhs._endPoint != rhs._endPoint {return false}
    if lhs._request != rhs._request {return false}
    if lhs._successResponse != rhs._successResponse {return false}
    if lhs._errorResponse != rhs._errorResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataSourceAPI.DataSourceService: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SERVICE"),
    1: .same(proto: "ZOHO_SHEET"),
  ]
}

extension DataSourceAPI.EndPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DataSourceAPI.protoMessageName + ".EndPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataSourceAPI.EndPoint, rhs: DataSourceAPI.EndPoint) -> Bool {
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataSourceAPI.EndPoint.EndPointModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DataSourceAPI.EndPoint.protoMessageName + ".EndPointModule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "str"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._str) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._str {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataSourceAPI.EndPoint.EndPointModule, rhs: DataSourceAPI.EndPoint.EndPointModule) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._str != rhs._str {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataSourceAPI.EndPoint.EndPointModule.ModuleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_MODULE_TYPE"),
    1: .same(proto: "CONSTANT"),
    2: .same(proto: "ARGUMENT"),
  ]
}

extension DataSourceAPI.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DataSourceAPI.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "method"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._method) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try { if let v = self._method {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataSourceAPI.Request, rhs: DataSourceAPI.Request) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs._method != rhs._method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataSourceAPI.Request.RequestMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REQUEST_METHOD"),
    1: .same(proto: "GET"),
    2: .same(proto: "POST"),
  ]
}

extension DataSourceAPI.Request.RequestKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DataSourceAPI.Request.protoMessageName + ".RequestKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "str"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._str) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._str {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataSourceAPI.Request.RequestKey, rhs: DataSourceAPI.Request.RequestKey) -> Bool {
    if lhs._str != rhs._str {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataSourceAPI.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DataSourceAPI.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.params) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.params.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.params, fieldNumber: 1)
    }
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataSourceAPI.Response, rhs: DataSourceAPI.Response) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataSourceAPI.Response.ResponseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REPONSE_TYPE"),
    1: .same(proto: "JSON"),
    2: .same(proto: "XML"),
  ]
}

extension DataSourceAPI.Response.ResponseParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DataSourceAPI.Response.protoMessageName + ".ResponseParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "str"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._str) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._str {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DataSourceAPI.Response.ResponseParams, rhs: DataSourceAPI.Response.ResponseParams) -> Bool {
    if lhs._str != rhs._str {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
