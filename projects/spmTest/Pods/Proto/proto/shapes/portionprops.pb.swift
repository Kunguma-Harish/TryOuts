// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: portionprops.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PortionProps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// font name
  public var font: Font {
    get {return _storage._font ?? Font()}
    set {_uniqueStorage()._font = newValue}
  }
  /// Returns true if `font` has been explicitly set.
  public var hasFont: Bool {return _storage._font != nil}
  /// Clears the value of `font`. Subsequent reads from it will return its default value.
  public mutating func clearFont() {_uniqueStorage()._font = nil}

  /// font fill
  public var fill: Fill {
    get {return _storage._fill ?? Fill()}
    set {_uniqueStorage()._fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  public var hasFill: Bool {return _storage._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  public mutating func clearFill() {_uniqueStorage()._fill = nil}

  /// font stroke
  public var stroke: Stroke {
    get {return _storage._stroke ?? Stroke()}
    set {_uniqueStorage()._stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  public var hasStroke: Bool {return _storage._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  public mutating func clearStroke() {_uniqueStorage()._stroke = nil}

  /// font size , in pt. Font Size alone is stored in Pt instead of pixel , as there are rendering differences in the browser between pixel and point. The font size will change accoring to the slide size and will be handled by Rendering engine. 
  public var size: Float {
    get {return _storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {_uniqueStorage()._size = nil}

  /// Bold -- Deprecated.
  public var bold: Bool {
    get {return _storage._bold ?? false}
    set {_uniqueStorage()._bold = newValue}
  }
  /// Returns true if `bold` has been explicitly set.
  public var hasBold: Bool {return _storage._bold != nil}
  /// Clears the value of `bold`. Subsequent reads from it will return its default value.
  public mutating func clearBold() {_uniqueStorage()._bold = nil}

  /// Italic
  public var italic: Bool {
    get {return _storage._italic ?? false}
    set {_uniqueStorage()._italic = newValue}
  }
  /// Returns true if `italic` has been explicitly set.
  public var hasItalic: Bool {return _storage._italic != nil}
  /// Clears the value of `italic`. Subsequent reads from it will return its default value.
  public mutating func clearItalic() {_uniqueStorage()._italic = nil}

  /// Underline	
  public var underline: LineType {
    get {return _storage._underline ?? .none}
    set {_uniqueStorage()._underline = newValue}
  }
  /// Returns true if `underline` has been explicitly set.
  public var hasUnderline: Bool {return _storage._underline != nil}
  /// Clears the value of `underline`. Subsequent reads from it will return its default value.
  public mutating func clearUnderline() {_uniqueStorage()._underline = nil}

  /// Strike through	
  public var strike: LineType {
    get {return _storage._strike ?? .none}
    set {_uniqueStorage()._strike = newValue}
  }
  /// Returns true if `strike` has been explicitly set.
  public var hasStrike: Bool {return _storage._strike != nil}
  /// Clears the value of `strike`. Subsequent reads from it will return its default value.
  public mutating func clearStrike() {_uniqueStorage()._strike = nil}

  /// As of now , any positive value indicates superscript and negative value indicates subscript. 0.3 represents 30% superscript and -0.25 represents 25% subscript. % indicates depends on font size.
  public var baseline: Float {
    get {return _storage._baseline ?? 0}
    set {_uniqueStorage()._baseline = newValue}
  }
  /// Returns true if `baseline` has been explicitly set.
  public var hasBaseline: Bool {return _storage._baseline != nil}
  /// Clears the value of `baseline`. Subsequent reads from it will return its default value.
  public mutating func clearBaseline() {_uniqueStorage()._baseline = nil}

  public var cap: PortionField.FontVariant {
    get {return _storage._cap ?? .smallcaps}
    set {_uniqueStorage()._cap = newValue}
  }
  /// Returns true if `cap` has been explicitly set.
  public var hasCap: Bool {return _storage._cap != nil}
  /// Clears the value of `cap`. Subsequent reads from it will return its default value.
  public mutating func clearCap() {_uniqueStorage()._cap = nil}

  /// Positive Value indicate expansion of Character space , negative values indicates contraction. indicated in Px.
  public var space: Float {
    get {return _storage._space ?? 0}
    set {_uniqueStorage()._space = newValue}
  }
  /// Returns true if `space` has been explicitly set.
  public var hasSpace: Bool {return _storage._space != nil}
  /// Clears the value of `space`. Subsequent reads from it will return its default value.
  public mutating func clearSpace() {_uniqueStorage()._space = nil}

  /// Hyperlink action on click
  public var click: HyperLink {
    get {return _storage._click ?? HyperLink()}
    set {_uniqueStorage()._click = newValue}
  }
  /// Returns true if `click` has been explicitly set.
  public var hasClick: Bool {return _storage._click != nil}
  /// Clears the value of `click`. Subsequent reads from it will return its default value.
  public mutating func clearClick() {_uniqueStorage()._click = nil}

  /// Hyperlink action on mouse over.
  public var hover: HyperLink {
    get {return _storage._hover ?? HyperLink()}
    set {_uniqueStorage()._hover = newValue}
  }
  /// Returns true if `hover` has been explicitly set.
  public var hasHover: Bool {return _storage._hover != nil}
  /// Clears the value of `hover`. Subsequent reads from it will return its default value.
  public mutating func clearHover() {_uniqueStorage()._hover = nil}

  /// Replace "bold" with this enum.
  public var fontweight: PortionField.FontWeight {
    get {return _storage._fontweight ?? .thin}
    set {_uniqueStorage()._fontweight = newValue}
  }
  /// Returns true if `fontweight` has been explicitly set.
  public var hasFontweight: Bool {return _storage._fontweight != nil}
  /// Clears the value of `fontweight`. Subsequent reads from it will return its default value.
  public mutating func clearFontweight() {_uniqueStorage()._fontweight = nil}

  public var chk: PortionProps.ReviewCheck {
    get {return _storage._chk ?? PortionProps.ReviewCheck()}
    set {_uniqueStorage()._chk = newValue}
  }
  /// Returns true if `chk` has been explicitly set.
  public var hasChk: Bool {return _storage._chk != nil}
  /// Clears the value of `chk`. Subsequent reads from it will return its default value.
  public mutating func clearChk() {_uniqueStorage()._chk = nil}

  /// Comments associated with this portion.
  public var commentIds: [String] {
    get {return _storage._commentIds}
    set {_uniqueStorage()._commentIds = newValue}
  }

  /// Effects on a text i.e. Shadow , reflection etc..
  public var effects: Effects {
    get {return _storage._effects ?? Effects()}
    set {_uniqueStorage()._effects = newValue}
  }
  /// Returns true if `effects` has been explicitly set.
  public var hasEffects: Bool {return _storage._effects != nil}
  /// Clears the value of `effects`. Subsequent reads from it will return its default value.
  public mutating func clearEffects() {_uniqueStorage()._effects = nil}

  /// This is the font post script name. Required to handle all system based fonts. 
  public var postScriptName: String {
    get {return _storage._postScriptName ?? String()}
    set {_uniqueStorage()._postScriptName = newValue}
  }
  /// Returns true if `postScriptName` has been explicitly set.
  public var hasPostScriptName: Bool {return _storage._postScriptName != nil}
  /// Clears the value of `postScriptName`. Subsequent reads from it will return its default value.
  public mutating func clearPostScriptName() {_uniqueStorage()._postScriptName = nil}

  public var textLayerProps: TextLayerProperties {
    get {return _storage._textLayerProps ?? TextLayerProperties()}
    set {_uniqueStorage()._textLayerProps = newValue}
  }
  /// Returns true if `textLayerProps` has been explicitly set.
  public var hasTextLayerProps: Bool {return _storage._textLayerProps != nil}
  /// Clears the value of `textLayerProps`. Subsequent reads from it will return its default value.
  public mutating func clearTextLayerProps() {_uniqueStorage()._textLayerProps = nil}

  public var styleRef: StyleReferenceDetails {
    get {return _storage._styleRef ?? StyleReferenceDetails()}
    set {_uniqueStorage()._styleRef = newValue}
  }
  /// Returns true if `styleRef` has been explicitly set.
  public var hasStyleRef: Bool {return _storage._styleRef != nil}
  /// Clears the value of `styleRef`. Subsequent reads from it will return its default value.
  public mutating func clearStyleRef() {_uniqueStorage()._styleRef = nil}

  public var highlight: Fill {
    get {return _storage._highlight ?? Fill()}
    set {_uniqueStorage()._highlight = newValue}
  }
  /// Returns true if `highlight` has been explicitly set.
  public var hasHighlight: Bool {return _storage._highlight != nil}
  /// Clears the value of `highlight`. Subsequent reads from it will return its default value.
  public mutating func clearHighlight() {_uniqueStorage()._highlight = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates whether we have checked the contents for any spelling/grammar and if it has any errors.
  public struct ReviewCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var state: PortionProps.ReviewCheck.ReviewState {
      get {return _state ?? .error}
      set {_state = newValue}
    }
    /// Returns true if `state` has been explicitly set.
    public var hasState: Bool {return self._state != nil}
    /// Clears the value of `state`. Subsequent reads from it will return its default value.
    public mutating func clearState() {self._state = nil}

    public var lang: String {
      get {return _lang ?? String()}
      set {_lang = newValue}
    }
    /// Returns true if `lang` has been explicitly set.
    public var hasLang: Bool {return self._lang != nil}
    /// Clears the value of `lang`. Subsequent reads from it will return its default value.
    public mutating func clearLang() {self._lang = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ReviewState: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case error // = 0
      case processed // = 1
      case ignored // = 2

      public init() {
        self = .error
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .error
        case 1: self = .processed
        case 2: self = .ignored
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .error: return 0
        case .processed: return 1
        case .ignored: return 2
        }
      }

    }

    public init() {}

    fileprivate var _state: PortionProps.ReviewCheck.ReviewState? = nil
    fileprivate var _lang: String? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension PortionProps.ReviewCheck.ReviewState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension PortionProps: @unchecked Sendable {}
extension PortionProps.ReviewCheck: @unchecked Sendable {}
extension PortionProps.ReviewCheck.ReviewState: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension PortionProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PortionProps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "font"),
    2: .same(proto: "fill"),
    3: .same(proto: "stroke"),
    4: .same(proto: "size"),
    5: .same(proto: "bold"),
    6: .same(proto: "italic"),
    7: .same(proto: "underline"),
    8: .same(proto: "strike"),
    9: .same(proto: "baseline"),
    10: .same(proto: "cap"),
    11: .same(proto: "space"),
    12: .same(proto: "click"),
    13: .same(proto: "hover"),
    14: .same(proto: "fontweight"),
    15: .same(proto: "chk"),
    16: .same(proto: "commentIds"),
    17: .same(proto: "effects"),
    18: .same(proto: "postScriptName"),
    19: .same(proto: "textLayerProps"),
    20: .same(proto: "styleRef"),
    21: .same(proto: "highlight"),
  ]

  fileprivate class _StorageClass {
    var _font: Font? = nil
    var _fill: Fill? = nil
    var _stroke: Stroke? = nil
    var _size: Float? = nil
    var _bold: Bool? = nil
    var _italic: Bool? = nil
    var _underline: LineType? = nil
    var _strike: LineType? = nil
    var _baseline: Float? = nil
    var _cap: PortionField.FontVariant? = nil
    var _space: Float? = nil
    var _click: HyperLink? = nil
    var _hover: HyperLink? = nil
    var _fontweight: PortionField.FontWeight? = nil
    var _chk: PortionProps.ReviewCheck? = nil
    var _commentIds: [String] = []
    var _effects: Effects? = nil
    var _postScriptName: String? = nil
    var _textLayerProps: TextLayerProperties? = nil
    var _styleRef: StyleReferenceDetails? = nil
    var _highlight: Fill? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _font = source._font
      _fill = source._fill
      _stroke = source._stroke
      _size = source._size
      _bold = source._bold
      _italic = source._italic
      _underline = source._underline
      _strike = source._strike
      _baseline = source._baseline
      _cap = source._cap
      _space = source._space
      _click = source._click
      _hover = source._hover
      _fontweight = source._fontweight
      _chk = source._chk
      _commentIds = source._commentIds
      _effects = source._effects
      _postScriptName = source._postScriptName
      _textLayerProps = source._textLayerProps
      _styleRef = source._styleRef
      _highlight = source._highlight
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._font, !v.isInitialized {return false}
      if let v = _storage._fill, !v.isInitialized {return false}
      if let v = _storage._stroke, !v.isInitialized {return false}
      if let v = _storage._click, !v.isInitialized {return false}
      if let v = _storage._hover, !v.isInitialized {return false}
      if let v = _storage._effects, !v.isInitialized {return false}
      if let v = _storage._textLayerProps, !v.isInitialized {return false}
      if let v = _storage._highlight, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._font) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._size) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._bold) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._italic) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._underline) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._strike) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._baseline) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._cap) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._space) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._click) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._hover) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._fontweight) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._chk) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._commentIds) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._effects) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._postScriptName) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._textLayerProps) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._styleRef) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._highlight) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._font {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bold {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._italic {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._underline {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._strike {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._baseline {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._cap {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._space {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._click {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._hover {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._fontweight {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._chk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._commentIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commentIds, fieldNumber: 16)
      }
      try { if let v = _storage._effects {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._postScriptName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._textLayerProps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._styleRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._highlight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortionProps, rhs: PortionProps) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._font != rhs_storage._font {return false}
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._bold != rhs_storage._bold {return false}
        if _storage._italic != rhs_storage._italic {return false}
        if _storage._underline != rhs_storage._underline {return false}
        if _storage._strike != rhs_storage._strike {return false}
        if _storage._baseline != rhs_storage._baseline {return false}
        if _storage._cap != rhs_storage._cap {return false}
        if _storage._space != rhs_storage._space {return false}
        if _storage._click != rhs_storage._click {return false}
        if _storage._hover != rhs_storage._hover {return false}
        if _storage._fontweight != rhs_storage._fontweight {return false}
        if _storage._chk != rhs_storage._chk {return false}
        if _storage._commentIds != rhs_storage._commentIds {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._postScriptName != rhs_storage._postScriptName {return false}
        if _storage._textLayerProps != rhs_storage._textLayerProps {return false}
        if _storage._styleRef != rhs_storage._styleRef {return false}
        if _storage._highlight != rhs_storage._highlight {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortionProps.ReviewCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PortionProps.protoMessageName + ".ReviewCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "lang"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._lang) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lang {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PortionProps.ReviewCheck, rhs: PortionProps.ReviewCheck) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs._lang != rhs._lang {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PortionProps.ReviewCheck.ReviewState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR"),
    1: .same(proto: "PROCESSED"),
    2: .same(proto: "IGNORED"),
  ]
}
