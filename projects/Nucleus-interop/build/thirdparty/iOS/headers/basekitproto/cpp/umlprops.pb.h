// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: umlprops.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_umlprops_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_umlprops_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "designdiagramfields.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_umlprops_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_umlprops_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_umlprops_2eproto;
namespace com {
namespace zoho {
namespace kits {
class UMLProps;
struct UMLPropsDefaultTypeInternal;
extern UMLPropsDefaultTypeInternal _UMLProps_default_instance_;
class UMLProps_ClassDiagram;
struct UMLProps_ClassDiagramDefaultTypeInternal;
extern UMLProps_ClassDiagramDefaultTypeInternal _UMLProps_ClassDiagram_default_instance_;
class UMLProps_ClassDiagram_UMLClassConnection;
struct UMLProps_ClassDiagram_UMLClassConnectionDefaultTypeInternal;
extern UMLProps_ClassDiagram_UMLClassConnectionDefaultTypeInternal _UMLProps_ClassDiagram_UMLClassConnection_default_instance_;
class UMLProps_ClassDiagram_UMLClassRelationship;
struct UMLProps_ClassDiagram_UMLClassRelationshipDefaultTypeInternal;
extern UMLProps_ClassDiagram_UMLClassRelationshipDefaultTypeInternal _UMLProps_ClassDiagram_UMLClassRelationship_default_instance_;
class UMLProps_UsecaseDiagram;
struct UMLProps_UsecaseDiagramDefaultTypeInternal;
extern UMLProps_UsecaseDiagramDefaultTypeInternal _UMLProps_UsecaseDiagram_default_instance_;
class UMLProps_UsecaseDiagram_UMLUsecaseConnection;
struct UMLProps_UsecaseDiagram_UMLUsecaseConnectionDefaultTypeInternal;
extern UMLProps_UsecaseDiagram_UMLUsecaseConnectionDefaultTypeInternal _UMLProps_UsecaseDiagram_UMLUsecaseConnection_default_instance_;
class UMLProps_UsecaseDiagram_UMLUsecaseRelationship;
struct UMLProps_UsecaseDiagram_UMLUsecaseRelationshipDefaultTypeInternal;
extern UMLProps_UsecaseDiagram_UMLUsecaseRelationshipDefaultTypeInternal _UMLProps_UsecaseDiagram_UMLUsecaseRelationship_default_instance_;
}  // namespace kits
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace kits {
enum UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType : int {
  UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_UNKNOWN_DIRECTED_ASSOCIATION = 0,
  UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_INITIATOR = 1,
  UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_TARGET = 2,
  UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_internal_data_[];
constexpr UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_DirectedAssociationType_MIN = static_cast<UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType>(0);
constexpr UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_DirectedAssociationType_MAX = static_cast<UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType>(2);
constexpr int UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_DirectedAssociationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DirectedAssociationType_Name().");
  return UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_Name(static_cast<UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_Name(UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_Parse(absl::string_view name, UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType>(
      UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_descriptor(), name, value);
}
enum UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type : int {
  UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_UNKNOWN_AGGREGATION = 0,
  UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_WHOLE = 1,
  UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_PART = 2,
  UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_internal_data_[];
constexpr UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Aggregation_Composition_Type_MIN = static_cast<UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>(0);
constexpr UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Aggregation_Composition_Type_MAX = static_cast<UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>(2);
constexpr int UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Aggregation_Composition_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Aggregation_Composition_Type_Name().");
  return UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Name(static_cast<UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Name(UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Parse(absl::string_view name, UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>(
      UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_descriptor(), name, value);
}
enum UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType : int {
  UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_UNKNOWN_GENERALIZATION = 0,
  UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_SUB_CLASS = 1,
  UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_SUPER_CLASS = 2,
  UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_internal_data_[];
constexpr UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_GeneralizationType_MIN = static_cast<UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType>(0);
constexpr UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_GeneralizationType_MAX = static_cast<UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType>(2);
constexpr int UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_GeneralizationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GeneralizationType_Name().");
  return UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_Name(static_cast<UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_Name(UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_Parse(absl::string_view name, UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType>(
      UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_descriptor(), name, value);
}
enum UMLProps_ClassDiagram_UMLClassConnection_RealizationType : int {
  UMLProps_ClassDiagram_UMLClassConnection_RealizationType_UNKNOWN_REALIZATION = 0,
  UMLProps_ClassDiagram_UMLClassConnection_RealizationType_IMPLEMENTING_CLASS = 1,
  UMLProps_ClassDiagram_UMLClassConnection_RealizationType_INTERFACE = 2,
  UMLProps_ClassDiagram_UMLClassConnection_RealizationType_UMLProps_ClassDiagram_UMLClassConnection_RealizationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_UMLClassConnection_RealizationType_UMLProps_ClassDiagram_UMLClassConnection_RealizationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_UMLClassConnection_RealizationType_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_UMLClassConnection_RealizationType_internal_data_[];
constexpr UMLProps_ClassDiagram_UMLClassConnection_RealizationType UMLProps_ClassDiagram_UMLClassConnection_RealizationType_RealizationType_MIN = static_cast<UMLProps_ClassDiagram_UMLClassConnection_RealizationType>(0);
constexpr UMLProps_ClassDiagram_UMLClassConnection_RealizationType UMLProps_ClassDiagram_UMLClassConnection_RealizationType_RealizationType_MAX = static_cast<UMLProps_ClassDiagram_UMLClassConnection_RealizationType>(2);
constexpr int UMLProps_ClassDiagram_UMLClassConnection_RealizationType_RealizationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_UMLClassConnection_RealizationType_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_UMLClassConnection_RealizationType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_UMLClassConnection_RealizationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RealizationType_Name().");
  return UMLProps_ClassDiagram_UMLClassConnection_RealizationType_Name(static_cast<UMLProps_ClassDiagram_UMLClassConnection_RealizationType>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_UMLClassConnection_RealizationType_Name(UMLProps_ClassDiagram_UMLClassConnection_RealizationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_UMLClassConnection_RealizationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_UMLClassConnection_RealizationType_Parse(absl::string_view name, UMLProps_ClassDiagram_UMLClassConnection_RealizationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_UMLClassConnection_RealizationType>(
      UMLProps_ClassDiagram_UMLClassConnection_RealizationType_descriptor(), name, value);
}
enum UMLProps_ClassDiagram_UMLClassConnection_DependencyType : int {
  UMLProps_ClassDiagram_UMLClassConnection_DependencyType_UNKNOWN_DEPENDENCY = 0,
  UMLProps_ClassDiagram_UMLClassConnection_DependencyType_SOURCE = 1,
  UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DEPENDENT = 2,
  UMLProps_ClassDiagram_UMLClassConnection_DependencyType_UMLProps_ClassDiagram_UMLClassConnection_DependencyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_UMLClassConnection_DependencyType_UMLProps_ClassDiagram_UMLClassConnection_DependencyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_UMLClassConnection_DependencyType_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_UMLClassConnection_DependencyType_internal_data_[];
constexpr UMLProps_ClassDiagram_UMLClassConnection_DependencyType UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DependencyType_MIN = static_cast<UMLProps_ClassDiagram_UMLClassConnection_DependencyType>(0);
constexpr UMLProps_ClassDiagram_UMLClassConnection_DependencyType UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DependencyType_MAX = static_cast<UMLProps_ClassDiagram_UMLClassConnection_DependencyType>(2);
constexpr int UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DependencyType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_UMLClassConnection_DependencyType_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_UMLClassConnection_DependencyType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_UMLClassConnection_DependencyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DependencyType_Name().");
  return UMLProps_ClassDiagram_UMLClassConnection_DependencyType_Name(static_cast<UMLProps_ClassDiagram_UMLClassConnection_DependencyType>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_UMLClassConnection_DependencyType_Name(UMLProps_ClassDiagram_UMLClassConnection_DependencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_UMLClassConnection_DependencyType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_UMLClassConnection_DependencyType_Parse(absl::string_view name, UMLProps_ClassDiagram_UMLClassConnection_DependencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_UMLClassConnection_DependencyType>(
      UMLProps_ClassDiagram_UMLClassConnection_DependencyType_descriptor(), name, value);
}
enum UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType : int {
  UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UNKNOWN_USAGE_TYPE = 0,
  UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_CLIENT = 1,
  UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_SUPPLIER = 2,
  UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_internal_data_[];
constexpr UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UsageDependencyType_MIN = static_cast<UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType>(0);
constexpr UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UsageDependencyType_MAX = static_cast<UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType>(2);
constexpr int UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UsageDependencyType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UsageDependencyType_Name().");
  return UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_Name(static_cast<UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_Name(UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_Parse(absl::string_view name, UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType>(
      UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_descriptor(), name, value);
}
enum UMLProps_ClassDiagram_ClassDiagramComponent : int {
  UMLProps_ClassDiagram_ClassDiagramComponent_UNKNOWN_CLASS_DIAGRAM_COMPONENT = 0,
  UMLProps_ClassDiagram_ClassDiagramComponent_CLASS = 1,
  UMLProps_ClassDiagram_ClassDiagramComponent_ACTIVE_CLASS = 2,
  UMLProps_ClassDiagram_ClassDiagramComponent_SIMPLE_CLASS = 3,
  UMLProps_ClassDiagram_ClassDiagramComponent_INTERFACE = 4,
  UMLProps_ClassDiagram_ClassDiagramComponent_SIMPLE_INTERFACE = 5,
  UMLProps_ClassDiagram_ClassDiagramComponent_MULTIPLICITY = 6,
  UMLProps_ClassDiagram_ClassDiagramComponent_PACKAGE = 7,
  UMLProps_ClassDiagram_ClassDiagramComponent_CONSTRAINT = 8,
  UMLProps_ClassDiagram_ClassDiagramComponent_NOTE = 9,
  UMLProps_ClassDiagram_ClassDiagramComponent_TEXT = 10,
  UMLProps_ClassDiagram_ClassDiagramComponent_RELATIONSHIP = 11,
  UMLProps_ClassDiagram_ClassDiagramComponent_UMLProps_ClassDiagram_ClassDiagramComponent_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_ClassDiagramComponent_UMLProps_ClassDiagram_ClassDiagramComponent_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_ClassDiagramComponent_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_ClassDiagramComponent_internal_data_[];
constexpr UMLProps_ClassDiagram_ClassDiagramComponent UMLProps_ClassDiagram_ClassDiagramComponent_ClassDiagramComponent_MIN = static_cast<UMLProps_ClassDiagram_ClassDiagramComponent>(0);
constexpr UMLProps_ClassDiagram_ClassDiagramComponent UMLProps_ClassDiagram_ClassDiagramComponent_ClassDiagramComponent_MAX = static_cast<UMLProps_ClassDiagram_ClassDiagramComponent>(11);
constexpr int UMLProps_ClassDiagram_ClassDiagramComponent_ClassDiagramComponent_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_ClassDiagramComponent_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_ClassDiagramComponent_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_ClassDiagramComponent>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ClassDiagramComponent_Name().");
  return UMLProps_ClassDiagram_ClassDiagramComponent_Name(static_cast<UMLProps_ClassDiagram_ClassDiagramComponent>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_ClassDiagramComponent_Name(UMLProps_ClassDiagram_ClassDiagramComponent value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_ClassDiagramComponent_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_ClassDiagramComponent_Parse(absl::string_view name, UMLProps_ClassDiagram_ClassDiagramComponent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_ClassDiagramComponent>(
      UMLProps_ClassDiagram_ClassDiagramComponent_descriptor(), name, value);
}
enum UMLProps_ClassDiagram_RelationshipType : int {
  UMLProps_ClassDiagram_RelationshipType_UNKNOWN_ASSOCIATION = 0,
  UMLProps_ClassDiagram_RelationshipType_DIRECTED_ASSOCIATION = 1,
  UMLProps_ClassDiagram_RelationshipType_NON_DIRECTED_ASSOCIATION = 2,
  UMLProps_ClassDiagram_RelationshipType_GENERALIZATION = 3,
  UMLProps_ClassDiagram_RelationshipType_DEPENDENCY = 4,
  UMLProps_ClassDiagram_RelationshipType_AGGREGATION = 5,
  UMLProps_ClassDiagram_RelationshipType_COMPOSITION = 6,
  UMLProps_ClassDiagram_RelationshipType_REALIZATION = 7,
  UMLProps_ClassDiagram_RelationshipType_USAGE = 8,
  UMLProps_ClassDiagram_RelationshipType_UMLProps_ClassDiagram_RelationshipType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_ClassDiagram_RelationshipType_UMLProps_ClassDiagram_RelationshipType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_ClassDiagram_RelationshipType_IsValid(int value);
extern const uint32_t UMLProps_ClassDiagram_RelationshipType_internal_data_[];
constexpr UMLProps_ClassDiagram_RelationshipType UMLProps_ClassDiagram_RelationshipType_RelationshipType_MIN = static_cast<UMLProps_ClassDiagram_RelationshipType>(0);
constexpr UMLProps_ClassDiagram_RelationshipType UMLProps_ClassDiagram_RelationshipType_RelationshipType_MAX = static_cast<UMLProps_ClassDiagram_RelationshipType>(8);
constexpr int UMLProps_ClassDiagram_RelationshipType_RelationshipType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_ClassDiagram_RelationshipType_descriptor();
template <typename T>
const std::string& UMLProps_ClassDiagram_RelationshipType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_ClassDiagram_RelationshipType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RelationshipType_Name().");
  return UMLProps_ClassDiagram_RelationshipType_Name(static_cast<UMLProps_ClassDiagram_RelationshipType>(value));
}
template <>
inline const std::string& UMLProps_ClassDiagram_RelationshipType_Name(UMLProps_ClassDiagram_RelationshipType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_ClassDiagram_RelationshipType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool UMLProps_ClassDiagram_RelationshipType_Parse(absl::string_view name, UMLProps_ClassDiagram_RelationshipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_ClassDiagram_RelationshipType>(
      UMLProps_ClassDiagram_RelationshipType_descriptor(), name, value);
}
enum UMLProps_UsecaseDiagram_UsecaseDiagramComponent : int {
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UNKNOWN_USECASE_DIAGRAM_COMPONENT = 0,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_ACTOR = 1,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_USECASE = 2,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_USECASE_WITH_EXTENSION = 3,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_CONTAINER_RECTANGLE = 4,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_CONTAINER_OVAL = 5,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_NOTE = 6,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_TEXT = 7,
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UMLProps_UsecaseDiagram_UsecaseDiagramComponent_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UMLProps_UsecaseDiagram_UsecaseDiagramComponent_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_UsecaseDiagram_UsecaseDiagramComponent_IsValid(int value);
extern const uint32_t UMLProps_UsecaseDiagram_UsecaseDiagramComponent_internal_data_[];
constexpr UMLProps_UsecaseDiagram_UsecaseDiagramComponent UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UsecaseDiagramComponent_MIN = static_cast<UMLProps_UsecaseDiagram_UsecaseDiagramComponent>(0);
constexpr UMLProps_UsecaseDiagram_UsecaseDiagramComponent UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UsecaseDiagramComponent_MAX = static_cast<UMLProps_UsecaseDiagram_UsecaseDiagramComponent>(7);
constexpr int UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UsecaseDiagramComponent_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_UsecaseDiagram_UsecaseDiagramComponent_descriptor();
template <typename T>
const std::string& UMLProps_UsecaseDiagram_UsecaseDiagramComponent_Name(T value) {
  static_assert(std::is_same<T, UMLProps_UsecaseDiagram_UsecaseDiagramComponent>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UsecaseDiagramComponent_Name().");
  return UMLProps_UsecaseDiagram_UsecaseDiagramComponent_Name(static_cast<UMLProps_UsecaseDiagram_UsecaseDiagramComponent>(value));
}
template <>
inline const std::string& UMLProps_UsecaseDiagram_UsecaseDiagramComponent_Name(UMLProps_UsecaseDiagram_UsecaseDiagramComponent value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_UsecaseDiagram_UsecaseDiagramComponent_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool UMLProps_UsecaseDiagram_UsecaseDiagramComponent_Parse(absl::string_view name, UMLProps_UsecaseDiagram_UsecaseDiagramComponent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_UsecaseDiagram_UsecaseDiagramComponent>(
      UMLProps_UsecaseDiagram_UsecaseDiagramComponent_descriptor(), name, value);
}
enum UMLProps_UsecaseDiagram_RelationshipType : int {
  UMLProps_UsecaseDiagram_RelationshipType_UNKNOWN_RELATIONSHIP = 0,
  UMLProps_UsecaseDiagram_RelationshipType_ASSOCIATION = 1,
  UMLProps_UsecaseDiagram_RelationshipType_INCLUDE = 2,
  UMLProps_UsecaseDiagram_RelationshipType_EXTEND = 3,
  UMLProps_UsecaseDiagram_RelationshipType_GENERALIZATION = 4,
  UMLProps_UsecaseDiagram_RelationshipType_UMLProps_UsecaseDiagram_RelationshipType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_UsecaseDiagram_RelationshipType_UMLProps_UsecaseDiagram_RelationshipType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_UsecaseDiagram_RelationshipType_IsValid(int value);
extern const uint32_t UMLProps_UsecaseDiagram_RelationshipType_internal_data_[];
constexpr UMLProps_UsecaseDiagram_RelationshipType UMLProps_UsecaseDiagram_RelationshipType_RelationshipType_MIN = static_cast<UMLProps_UsecaseDiagram_RelationshipType>(0);
constexpr UMLProps_UsecaseDiagram_RelationshipType UMLProps_UsecaseDiagram_RelationshipType_RelationshipType_MAX = static_cast<UMLProps_UsecaseDiagram_RelationshipType>(4);
constexpr int UMLProps_UsecaseDiagram_RelationshipType_RelationshipType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_UsecaseDiagram_RelationshipType_descriptor();
template <typename T>
const std::string& UMLProps_UsecaseDiagram_RelationshipType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_UsecaseDiagram_RelationshipType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RelationshipType_Name().");
  return UMLProps_UsecaseDiagram_RelationshipType_Name(static_cast<UMLProps_UsecaseDiagram_RelationshipType>(value));
}
template <>
inline const std::string& UMLProps_UsecaseDiagram_RelationshipType_Name(UMLProps_UsecaseDiagram_RelationshipType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_UsecaseDiagram_RelationshipType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool UMLProps_UsecaseDiagram_RelationshipType_Parse(absl::string_view name, UMLProps_UsecaseDiagram_RelationshipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_UsecaseDiagram_RelationshipType>(
      UMLProps_UsecaseDiagram_RelationshipType_descriptor(), name, value);
}
enum UMLProps_UsecaseDiagram_UsecaseExtendType : int {
  UMLProps_UsecaseDiagram_UsecaseExtendType_UNKNOWN_EXTEND = 0,
  UMLProps_UsecaseDiagram_UsecaseExtendType_BASE = 1,
  UMLProps_UsecaseDiagram_UsecaseExtendType_EXTENSION = 2,
  UMLProps_UsecaseDiagram_UsecaseExtendType_UMLProps_UsecaseDiagram_UsecaseExtendType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_UsecaseDiagram_UsecaseExtendType_UMLProps_UsecaseDiagram_UsecaseExtendType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_UsecaseDiagram_UsecaseExtendType_IsValid(int value);
extern const uint32_t UMLProps_UsecaseDiagram_UsecaseExtendType_internal_data_[];
constexpr UMLProps_UsecaseDiagram_UsecaseExtendType UMLProps_UsecaseDiagram_UsecaseExtendType_UsecaseExtendType_MIN = static_cast<UMLProps_UsecaseDiagram_UsecaseExtendType>(0);
constexpr UMLProps_UsecaseDiagram_UsecaseExtendType UMLProps_UsecaseDiagram_UsecaseExtendType_UsecaseExtendType_MAX = static_cast<UMLProps_UsecaseDiagram_UsecaseExtendType>(2);
constexpr int UMLProps_UsecaseDiagram_UsecaseExtendType_UsecaseExtendType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_UsecaseDiagram_UsecaseExtendType_descriptor();
template <typename T>
const std::string& UMLProps_UsecaseDiagram_UsecaseExtendType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_UsecaseDiagram_UsecaseExtendType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UsecaseExtendType_Name().");
  return UMLProps_UsecaseDiagram_UsecaseExtendType_Name(static_cast<UMLProps_UsecaseDiagram_UsecaseExtendType>(value));
}
template <>
inline const std::string& UMLProps_UsecaseDiagram_UsecaseExtendType_Name(UMLProps_UsecaseDiagram_UsecaseExtendType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_UsecaseDiagram_UsecaseExtendType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_UsecaseDiagram_UsecaseExtendType_Parse(absl::string_view name, UMLProps_UsecaseDiagram_UsecaseExtendType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_UsecaseDiagram_UsecaseExtendType>(
      UMLProps_UsecaseDiagram_UsecaseExtendType_descriptor(), name, value);
}
enum UMLProps_UsecaseDiagram_UsecaseGeneralizationType : int {
  UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UNKNOWN_GENERALIZATION = 0,
  UMLProps_UsecaseDiagram_UsecaseGeneralizationType_GENERAL = 1,
  UMLProps_UsecaseDiagram_UsecaseGeneralizationType_SPECIFIC = 2,
  UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UMLProps_UsecaseDiagram_UsecaseGeneralizationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UMLProps_UsecaseDiagram_UsecaseGeneralizationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_UsecaseDiagram_UsecaseGeneralizationType_IsValid(int value);
extern const uint32_t UMLProps_UsecaseDiagram_UsecaseGeneralizationType_internal_data_[];
constexpr UMLProps_UsecaseDiagram_UsecaseGeneralizationType UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UsecaseGeneralizationType_MIN = static_cast<UMLProps_UsecaseDiagram_UsecaseGeneralizationType>(0);
constexpr UMLProps_UsecaseDiagram_UsecaseGeneralizationType UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UsecaseGeneralizationType_MAX = static_cast<UMLProps_UsecaseDiagram_UsecaseGeneralizationType>(2);
constexpr int UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UsecaseGeneralizationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_UsecaseDiagram_UsecaseGeneralizationType_descriptor();
template <typename T>
const std::string& UMLProps_UsecaseDiagram_UsecaseGeneralizationType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_UsecaseDiagram_UsecaseGeneralizationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UsecaseGeneralizationType_Name().");
  return UMLProps_UsecaseDiagram_UsecaseGeneralizationType_Name(static_cast<UMLProps_UsecaseDiagram_UsecaseGeneralizationType>(value));
}
template <>
inline const std::string& UMLProps_UsecaseDiagram_UsecaseGeneralizationType_Name(UMLProps_UsecaseDiagram_UsecaseGeneralizationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_UsecaseDiagram_UsecaseGeneralizationType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_UsecaseDiagram_UsecaseGeneralizationType_Parse(absl::string_view name, UMLProps_UsecaseDiagram_UsecaseGeneralizationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_UsecaseDiagram_UsecaseGeneralizationType>(
      UMLProps_UsecaseDiagram_UsecaseGeneralizationType_descriptor(), name, value);
}
enum UMLProps_UsecaseDiagram_UsecaseIncludeType : int {
  UMLProps_UsecaseDiagram_UsecaseIncludeType_UNKNOWN_INCLUDE = 0,
  UMLProps_UsecaseDiagram_UsecaseIncludeType_INCLUDING = 1,
  UMLProps_UsecaseDiagram_UsecaseIncludeType_INCLUDED = 2,
  UMLProps_UsecaseDiagram_UsecaseIncludeType_UMLProps_UsecaseDiagram_UsecaseIncludeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_UsecaseDiagram_UsecaseIncludeType_UMLProps_UsecaseDiagram_UsecaseIncludeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_UsecaseDiagram_UsecaseIncludeType_IsValid(int value);
extern const uint32_t UMLProps_UsecaseDiagram_UsecaseIncludeType_internal_data_[];
constexpr UMLProps_UsecaseDiagram_UsecaseIncludeType UMLProps_UsecaseDiagram_UsecaseIncludeType_UsecaseIncludeType_MIN = static_cast<UMLProps_UsecaseDiagram_UsecaseIncludeType>(0);
constexpr UMLProps_UsecaseDiagram_UsecaseIncludeType UMLProps_UsecaseDiagram_UsecaseIncludeType_UsecaseIncludeType_MAX = static_cast<UMLProps_UsecaseDiagram_UsecaseIncludeType>(2);
constexpr int UMLProps_UsecaseDiagram_UsecaseIncludeType_UsecaseIncludeType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_UsecaseDiagram_UsecaseIncludeType_descriptor();
template <typename T>
const std::string& UMLProps_UsecaseDiagram_UsecaseIncludeType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_UsecaseDiagram_UsecaseIncludeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UsecaseIncludeType_Name().");
  return UMLProps_UsecaseDiagram_UsecaseIncludeType_Name(static_cast<UMLProps_UsecaseDiagram_UsecaseIncludeType>(value));
}
template <>
inline const std::string& UMLProps_UsecaseDiagram_UsecaseIncludeType_Name(UMLProps_UsecaseDiagram_UsecaseIncludeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_UsecaseDiagram_UsecaseIncludeType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UMLProps_UsecaseDiagram_UsecaseIncludeType_Parse(absl::string_view name, UMLProps_UsecaseDiagram_UsecaseIncludeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_UsecaseDiagram_UsecaseIncludeType>(
      UMLProps_UsecaseDiagram_UsecaseIncludeType_descriptor(), name, value);
}
enum UMLProps_UMLDiagramType : int {
  UMLProps_UMLDiagramType_UNKNOWN_UML = 0,
  UMLProps_UMLDiagramType_CLASS_DIAGRAM = 1,
  UMLProps_UMLDiagramType_USECASE_DIAGRAM = 2,
  UMLProps_UMLDiagramType_SEQUENCE_DIAGRAM = 3,
  UMLProps_UMLDiagramType_COMPONENT_DIAGRAM = 4,
  UMLProps_UMLDiagramType_DEPLOYMENT_DIAGRAM = 5,
  UMLProps_UMLDiagramType_STATE_DIAGRAM = 6,
  UMLProps_UMLDiagramType_ACTIVITY_DIAGRAM = 7,
  UMLProps_UMLDiagramType_UMLProps_UMLDiagramType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UMLProps_UMLDiagramType_UMLProps_UMLDiagramType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UMLProps_UMLDiagramType_IsValid(int value);
extern const uint32_t UMLProps_UMLDiagramType_internal_data_[];
constexpr UMLProps_UMLDiagramType UMLProps_UMLDiagramType_UMLDiagramType_MIN = static_cast<UMLProps_UMLDiagramType>(0);
constexpr UMLProps_UMLDiagramType UMLProps_UMLDiagramType_UMLDiagramType_MAX = static_cast<UMLProps_UMLDiagramType>(7);
constexpr int UMLProps_UMLDiagramType_UMLDiagramType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
UMLProps_UMLDiagramType_descriptor();
template <typename T>
const std::string& UMLProps_UMLDiagramType_Name(T value) {
  static_assert(std::is_same<T, UMLProps_UMLDiagramType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UMLDiagramType_Name().");
  return UMLProps_UMLDiagramType_Name(static_cast<UMLProps_UMLDiagramType>(value));
}
template <>
inline const std::string& UMLProps_UMLDiagramType_Name(UMLProps_UMLDiagramType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UMLProps_UMLDiagramType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool UMLProps_UMLDiagramType_Parse(absl::string_view name, UMLProps_UMLDiagramType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMLProps_UMLDiagramType>(
      UMLProps_UMLDiagramType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UMLProps_UsecaseDiagram_UMLUsecaseConnection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection) */ {
 public:
  inline UMLProps_UsecaseDiagram_UMLUsecaseConnection() : UMLProps_UsecaseDiagram_UMLUsecaseConnection(nullptr) {}
  ~UMLProps_UsecaseDiagram_UMLUsecaseConnection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UMLProps_UsecaseDiagram_UMLUsecaseConnection(::google::protobuf::internal::ConstantInitialized);

  inline UMLProps_UsecaseDiagram_UMLUsecaseConnection(const UMLProps_UsecaseDiagram_UMLUsecaseConnection& from)
      : UMLProps_UsecaseDiagram_UMLUsecaseConnection(nullptr, from) {}
  UMLProps_UsecaseDiagram_UMLUsecaseConnection(UMLProps_UsecaseDiagram_UMLUsecaseConnection&& from) noexcept
    : UMLProps_UsecaseDiagram_UMLUsecaseConnection() {
    *this = ::std::move(from);
  }

  inline UMLProps_UsecaseDiagram_UMLUsecaseConnection& operator=(const UMLProps_UsecaseDiagram_UMLUsecaseConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMLProps_UsecaseDiagram_UMLUsecaseConnection& operator=(UMLProps_UsecaseDiagram_UMLUsecaseConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UMLProps_UsecaseDiagram_UMLUsecaseConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMLProps_UsecaseDiagram_UMLUsecaseConnection* internal_default_instance() {
    return reinterpret_cast<const UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(
               &_UMLProps_UsecaseDiagram_UMLUsecaseConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UMLProps_UsecaseDiagram_UMLUsecaseConnection& a, UMLProps_UsecaseDiagram_UMLUsecaseConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(UMLProps_UsecaseDiagram_UMLUsecaseConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMLProps_UsecaseDiagram_UMLUsecaseConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMLProps_UsecaseDiagram_UMLUsecaseConnection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMLProps_UsecaseDiagram_UMLUsecaseConnection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UMLProps_UsecaseDiagram_UMLUsecaseConnection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UMLProps_UsecaseDiagram_UMLUsecaseConnection& from) {
    UMLProps_UsecaseDiagram_UMLUsecaseConnection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UMLProps_UsecaseDiagram_UMLUsecaseConnection* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection";
  }
  protected:
  explicit UMLProps_UsecaseDiagram_UMLUsecaseConnection(::google::protobuf::Arena* arena);
  UMLProps_UsecaseDiagram_UMLUsecaseConnection(::google::protobuf::Arena* arena, const UMLProps_UsecaseDiagram_UMLUsecaseConnection& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtendTypeFieldNumber = 1,
    kGeneralizationTypeFieldNumber = 2,
    kIncludeTypeFieldNumber = 3,
  };
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseExtendType extendType = 1;
  bool has_extendtype() const;
  void clear_extendtype() ;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType extendtype() const;
  void set_extendtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType value);

  private:
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType _internal_extendtype() const;
  void _internal_set_extendtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType value);

  public:
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseGeneralizationType generalizationType = 2;
  bool has_generalizationtype() const;
  void clear_generalizationtype() ;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType generalizationtype() const;
  void set_generalizationtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType value);

  private:
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType _internal_generalizationtype() const;
  void _internal_set_generalizationtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType value);

  public:
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseIncludeType includeType = 3;
  bool has_includetype() const;
  void clear_includetype() ;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType includetype() const;
  void set_includetype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType value);

  private:
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType _internal_includetype() const;
  void _internal_set_includetype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int extendtype_;
    int generalizationtype_;
    int includetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_umlprops_2eproto;
};// -------------------------------------------------------------------

class UMLProps_ClassDiagram_UMLClassConnection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection) */ {
 public:
  inline UMLProps_ClassDiagram_UMLClassConnection() : UMLProps_ClassDiagram_UMLClassConnection(nullptr) {}
  ~UMLProps_ClassDiagram_UMLClassConnection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UMLProps_ClassDiagram_UMLClassConnection(::google::protobuf::internal::ConstantInitialized);

  inline UMLProps_ClassDiagram_UMLClassConnection(const UMLProps_ClassDiagram_UMLClassConnection& from)
      : UMLProps_ClassDiagram_UMLClassConnection(nullptr, from) {}
  UMLProps_ClassDiagram_UMLClassConnection(UMLProps_ClassDiagram_UMLClassConnection&& from) noexcept
    : UMLProps_ClassDiagram_UMLClassConnection() {
    *this = ::std::move(from);
  }

  inline UMLProps_ClassDiagram_UMLClassConnection& operator=(const UMLProps_ClassDiagram_UMLClassConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMLProps_ClassDiagram_UMLClassConnection& operator=(UMLProps_ClassDiagram_UMLClassConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UMLProps_ClassDiagram_UMLClassConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMLProps_ClassDiagram_UMLClassConnection* internal_default_instance() {
    return reinterpret_cast<const UMLProps_ClassDiagram_UMLClassConnection*>(
               &_UMLProps_ClassDiagram_UMLClassConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UMLProps_ClassDiagram_UMLClassConnection& a, UMLProps_ClassDiagram_UMLClassConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(UMLProps_ClassDiagram_UMLClassConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMLProps_ClassDiagram_UMLClassConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMLProps_ClassDiagram_UMLClassConnection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMLProps_ClassDiagram_UMLClassConnection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UMLProps_ClassDiagram_UMLClassConnection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UMLProps_ClassDiagram_UMLClassConnection& from) {
    UMLProps_ClassDiagram_UMLClassConnection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UMLProps_ClassDiagram_UMLClassConnection* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection";
  }
  protected:
  explicit UMLProps_ClassDiagram_UMLClassConnection(::google::protobuf::Arena* arena);
  UMLProps_ClassDiagram_UMLClassConnection(::google::protobuf::Arena* arena, const UMLProps_ClassDiagram_UMLClassConnection& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DirectedAssociationType = UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType;
  static constexpr DirectedAssociationType UNKNOWN_DIRECTED_ASSOCIATION = UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_UNKNOWN_DIRECTED_ASSOCIATION;
  static constexpr DirectedAssociationType INITIATOR = UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_INITIATOR;
  static constexpr DirectedAssociationType TARGET = UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_TARGET;
  static inline bool DirectedAssociationType_IsValid(int value) {
    return UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_IsValid(value);
  }
  static constexpr DirectedAssociationType DirectedAssociationType_MIN = UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_DirectedAssociationType_MIN;
  static constexpr DirectedAssociationType DirectedAssociationType_MAX = UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_DirectedAssociationType_MAX;
  static constexpr int DirectedAssociationType_ARRAYSIZE = UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_DirectedAssociationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DirectedAssociationType_descriptor() {
    return UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_descriptor();
  }
  template <typename T>
  static inline const std::string& DirectedAssociationType_Name(T value) {
    return UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_Name(value);
  }
  static inline bool DirectedAssociationType_Parse(absl::string_view name, DirectedAssociationType* value) {
    return UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_Parse(name, value);
  }

  using Aggregation_Composition_Type = UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type;
  static constexpr Aggregation_Composition_Type UNKNOWN_AGGREGATION = UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_UNKNOWN_AGGREGATION;
  static constexpr Aggregation_Composition_Type WHOLE = UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_WHOLE;
  static constexpr Aggregation_Composition_Type PART = UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_PART;
  static inline bool Aggregation_Composition_Type_IsValid(int value) {
    return UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_IsValid(value);
  }
  static constexpr Aggregation_Composition_Type Aggregation_Composition_Type_MIN = UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Aggregation_Composition_Type_MIN;
  static constexpr Aggregation_Composition_Type Aggregation_Composition_Type_MAX = UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Aggregation_Composition_Type_MAX;
  static constexpr int Aggregation_Composition_Type_ARRAYSIZE = UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Aggregation_Composition_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Aggregation_Composition_Type_descriptor() {
    return UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Aggregation_Composition_Type_Name(T value) {
    return UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Name(value);
  }
  static inline bool Aggregation_Composition_Type_Parse(absl::string_view name, Aggregation_Composition_Type* value) {
    return UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_Parse(name, value);
  }

  using GeneralizationType = UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType;
  static constexpr GeneralizationType UNKNOWN_GENERALIZATION = UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_UNKNOWN_GENERALIZATION;
  static constexpr GeneralizationType SUB_CLASS = UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_SUB_CLASS;
  static constexpr GeneralizationType SUPER_CLASS = UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_SUPER_CLASS;
  static inline bool GeneralizationType_IsValid(int value) {
    return UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_IsValid(value);
  }
  static constexpr GeneralizationType GeneralizationType_MIN = UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_GeneralizationType_MIN;
  static constexpr GeneralizationType GeneralizationType_MAX = UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_GeneralizationType_MAX;
  static constexpr int GeneralizationType_ARRAYSIZE = UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_GeneralizationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GeneralizationType_descriptor() {
    return UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_descriptor();
  }
  template <typename T>
  static inline const std::string& GeneralizationType_Name(T value) {
    return UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_Name(value);
  }
  static inline bool GeneralizationType_Parse(absl::string_view name, GeneralizationType* value) {
    return UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_Parse(name, value);
  }

  using RealizationType = UMLProps_ClassDiagram_UMLClassConnection_RealizationType;
  static constexpr RealizationType UNKNOWN_REALIZATION = UMLProps_ClassDiagram_UMLClassConnection_RealizationType_UNKNOWN_REALIZATION;
  static constexpr RealizationType IMPLEMENTING_CLASS = UMLProps_ClassDiagram_UMLClassConnection_RealizationType_IMPLEMENTING_CLASS;
  static constexpr RealizationType INTERFACE = UMLProps_ClassDiagram_UMLClassConnection_RealizationType_INTERFACE;
  static inline bool RealizationType_IsValid(int value) {
    return UMLProps_ClassDiagram_UMLClassConnection_RealizationType_IsValid(value);
  }
  static constexpr RealizationType RealizationType_MIN = UMLProps_ClassDiagram_UMLClassConnection_RealizationType_RealizationType_MIN;
  static constexpr RealizationType RealizationType_MAX = UMLProps_ClassDiagram_UMLClassConnection_RealizationType_RealizationType_MAX;
  static constexpr int RealizationType_ARRAYSIZE = UMLProps_ClassDiagram_UMLClassConnection_RealizationType_RealizationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RealizationType_descriptor() {
    return UMLProps_ClassDiagram_UMLClassConnection_RealizationType_descriptor();
  }
  template <typename T>
  static inline const std::string& RealizationType_Name(T value) {
    return UMLProps_ClassDiagram_UMLClassConnection_RealizationType_Name(value);
  }
  static inline bool RealizationType_Parse(absl::string_view name, RealizationType* value) {
    return UMLProps_ClassDiagram_UMLClassConnection_RealizationType_Parse(name, value);
  }

  using DependencyType = UMLProps_ClassDiagram_UMLClassConnection_DependencyType;
  static constexpr DependencyType UNKNOWN_DEPENDENCY = UMLProps_ClassDiagram_UMLClassConnection_DependencyType_UNKNOWN_DEPENDENCY;
  static constexpr DependencyType SOURCE = UMLProps_ClassDiagram_UMLClassConnection_DependencyType_SOURCE;
  static constexpr DependencyType DEPENDENT = UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DEPENDENT;
  static inline bool DependencyType_IsValid(int value) {
    return UMLProps_ClassDiagram_UMLClassConnection_DependencyType_IsValid(value);
  }
  static constexpr DependencyType DependencyType_MIN = UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DependencyType_MIN;
  static constexpr DependencyType DependencyType_MAX = UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DependencyType_MAX;
  static constexpr int DependencyType_ARRAYSIZE = UMLProps_ClassDiagram_UMLClassConnection_DependencyType_DependencyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DependencyType_descriptor() {
    return UMLProps_ClassDiagram_UMLClassConnection_DependencyType_descriptor();
  }
  template <typename T>
  static inline const std::string& DependencyType_Name(T value) {
    return UMLProps_ClassDiagram_UMLClassConnection_DependencyType_Name(value);
  }
  static inline bool DependencyType_Parse(absl::string_view name, DependencyType* value) {
    return UMLProps_ClassDiagram_UMLClassConnection_DependencyType_Parse(name, value);
  }

  using UsageDependencyType = UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType;
  static constexpr UsageDependencyType UNKNOWN_USAGE_TYPE = UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UNKNOWN_USAGE_TYPE;
  static constexpr UsageDependencyType CLIENT = UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_CLIENT;
  static constexpr UsageDependencyType SUPPLIER = UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_SUPPLIER;
  static inline bool UsageDependencyType_IsValid(int value) {
    return UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_IsValid(value);
  }
  static constexpr UsageDependencyType UsageDependencyType_MIN = UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UsageDependencyType_MIN;
  static constexpr UsageDependencyType UsageDependencyType_MAX = UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UsageDependencyType_MAX;
  static constexpr int UsageDependencyType_ARRAYSIZE = UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_UsageDependencyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UsageDependencyType_descriptor() {
    return UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_descriptor();
  }
  template <typename T>
  static inline const std::string& UsageDependencyType_Name(T value) {
    return UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_Name(value);
  }
  static inline bool UsageDependencyType_Parse(absl::string_view name, UsageDependencyType* value) {
    return UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCardinalityFieldNumber = 1,
    kAssociationTypeFieldNumber = 2,
    kAggregationTypeFieldNumber = 3,
    kCompositionTypeFieldNumber = 4,
    kGeneralizationTypeFieldNumber = 5,
    kRelaizationTypeFieldNumber = 6,
    kDependencyTypeFieldNumber = 7,
  };
  // optional .com.zoho.kits.DesignDiagramFields.Cardinality cardinality = 1;
  bool has_cardinality() const;
  void clear_cardinality() ;
  ::com::zoho::kits::DesignDiagramFields_Cardinality cardinality() const;
  void set_cardinality(::com::zoho::kits::DesignDiagramFields_Cardinality value);

  private:
  ::com::zoho::kits::DesignDiagramFields_Cardinality _internal_cardinality() const;
  void _internal_set_cardinality(::com::zoho::kits::DesignDiagramFields_Cardinality value);

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.DirectedAssociationType associationType = 2;
  bool has_associationtype() const;
  void clear_associationtype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType associationtype() const;
  void set_associationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType _internal_associationtype() const;
  void _internal_set_associationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType value);

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.Aggregation_Composition_Type aggregationType = 3;
  bool has_aggregationtype() const;
  void clear_aggregationtype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type aggregationtype() const;
  void set_aggregationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type _internal_aggregationtype() const;
  void _internal_set_aggregationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value);

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.Aggregation_Composition_Type compositionType = 4;
  bool has_compositiontype() const;
  void clear_compositiontype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type compositiontype() const;
  void set_compositiontype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type _internal_compositiontype() const;
  void _internal_set_compositiontype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value);

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.GeneralizationType generalizationType = 5;
  bool has_generalizationtype() const;
  void clear_generalizationtype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType generalizationtype() const;
  void set_generalizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType _internal_generalizationtype() const;
  void _internal_set_generalizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType value);

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.RealizationType relaizationType = 6;
  bool has_relaizationtype() const;
  void clear_relaizationtype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType relaizationtype() const;
  void set_relaizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType _internal_relaizationtype() const;
  void _internal_set_relaizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType value);

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.DependencyType dependencyType = 7;
  bool has_dependencytype() const;
  void clear_dependencytype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType dependencytype() const;
  void set_dependencytype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType _internal_dependencytype() const;
  void _internal_set_dependencytype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int cardinality_;
    int associationtype_;
    int aggregationtype_;
    int compositiontype_;
    int generalizationtype_;
    int relaizationtype_;
    int dependencytype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_umlprops_2eproto;
};// -------------------------------------------------------------------

class UMLProps_UsecaseDiagram_UMLUsecaseRelationship final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship) */ {
 public:
  inline UMLProps_UsecaseDiagram_UMLUsecaseRelationship() : UMLProps_UsecaseDiagram_UMLUsecaseRelationship(nullptr) {}
  ~UMLProps_UsecaseDiagram_UMLUsecaseRelationship() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UMLProps_UsecaseDiagram_UMLUsecaseRelationship(::google::protobuf::internal::ConstantInitialized);

  inline UMLProps_UsecaseDiagram_UMLUsecaseRelationship(const UMLProps_UsecaseDiagram_UMLUsecaseRelationship& from)
      : UMLProps_UsecaseDiagram_UMLUsecaseRelationship(nullptr, from) {}
  UMLProps_UsecaseDiagram_UMLUsecaseRelationship(UMLProps_UsecaseDiagram_UMLUsecaseRelationship&& from) noexcept
    : UMLProps_UsecaseDiagram_UMLUsecaseRelationship() {
    *this = ::std::move(from);
  }

  inline UMLProps_UsecaseDiagram_UMLUsecaseRelationship& operator=(const UMLProps_UsecaseDiagram_UMLUsecaseRelationship& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMLProps_UsecaseDiagram_UMLUsecaseRelationship& operator=(UMLProps_UsecaseDiagram_UMLUsecaseRelationship&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UMLProps_UsecaseDiagram_UMLUsecaseRelationship& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMLProps_UsecaseDiagram_UMLUsecaseRelationship* internal_default_instance() {
    return reinterpret_cast<const UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(
               &_UMLProps_UsecaseDiagram_UMLUsecaseRelationship_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UMLProps_UsecaseDiagram_UMLUsecaseRelationship& a, UMLProps_UsecaseDiagram_UMLUsecaseRelationship& b) {
    a.Swap(&b);
  }
  inline void Swap(UMLProps_UsecaseDiagram_UMLUsecaseRelationship* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMLProps_UsecaseDiagram_UMLUsecaseRelationship* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMLProps_UsecaseDiagram_UMLUsecaseRelationship* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMLProps_UsecaseDiagram_UMLUsecaseRelationship>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UMLProps_UsecaseDiagram_UMLUsecaseRelationship& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UMLProps_UsecaseDiagram_UMLUsecaseRelationship& from) {
    UMLProps_UsecaseDiagram_UMLUsecaseRelationship::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UMLProps_UsecaseDiagram_UMLUsecaseRelationship* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship";
  }
  protected:
  explicit UMLProps_UsecaseDiagram_UMLUsecaseRelationship(::google::protobuf::Arena* arena);
  UMLProps_UsecaseDiagram_UMLUsecaseRelationship(::google::protobuf::Arena* arena, const UMLProps_UsecaseDiagram_UMLUsecaseRelationship& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection start = 2;
  bool has_start() const;
  void clear_start() ;
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& start() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* release_start();
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* mutable_start();
  void set_allocated_start(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value);
  void unsafe_arena_set_allocated_start(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value);
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* unsafe_arena_release_start();

  private:
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& _internal_start() const;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* _internal_mutable_start();

  public:
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection end = 3;
  bool has_end() const;
  void clear_end() ;
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& end() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* release_end();
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* mutable_end();
  void set_allocated_end(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value);
  void unsafe_arena_set_allocated_end(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value);
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* unsafe_arena_release_end();

  private:
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& _internal_end() const;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* _internal_mutable_end();

  public:
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.RelationshipType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType type() const;
  void set_type(::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType value);

  private:
  ::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType _internal_type() const;
  void _internal_set_type(::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType value);

  public:
  void temp_setstart(com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* start) {
    if(&this->start() != start) {
      set_allocated_start(start);
    }
  }
  
  com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* temp_getstart() const {
    if (has_start()) 
      return (const_cast<com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(this))->mutable_start();
    return nullptr;
  }
  
  void temp_setend(com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* end) {
    if(&this->end() != end) {
      set_allocated_end(end);
    }
  }
  
  com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* temp_getend() const {
    if (has_end()) 
      return (const_cast<com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(this))->mutable_end();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* start_;
    ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* end_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_umlprops_2eproto;
};// -------------------------------------------------------------------

class UMLProps_ClassDiagram_UMLClassRelationship final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship) */ {
 public:
  inline UMLProps_ClassDiagram_UMLClassRelationship() : UMLProps_ClassDiagram_UMLClassRelationship(nullptr) {}
  ~UMLProps_ClassDiagram_UMLClassRelationship() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UMLProps_ClassDiagram_UMLClassRelationship(::google::protobuf::internal::ConstantInitialized);

  inline UMLProps_ClassDiagram_UMLClassRelationship(const UMLProps_ClassDiagram_UMLClassRelationship& from)
      : UMLProps_ClassDiagram_UMLClassRelationship(nullptr, from) {}
  UMLProps_ClassDiagram_UMLClassRelationship(UMLProps_ClassDiagram_UMLClassRelationship&& from) noexcept
    : UMLProps_ClassDiagram_UMLClassRelationship() {
    *this = ::std::move(from);
  }

  inline UMLProps_ClassDiagram_UMLClassRelationship& operator=(const UMLProps_ClassDiagram_UMLClassRelationship& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMLProps_ClassDiagram_UMLClassRelationship& operator=(UMLProps_ClassDiagram_UMLClassRelationship&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UMLProps_ClassDiagram_UMLClassRelationship& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMLProps_ClassDiagram_UMLClassRelationship* internal_default_instance() {
    return reinterpret_cast<const UMLProps_ClassDiagram_UMLClassRelationship*>(
               &_UMLProps_ClassDiagram_UMLClassRelationship_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UMLProps_ClassDiagram_UMLClassRelationship& a, UMLProps_ClassDiagram_UMLClassRelationship& b) {
    a.Swap(&b);
  }
  inline void Swap(UMLProps_ClassDiagram_UMLClassRelationship* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMLProps_ClassDiagram_UMLClassRelationship* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMLProps_ClassDiagram_UMLClassRelationship* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMLProps_ClassDiagram_UMLClassRelationship>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UMLProps_ClassDiagram_UMLClassRelationship& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UMLProps_ClassDiagram_UMLClassRelationship& from) {
    UMLProps_ClassDiagram_UMLClassRelationship::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UMLProps_ClassDiagram_UMLClassRelationship* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship";
  }
  protected:
  explicit UMLProps_ClassDiagram_UMLClassRelationship(::google::protobuf::Arena* arena);
  UMLProps_ClassDiagram_UMLClassRelationship(::google::protobuf::Arena* arena, const UMLProps_ClassDiagram_UMLClassRelationship& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kRelationshipTypeFieldNumber = 1,
  };
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection start = 2;
  bool has_start() const;
  void clear_start() ;
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& start() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* release_start();
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* mutable_start();
  void set_allocated_start(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value);
  void unsafe_arena_set_allocated_start(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value);
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* unsafe_arena_release_start();

  private:
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& _internal_start() const;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* _internal_mutable_start();

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection end = 3;
  bool has_end() const;
  void clear_end() ;
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& end() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* release_end();
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* mutable_end();
  void set_allocated_end(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value);
  void unsafe_arena_set_allocated_end(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value);
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* unsafe_arena_release_end();

  private:
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& _internal_end() const;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* _internal_mutable_end();

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.RelationshipType relationshipType = 1;
  bool has_relationshiptype() const;
  void clear_relationshiptype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType relationshiptype() const;
  void set_relationshiptype(::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType _internal_relationshiptype() const;
  void _internal_set_relationshiptype(::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType value);

  public:
  void temp_setstart(com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* start) {
    if(&this->start() != start) {
      set_allocated_start(start);
    }
  }
  
  com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* temp_getstart() const {
    if (has_start()) 
      return (const_cast<com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship*>(this))->mutable_start();
    return nullptr;
  }
  
  void temp_setend(com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* end) {
    if(&this->end() != end) {
      set_allocated_end(end);
    }
  }
  
  com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* temp_getend() const {
    if (has_end()) 
      return (const_cast<com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship*>(this))->mutable_end();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* start_;
    ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* end_;
    int relationshiptype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_umlprops_2eproto;
};// -------------------------------------------------------------------

class UMLProps_UsecaseDiagram final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.kits.UMLProps.UsecaseDiagram) */ {
 public:
  inline UMLProps_UsecaseDiagram() : UMLProps_UsecaseDiagram(nullptr) {}
  ~UMLProps_UsecaseDiagram() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UMLProps_UsecaseDiagram(::google::protobuf::internal::ConstantInitialized);

  inline UMLProps_UsecaseDiagram(const UMLProps_UsecaseDiagram& from)
      : UMLProps_UsecaseDiagram(nullptr, from) {}
  UMLProps_UsecaseDiagram(UMLProps_UsecaseDiagram&& from) noexcept
    : UMLProps_UsecaseDiagram() {
    *this = ::std::move(from);
  }

  inline UMLProps_UsecaseDiagram& operator=(const UMLProps_UsecaseDiagram& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMLProps_UsecaseDiagram& operator=(UMLProps_UsecaseDiagram&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UMLProps_UsecaseDiagram& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMLProps_UsecaseDiagram* internal_default_instance() {
    return reinterpret_cast<const UMLProps_UsecaseDiagram*>(
               &_UMLProps_UsecaseDiagram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UMLProps_UsecaseDiagram& a, UMLProps_UsecaseDiagram& b) {
    a.Swap(&b);
  }
  inline void Swap(UMLProps_UsecaseDiagram* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMLProps_UsecaseDiagram* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMLProps_UsecaseDiagram* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMLProps_UsecaseDiagram>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UMLProps_UsecaseDiagram& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UMLProps_UsecaseDiagram& from) {
    UMLProps_UsecaseDiagram::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UMLProps_UsecaseDiagram* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.kits.UMLProps.UsecaseDiagram";
  }
  protected:
  explicit UMLProps_UsecaseDiagram(::google::protobuf::Arena* arena);
  UMLProps_UsecaseDiagram(::google::protobuf::Arena* arena, const UMLProps_UsecaseDiagram& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UMLUsecaseConnection = UMLProps_UsecaseDiagram_UMLUsecaseConnection;
  using UMLUsecaseRelationship = UMLProps_UsecaseDiagram_UMLUsecaseRelationship;

  using UsecaseDiagramComponent = UMLProps_UsecaseDiagram_UsecaseDiagramComponent;
  static constexpr UsecaseDiagramComponent UNKNOWN_USECASE_DIAGRAM_COMPONENT = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UNKNOWN_USECASE_DIAGRAM_COMPONENT;
  static constexpr UsecaseDiagramComponent ACTOR = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_ACTOR;
  static constexpr UsecaseDiagramComponent USECASE = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_USECASE;
  static constexpr UsecaseDiagramComponent USECASE_WITH_EXTENSION = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_USECASE_WITH_EXTENSION;
  static constexpr UsecaseDiagramComponent CONTAINER_RECTANGLE = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_CONTAINER_RECTANGLE;
  static constexpr UsecaseDiagramComponent CONTAINER_OVAL = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_CONTAINER_OVAL;
  static constexpr UsecaseDiagramComponent NOTE = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_NOTE;
  static constexpr UsecaseDiagramComponent TEXT = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_TEXT;
  static inline bool UsecaseDiagramComponent_IsValid(int value) {
    return UMLProps_UsecaseDiagram_UsecaseDiagramComponent_IsValid(value);
  }
  static constexpr UsecaseDiagramComponent UsecaseDiagramComponent_MIN = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UsecaseDiagramComponent_MIN;
  static constexpr UsecaseDiagramComponent UsecaseDiagramComponent_MAX = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UsecaseDiagramComponent_MAX;
  static constexpr int UsecaseDiagramComponent_ARRAYSIZE = UMLProps_UsecaseDiagram_UsecaseDiagramComponent_UsecaseDiagramComponent_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UsecaseDiagramComponent_descriptor() {
    return UMLProps_UsecaseDiagram_UsecaseDiagramComponent_descriptor();
  }
  template <typename T>
  static inline const std::string& UsecaseDiagramComponent_Name(T value) {
    return UMLProps_UsecaseDiagram_UsecaseDiagramComponent_Name(value);
  }
  static inline bool UsecaseDiagramComponent_Parse(absl::string_view name, UsecaseDiagramComponent* value) {
    return UMLProps_UsecaseDiagram_UsecaseDiagramComponent_Parse(name, value);
  }

  using RelationshipType = UMLProps_UsecaseDiagram_RelationshipType;
  static constexpr RelationshipType UNKNOWN_RELATIONSHIP = UMLProps_UsecaseDiagram_RelationshipType_UNKNOWN_RELATIONSHIP;
  static constexpr RelationshipType ASSOCIATION = UMLProps_UsecaseDiagram_RelationshipType_ASSOCIATION;
  static constexpr RelationshipType INCLUDE = UMLProps_UsecaseDiagram_RelationshipType_INCLUDE;
  static constexpr RelationshipType EXTEND = UMLProps_UsecaseDiagram_RelationshipType_EXTEND;
  static constexpr RelationshipType GENERALIZATION = UMLProps_UsecaseDiagram_RelationshipType_GENERALIZATION;
  static inline bool RelationshipType_IsValid(int value) {
    return UMLProps_UsecaseDiagram_RelationshipType_IsValid(value);
  }
  static constexpr RelationshipType RelationshipType_MIN = UMLProps_UsecaseDiagram_RelationshipType_RelationshipType_MIN;
  static constexpr RelationshipType RelationshipType_MAX = UMLProps_UsecaseDiagram_RelationshipType_RelationshipType_MAX;
  static constexpr int RelationshipType_ARRAYSIZE = UMLProps_UsecaseDiagram_RelationshipType_RelationshipType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RelationshipType_descriptor() {
    return UMLProps_UsecaseDiagram_RelationshipType_descriptor();
  }
  template <typename T>
  static inline const std::string& RelationshipType_Name(T value) {
    return UMLProps_UsecaseDiagram_RelationshipType_Name(value);
  }
  static inline bool RelationshipType_Parse(absl::string_view name, RelationshipType* value) {
    return UMLProps_UsecaseDiagram_RelationshipType_Parse(name, value);
  }

  using UsecaseExtendType = UMLProps_UsecaseDiagram_UsecaseExtendType;
  static constexpr UsecaseExtendType UNKNOWN_EXTEND = UMLProps_UsecaseDiagram_UsecaseExtendType_UNKNOWN_EXTEND;
  static constexpr UsecaseExtendType BASE = UMLProps_UsecaseDiagram_UsecaseExtendType_BASE;
  static constexpr UsecaseExtendType EXTENSION = UMLProps_UsecaseDiagram_UsecaseExtendType_EXTENSION;
  static inline bool UsecaseExtendType_IsValid(int value) {
    return UMLProps_UsecaseDiagram_UsecaseExtendType_IsValid(value);
  }
  static constexpr UsecaseExtendType UsecaseExtendType_MIN = UMLProps_UsecaseDiagram_UsecaseExtendType_UsecaseExtendType_MIN;
  static constexpr UsecaseExtendType UsecaseExtendType_MAX = UMLProps_UsecaseDiagram_UsecaseExtendType_UsecaseExtendType_MAX;
  static constexpr int UsecaseExtendType_ARRAYSIZE = UMLProps_UsecaseDiagram_UsecaseExtendType_UsecaseExtendType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UsecaseExtendType_descriptor() {
    return UMLProps_UsecaseDiagram_UsecaseExtendType_descriptor();
  }
  template <typename T>
  static inline const std::string& UsecaseExtendType_Name(T value) {
    return UMLProps_UsecaseDiagram_UsecaseExtendType_Name(value);
  }
  static inline bool UsecaseExtendType_Parse(absl::string_view name, UsecaseExtendType* value) {
    return UMLProps_UsecaseDiagram_UsecaseExtendType_Parse(name, value);
  }

  using UsecaseGeneralizationType = UMLProps_UsecaseDiagram_UsecaseGeneralizationType;
  static constexpr UsecaseGeneralizationType UNKNOWN_GENERALIZATION = UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UNKNOWN_GENERALIZATION;
  static constexpr UsecaseGeneralizationType GENERAL = UMLProps_UsecaseDiagram_UsecaseGeneralizationType_GENERAL;
  static constexpr UsecaseGeneralizationType SPECIFIC = UMLProps_UsecaseDiagram_UsecaseGeneralizationType_SPECIFIC;
  static inline bool UsecaseGeneralizationType_IsValid(int value) {
    return UMLProps_UsecaseDiagram_UsecaseGeneralizationType_IsValid(value);
  }
  static constexpr UsecaseGeneralizationType UsecaseGeneralizationType_MIN = UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UsecaseGeneralizationType_MIN;
  static constexpr UsecaseGeneralizationType UsecaseGeneralizationType_MAX = UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UsecaseGeneralizationType_MAX;
  static constexpr int UsecaseGeneralizationType_ARRAYSIZE = UMLProps_UsecaseDiagram_UsecaseGeneralizationType_UsecaseGeneralizationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UsecaseGeneralizationType_descriptor() {
    return UMLProps_UsecaseDiagram_UsecaseGeneralizationType_descriptor();
  }
  template <typename T>
  static inline const std::string& UsecaseGeneralizationType_Name(T value) {
    return UMLProps_UsecaseDiagram_UsecaseGeneralizationType_Name(value);
  }
  static inline bool UsecaseGeneralizationType_Parse(absl::string_view name, UsecaseGeneralizationType* value) {
    return UMLProps_UsecaseDiagram_UsecaseGeneralizationType_Parse(name, value);
  }

  using UsecaseIncludeType = UMLProps_UsecaseDiagram_UsecaseIncludeType;
  static constexpr UsecaseIncludeType UNKNOWN_INCLUDE = UMLProps_UsecaseDiagram_UsecaseIncludeType_UNKNOWN_INCLUDE;
  static constexpr UsecaseIncludeType INCLUDING = UMLProps_UsecaseDiagram_UsecaseIncludeType_INCLUDING;
  static constexpr UsecaseIncludeType INCLUDED = UMLProps_UsecaseDiagram_UsecaseIncludeType_INCLUDED;
  static inline bool UsecaseIncludeType_IsValid(int value) {
    return UMLProps_UsecaseDiagram_UsecaseIncludeType_IsValid(value);
  }
  static constexpr UsecaseIncludeType UsecaseIncludeType_MIN = UMLProps_UsecaseDiagram_UsecaseIncludeType_UsecaseIncludeType_MIN;
  static constexpr UsecaseIncludeType UsecaseIncludeType_MAX = UMLProps_UsecaseDiagram_UsecaseIncludeType_UsecaseIncludeType_MAX;
  static constexpr int UsecaseIncludeType_ARRAYSIZE = UMLProps_UsecaseDiagram_UsecaseIncludeType_UsecaseIncludeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UsecaseIncludeType_descriptor() {
    return UMLProps_UsecaseDiagram_UsecaseIncludeType_descriptor();
  }
  template <typename T>
  static inline const std::string& UsecaseIncludeType_Name(T value) {
    return UMLProps_UsecaseDiagram_UsecaseIncludeType_Name(value);
  }
  static inline bool UsecaseIncludeType_Parse(absl::string_view name, UsecaseIncludeType* value) {
    return UMLProps_UsecaseDiagram_UsecaseIncludeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRelationshipFieldNumber = 2,
    kComponentTypeFieldNumber = 1,
  };
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship relationship = 2;
  bool has_relationship() const;
  void clear_relationship() ;
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship& relationship() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* release_relationship();
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* mutable_relationship();
  void set_allocated_relationship(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* value);
  void unsafe_arena_set_allocated_relationship(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* value);
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* unsafe_arena_release_relationship();

  private:
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship& _internal_relationship() const;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* _internal_mutable_relationship();

  public:
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseDiagramComponent componentType = 1;
  bool has_componenttype() const;
  void clear_componenttype() ;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent componenttype() const;
  void set_componenttype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent value);

  private:
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent _internal_componenttype() const;
  void _internal_set_componenttype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent value);

  public:
  void temp_setrelationship(com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* relationship) {
    if(&this->relationship() != relationship) {
      set_allocated_relationship(relationship);
    }
  }
  
  com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* temp_getrelationship() const {
    if (has_relationship()) 
      return (const_cast<com::zoho::kits::UMLProps_UsecaseDiagram*>(this))->mutable_relationship();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.kits.UMLProps.UsecaseDiagram)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* relationship_;
    int componenttype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_umlprops_2eproto;
};// -------------------------------------------------------------------

class UMLProps_ClassDiagram final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.kits.UMLProps.ClassDiagram) */ {
 public:
  inline UMLProps_ClassDiagram() : UMLProps_ClassDiagram(nullptr) {}
  ~UMLProps_ClassDiagram() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UMLProps_ClassDiagram(::google::protobuf::internal::ConstantInitialized);

  inline UMLProps_ClassDiagram(const UMLProps_ClassDiagram& from)
      : UMLProps_ClassDiagram(nullptr, from) {}
  UMLProps_ClassDiagram(UMLProps_ClassDiagram&& from) noexcept
    : UMLProps_ClassDiagram() {
    *this = ::std::move(from);
  }

  inline UMLProps_ClassDiagram& operator=(const UMLProps_ClassDiagram& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMLProps_ClassDiagram& operator=(UMLProps_ClassDiagram&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UMLProps_ClassDiagram& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMLProps_ClassDiagram* internal_default_instance() {
    return reinterpret_cast<const UMLProps_ClassDiagram*>(
               &_UMLProps_ClassDiagram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UMLProps_ClassDiagram& a, UMLProps_ClassDiagram& b) {
    a.Swap(&b);
  }
  inline void Swap(UMLProps_ClassDiagram* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMLProps_ClassDiagram* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMLProps_ClassDiagram* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMLProps_ClassDiagram>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UMLProps_ClassDiagram& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UMLProps_ClassDiagram& from) {
    UMLProps_ClassDiagram::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UMLProps_ClassDiagram* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.kits.UMLProps.ClassDiagram";
  }
  protected:
  explicit UMLProps_ClassDiagram(::google::protobuf::Arena* arena);
  UMLProps_ClassDiagram(::google::protobuf::Arena* arena, const UMLProps_ClassDiagram& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UMLClassConnection = UMLProps_ClassDiagram_UMLClassConnection;
  using UMLClassRelationship = UMLProps_ClassDiagram_UMLClassRelationship;

  using ClassDiagramComponent = UMLProps_ClassDiagram_ClassDiagramComponent;
  static constexpr ClassDiagramComponent UNKNOWN_CLASS_DIAGRAM_COMPONENT = UMLProps_ClassDiagram_ClassDiagramComponent_UNKNOWN_CLASS_DIAGRAM_COMPONENT;
  static constexpr ClassDiagramComponent CLASS = UMLProps_ClassDiagram_ClassDiagramComponent_CLASS;
  static constexpr ClassDiagramComponent ACTIVE_CLASS = UMLProps_ClassDiagram_ClassDiagramComponent_ACTIVE_CLASS;
  static constexpr ClassDiagramComponent SIMPLE_CLASS = UMLProps_ClassDiagram_ClassDiagramComponent_SIMPLE_CLASS;
  static constexpr ClassDiagramComponent INTERFACE = UMLProps_ClassDiagram_ClassDiagramComponent_INTERFACE;
  static constexpr ClassDiagramComponent SIMPLE_INTERFACE = UMLProps_ClassDiagram_ClassDiagramComponent_SIMPLE_INTERFACE;
  static constexpr ClassDiagramComponent MULTIPLICITY = UMLProps_ClassDiagram_ClassDiagramComponent_MULTIPLICITY;
  static constexpr ClassDiagramComponent PACKAGE = UMLProps_ClassDiagram_ClassDiagramComponent_PACKAGE;
  static constexpr ClassDiagramComponent CONSTRAINT = UMLProps_ClassDiagram_ClassDiagramComponent_CONSTRAINT;
  static constexpr ClassDiagramComponent NOTE = UMLProps_ClassDiagram_ClassDiagramComponent_NOTE;
  static constexpr ClassDiagramComponent TEXT = UMLProps_ClassDiagram_ClassDiagramComponent_TEXT;
  static constexpr ClassDiagramComponent RELATIONSHIP = UMLProps_ClassDiagram_ClassDiagramComponent_RELATIONSHIP;
  static inline bool ClassDiagramComponent_IsValid(int value) {
    return UMLProps_ClassDiagram_ClassDiagramComponent_IsValid(value);
  }
  static constexpr ClassDiagramComponent ClassDiagramComponent_MIN = UMLProps_ClassDiagram_ClassDiagramComponent_ClassDiagramComponent_MIN;
  static constexpr ClassDiagramComponent ClassDiagramComponent_MAX = UMLProps_ClassDiagram_ClassDiagramComponent_ClassDiagramComponent_MAX;
  static constexpr int ClassDiagramComponent_ARRAYSIZE = UMLProps_ClassDiagram_ClassDiagramComponent_ClassDiagramComponent_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ClassDiagramComponent_descriptor() {
    return UMLProps_ClassDiagram_ClassDiagramComponent_descriptor();
  }
  template <typename T>
  static inline const std::string& ClassDiagramComponent_Name(T value) {
    return UMLProps_ClassDiagram_ClassDiagramComponent_Name(value);
  }
  static inline bool ClassDiagramComponent_Parse(absl::string_view name, ClassDiagramComponent* value) {
    return UMLProps_ClassDiagram_ClassDiagramComponent_Parse(name, value);
  }

  using RelationshipType = UMLProps_ClassDiagram_RelationshipType;
  static constexpr RelationshipType UNKNOWN_ASSOCIATION = UMLProps_ClassDiagram_RelationshipType_UNKNOWN_ASSOCIATION;
  static constexpr RelationshipType DIRECTED_ASSOCIATION = UMLProps_ClassDiagram_RelationshipType_DIRECTED_ASSOCIATION;
  static constexpr RelationshipType NON_DIRECTED_ASSOCIATION = UMLProps_ClassDiagram_RelationshipType_NON_DIRECTED_ASSOCIATION;
  static constexpr RelationshipType GENERALIZATION = UMLProps_ClassDiagram_RelationshipType_GENERALIZATION;
  static constexpr RelationshipType DEPENDENCY = UMLProps_ClassDiagram_RelationshipType_DEPENDENCY;
  static constexpr RelationshipType AGGREGATION = UMLProps_ClassDiagram_RelationshipType_AGGREGATION;
  static constexpr RelationshipType COMPOSITION = UMLProps_ClassDiagram_RelationshipType_COMPOSITION;
  static constexpr RelationshipType REALIZATION = UMLProps_ClassDiagram_RelationshipType_REALIZATION;
  static constexpr RelationshipType USAGE = UMLProps_ClassDiagram_RelationshipType_USAGE;
  static inline bool RelationshipType_IsValid(int value) {
    return UMLProps_ClassDiagram_RelationshipType_IsValid(value);
  }
  static constexpr RelationshipType RelationshipType_MIN = UMLProps_ClassDiagram_RelationshipType_RelationshipType_MIN;
  static constexpr RelationshipType RelationshipType_MAX = UMLProps_ClassDiagram_RelationshipType_RelationshipType_MAX;
  static constexpr int RelationshipType_ARRAYSIZE = UMLProps_ClassDiagram_RelationshipType_RelationshipType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RelationshipType_descriptor() {
    return UMLProps_ClassDiagram_RelationshipType_descriptor();
  }
  template <typename T>
  static inline const std::string& RelationshipType_Name(T value) {
    return UMLProps_ClassDiagram_RelationshipType_Name(value);
  }
  static inline bool RelationshipType_Parse(absl::string_view name, RelationshipType* value) {
    return UMLProps_ClassDiagram_RelationshipType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRelationshipFieldNumber = 2,
    kComponentTypeFieldNumber = 1,
  };
  // optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship relationship = 2;
  bool has_relationship() const;
  void clear_relationship() ;
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship& relationship() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* release_relationship();
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* mutable_relationship();
  void set_allocated_relationship(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* value);
  void unsafe_arena_set_allocated_relationship(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* value);
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* unsafe_arena_release_relationship();

  private:
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship& _internal_relationship() const;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* _internal_mutable_relationship();

  public:
  // optional .com.zoho.kits.UMLProps.ClassDiagram.ClassDiagramComponent componentType = 1;
  bool has_componenttype() const;
  void clear_componenttype() ;
  ::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent componenttype() const;
  void set_componenttype(::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent value);

  private:
  ::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent _internal_componenttype() const;
  void _internal_set_componenttype(::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent value);

  public:
  void temp_setrelationship(com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* relationship) {
    if(&this->relationship() != relationship) {
      set_allocated_relationship(relationship);
    }
  }
  
  com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* temp_getrelationship() const {
    if (has_relationship()) 
      return (const_cast<com::zoho::kits::UMLProps_ClassDiagram*>(this))->mutable_relationship();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.kits.UMLProps.ClassDiagram)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* relationship_;
    int componenttype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_umlprops_2eproto;
};// -------------------------------------------------------------------

class UMLProps final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.kits.UMLProps) */ {
 public:
  inline UMLProps() : UMLProps(nullptr) {}
  ~UMLProps() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UMLProps(::google::protobuf::internal::ConstantInitialized);

  inline UMLProps(const UMLProps& from)
      : UMLProps(nullptr, from) {}
  UMLProps(UMLProps&& from) noexcept
    : UMLProps() {
    *this = ::std::move(from);
  }

  inline UMLProps& operator=(const UMLProps& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMLProps& operator=(UMLProps&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UMLProps& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMLProps* internal_default_instance() {
    return reinterpret_cast<const UMLProps*>(
               &_UMLProps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UMLProps& a, UMLProps& b) {
    a.Swap(&b);
  }
  inline void Swap(UMLProps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMLProps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMLProps* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMLProps>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UMLProps& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UMLProps& from) {
    UMLProps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UMLProps* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.kits.UMLProps";
  }
  protected:
  explicit UMLProps(::google::protobuf::Arena* arena);
  UMLProps(::google::protobuf::Arena* arena, const UMLProps& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ClassDiagram = UMLProps_ClassDiagram;
  using UsecaseDiagram = UMLProps_UsecaseDiagram;

  using UMLDiagramType = UMLProps_UMLDiagramType;
  static constexpr UMLDiagramType UNKNOWN_UML = UMLProps_UMLDiagramType_UNKNOWN_UML;
  static constexpr UMLDiagramType CLASS_DIAGRAM = UMLProps_UMLDiagramType_CLASS_DIAGRAM;
  static constexpr UMLDiagramType USECASE_DIAGRAM = UMLProps_UMLDiagramType_USECASE_DIAGRAM;
  static constexpr UMLDiagramType SEQUENCE_DIAGRAM = UMLProps_UMLDiagramType_SEQUENCE_DIAGRAM;
  static constexpr UMLDiagramType COMPONENT_DIAGRAM = UMLProps_UMLDiagramType_COMPONENT_DIAGRAM;
  static constexpr UMLDiagramType DEPLOYMENT_DIAGRAM = UMLProps_UMLDiagramType_DEPLOYMENT_DIAGRAM;
  static constexpr UMLDiagramType STATE_DIAGRAM = UMLProps_UMLDiagramType_STATE_DIAGRAM;
  static constexpr UMLDiagramType ACTIVITY_DIAGRAM = UMLProps_UMLDiagramType_ACTIVITY_DIAGRAM;
  static inline bool UMLDiagramType_IsValid(int value) {
    return UMLProps_UMLDiagramType_IsValid(value);
  }
  static constexpr UMLDiagramType UMLDiagramType_MIN = UMLProps_UMLDiagramType_UMLDiagramType_MIN;
  static constexpr UMLDiagramType UMLDiagramType_MAX = UMLProps_UMLDiagramType_UMLDiagramType_MAX;
  static constexpr int UMLDiagramType_ARRAYSIZE = UMLProps_UMLDiagramType_UMLDiagramType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UMLDiagramType_descriptor() {
    return UMLProps_UMLDiagramType_descriptor();
  }
  template <typename T>
  static inline const std::string& UMLDiagramType_Name(T value) {
    return UMLProps_UMLDiagramType_Name(value);
  }
  static inline bool UMLDiagramType_Parse(absl::string_view name, UMLDiagramType* value) {
    return UMLProps_UMLDiagramType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClassDiagramFieldNumber = 2,
    kUsecaseDiagramFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.kits.UMLProps.ClassDiagram classDiagram = 2;
  bool has_classdiagram() const;
  void clear_classdiagram() ;
  const ::com::zoho::kits::UMLProps_ClassDiagram& classdiagram() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_ClassDiagram* release_classdiagram();
  ::com::zoho::kits::UMLProps_ClassDiagram* mutable_classdiagram();
  void set_allocated_classdiagram(::com::zoho::kits::UMLProps_ClassDiagram* value);
  void unsafe_arena_set_allocated_classdiagram(::com::zoho::kits::UMLProps_ClassDiagram* value);
  ::com::zoho::kits::UMLProps_ClassDiagram* unsafe_arena_release_classdiagram();

  private:
  const ::com::zoho::kits::UMLProps_ClassDiagram& _internal_classdiagram() const;
  ::com::zoho::kits::UMLProps_ClassDiagram* _internal_mutable_classdiagram();

  public:
  // optional .com.zoho.kits.UMLProps.UsecaseDiagram usecaseDiagram = 3;
  bool has_usecasediagram() const;
  void clear_usecasediagram() ;
  const ::com::zoho::kits::UMLProps_UsecaseDiagram& usecasediagram() const;
  PROTOBUF_NODISCARD ::com::zoho::kits::UMLProps_UsecaseDiagram* release_usecasediagram();
  ::com::zoho::kits::UMLProps_UsecaseDiagram* mutable_usecasediagram();
  void set_allocated_usecasediagram(::com::zoho::kits::UMLProps_UsecaseDiagram* value);
  void unsafe_arena_set_allocated_usecasediagram(::com::zoho::kits::UMLProps_UsecaseDiagram* value);
  ::com::zoho::kits::UMLProps_UsecaseDiagram* unsafe_arena_release_usecasediagram();

  private:
  const ::com::zoho::kits::UMLProps_UsecaseDiagram& _internal_usecasediagram() const;
  ::com::zoho::kits::UMLProps_UsecaseDiagram* _internal_mutable_usecasediagram();

  public:
  // optional .com.zoho.kits.UMLProps.UMLDiagramType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::kits::UMLProps_UMLDiagramType type() const;
  void set_type(::com::zoho::kits::UMLProps_UMLDiagramType value);

  private:
  ::com::zoho::kits::UMLProps_UMLDiagramType _internal_type() const;
  void _internal_set_type(::com::zoho::kits::UMLProps_UMLDiagramType value);

  public:
  void temp_setclassDiagram(com::zoho::kits::UMLProps_ClassDiagram* classDiagram) {
    if(&this->classdiagram() != classDiagram) {
      set_allocated_classdiagram(classDiagram);
    }
  }
  
  com::zoho::kits::UMLProps_ClassDiagram* temp_getclassDiagram() const {
    if (has_classdiagram()) 
      return (const_cast<com::zoho::kits::UMLProps*>(this))->mutable_classdiagram();
    return nullptr;
  }
  
  void temp_setusecaseDiagram(com::zoho::kits::UMLProps_UsecaseDiagram* usecaseDiagram) {
    if(&this->usecasediagram() != usecaseDiagram) {
      set_allocated_usecasediagram(usecaseDiagram);
    }
  }
  
  com::zoho::kits::UMLProps_UsecaseDiagram* temp_getusecaseDiagram() const {
    if (has_usecasediagram()) 
      return (const_cast<com::zoho::kits::UMLProps*>(this))->mutable_usecasediagram();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.kits.UMLProps)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::kits::UMLProps_ClassDiagram* classdiagram_;
    ::com::zoho::kits::UMLProps_UsecaseDiagram* usecasediagram_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_umlprops_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UMLProps_ClassDiagram_UMLClassConnection

// optional .com.zoho.kits.DesignDiagramFields.Cardinality cardinality = 1;
inline bool UMLProps_ClassDiagram_UMLClassConnection::has_cardinality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassConnection::clear_cardinality() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cardinality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::kits::DesignDiagramFields_Cardinality UMLProps_ClassDiagram_UMLClassConnection::cardinality() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.cardinality)
  return _internal_cardinality();
}
inline void UMLProps_ClassDiagram_UMLClassConnection::set_cardinality(::com::zoho::kits::DesignDiagramFields_Cardinality value) {
  _internal_set_cardinality(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.cardinality)
}
inline ::com::zoho::kits::DesignDiagramFields_Cardinality UMLProps_ClassDiagram_UMLClassConnection::_internal_cardinality() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::DesignDiagramFields_Cardinality>(_impl_.cardinality_);
}
inline void UMLProps_ClassDiagram_UMLClassConnection::_internal_set_cardinality(::com::zoho::kits::DesignDiagramFields_Cardinality value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cardinality_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.DirectedAssociationType associationType = 2;
inline bool UMLProps_ClassDiagram_UMLClassConnection::has_associationtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassConnection::clear_associationtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.associationtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType UMLProps_ClassDiagram_UMLClassConnection::associationtype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.associationType)
  return _internal_associationtype();
}
inline void UMLProps_ClassDiagram_UMLClassConnection::set_associationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType value) {
  _internal_set_associationtype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.associationType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType UMLProps_ClassDiagram_UMLClassConnection::_internal_associationtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType>(_impl_.associationtype_);
}
inline void UMLProps_ClassDiagram_UMLClassConnection::_internal_set_associationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.associationtype_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.Aggregation_Composition_Type aggregationType = 3;
inline bool UMLProps_ClassDiagram_UMLClassConnection::has_aggregationtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassConnection::clear_aggregationtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aggregationtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type UMLProps_ClassDiagram_UMLClassConnection::aggregationtype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.aggregationType)
  return _internal_aggregationtype();
}
inline void UMLProps_ClassDiagram_UMLClassConnection::set_aggregationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value) {
  _internal_set_aggregationtype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.aggregationType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type UMLProps_ClassDiagram_UMLClassConnection::_internal_aggregationtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>(_impl_.aggregationtype_);
}
inline void UMLProps_ClassDiagram_UMLClassConnection::_internal_set_aggregationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.aggregationtype_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.Aggregation_Composition_Type compositionType = 4;
inline bool UMLProps_ClassDiagram_UMLClassConnection::has_compositiontype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassConnection::clear_compositiontype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compositiontype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type UMLProps_ClassDiagram_UMLClassConnection::compositiontype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.compositionType)
  return _internal_compositiontype();
}
inline void UMLProps_ClassDiagram_UMLClassConnection::set_compositiontype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value) {
  _internal_set_compositiontype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.compositionType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type UMLProps_ClassDiagram_UMLClassConnection::_internal_compositiontype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>(_impl_.compositiontype_);
}
inline void UMLProps_ClassDiagram_UMLClassConnection::_internal_set_compositiontype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.compositiontype_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.GeneralizationType generalizationType = 5;
inline bool UMLProps_ClassDiagram_UMLClassConnection::has_generalizationtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassConnection::clear_generalizationtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.generalizationtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType UMLProps_ClassDiagram_UMLClassConnection::generalizationtype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.generalizationType)
  return _internal_generalizationtype();
}
inline void UMLProps_ClassDiagram_UMLClassConnection::set_generalizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType value) {
  _internal_set_generalizationtype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.generalizationType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType UMLProps_ClassDiagram_UMLClassConnection::_internal_generalizationtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType>(_impl_.generalizationtype_);
}
inline void UMLProps_ClassDiagram_UMLClassConnection::_internal_set_generalizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.generalizationtype_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.RealizationType relaizationType = 6;
inline bool UMLProps_ClassDiagram_UMLClassConnection::has_relaizationtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassConnection::clear_relaizationtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relaizationtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType UMLProps_ClassDiagram_UMLClassConnection::relaizationtype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.relaizationType)
  return _internal_relaizationtype();
}
inline void UMLProps_ClassDiagram_UMLClassConnection::set_relaizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType value) {
  _internal_set_relaizationtype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.relaizationType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType UMLProps_ClassDiagram_UMLClassConnection::_internal_relaizationtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType>(_impl_.relaizationtype_);
}
inline void UMLProps_ClassDiagram_UMLClassConnection::_internal_set_relaizationtype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.relaizationtype_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.DependencyType dependencyType = 7;
inline bool UMLProps_ClassDiagram_UMLClassConnection::has_dependencytype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassConnection::clear_dependencytype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dependencytype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType UMLProps_ClassDiagram_UMLClassConnection::dependencytype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.dependencyType)
  return _internal_dependencytype();
}
inline void UMLProps_ClassDiagram_UMLClassConnection::set_dependencytype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType value) {
  _internal_set_dependencytype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection.dependencyType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType UMLProps_ClassDiagram_UMLClassConnection::_internal_dependencytype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType>(_impl_.dependencytype_);
}
inline void UMLProps_ClassDiagram_UMLClassConnection::_internal_set_dependencytype(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.dependencytype_ = value;
}

// -------------------------------------------------------------------

// UMLProps_ClassDiagram_UMLClassRelationship

// optional .com.zoho.kits.UMLProps.ClassDiagram.RelationshipType relationshipType = 1;
inline bool UMLProps_ClassDiagram_UMLClassRelationship::has_relationshiptype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::clear_relationshiptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relationshiptype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType UMLProps_ClassDiagram_UMLClassRelationship::relationshiptype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.relationshipType)
  return _internal_relationshiptype();
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::set_relationshiptype(::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType value) {
  _internal_set_relationshiptype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.relationshipType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType UMLProps_ClassDiagram_UMLClassRelationship::_internal_relationshiptype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType>(_impl_.relationshiptype_);
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::_internal_set_relationshiptype(::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.relationshiptype_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection start = 2;
inline bool UMLProps_ClassDiagram_UMLClassRelationship::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& UMLProps_ClassDiagram_UMLClassRelationship::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection&>(::com::zoho::kits::_UMLProps_ClassDiagram_UMLClassConnection_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& UMLProps_ClassDiagram_UMLClassRelationship::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.start)
  return _internal_start();
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::unsafe_arena_set_allocated_start(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.start)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* released = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::unsafe_arena_release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::_internal_mutable_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection>(GetArena());
    _impl_.start_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(p);
  }
  return _impl_.start_;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::mutable_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.start)
  return _msg;
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::set_allocated_start(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(_impl_.start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.start)
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassConnection end = 3;
inline bool UMLProps_ClassDiagram_UMLClassRelationship::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& UMLProps_ClassDiagram_UMLClassRelationship::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection&>(::com::zoho::kits::_UMLProps_ClassDiagram_UMLClassConnection_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection& UMLProps_ClassDiagram_UMLClassRelationship::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.end)
  return _internal_end();
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::unsafe_arena_set_allocated_end(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.end)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* released = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::unsafe_arena_release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.end)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::_internal_mutable_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection>(GetArena());
    _impl_.end_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(p);
  }
  return _impl_.end_;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* UMLProps_ClassDiagram_UMLClassRelationship::mutable_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.end)
  return _msg;
}
inline void UMLProps_ClassDiagram_UMLClassRelationship::set_allocated_end(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(_impl_.end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship.end)
}

// -------------------------------------------------------------------

// UMLProps_ClassDiagram

// optional .com.zoho.kits.UMLProps.ClassDiagram.ClassDiagramComponent componentType = 1;
inline bool UMLProps_ClassDiagram::has_componenttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UMLProps_ClassDiagram::clear_componenttype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.componenttype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent UMLProps_ClassDiagram::componenttype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.componentType)
  return _internal_componenttype();
}
inline void UMLProps_ClassDiagram::set_componenttype(::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent value) {
  _internal_set_componenttype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.ClassDiagram.componentType)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent UMLProps_ClassDiagram::_internal_componenttype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent>(_impl_.componenttype_);
}
inline void UMLProps_ClassDiagram::_internal_set_componenttype(::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.componenttype_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram.UMLClassRelationship relationship = 2;
inline bool UMLProps_ClassDiagram::has_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relationship_ != nullptr);
  return value;
}
inline void UMLProps_ClassDiagram::clear_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.relationship_ != nullptr) _impl_.relationship_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship& UMLProps_ClassDiagram::_internal_relationship() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* p = _impl_.relationship_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship&>(::com::zoho::kits::_UMLProps_ClassDiagram_UMLClassRelationship_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship& UMLProps_ClassDiagram::relationship() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.ClassDiagram.relationship)
  return _internal_relationship();
}
inline void UMLProps_ClassDiagram::unsafe_arena_set_allocated_relationship(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relationship_);
  }
  _impl_.relationship_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.ClassDiagram.relationship)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* UMLProps_ClassDiagram::release_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* released = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* UMLProps_ClassDiagram::unsafe_arena_release_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.ClassDiagram.relationship)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* temp = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* UMLProps_ClassDiagram::_internal_mutable_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.relationship_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship>(GetArena());
    _impl_.relationship_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship*>(p);
  }
  return _impl_.relationship_;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* UMLProps_ClassDiagram::mutable_relationship() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* _msg = _internal_mutable_relationship();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.ClassDiagram.relationship)
  return _msg;
}
inline void UMLProps_ClassDiagram::set_allocated_relationship(::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship*>(_impl_.relationship_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.relationship_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassRelationship*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.ClassDiagram.relationship)
}

// -------------------------------------------------------------------

// UMLProps_UsecaseDiagram_UMLUsecaseConnection

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseExtendType extendType = 1;
inline bool UMLProps_UsecaseDiagram_UMLUsecaseConnection::has_extendtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::clear_extendtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extendtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType UMLProps_UsecaseDiagram_UMLUsecaseConnection::extendtype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection.extendType)
  return _internal_extendtype();
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::set_extendtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType value) {
  _internal_set_extendtype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection.extendType)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType UMLProps_UsecaseDiagram_UMLUsecaseConnection::_internal_extendtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType>(_impl_.extendtype_);
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::_internal_set_extendtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.extendtype_ = value;
}

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseGeneralizationType generalizationType = 2;
inline bool UMLProps_UsecaseDiagram_UMLUsecaseConnection::has_generalizationtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::clear_generalizationtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.generalizationtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType UMLProps_UsecaseDiagram_UMLUsecaseConnection::generalizationtype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection.generalizationType)
  return _internal_generalizationtype();
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::set_generalizationtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType value) {
  _internal_set_generalizationtype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection.generalizationType)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType UMLProps_UsecaseDiagram_UMLUsecaseConnection::_internal_generalizationtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType>(_impl_.generalizationtype_);
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::_internal_set_generalizationtype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.generalizationtype_ = value;
}

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseIncludeType includeType = 3;
inline bool UMLProps_UsecaseDiagram_UMLUsecaseConnection::has_includetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::clear_includetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.includetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType UMLProps_UsecaseDiagram_UMLUsecaseConnection::includetype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection.includeType)
  return _internal_includetype();
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::set_includetype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType value) {
  _internal_set_includetype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection.includeType)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType UMLProps_UsecaseDiagram_UMLUsecaseConnection::_internal_includetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType>(_impl_.includetype_);
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseConnection::_internal_set_includetype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.includetype_ = value;
}

// -------------------------------------------------------------------

// UMLProps_UsecaseDiagram_UMLUsecaseRelationship

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.RelationshipType type = 1;
inline bool UMLProps_UsecaseDiagram_UMLUsecaseRelationship::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType UMLProps_UsecaseDiagram_UMLUsecaseRelationship::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.type)
  return _internal_type();
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::set_type(::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.type)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType UMLProps_UsecaseDiagram_UMLUsecaseRelationship::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType>(_impl_.type_);
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::_internal_set_type(::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection start = 2;
inline bool UMLProps_UsecaseDiagram_UMLUsecaseRelationship::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& UMLProps_UsecaseDiagram_UMLUsecaseRelationship::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection&>(::com::zoho::kits::_UMLProps_UsecaseDiagram_UMLUsecaseConnection_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& UMLProps_UsecaseDiagram_UMLUsecaseRelationship::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.start)
  return _internal_start();
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::unsafe_arena_set_allocated_start(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.start)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* released = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::unsafe_arena_release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::_internal_mutable_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection>(GetArena());
    _impl_.start_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(p);
  }
  return _impl_.start_;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::mutable_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.start)
  return _msg;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::set_allocated_start(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(_impl_.start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.start)
}

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseConnection end = 3;
inline bool UMLProps_UsecaseDiagram_UMLUsecaseRelationship::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& UMLProps_UsecaseDiagram_UMLUsecaseRelationship::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection&>(::com::zoho::kits::_UMLProps_UsecaseDiagram_UMLUsecaseConnection_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection& UMLProps_UsecaseDiagram_UMLUsecaseRelationship::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.end)
  return _internal_end();
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::unsafe_arena_set_allocated_end(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.end)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* released = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::unsafe_arena_release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.end)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::_internal_mutable_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection>(GetArena());
    _impl_.end_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(p);
  }
  return _impl_.end_;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* UMLProps_UsecaseDiagram_UMLUsecaseRelationship::mutable_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.end)
  return _msg;
}
inline void UMLProps_UsecaseDiagram_UMLUsecaseRelationship::set_allocated_end(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(_impl_.end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseConnection*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship.end)
}

// -------------------------------------------------------------------

// UMLProps_UsecaseDiagram

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.UsecaseDiagramComponent componentType = 1;
inline bool UMLProps_UsecaseDiagram::has_componenttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UMLProps_UsecaseDiagram::clear_componenttype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.componenttype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent UMLProps_UsecaseDiagram::componenttype() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.componentType)
  return _internal_componenttype();
}
inline void UMLProps_UsecaseDiagram::set_componenttype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent value) {
  _internal_set_componenttype(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.UsecaseDiagram.componentType)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent UMLProps_UsecaseDiagram::_internal_componenttype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent>(_impl_.componenttype_);
}
inline void UMLProps_UsecaseDiagram::_internal_set_componenttype(::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.componenttype_ = value;
}

// optional .com.zoho.kits.UMLProps.UsecaseDiagram.UMLUsecaseRelationship relationship = 2;
inline bool UMLProps_UsecaseDiagram::has_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relationship_ != nullptr);
  return value;
}
inline void UMLProps_UsecaseDiagram::clear_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.relationship_ != nullptr) _impl_.relationship_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship& UMLProps_UsecaseDiagram::_internal_relationship() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* p = _impl_.relationship_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship&>(::com::zoho::kits::_UMLProps_UsecaseDiagram_UMLUsecaseRelationship_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship& UMLProps_UsecaseDiagram::relationship() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.UsecaseDiagram.relationship)
  return _internal_relationship();
}
inline void UMLProps_UsecaseDiagram::unsafe_arena_set_allocated_relationship(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relationship_);
  }
  _impl_.relationship_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.UsecaseDiagram.relationship)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* UMLProps_UsecaseDiagram::release_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* released = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* UMLProps_UsecaseDiagram::unsafe_arena_release_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.UsecaseDiagram.relationship)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* temp = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* UMLProps_UsecaseDiagram::_internal_mutable_relationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.relationship_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship>(GetArena());
    _impl_.relationship_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(p);
  }
  return _impl_.relationship_;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* UMLProps_UsecaseDiagram::mutable_relationship() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* _msg = _internal_mutable_relationship();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.UsecaseDiagram.relationship)
  return _msg;
}
inline void UMLProps_UsecaseDiagram::set_allocated_relationship(::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(_impl_.relationship_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.relationship_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram_UMLUsecaseRelationship*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.UsecaseDiagram.relationship)
}

// -------------------------------------------------------------------

// UMLProps

// optional .com.zoho.kits.UMLProps.UMLDiagramType type = 1;
inline bool UMLProps::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UMLProps::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::kits::UMLProps_UMLDiagramType UMLProps::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.type)
  return _internal_type();
}
inline void UMLProps::set_type(::com::zoho::kits::UMLProps_UMLDiagramType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.kits.UMLProps.type)
}
inline ::com::zoho::kits::UMLProps_UMLDiagramType UMLProps::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::kits::UMLProps_UMLDiagramType>(_impl_.type_);
}
inline void UMLProps::_internal_set_type(::com::zoho::kits::UMLProps_UMLDiagramType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .com.zoho.kits.UMLProps.ClassDiagram classDiagram = 2;
inline bool UMLProps::has_classdiagram() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classdiagram_ != nullptr);
  return value;
}
inline void UMLProps::clear_classdiagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.classdiagram_ != nullptr) _impl_.classdiagram_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram& UMLProps::_internal_classdiagram() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_ClassDiagram* p = _impl_.classdiagram_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_ClassDiagram&>(::com::zoho::kits::_UMLProps_ClassDiagram_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_ClassDiagram& UMLProps::classdiagram() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.classDiagram)
  return _internal_classdiagram();
}
inline void UMLProps::unsafe_arena_set_allocated_classdiagram(::com::zoho::kits::UMLProps_ClassDiagram* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.classdiagram_);
  }
  _impl_.classdiagram_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.classDiagram)
}
inline ::com::zoho::kits::UMLProps_ClassDiagram* UMLProps::release_classdiagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_ClassDiagram* released = _impl_.classdiagram_;
  _impl_.classdiagram_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram* UMLProps::unsafe_arena_release_classdiagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.classDiagram)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::kits::UMLProps_ClassDiagram* temp = _impl_.classdiagram_;
  _impl_.classdiagram_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram* UMLProps::_internal_mutable_classdiagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.classdiagram_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_ClassDiagram>(GetArena());
    _impl_.classdiagram_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram*>(p);
  }
  return _impl_.classdiagram_;
}
inline ::com::zoho::kits::UMLProps_ClassDiagram* UMLProps::mutable_classdiagram() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_ClassDiagram* _msg = _internal_mutable_classdiagram();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.classDiagram)
  return _msg;
}
inline void UMLProps::set_allocated_classdiagram(::com::zoho::kits::UMLProps_ClassDiagram* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram*>(_impl_.classdiagram_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.classdiagram_ = reinterpret_cast<::com::zoho::kits::UMLProps_ClassDiagram*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.classDiagram)
}

// optional .com.zoho.kits.UMLProps.UsecaseDiagram usecaseDiagram = 3;
inline bool UMLProps::has_usecasediagram() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usecasediagram_ != nullptr);
  return value;
}
inline void UMLProps::clear_usecasediagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.usecasediagram_ != nullptr) _impl_.usecasediagram_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram& UMLProps::_internal_usecasediagram() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::kits::UMLProps_UsecaseDiagram* p = _impl_.usecasediagram_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::kits::UMLProps_UsecaseDiagram&>(::com::zoho::kits::_UMLProps_UsecaseDiagram_default_instance_);
}
inline const ::com::zoho::kits::UMLProps_UsecaseDiagram& UMLProps::usecasediagram() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.kits.UMLProps.usecaseDiagram)
  return _internal_usecasediagram();
}
inline void UMLProps::unsafe_arena_set_allocated_usecasediagram(::com::zoho::kits::UMLProps_UsecaseDiagram* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usecasediagram_);
  }
  _impl_.usecasediagram_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.kits.UMLProps.usecaseDiagram)
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram* UMLProps::release_usecasediagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram* released = _impl_.usecasediagram_;
  _impl_.usecasediagram_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram* UMLProps::unsafe_arena_release_usecasediagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.kits.UMLProps.usecaseDiagram)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::kits::UMLProps_UsecaseDiagram* temp = _impl_.usecasediagram_;
  _impl_.usecasediagram_ = nullptr;
  return temp;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram* UMLProps::_internal_mutable_usecasediagram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.usecasediagram_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::kits::UMLProps_UsecaseDiagram>(GetArena());
    _impl_.usecasediagram_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram*>(p);
  }
  return _impl_.usecasediagram_;
}
inline ::com::zoho::kits::UMLProps_UsecaseDiagram* UMLProps::mutable_usecasediagram() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::kits::UMLProps_UsecaseDiagram* _msg = _internal_mutable_usecasediagram();
  // @@protoc_insertion_point(field_mutable:com.zoho.kits.UMLProps.usecaseDiagram)
  return _msg;
}
inline void UMLProps::set_allocated_usecasediagram(::com::zoho::kits::UMLProps_UsecaseDiagram* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram*>(_impl_.usecasediagram_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.usecasediagram_ = reinterpret_cast<::com::zoho::kits::UMLProps_UsecaseDiagram*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.kits.UMLProps.usecaseDiagram)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace kits
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DirectedAssociationType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_Aggregation_Composition_Type_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_GeneralizationType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_RealizationType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_DependencyType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_UMLClassConnection_UsageDependencyType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_ClassDiagramComponent_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType>() {
  return ::com::zoho::kits::UMLProps_ClassDiagram_RelationshipType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent>() {
  return ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseDiagramComponent_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType>() {
  return ::com::zoho::kits::UMLProps_UsecaseDiagram_RelationshipType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType>() {
  return ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseExtendType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType>() {
  return ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseGeneralizationType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType>() {
  return ::com::zoho::kits::UMLProps_UsecaseDiagram_UsecaseIncludeType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::kits::UMLProps_UMLDiagramType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::kits::UMLProps_UMLDiagramType>() {
  return ::com::zoho::kits::UMLProps_UMLDiagramType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_umlprops_2eproto_2epb_2eh
