// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: nonvisualprops.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct NonVisualProps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// indicates PlaceHolder type
  public var placeHolder: PlaceHolder {
    get {return _placeHolder ?? PlaceHolder()}
    set {_placeHolder = newValue}
  }
  /// Returns true if `placeHolder` has been explicitly set.
  public var hasPlaceHolder: Bool {return self._placeHolder != nil}
  /// Clears the value of `placeHolder`. Subsequent reads from it will return its default value.
  public mutating func clearPlaceHolder() {self._placeHolder = nil}

  public var embed: NonVisualProps.EmbedFile {
    get {return _embed ?? NonVisualProps.EmbedFile()}
    set {_embed = newValue}
  }
  /// Returns true if `embed` has been explicitly set.
  public var hasEmbed: Bool {return self._embed != nil}
  /// Clears the value of `embed`. Subsequent reads from it will return its default value.
  public mutating func clearEmbed() {self._embed = nil}

  /// This boolean is used to indicate that this pariticular shape has been drawn by the User. Used in Layouts and Masters to differentiate the shapes in-built in them with others.
  public var userDrawn: Bool {
    get {return _userDrawn ?? false}
    set {_userDrawn = newValue}
  }
  /// Returns true if `userDrawn` has been explicitly set.
  public var hasUserDrawn: Bool {return self._userDrawn != nil}
  /// Clears the value of `userDrawn`. Subsequent reads from it will return its default value.
  public mutating func clearUserDrawn() {self._userDrawn = nil}

  /// Comments associated with this Shape.
  public var commentIds: [String] = []

  public var markedForExport: Bool {
    get {return _markedForExport ?? false}
    set {_markedForExport = newValue}
  }
  /// Returns true if `markedForExport` has been explicitly set.
  public var hasMarkedForExport: Bool {return self._markedForExport != nil}
  /// Clears the value of `markedForExport`. Subsequent reads from it will return its default value.
  public mutating func clearMarkedForExport() {self._markedForExport = nil}

  public var reactions: [Reaction] = []

  public var exportOptions: [ExportOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct EmbedFile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: NonVisualProps.EmbedFile.EmbedType {
      get {return _storage._type ?? .internal}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    public var code: String {
      get {return _storage._code ?? String()}
      set {_uniqueStorage()._code = newValue}
    }
    /// Returns true if `code` has been explicitly set.
    public var hasCode: Bool {return _storage._code != nil}
    /// Clears the value of `code`. Subsequent reads from it will return its default value.
    public mutating func clearCode() {_uniqueStorage()._code = nil}

    public var site: NonVisualProps.EmbedFile.EmbeddedSite {
      get {return _storage._site ?? .youtube}
      set {_uniqueStorage()._site = newValue}
    }
    /// Returns true if `site` has been explicitly set.
    public var hasSite: Bool {return _storage._site != nil}
    /// Clears the value of `site`. Subsequent reads from it will return its default value.
    public mutating func clearSite() {_uniqueStorage()._site = nil}

    public var twitter: NonVisualProps.EmbedFile.TwitterData {
      get {return _storage._twitter ?? NonVisualProps.EmbedFile.TwitterData()}
      set {_uniqueStorage()._twitter = newValue}
    }
    /// Returns true if `twitter` has been explicitly set.
    public var hasTwitter: Bool {return _storage._twitter != nil}
    /// Clears the value of `twitter`. Subsequent reads from it will return its default value.
    public mutating func clearTwitter() {_uniqueStorage()._twitter = nil}

    /// For now , this will be used to maintain the search strings for Youtube/DailyMotion Video.
    public var searchKeys: [String] {
      get {return _storage._searchKeys}
      set {_uniqueStorage()._searchKeys = newValue}
    }

    public var embedObject: NonVisualProps.EmbedFile.EmbedObject {
      get {return _storage._embedObject ?? NonVisualProps.EmbedFile.EmbedObject()}
      set {_uniqueStorage()._embedObject = newValue}
    }
    /// Returns true if `embedObject` has been explicitly set.
    public var hasEmbedObject: Bool {return _storage._embedObject != nil}
    /// Clears the value of `embedObject`. Subsequent reads from it will return its default value.
    public mutating func clearEmbedObject() {_uniqueStorage()._embedObject = nil}

    public var mediaObject: MediaObject {
      get {return _storage._mediaObject ?? MediaObject()}
      set {_uniqueStorage()._mediaObject = newValue}
    }
    /// Returns true if `mediaObject` has been explicitly set.
    public var hasMediaObject: Bool {return _storage._mediaObject != nil}
    /// Clears the value of `mediaObject`. Subsequent reads from it will return its default value.
    public mutating func clearMediaObject() {_uniqueStorage()._mediaObject = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum EmbedType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case `internal` // = 0
      case external // = 1

      /// Video / Audio embed.
      case media // = 2

      public init() {
        self = .internal
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .internal
        case 1: self = .external
        case 2: self = .media
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .internal: return 0
        case .external: return 1
        case .media: return 2
        }
      }

    }

    public enum EmbeddedSite: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case youtube // = 0
      case twitter // = 1
      case dailymotion // = 2

      public init() {
        self = .youtube
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .youtube
        case 1: self = .twitter
        case 2: self = .dailymotion
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .youtube: return 0
        case .twitter: return 1
        case .dailymotion: return 2
        }
      }

    }

    public struct TwitterData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: NonVisualProps.EmbedFile.TwitterData.TwitterType {
        get {return _type ?? .live}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      /// Hold the search strings.
      public var keys: [String] = []

      public var update: NonVisualProps.EmbedFile.TwitterData.UpdateType {
        get {return _update ?? .manual}
        set {_update = newValue}
      }
      /// Returns true if `update` has been explicitly set.
      public var hasUpdate: Bool {return self._update != nil}
      /// Clears the value of `update`. Subsequent reads from it will return its default value.
      public mutating func clearUpdate() {self._update = nil}

      /// For Marked this will hold the tweet-ids.
      public var ids: [String] = []

      /// Zoho Unique ID for the user who added the twitter data.
      public var userID: String {
        get {return _userID ?? String()}
        set {_userID = newValue}
      }
      /// Returns true if `userID` has been explicitly set.
      public var hasUserID: Bool {return self._userID != nil}
      /// Clears the value of `userID`. Subsequent reads from it will return its default value.
      public mutating func clearUserID() {self._userID = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum TwitterType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case live // = 0
        case marked // = 1

        public init() {
          self = .live
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .live
          case 1: self = .marked
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .live: return 0
          case .marked: return 1
          }
        }

      }

      /// Should we update the live tweets Automatically or Manually.
      public enum UpdateType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case manual // = 0
        case automatic // = 1

        public init() {
          self = .manual
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .manual
          case 1: self = .automatic
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .manual: return 0
          case .automatic: return 1
          }
        }

      }

      public init() {}

      fileprivate var _type: NonVisualProps.EmbedFile.TwitterData.TwitterType? = nil
      fileprivate var _update: NonVisualProps.EmbedFile.TwitterData.UpdateType? = nil
      fileprivate var _userID: String? = nil
    }

    public struct EmbedObject {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: NonVisualProps.EmbedFile.EmbedObject.EmbedObjectType {
        get {return _storage._type ?? .notKnown}
        set {_uniqueStorage()._type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return _storage._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {_uniqueStorage()._type = nil}

      public var url: URL {
        get {return _storage._url ?? URL()}
        set {_uniqueStorage()._url = newValue}
      }
      /// Returns true if `url` has been explicitly set.
      public var hasURL: Bool {return _storage._url != nil}
      /// Clears the value of `url`. Subsequent reads from it will return its default value.
      public mutating func clearURL() {_uniqueStorage()._url = nil}

      public var dim: Dimension {
        get {return _storage._dim ?? Dimension()}
        set {_uniqueStorage()._dim = newValue}
      }
      /// Returns true if `dim` has been explicitly set.
      public var hasDim: Bool {return _storage._dim != nil}
      /// Clears the value of `dim`. Subsequent reads from it will return its default value.
      public mutating func clearDim() {_uniqueStorage()._dim = nil}

      public var margin: Margin {
        get {return _storage._margin ?? Margin()}
        set {_uniqueStorage()._margin = newValue}
      }
      /// Returns true if `margin` has been explicitly set.
      public var hasMargin: Bool {return _storage._margin != nil}
      /// Clears the value of `margin`. Subsequent reads from it will return its default value.
      public mutating func clearMargin() {_uniqueStorage()._margin = nil}

      public var variables: [NonVisualProps.EmbedFile.EmbedObject.VariableMap] {
        get {return _storage._variables}
        set {_uniqueStorage()._variables = newValue}
      }

      public var style: String {
        get {return _storage._style ?? String()}
        set {_uniqueStorage()._style = newValue}
      }
      /// Returns true if `style` has been explicitly set.
      public var hasStyle: Bool {return _storage._style != nil}
      /// Clears the value of `style`. Subsequent reads from it will return its default value.
      public mutating func clearStyle() {_uniqueStorage()._style = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum EmbedObjectType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case notKnown // = 0
        case iframe // = 1

        public init() {
          self = .notKnown
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .notKnown
          case 1: self = .iframe
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .notKnown: return 0
          case .iframe: return 1
          }
        }

      }

      public struct VariableMap {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var key: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key {
          get {return _key ?? NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key()}
          set {_key = newValue}
        }
        /// Returns true if `key` has been explicitly set.
        public var hasKey: Bool {return self._key != nil}
        /// Clears the value of `key`. Subsequent reads from it will return its default value.
        public mutating func clearKey() {self._key = nil}

        public var value: Value {
          get {return _value ?? Value()}
          set {_value = newValue}
        }
        /// Returns true if `value` has been explicitly set.
        public var hasValue: Bool {return self._value != nil}
        /// Clears the value of `value`. Subsequent reads from it will return its default value.
        public mutating func clearValue() {self._value = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Key {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var keyType: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.KeyType {
            get {return _keyType ?? .noType}
            set {_keyType = newValue}
          }
          /// Returns true if `keyType` has been explicitly set.
          public var hasKeyType: Bool {return self._keyType != nil}
          /// Clears the value of `keyType`. Subsequent reads from it will return its default value.
          public mutating func clearKeyType() {self._keyType = nil}

          public var defined: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.DefinedKey {
            get {return _defined ?? .undefined}
            set {_defined = newValue}
          }
          /// Returns true if `defined` has been explicitly set.
          public var hasDefined: Bool {return self._defined != nil}
          /// Clears the value of `defined`. Subsequent reads from it will return its default value.
          public mutating func clearDefined() {self._defined = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum KeyType: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case noType // = 0
            case defined // = 1

            public init() {
              self = .noType
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .noType
              case 1: self = .defined
              default: return nil
              }
            }

            public var rawValue: Int {
              switch self {
              case .noType: return 0
              case .defined: return 1
              }
            }

          }

          /// properties of iframe.
          public enum DefinedKey: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case undefined // = 0
            case scrolling // = 1
            case border // = 2
            case fullscreen // = 3
            case transparency // = 4

            public init() {
              self = .undefined
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .undefined
              case 1: self = .scrolling
              case 2: self = .border
              case 3: self = .fullscreen
              case 4: self = .transparency
              default: return nil
              }
            }

            public var rawValue: Int {
              switch self {
              case .undefined: return 0
              case .scrolling: return 1
              case .border: return 2
              case .fullscreen: return 3
              case .transparency: return 4
              }
            }

          }

          public init() {}

          fileprivate var _keyType: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.KeyType? = nil
          fileprivate var _defined: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.DefinedKey? = nil
        }

        public init() {}

        fileprivate var _key: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key? = nil
        fileprivate var _value: Value? = nil
      }

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _placeHolder: PlaceHolder? = nil
  fileprivate var _embed: NonVisualProps.EmbedFile? = nil
  fileprivate var _userDrawn: Bool? = nil
  fileprivate var _markedForExport: Bool? = nil
}

#if swift(>=4.2)

extension NonVisualProps.EmbedFile.EmbedType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NonVisualProps.EmbedFile.EmbeddedSite: CaseIterable {
  // Support synthesized by the compiler.
}

extension NonVisualProps.EmbedFile.TwitterData.TwitterType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NonVisualProps.EmbedFile.TwitterData.UpdateType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NonVisualProps.EmbedFile.EmbedObject.EmbedObjectType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.KeyType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.DefinedKey: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension NonVisualProps: @unchecked Sendable {}
extension NonVisualProps.EmbedFile: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbedType: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbeddedSite: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.TwitterData: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.TwitterData.TwitterType: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.TwitterData.UpdateType: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbedObject: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbedObject.EmbedObjectType: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbedObject.VariableMap: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.KeyType: @unchecked Sendable {}
extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.DefinedKey: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension NonVisualProps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NonVisualProps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "placeHolder"),
    2: .same(proto: "embed"),
    3: .same(proto: "userDrawn"),
    4: .same(proto: "commentIds"),
    5: .same(proto: "markedForExport"),
    6: .same(proto: "reactions"),
    7: .same(proto: "exportOptions"),
  ]

  public var isInitialized: Bool {
    if let v = self._placeHolder, !v.isInitialized {return false}
    if let v = self._embed, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.reactions) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._placeHolder) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._embed) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._userDrawn) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.commentIds) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._markedForExport) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.exportOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._placeHolder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._embed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._userDrawn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.commentIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.commentIds, fieldNumber: 4)
    }
    try { if let v = self._markedForExport {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 6)
    }
    if !self.exportOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exportOptions, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NonVisualProps, rhs: NonVisualProps) -> Bool {
    if lhs._placeHolder != rhs._placeHolder {return false}
    if lhs._embed != rhs._embed {return false}
    if lhs._userDrawn != rhs._userDrawn {return false}
    if lhs.commentIds != rhs.commentIds {return false}
    if lhs._markedForExport != rhs._markedForExport {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.exportOptions != rhs.exportOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NonVisualProps.EmbedFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NonVisualProps.protoMessageName + ".EmbedFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "code"),
    3: .same(proto: "site"),
    4: .same(proto: "twitter"),
    5: .same(proto: "searchKeys"),
    6: .same(proto: "embedObject"),
    7: .same(proto: "mediaObject"),
  ]

  fileprivate class _StorageClass {
    var _type: NonVisualProps.EmbedFile.EmbedType? = nil
    var _code: String? = nil
    var _site: NonVisualProps.EmbedFile.EmbeddedSite? = nil
    var _twitter: NonVisualProps.EmbedFile.TwitterData? = nil
    var _searchKeys: [String] = []
    var _embedObject: NonVisualProps.EmbedFile.EmbedObject? = nil
    var _mediaObject: MediaObject? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _code = source._code
      _site = source._site
      _twitter = source._twitter
      _searchKeys = source._searchKeys
      _embedObject = source._embedObject
      _mediaObject = source._mediaObject
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code == nil {return false}
      if let v = _storage._embedObject, !v.isInitialized {return false}
      if let v = _storage._mediaObject, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._code) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._site) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._twitter) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._searchKeys) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._embedObject) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._mediaObject) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._code {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._site {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._twitter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._searchKeys.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._searchKeys, fieldNumber: 5)
      }
      try { if let v = _storage._embedObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._mediaObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NonVisualProps.EmbedFile, rhs: NonVisualProps.EmbedFile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._site != rhs_storage._site {return false}
        if _storage._twitter != rhs_storage._twitter {return false}
        if _storage._searchKeys != rhs_storage._searchKeys {return false}
        if _storage._embedObject != rhs_storage._embedObject {return false}
        if _storage._mediaObject != rhs_storage._mediaObject {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NonVisualProps.EmbedFile.EmbedType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERNAL"),
    1: .same(proto: "EXTERNAL"),
    2: .same(proto: "MEDIA"),
  ]
}

extension NonVisualProps.EmbedFile.EmbeddedSite: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "YOUTUBE"),
    1: .same(proto: "TWITTER"),
    2: .same(proto: "DAILYMOTION"),
  ]
}

extension NonVisualProps.EmbedFile.TwitterData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NonVisualProps.EmbedFile.protoMessageName + ".TwitterData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "keys"),
    3: .same(proto: "update"),
    4: .same(proto: "ids"),
    5: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._update) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    try { if let v = self._update {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 4)
    }
    try { if let v = self._userID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NonVisualProps.EmbedFile.TwitterData, rhs: NonVisualProps.EmbedFile.TwitterData) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs._update != rhs._update {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NonVisualProps.EmbedFile.TwitterData.TwitterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIVE"),
    1: .same(proto: "MARKED"),
  ]
}

extension NonVisualProps.EmbedFile.TwitterData.UpdateType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANUAL"),
    1: .same(proto: "AUTOMATIC"),
  ]
}

extension NonVisualProps.EmbedFile.EmbedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NonVisualProps.EmbedFile.protoMessageName + ".EmbedObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "url"),
    3: .same(proto: "dim"),
    4: .same(proto: "margin"),
    5: .same(proto: "variables"),
    6: .same(proto: "style"),
  ]

  fileprivate class _StorageClass {
    var _type: NonVisualProps.EmbedFile.EmbedObject.EmbedObjectType? = nil
    var _url: URL? = nil
    var _dim: Dimension? = nil
    var _margin: Margin? = nil
    var _variables: [NonVisualProps.EmbedFile.EmbedObject.VariableMap] = []
    var _style: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _url = source._url
      _dim = source._dim
      _margin = source._margin
      _variables = source._variables
      _style = source._style
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._url, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._variables) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._url) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dim) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._margin) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._variables) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._style) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._url {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dim {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._margin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._variables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._variables, fieldNumber: 5)
      }
      try { if let v = _storage._style {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NonVisualProps.EmbedFile.EmbedObject, rhs: NonVisualProps.EmbedFile.EmbedObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._dim != rhs_storage._dim {return false}
        if _storage._margin != rhs_storage._margin {return false}
        if _storage._variables != rhs_storage._variables {return false}
        if _storage._style != rhs_storage._style {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NonVisualProps.EmbedFile.EmbedObject.EmbedObjectType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_KNOWN"),
    1: .same(proto: "IFRAME"),
  ]
}

extension NonVisualProps.EmbedFile.EmbedObject.VariableMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NonVisualProps.EmbedFile.EmbedObject.protoMessageName + ".VariableMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NonVisualProps.EmbedFile.EmbedObject.VariableMap, rhs: NonVisualProps.EmbedFile.EmbedObject.VariableMap) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NonVisualProps.EmbedFile.EmbedObject.VariableMap.protoMessageName + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyType"),
    2: .same(proto: "defined"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._keyType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._defined) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._defined {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key, rhs: NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key) -> Bool {
    if lhs._keyType != rhs._keyType {return false}
    if lhs._defined != rhs._defined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_TYPE"),
    1: .same(proto: "DEFINED"),
  ]
}

extension NonVisualProps.EmbedFile.EmbedObject.VariableMap.Key.DefinedKey: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "SCROLLING"),
    2: .same(proto: "BORDER"),
    3: .same(proto: "FULLSCREEN"),
    4: .same(proto: "TRANSPARENCY"),
  ]
}
