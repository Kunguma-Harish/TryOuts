// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mediaproperties.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct MediaProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DB Key
  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var format: MediaProperties.MediaFormat {
    get {return _format ?? .unknownMediaFormat}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  public var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  public mutating func clearFormat() {self._format = nil}

  public var audio: MediaProperties.AudioMedia {
    get {return _audio ?? MediaProperties.AudioMedia()}
    set {_audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return self._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {self._audio = nil}

  public var video: MediaProperties.VideoMedia {
    get {return _video ?? MediaProperties.VideoMedia()}
    set {_video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return self._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {self._video = nil}

  public var duration: String {
    get {return _duration ?? String()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// By default, it is of UPLOADED type
  public var type: MediaProperties.MediaInsertType {
    get {return _type ?? .unknownType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var recordInfo: MediaProperties.RecordMetadata {
    get {return _recordInfo ?? MediaProperties.RecordMetadata()}
    set {_recordInfo = newValue}
  }
  /// Returns true if `recordInfo` has been explicitly set.
  public var hasRecordInfo: Bool {return self._recordInfo != nil}
  /// Clears the value of `recordInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRecordInfo() {self._recordInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MediaFormat: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownMediaFormat // = 0
    case audio // = 1
    case video // = 2

    public init() {
      self = .unknownMediaFormat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownMediaFormat
      case 1: self = .audio
      case 2: self = .video
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownMediaFormat: return 0
      case .audio: return 1
      case .video: return 2
      }
    }

  }

  public enum MediaInsertType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case uploaded // = 1
    case recorded // = 2

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .uploaded
      case 2: self = .recorded
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .uploaded: return 1
      case .recorded: return 2
      }
    }

  }

  public struct AudioMedia {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var format: MediaProperties.AudioMedia.AudioFormat {
      get {return _format ?? .unknownAudioFormat}
      set {_format = newValue}
    }
    /// Returns true if `format` has been explicitly set.
    public var hasFormat: Bool {return self._format != nil}
    /// Clears the value of `format`. Subsequent reads from it will return its default value.
    public mutating func clearFormat() {self._format = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum AudioFormat: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownAudioFormat // = 0
      case mp3 // = 1
      case wav // = 2
      case wma // = 3
      case mpeg // = 4
      case m4A // = 5

      public init() {
        self = .unknownAudioFormat
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownAudioFormat
        case 1: self = .mp3
        case 2: self = .wav
        case 3: self = .wma
        case 4: self = .mpeg
        case 5: self = .m4A
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownAudioFormat: return 0
        case .mp3: return 1
        case .wav: return 2
        case .wma: return 3
        case .mpeg: return 4
        case .m4A: return 5
        }
      }

    }

    public init() {}

    fileprivate var _format: MediaProperties.AudioMedia.AudioFormat? = nil
  }

  public struct VideoMedia {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var format: MediaProperties.VideoMedia.VideoFormat {
      get {return _format ?? .unknownVideoFormat}
      set {_format = newValue}
    }
    /// Returns true if `format` has been explicitly set.
    public var hasFormat: Bool {return self._format != nil}
    /// Clears the value of `format`. Subsequent reads from it will return its default value.
    public mutating func clearFormat() {self._format = nil}

    public var dim: Dimension {
      get {return _dim ?? Dimension()}
      set {_dim = newValue}
    }
    /// Returns true if `dim` has been explicitly set.
    public var hasDim: Bool {return self._dim != nil}
    /// Clears the value of `dim`. Subsequent reads from it will return its default value.
    public mutating func clearDim() {self._dim = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum VideoFormat: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownVideoFormat // = 0
      case mp4 // = 1
      case mov // = 2
      case wmv // = 3
      case avi // = 4
      case webm // = 5
      case m4V // = 6
      case mkv // = 7
      case mpeg // = 8
      case mwv // = 9
      case mpg // = 10

      public init() {
        self = .unknownVideoFormat
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownVideoFormat
        case 1: self = .mp4
        case 2: self = .mov
        case 3: self = .wmv
        case 4: self = .avi
        case 5: self = .webm
        case 6: self = .m4V
        case 7: self = .mkv
        case 8: self = .mpeg
        case 9: self = .mwv
        case 10: self = .mpg
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownVideoFormat: return 0
        case .mp4: return 1
        case .mov: return 2
        case .wmv: return 3
        case .avi: return 4
        case .webm: return 5
        case .m4V: return 6
        case .mkv: return 7
        case .mpeg: return 8
        case .mwv: return 9
        case .mpg: return 10
        }
      }

    }

    public init() {}

    fileprivate var _format: MediaProperties.VideoMedia.VideoFormat? = nil
    fileprivate var _dim: Dimension? = nil
  }

  public struct RecordMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var zuid: String {
      get {return _zuid ?? String()}
      set {_zuid = newValue}
    }
    /// Returns true if `zuid` has been explicitly set.
    public var hasZuid: Bool {return self._zuid != nil}
    /// Clears the value of `zuid`. Subsequent reads from it will return its default value.
    public mutating func clearZuid() {self._zuid = nil}

    /// save userName, if the zuid left the organization, we can use this.
    public var userName: String {
      get {return _userName ?? String()}
      set {_userName = newValue}
    }
    /// Returns true if `userName` has been explicitly set.
    public var hasUserName: Bool {return self._userName != nil}
    /// Clears the value of `userName`. Subsequent reads from it will return its default value.
    public mutating func clearUserName() {self._userName = nil}

    /// Date in current time millis. It denotes the recorded date and time.
    public var date: Time {
      get {return _date ?? Time()}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    public var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    public mutating func clearDate() {self._date = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _zuid: String? = nil
    fileprivate var _userName: String? = nil
    fileprivate var _date: Time? = nil
  }

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _format: MediaProperties.MediaFormat? = nil
  fileprivate var _audio: MediaProperties.AudioMedia? = nil
  fileprivate var _video: MediaProperties.VideoMedia? = nil
  fileprivate var _duration: String? = nil
  fileprivate var _type: MediaProperties.MediaInsertType? = nil
  fileprivate var _recordInfo: MediaProperties.RecordMetadata? = nil
}

#if swift(>=4.2)

extension MediaProperties.MediaFormat: CaseIterable {
  // Support synthesized by the compiler.
}

extension MediaProperties.MediaInsertType: CaseIterable {
  // Support synthesized by the compiler.
}

extension MediaProperties.AudioMedia.AudioFormat: CaseIterable {
  // Support synthesized by the compiler.
}

extension MediaProperties.VideoMedia.VideoFormat: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension MediaProperties: @unchecked Sendable {}
extension MediaProperties.MediaFormat: @unchecked Sendable {}
extension MediaProperties.MediaInsertType: @unchecked Sendable {}
extension MediaProperties.AudioMedia: @unchecked Sendable {}
extension MediaProperties.AudioMedia.AudioFormat: @unchecked Sendable {}
extension MediaProperties.VideoMedia: @unchecked Sendable {}
extension MediaProperties.VideoMedia.VideoFormat: @unchecked Sendable {}
extension MediaProperties.RecordMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.common"

extension MediaProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "name"),
    3: .same(proto: "format"),
    4: .same(proto: "audio"),
    5: .same(proto: "video"),
    6: .same(proto: "duration"),
    7: .same(proto: "type"),
    8: .same(proto: "recordInfo"),
  ]

  public var isInitialized: Bool {
    if let v = self._recordInfo, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._format) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._video) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._duration) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._recordInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._video {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._recordInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MediaProperties, rhs: MediaProperties) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._name != rhs._name {return false}
    if lhs._format != rhs._format {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs._video != rhs._video {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._type != rhs._type {return false}
    if lhs._recordInfo != rhs._recordInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MediaProperties.MediaFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_MEDIA_FORMAT"),
    1: .same(proto: "AUDIO"),
    2: .same(proto: "VIDEO"),
  ]
}

extension MediaProperties.MediaInsertType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "UPLOADED"),
    2: .same(proto: "RECORDED"),
  ]
}

extension MediaProperties.AudioMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MediaProperties.protoMessageName + ".AudioMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._format {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MediaProperties.AudioMedia, rhs: MediaProperties.AudioMedia) -> Bool {
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MediaProperties.AudioMedia.AudioFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_AUDIO_FORMAT"),
    1: .same(proto: "MP3"),
    2: .same(proto: "WAV"),
    3: .same(proto: "WMA"),
    4: .same(proto: "MPEG"),
    5: .same(proto: "M4A"),
  ]
}

extension MediaProperties.VideoMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MediaProperties.protoMessageName + ".VideoMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "dim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._format) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dim) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._format {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MediaProperties.VideoMedia, rhs: MediaProperties.VideoMedia) -> Bool {
    if lhs._format != rhs._format {return false}
    if lhs._dim != rhs._dim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MediaProperties.VideoMedia.VideoFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_VIDEO_FORMAT"),
    1: .same(proto: "MP4"),
    2: .same(proto: "MOV"),
    3: .same(proto: "WMV"),
    4: .same(proto: "AVI"),
    5: .same(proto: "WEBM"),
    6: .same(proto: "M4V"),
    7: .same(proto: "MKV"),
    8: .same(proto: "MPEG"),
    9: .same(proto: "MWV"),
    10: .same(proto: "MPG"),
  ]
}

extension MediaProperties.RecordMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MediaProperties.protoMessageName + ".RecordMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "zuid"),
    2: .same(proto: "userName"),
    3: .same(proto: "date"),
  ]

  public var isInitialized: Bool {
    if let v = self._date, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._zuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._userName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._zuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MediaProperties.RecordMetadata, rhs: MediaProperties.RecordMetadata) -> Bool {
    if lhs._zuid != rhs._zuid {return false}
    if lhs._userName != rhs._userName {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
