// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: projectmapping.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ProjectMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: String {
    get {return _projectID ?? String()}
    set {_projectID = newValue}
  }
  /// Returns true if `projectID` has been explicitly set.
  public var hasProjectID: Bool {return self._projectID != nil}
  /// Clears the value of `projectID`. Subsequent reads from it will return its default value.
  public mutating func clearProjectID() {self._projectID = nil}

  public var docMapping: [ProjectMapping.DocumentMappingDetails] = []

  public var pictureRels: [Relationship] = []

  public var commentPictureRels: [Relationship] = []

  public var mediaRels: [Relationship] = []

  public var commentMediaRels: [Relationship] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DocumentMapping {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var documentRel: Relationship {
      get {return _documentRel ?? Relationship()}
      set {_documentRel = newValue}
    }
    /// Returns true if `documentRel` has been explicitly set.
    public var hasDocumentRel: Bool {return self._documentRel != nil}
    /// Clears the value of `documentRel`. Subsequent reads from it will return its default value.
    public mutating func clearDocumentRel() {self._documentRel = nil}

    public var screenRels: [Relationship] = []

    public var placeHolderDatas: [ProjectMapping.DocumentMapping.DocumentPlaceHolderData] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DocumentPlaceHolderData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var placeholderRel: Relationship {
        get {return _placeholderRel ?? Relationship()}
        set {_placeholderRel = newValue}
      }
      /// Returns true if `placeholderRel` has been explicitly set.
      public var hasPlaceholderRel: Bool {return self._placeholderRel != nil}
      /// Clears the value of `placeholderRel`. Subsequent reads from it will return its default value.
      public mutating func clearPlaceholderRel() {self._placeholderRel = nil}

      public var contentLanguage: ProjectMapping.DocumentMapping.DocumentPlaceHolderData.ContentLanguage {
        get {return _contentLanguage ?? .defLanguage}
        set {_contentLanguage = newValue}
      }
      /// Returns true if `contentLanguage` has been explicitly set.
      public var hasContentLanguage: Bool {return self._contentLanguage != nil}
      /// Clears the value of `contentLanguage`. Subsequent reads from it will return its default value.
      public mutating func clearContentLanguage() {self._contentLanguage = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum ContentLanguage: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case defLanguage // = 0
        case unspecifiedLanguage // = 1
        case english // = 2

        public init() {
          self = .defLanguage
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .defLanguage
          case 1: self = .unspecifiedLanguage
          case 2: self = .english
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .defLanguage: return 0
          case .unspecifiedLanguage: return 1
          case .english: return 2
          }
        }

      }

      public init() {}

      fileprivate var _placeholderRel: Relationship? = nil
      fileprivate var _contentLanguage: ProjectMapping.DocumentMapping.DocumentPlaceHolderData.ContentLanguage? = nil
    }

    public init() {}

    fileprivate var _documentRel: Relationship? = nil
  }

  public struct DocumentMappingDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///client id
    public var documentID: String {
      get {return _documentID ?? String()}
      set {_documentID = newValue}
    }
    /// Returns true if `documentID` has been explicitly set.
    public var hasDocumentID: Bool {return self._documentID != nil}
    /// Clears the value of `documentID`. Subsequent reads from it will return its default value.
    public mutating func clearDocumentID() {self._documentID = nil}

    public var mapping: ProjectMapping.DocumentMapping {
      get {return _mapping ?? ProjectMapping.DocumentMapping()}
      set {_mapping = newValue}
    }
    /// Returns true if `mapping` has been explicitly set.
    public var hasMapping: Bool {return self._mapping != nil}
    /// Clears the value of `mapping`. Subsequent reads from it will return its default value.
    public mutating func clearMapping() {self._mapping = nil}

    public var componentDetails: [ProjectMapping.DocumentMappingDetails.ComponentDetail] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ComponentDetail {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: String {
        get {return _id ?? String()}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      public var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      public mutating func clearID() {self._id = nil}

      public var versionID: String {
        get {return _versionID ?? String()}
        set {_versionID = newValue}
      }
      /// Returns true if `versionID` has been explicitly set.
      public var hasVersionID: Bool {return self._versionID != nil}
      /// Clears the value of `versionID`. Subsequent reads from it will return its default value.
      public mutating func clearVersionID() {self._versionID = nil}

      public var time: Time {
        get {return _time ?? Time()}
        set {_time = newValue}
      }
      /// Returns true if `time` has been explicitly set.
      public var hasTime: Bool {return self._time != nil}
      /// Clears the value of `time`. Subsequent reads from it will return its default value.
      public mutating func clearTime() {self._time = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _id: String? = nil
      fileprivate var _versionID: String? = nil
      fileprivate var _time: Time? = nil
    }

    public init() {}

    fileprivate var _documentID: String? = nil
    fileprivate var _mapping: ProjectMapping.DocumentMapping? = nil
  }

  public init() {}

  fileprivate var _projectID: String? = nil
}

#if swift(>=4.2)

extension ProjectMapping.DocumentMapping.DocumentPlaceHolderData.ContentLanguage: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension ProjectMapping: @unchecked Sendable {}
extension ProjectMapping.DocumentMapping: @unchecked Sendable {}
extension ProjectMapping.DocumentMapping.DocumentPlaceHolderData: @unchecked Sendable {}
extension ProjectMapping.DocumentMapping.DocumentPlaceHolderData.ContentLanguage: @unchecked Sendable {}
extension ProjectMapping.DocumentMappingDetails: @unchecked Sendable {}
extension ProjectMapping.DocumentMappingDetails.ComponentDetail: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.common"

extension ProjectMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProjectMapping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projectId"),
    2: .same(proto: "docMapping"),
    3: .same(proto: "pictureRels"),
    4: .same(proto: "commentPictureRels"),
    5: .same(proto: "mediaRels"),
    6: .same(proto: "commentMediaRels"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.docMapping) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.pictureRels) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.commentPictureRels) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mediaRels) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.commentMediaRels) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._projectID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.docMapping) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pictureRels) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.commentPictureRels) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.mediaRels) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.commentMediaRels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._projectID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.docMapping.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.docMapping, fieldNumber: 2)
    }
    if !self.pictureRels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pictureRels, fieldNumber: 3)
    }
    if !self.commentPictureRels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commentPictureRels, fieldNumber: 4)
    }
    if !self.mediaRels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mediaRels, fieldNumber: 5)
    }
    if !self.commentMediaRels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commentMediaRels, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectMapping, rhs: ProjectMapping) -> Bool {
    if lhs._projectID != rhs._projectID {return false}
    if lhs.docMapping != rhs.docMapping {return false}
    if lhs.pictureRels != rhs.pictureRels {return false}
    if lhs.commentPictureRels != rhs.commentPictureRels {return false}
    if lhs.mediaRels != rhs.mediaRels {return false}
    if lhs.commentMediaRels != rhs.commentMediaRels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectMapping.DocumentMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectMapping.protoMessageName + ".DocumentMapping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documentRel"),
    2: .same(proto: "screenRels"),
    4: .same(proto: "placeHolderDatas"),
  ]

  public var isInitialized: Bool {
    if let v = self._documentRel, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.screenRels) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.placeHolderDatas) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._documentRel) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.screenRels) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.placeHolderDatas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentRel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.screenRels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.screenRels, fieldNumber: 2)
    }
    if !self.placeHolderDatas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.placeHolderDatas, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectMapping.DocumentMapping, rhs: ProjectMapping.DocumentMapping) -> Bool {
    if lhs._documentRel != rhs._documentRel {return false}
    if lhs.screenRels != rhs.screenRels {return false}
    if lhs.placeHolderDatas != rhs.placeHolderDatas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectMapping.DocumentMapping.DocumentPlaceHolderData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectMapping.DocumentMapping.protoMessageName + ".DocumentPlaceHolderData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "placeholderRel"),
    2: .same(proto: "contentLanguage"),
  ]

  public var isInitialized: Bool {
    if let v = self._placeholderRel, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._placeholderRel) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._contentLanguage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._placeholderRel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contentLanguage {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectMapping.DocumentMapping.DocumentPlaceHolderData, rhs: ProjectMapping.DocumentMapping.DocumentPlaceHolderData) -> Bool {
    if lhs._placeholderRel != rhs._placeholderRel {return false}
    if lhs._contentLanguage != rhs._contentLanguage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectMapping.DocumentMapping.DocumentPlaceHolderData.ContentLanguage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_LANGUAGE"),
    1: .same(proto: "UNSPECIFIED_LANGUAGE"),
    2: .same(proto: "ENGLISH"),
  ]
}

extension ProjectMapping.DocumentMappingDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectMapping.protoMessageName + ".DocumentMappingDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documentId"),
    2: .same(proto: "mapping"),
    3: .same(proto: "componentDetails"),
  ]

  public var isInitialized: Bool {
    if let v = self._mapping, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.componentDetails) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._documentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mapping) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.componentDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mapping {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.componentDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.componentDetails, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectMapping.DocumentMappingDetails, rhs: ProjectMapping.DocumentMappingDetails) -> Bool {
    if lhs._documentID != rhs._documentID {return false}
    if lhs._mapping != rhs._mapping {return false}
    if lhs.componentDetails != rhs.componentDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectMapping.DocumentMappingDetails.ComponentDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectMapping.DocumentMappingDetails.protoMessageName + ".ComponentDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "versionId"),
    3: .same(proto: "time"),
  ]

  public var isInitialized: Bool {
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._versionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._versionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectMapping.DocumentMappingDetails.ComponentDetail, rhs: ProjectMapping.DocumentMappingDetails.ComponentDetail) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._versionID != rhs._versionID {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
