// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: colorscheme.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ColorScheme {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique Id for the scheme.
  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// Color scheme can be from a different theme. 
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var colorStyle: ColorScheme.ColorStyle {
    get {return _colorStyle ?? ColorScheme.ColorStyle()}
    set {_colorStyle = newValue}
  }
  /// Returns true if `colorStyle` has been explicitly set.
  public var hasColorStyle: Bool {return self._colorStyle != nil}
  /// Clears the value of `colorStyle`. Subsequent reads from it will return its default value.
  public mutating func clearColorStyle() {self._colorStyle = nil}

  /// Indicates whether the fontscheme has been modified or not. Will be updated for imported presentations too. 
  public var modified: Bool {
    get {return _modified ?? false}
    set {_modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return self._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {self._modified = nil}

  /// Theme document ID. This is only temporary data , any code should check for schemes (and any other needed stuffs) using this document id and if not present should continue its check in the full list of docs.
  public var themeID: String {
    get {return _themeID ?? String()}
    set {_themeID = newValue}
  }
  /// Returns true if `themeID` has been explicitly set.
  public var hasThemeID: Bool {return self._themeID != nil}
  /// Clears the value of `themeID`. Subsequent reads from it will return its default value.
  public mutating func clearThemeID() {self._themeID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ColorStyle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Dark Color for background , usually black
    public var dark1: [Int32] = []

    /// Light Color for text , usually white
    public var light1: [Int32] = []

    /// Dark color for background.
    public var dark2: [Int32] = []

    /// Light color for text.
    public var light2: [Int32] = []

    /// Accent Color 1 , will be used for objects drawn over the slide.
    public var accent1: [Int32] = []

    /// Accent Color 2
    public var accent2: [Int32] = []

    /// Accent Color 3
    public var accent3: [Int32] = []

    /// Accent Color 4
    public var accent4: [Int32] = []

    /// Accent Color 5
    public var accent5: [Int32] = []

    /// Accent Color 6
    public var accent6: [Int32] = []

    /// for hyper link
    public var hlink: [Int32] = []

    /// for followed hyper link
    public var followhlink: [Int32] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _colorStyle: ColorScheme.ColorStyle? = nil
  fileprivate var _modified: Bool? = nil
  fileprivate var _themeID: String? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ColorScheme: @unchecked Sendable {}
extension ColorScheme.ColorStyle: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.theme"

extension ColorScheme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ColorScheme"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "colorStyle"),
    4: .same(proto: "modified"),
    99: .same(proto: "themeId"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._colorStyle == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._colorStyle) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._modified) }()
      case 99: try { try decoder.decodeSingularStringField(value: &self._themeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._colorStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._modified {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._themeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 99)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ColorScheme, rhs: ColorScheme) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs._colorStyle != rhs._colorStyle {return false}
    if lhs._modified != rhs._modified {return false}
    if lhs._themeID != rhs._themeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ColorScheme.ColorStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ColorScheme.protoMessageName + ".ColorStyle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dark1"),
    2: .same(proto: "light1"),
    3: .same(proto: "dark2"),
    4: .same(proto: "light2"),
    5: .same(proto: "accent1"),
    6: .same(proto: "accent2"),
    7: .same(proto: "accent3"),
    8: .same(proto: "accent4"),
    9: .same(proto: "accent5"),
    10: .same(proto: "accent6"),
    11: .same(proto: "hlink"),
    12: .same(proto: "followhlink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.dark1) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.light1) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.dark2) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.light2) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.accent1) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.accent2) }()
      case 7: try { try decoder.decodeRepeatedInt32Field(value: &self.accent3) }()
      case 8: try { try decoder.decodeRepeatedInt32Field(value: &self.accent4) }()
      case 9: try { try decoder.decodeRepeatedInt32Field(value: &self.accent5) }()
      case 10: try { try decoder.decodeRepeatedInt32Field(value: &self.accent6) }()
      case 11: try { try decoder.decodeRepeatedInt32Field(value: &self.hlink) }()
      case 12: try { try decoder.decodeRepeatedInt32Field(value: &self.followhlink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dark1.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.dark1, fieldNumber: 1)
    }
    if !self.light1.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.light1, fieldNumber: 2)
    }
    if !self.dark2.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.dark2, fieldNumber: 3)
    }
    if !self.light2.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.light2, fieldNumber: 4)
    }
    if !self.accent1.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.accent1, fieldNumber: 5)
    }
    if !self.accent2.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.accent2, fieldNumber: 6)
    }
    if !self.accent3.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.accent3, fieldNumber: 7)
    }
    if !self.accent4.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.accent4, fieldNumber: 8)
    }
    if !self.accent5.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.accent5, fieldNumber: 9)
    }
    if !self.accent6.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.accent6, fieldNumber: 10)
    }
    if !self.hlink.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.hlink, fieldNumber: 11)
    }
    if !self.followhlink.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.followhlink, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ColorScheme.ColorStyle, rhs: ColorScheme.ColorStyle) -> Bool {
    if lhs.dark1 != rhs.dark1 {return false}
    if lhs.light1 != rhs.light1 {return false}
    if lhs.dark2 != rhs.dark2 {return false}
    if lhs.light2 != rhs.light2 {return false}
    if lhs.accent1 != rhs.accent1 {return false}
    if lhs.accent2 != rhs.accent2 {return false}
    if lhs.accent3 != rhs.accent3 {return false}
    if lhs.accent4 != rhs.accent4 {return false}
    if lhs.accent5 != rhs.accent5 {return false}
    if lhs.accent6 != rhs.accent6 {return false}
    if lhs.hlink != rhs.hlink {return false}
    if lhs.followhlink != rhs.followhlink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
