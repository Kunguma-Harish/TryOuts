// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: shapeobject.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ShapeObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: ShapeNodeType {
    get {return _storage._type ?? .shape}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// Shape 
  public var shape: Shape {
    get {return _storage._shape ?? Shape()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_uniqueStorage()._shape = nil}

  /// Picture 
  public var picture: Picture {
    get {return _storage._picture ?? Picture()}
    set {_uniqueStorage()._picture = newValue}
  }
  /// Returns true if `picture` has been explicitly set.
  public var hasPicture: Bool {return _storage._picture != nil}
  /// Clears the value of `picture`. Subsequent reads from it will return its default value.
  public mutating func clearPicture() {_uniqueStorage()._picture = nil}

  /// Connector
  public var connector: Connector {
    get {return _storage._connector ?? Connector()}
    set {_uniqueStorage()._connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  public var hasConnector: Bool {return _storage._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  public mutating func clearConnector() {_uniqueStorage()._connector = nil}

  /// Group Shape 
  public var groupshape: ShapeObject.GroupShape {
    get {return _storage._groupshape ?? ShapeObject.GroupShape()}
    set {_uniqueStorage()._groupshape = newValue}
  }
  /// Returns true if `groupshape` has been explicitly set.
  public var hasGroupshape: Bool {return _storage._groupshape != nil}
  /// Clears the value of `groupshape`. Subsequent reads from it will return its default value.
  public mutating func clearGroupshape() {_uniqueStorage()._groupshape = nil}

  /// GroupFrame to contain Tables, Charts and SmartArts.
  public var graphicframe: GraphicFrame {
    get {return _storage._graphicframe ?? GraphicFrame()}
    set {_uniqueStorage()._graphicframe = newValue}
  }
  /// Returns true if `graphicframe` has been explicitly set.
  public var hasGraphicframe: Bool {return _storage._graphicframe != nil}
  /// Clears the value of `graphicframe`. Subsequent reads from it will return its default value.
  public mutating func clearGraphicframe() {_uniqueStorage()._graphicframe = nil}

  public var paragraph: ShapeObject.ParagraphShape {
    get {return _storage._paragraph ?? ShapeObject.ParagraphShape()}
    set {_uniqueStorage()._paragraph = newValue}
  }
  /// Returns true if `paragraph` has been explicitly set.
  public var hasParagraph: Bool {return _storage._paragraph != nil}
  /// Clears the value of `paragraph`. Subsequent reads from it will return its default value.
  public mutating func clearParagraph() {_uniqueStorage()._paragraph = nil}

  public var combinedobject: ShapeObject.CombinedObject {
    get {return _storage._combinedobject ?? ShapeObject.CombinedObject()}
    set {_uniqueStorage()._combinedobject = newValue}
  }
  /// Returns true if `combinedobject` has been explicitly set.
  public var hasCombinedobject: Bool {return _storage._combinedobject != nil}
  /// Clears the value of `combinedobject`. Subsequent reads from it will return its default value.
  public mutating func clearCombinedobject() {_uniqueStorage()._combinedobject = nil}

  public var associatorID: String {
    get {return _storage._associatorID ?? String()}
    set {_uniqueStorage()._associatorID = newValue}
  }
  /// Returns true if `associatorID` has been explicitly set.
  public var hasAssociatorID: Bool {return _storage._associatorID != nil}
  /// Clears the value of `associatorID`. Subsequent reads from it will return its default value.
  public mutating func clearAssociatorID() {_uniqueStorage()._associatorID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct GroupShape {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Shapes Array.
    public var shapes: [ShapeObject] {
      get {return _storage._shapes}
      set {_uniqueStorage()._shapes = newValue}
    }

    /// Non visual group shape props.
    public var nvOprops: NonVisualGroupShapeProps {
      get {return _storage._nvOprops ?? NonVisualGroupShapeProps()}
      set {_uniqueStorage()._nvOprops = newValue}
    }
    /// Returns true if `nvOprops` has been explicitly set.
    public var hasNvOprops: Bool {return _storage._nvOprops != nil}
    /// Clears the value of `nvOprops`. Subsequent reads from it will return its default value.
    public mutating func clearNvOprops() {_uniqueStorage()._nvOprops = nil}

    /// Properties.
    public var props: Properties {
      get {return _storage._props ?? Properties()}
      set {_uniqueStorage()._props = newValue}
    }
    /// Returns true if `props` has been explicitly set.
    public var hasProps: Bool {return _storage._props != nil}
    /// Clears the value of `props`. Subsequent reads from it will return its default value.
    public mutating func clearProps() {_uniqueStorage()._props = nil}

    public var mask: ShapeObject {
      get {return _storage._mask ?? ShapeObject()}
      set {_uniqueStorage()._mask = newValue}
    }
    /// Returns true if `mask` has been explicitly set.
    public var hasMask: Bool {return _storage._mask != nil}
    /// Clears the value of `mask`. Subsequent reads from it will return its default value.
    public mutating func clearMask() {_uniqueStorage()._mask = nil}

    public var category: ElementCategory {
      get {return _storage._category ?? ElementCategory()}
      set {_uniqueStorage()._category = newValue}
    }
    /// Returns true if `category` has been explicitly set.
    public var hasCategory: Bool {return _storage._category != nil}
    /// Clears the value of `category`. Subsequent reads from it will return its default value.
    public mutating func clearCategory() {_uniqueStorage()._category = nil}

    public var modifiedFollowers: [ModifiedFollower] {
      get {return _storage._modifiedFollowers}
      set {_uniqueStorage()._modifiedFollowers = newValue}
    }

    public var additionalFollowers: ShapeObject.GroupShape.AdditionalElement {
      get {return _storage._additionalFollowers ?? ShapeObject.GroupShape.AdditionalElement()}
      set {_uniqueStorage()._additionalFollowers = newValue}
    }
    /// Returns true if `additionalFollowers` has been explicitly set.
    public var hasAdditionalFollowers: Bool {return _storage._additionalFollowers != nil}
    /// Clears the value of `additionalFollowers`. Subsequent reads from it will return its default value.
    public mutating func clearAdditionalFollowers() {_uniqueStorage()._additionalFollowers = nil}

    public var scroll: Scroll {
      get {return _storage._scroll ?? Scroll()}
      set {_uniqueStorage()._scroll = newValue}
    }
    /// Returns true if `scroll` has been explicitly set.
    public var hasScroll: Bool {return _storage._scroll != nil}
    /// Clears the value of `scroll`. Subsequent reads from it will return its default value.
    public mutating func clearScroll() {_uniqueStorage()._scroll = nil}

    public var followerOverrides: [ShapeObject.FollowerOverrides] {
      get {return _storage._followerOverrides}
      set {_uniqueStorage()._followerOverrides = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct AdditionalElement {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var shapesOnTop: [ShapeObject] = []

      public var shapesBeneath: [ShapeObject] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct CombinedObject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var combinedNodes: [ShapeObject.CombinedObject.CombinedNode] = []

    /// Non visual Combined shape props.
    public var nvOprops: NonVisualCombinedShapeProps {
      get {return _nvOprops ?? NonVisualCombinedShapeProps()}
      set {_nvOprops = newValue}
    }
    /// Returns true if `nvOprops` has been explicitly set.
    public var hasNvOprops: Bool {return self._nvOprops != nil}
    /// Clears the value of `nvOprops`. Subsequent reads from it will return its default value.
    public mutating func clearNvOprops() {self._nvOprops = nil}

    /// Properties.
    public var props: Properties {
      get {return _props ?? Properties()}
      set {_props = newValue}
    }
    /// Returns true if `props` has been explicitly set.
    public var hasProps: Bool {return self._props != nil}
    /// Clears the value of `props`. Subsequent reads from it will return its default value.
    public mutating func clearProps() {self._props = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct CombinedNode {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: ShapeObject.CombinedObject.CombinedNode.CombinedNodeType {
        get {return _type ?? .unknown}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var shape: Shape {
        get {return _shape ?? Shape()}
        set {_shape = newValue}
      }
      /// Returns true if `shape` has been explicitly set.
      public var hasShape: Bool {return self._shape != nil}
      /// Clears the value of `shape`. Subsequent reads from it will return its default value.
      public mutating func clearShape() {self._shape = nil}

      public var combinedobject: ShapeObject.CombinedObject {
        get {return _combinedobject ?? ShapeObject.CombinedObject()}
        set {_combinedobject = newValue}
      }
      /// Returns true if `combinedobject` has been explicitly set.
      public var hasCombinedobject: Bool {return self._combinedobject != nil}
      /// Clears the value of `combinedobject`. Subsequent reads from it will return its default value.
      public mutating func clearCombinedobject() {self._combinedobject = nil}

      public var rule: ShapeField.CombineRule {
        get {return _rule ?? .noRule}
        set {_rule = newValue}
      }
      /// Returns true if `rule` has been explicitly set.
      public var hasRule: Bool {return self._rule != nil}
      /// Clears the value of `rule`. Subsequent reads from it will return its default value.
      public mutating func clearRule() {self._rule = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum CombinedNodeType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknown // = 0
        case shape // = 1
        case combinedobject // = 2

        public init() {
          self = .unknown
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .shape
          case 2: self = .combinedobject
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .shape: return 1
          case .combinedobject: return 2
          }
        }

      }

      public init() {}

      fileprivate var _type: ShapeObject.CombinedObject.CombinedNode.CombinedNodeType? = nil
      fileprivate var _shape: Shape? = nil
      fileprivate var _combinedobject: ShapeObject.CombinedObject? = nil
      fileprivate var _rule: ShapeField.CombineRule? = nil
    }

    public init() {}

    fileprivate var _nvOprops: NonVisualCombinedShapeProps? = nil
    fileprivate var _props: Properties? = nil
  }

  public struct ParagraphShape {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var para: Paragraph {
      get {return _para ?? Paragraph()}
      set {_para = newValue}
    }
    /// Returns true if `para` has been explicitly set.
    public var hasPara: Bool {return self._para != nil}
    /// Clears the value of `para`. Subsequent reads from it will return its default value.
    public mutating func clearPara() {self._para = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
    fileprivate var _para: Paragraph? = nil
  }

  public struct FollowerOverrides {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    /// Denotes which child has been modified. Should be traversed top->bottom.
    public var child: [String] = []

    public var status: ShapeObject.FollowerOverrides.FollowerOverrideStatus {
      get {return _status ?? .defFollowerOverrideStatus}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    public var overrides: ShapeObject.FollowerOverrides.OverrideDetails {
      get {return _overrides ?? ShapeObject.FollowerOverrides.OverrideDetails()}
      set {_overrides = newValue}
    }
    /// Returns true if `overrides` has been explicitly set.
    public var hasOverrides: Bool {return self._overrides != nil}
    /// Clears the value of `overrides`. Subsequent reads from it will return its default value.
    public mutating func clearOverrides() {self._overrides = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum FollowerOverrideStatus: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case defFollowerOverrideStatus // = 0
      case noOverride // = 1
      case overridden // = 2
      case removed // = 3

      public init() {
        self = .defFollowerOverrideStatus
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .defFollowerOverrideStatus
        case 1: self = .noOverride
        case 2: self = .overridden
        case 3: self = .removed
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .defFollowerOverrideStatus: return 0
        case .noOverride: return 1
        case .overridden: return 2
        case .removed: return 3
        }
      }

    }

    public struct OverrideDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var object: ShapeObject {
        get {return _object ?? ShapeObject()}
        set {_object = newValue}
      }
      /// Returns true if `object` has been explicitly set.
      public var hasObject: Bool {return self._object != nil}
      /// Clears the value of `object`. Subsequent reads from it will return its default value.
      public mutating func clearObject() {self._object = nil}

      public var updatedLeader: UpdatedLeader {
        get {return _updatedLeader ?? UpdatedLeader()}
        set {_updatedLeader = newValue}
      }
      /// Returns true if `updatedLeader` has been explicitly set.
      public var hasUpdatedLeader: Bool {return self._updatedLeader != nil}
      /// Clears the value of `updatedLeader`. Subsequent reads from it will return its default value.
      public mutating func clearUpdatedLeader() {self._updatedLeader = nil}

      public var overrideParams: [ShapeObject.FollowerOverrides.OverrideDetails.OverrideParam] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OverrideParam: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case none // = 0
        case transform // = 1
        case fills // = 2
        case strokes // = 3
        case styleRef // = 4
        case effects // = 5
        case alpha // = 6
        case blur // = 7

        /// Depending on the ShapeObjectType appropriate nvOprops has to be considered
        case nonVisualObjectDrawingProps // = 8
        case pictureProps // = 9
        case pictureValue // = 10
        case crop // = 11
        case textContent // = 12
        case textStyle // = 13

        public init() {
          self = .none
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .transform
          case 2: self = .fills
          case 3: self = .strokes
          case 4: self = .styleRef
          case 5: self = .effects
          case 6: self = .alpha
          case 7: self = .blur
          case 8: self = .nonVisualObjectDrawingProps
          case 9: self = .pictureProps
          case 10: self = .pictureValue
          case 11: self = .crop
          case 12: self = .textContent
          case 13: self = .textStyle
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .none: return 0
          case .transform: return 1
          case .fills: return 2
          case .strokes: return 3
          case .styleRef: return 4
          case .effects: return 5
          case .alpha: return 6
          case .blur: return 7
          case .nonVisualObjectDrawingProps: return 8
          case .pictureProps: return 9
          case .pictureValue: return 10
          case .crop: return 11
          case .textContent: return 12
          case .textStyle: return 13
          }
        }

      }

      public init() {}

      fileprivate var _object: ShapeObject? = nil
      fileprivate var _updatedLeader: UpdatedLeader? = nil
    }

    public init() {}

    fileprivate var _id: String? = nil
    fileprivate var _status: ShapeObject.FollowerOverrides.FollowerOverrideStatus? = nil
    fileprivate var _overrides: ShapeObject.FollowerOverrides.OverrideDetails? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension ShapeObject.CombinedObject.CombinedNode.CombinedNodeType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ShapeObject.FollowerOverrides.FollowerOverrideStatus: CaseIterable {
  // Support synthesized by the compiler.
}

extension ShapeObject.FollowerOverrides.OverrideDetails.OverrideParam: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension ShapeObject: @unchecked Sendable {}
extension ShapeObject.GroupShape: @unchecked Sendable {}
extension ShapeObject.GroupShape.AdditionalElement: @unchecked Sendable {}
extension ShapeObject.CombinedObject: @unchecked Sendable {}
extension ShapeObject.CombinedObject.CombinedNode: @unchecked Sendable {}
extension ShapeObject.CombinedObject.CombinedNode.CombinedNodeType: @unchecked Sendable {}
extension ShapeObject.ParagraphShape: @unchecked Sendable {}
extension ShapeObject.FollowerOverrides: @unchecked Sendable {}
extension ShapeObject.FollowerOverrides.FollowerOverrideStatus: @unchecked Sendable {}
extension ShapeObject.FollowerOverrides.OverrideDetails: @unchecked Sendable {}
extension ShapeObject.FollowerOverrides.OverrideDetails.OverrideParam: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension ShapeObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShapeObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "shape"),
    3: .same(proto: "picture"),
    4: .same(proto: "connector"),
    5: .same(proto: "groupshape"),
    6: .same(proto: "graphicframe"),
    7: .same(proto: "paragraph"),
    8: .same(proto: "combinedobject"),
    9: .same(proto: "associatorId"),
  ]

  fileprivate class _StorageClass {
    var _type: ShapeNodeType? = nil
    var _shape: Shape? = nil
    var _picture: Picture? = nil
    var _connector: Connector? = nil
    var _groupshape: ShapeObject.GroupShape? = nil
    var _graphicframe: GraphicFrame? = nil
    var _paragraph: ShapeObject.ParagraphShape? = nil
    var _combinedobject: ShapeObject.CombinedObject? = nil
    var _associatorID: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _shape = source._shape
      _picture = source._picture
      _connector = source._connector
      _groupshape = source._groupshape
      _graphicframe = source._graphicframe
      _paragraph = source._paragraph
      _combinedobject = source._combinedobject
      _associatorID = source._associatorID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._shape, !v.isInitialized {return false}
      if let v = _storage._picture, !v.isInitialized {return false}
      if let v = _storage._connector, !v.isInitialized {return false}
      if let v = _storage._groupshape, !v.isInitialized {return false}
      if let v = _storage._graphicframe, !v.isInitialized {return false}
      if let v = _storage._paragraph, !v.isInitialized {return false}
      if let v = _storage._combinedobject, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._shape) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._picture) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connector) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._groupshape) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._graphicframe) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._paragraph) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._combinedobject) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._associatorID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._picture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._groupshape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._graphicframe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._paragraph {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._combinedobject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._associatorID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject, rhs: ShapeObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._shape != rhs_storage._shape {return false}
        if _storage._picture != rhs_storage._picture {return false}
        if _storage._connector != rhs_storage._connector {return false}
        if _storage._groupshape != rhs_storage._groupshape {return false}
        if _storage._graphicframe != rhs_storage._graphicframe {return false}
        if _storage._paragraph != rhs_storage._paragraph {return false}
        if _storage._combinedobject != rhs_storage._combinedobject {return false}
        if _storage._associatorID != rhs_storage._associatorID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.GroupShape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ShapeObject.protoMessageName + ".GroupShape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shapes"),
    2: .same(proto: "nvOProps"),
    3: .same(proto: "props"),
    4: .same(proto: "mask"),
    5: .same(proto: "category"),
    6: .same(proto: "modifiedFollowers"),
    7: .same(proto: "additionalFollowers"),
    8: .same(proto: "scroll"),
    9: .same(proto: "followerOverrides"),
  ]

  fileprivate class _StorageClass {
    var _shapes: [ShapeObject] = []
    var _nvOprops: NonVisualGroupShapeProps? = nil
    var _props: Properties? = nil
    var _mask: ShapeObject? = nil
    var _category: ElementCategory? = nil
    var _modifiedFollowers: [ModifiedFollower] = []
    var _additionalFollowers: ShapeObject.GroupShape.AdditionalElement? = nil
    var _scroll: Scroll? = nil
    var _followerOverrides: [ShapeObject.FollowerOverrides] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shapes = source._shapes
      _nvOprops = source._nvOprops
      _props = source._props
      _mask = source._mask
      _category = source._category
      _modifiedFollowers = source._modifiedFollowers
      _additionalFollowers = source._additionalFollowers
      _scroll = source._scroll
      _followerOverrides = source._followerOverrides
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._shapes) {return false}
      if let v = _storage._nvOprops, !v.isInitialized {return false}
      if let v = _storage._props, !v.isInitialized {return false}
      if let v = _storage._mask, !v.isInitialized {return false}
      if let v = _storage._category, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._modifiedFollowers) {return false}
      if let v = _storage._additionalFollowers, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._followerOverrides) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._shapes) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nvOprops) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._props) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._mask) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._category) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._modifiedFollowers) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._additionalFollowers) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scroll) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._followerOverrides) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._shapes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._shapes, fieldNumber: 1)
      }
      try { if let v = _storage._nvOprops {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._props {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._mask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._category {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._modifiedFollowers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modifiedFollowers, fieldNumber: 6)
      }
      try { if let v = _storage._additionalFollowers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scroll {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._followerOverrides.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._followerOverrides, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject.GroupShape, rhs: ShapeObject.GroupShape) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shapes != rhs_storage._shapes {return false}
        if _storage._nvOprops != rhs_storage._nvOprops {return false}
        if _storage._props != rhs_storage._props {return false}
        if _storage._mask != rhs_storage._mask {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._modifiedFollowers != rhs_storage._modifiedFollowers {return false}
        if _storage._additionalFollowers != rhs_storage._additionalFollowers {return false}
        if _storage._scroll != rhs_storage._scroll {return false}
        if _storage._followerOverrides != rhs_storage._followerOverrides {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.GroupShape.AdditionalElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ShapeObject.GroupShape.protoMessageName + ".AdditionalElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shapesOnTop"),
    2: .same(proto: "shapesBeneath"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.shapesOnTop) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.shapesBeneath) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shapesOnTop) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.shapesBeneath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shapesOnTop.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shapesOnTop, fieldNumber: 1)
    }
    if !self.shapesBeneath.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shapesBeneath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject.GroupShape.AdditionalElement, rhs: ShapeObject.GroupShape.AdditionalElement) -> Bool {
    if lhs.shapesOnTop != rhs.shapesOnTop {return false}
    if lhs.shapesBeneath != rhs.shapesBeneath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.CombinedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ShapeObject.protoMessageName + ".CombinedObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "combinedNodes"),
    2: .same(proto: "nvOProps"),
    3: .same(proto: "props"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.combinedNodes) {return false}
    if let v = self._nvOprops, !v.isInitialized {return false}
    if let v = self._props, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.combinedNodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nvOprops) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._props) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.combinedNodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.combinedNodes, fieldNumber: 1)
    }
    try { if let v = self._nvOprops {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._props {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject.CombinedObject, rhs: ShapeObject.CombinedObject) -> Bool {
    if lhs.combinedNodes != rhs.combinedNodes {return false}
    if lhs._nvOprops != rhs._nvOprops {return false}
    if lhs._props != rhs._props {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.CombinedObject.CombinedNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ShapeObject.CombinedObject.protoMessageName + ".CombinedNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "shape"),
    3: .same(proto: "combinedobject"),
    4: .same(proto: "rule"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if let v = self._shape, !v.isInitialized {return false}
    if let v = self._combinedobject, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shape) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._combinedobject) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._combinedobject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._rule {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject.CombinedObject.CombinedNode, rhs: ShapeObject.CombinedObject.CombinedNode) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs._combinedobject != rhs._combinedobject {return false}
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.CombinedObject.CombinedNode.CombinedNodeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SHAPE"),
    2: .same(proto: "COMBINEDOBJECT"),
  ]
}

extension ShapeObject.ParagraphShape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ShapeObject.protoMessageName + ".ParagraphShape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "para"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if let v = self._para, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._para) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._para {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject.ParagraphShape, rhs: ShapeObject.ParagraphShape) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._para != rhs._para {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.FollowerOverrides: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ShapeObject.protoMessageName + ".FollowerOverrides"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "child"),
    3: .same(proto: "status"),
    4: .same(proto: "overrides"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if let v = self._overrides, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.child) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._overrides) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.child.isEmpty {
      try visitor.visitRepeatedStringField(value: self.child, fieldNumber: 2)
    }
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._overrides {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject.FollowerOverrides, rhs: ShapeObject.FollowerOverrides) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.child != rhs.child {return false}
    if lhs._status != rhs._status {return false}
    if lhs._overrides != rhs._overrides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.FollowerOverrides.FollowerOverrideStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_FOLLOWER_OVERRIDE_STATUS"),
    1: .same(proto: "NO_OVERRIDE"),
    2: .same(proto: "OVERRIDDEN"),
    3: .same(proto: "REMOVED"),
  ]
}

extension ShapeObject.FollowerOverrides.OverrideDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ShapeObject.FollowerOverrides.protoMessageName + ".OverrideDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "object"),
    2: .same(proto: "updatedLeader"),
    3: .same(proto: "overrideParams"),
  ]

  public var isInitialized: Bool {
    if let v = self._object, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedLeader) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.overrideParams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedLeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.overrideParams.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.overrideParams, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShapeObject.FollowerOverrides.OverrideDetails, rhs: ShapeObject.FollowerOverrides.OverrideDetails) -> Bool {
    if lhs._object != rhs._object {return false}
    if lhs._updatedLeader != rhs._updatedLeader {return false}
    if lhs.overrideParams != rhs.overrideParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShapeObject.FollowerOverrides.OverrideDetails.OverrideParam: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "TRANSFORM"),
    2: .same(proto: "FILLS"),
    3: .same(proto: "STROKES"),
    4: .same(proto: "STYLE_REF"),
    5: .same(proto: "EFFECTS"),
    6: .same(proto: "ALPHA"),
    7: .same(proto: "BLUR"),
    8: .same(proto: "NON_VISUAL_OBJECT_DRAWING_PROPS"),
    9: .same(proto: "PICTURE_PROPS"),
    10: .same(proto: "PICTURE_VALUE"),
    11: .same(proto: "CROP"),
    12: .same(proto: "TEXT_CONTENT"),
    13: .same(proto: "TEXT_STYLE"),
  ]
}
