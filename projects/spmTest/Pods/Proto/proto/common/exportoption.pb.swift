// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exportoption.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ExportOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scale: ExportOption.ExportScale {
    get {return _scale ?? ExportOption.ExportScale()}
    set {_scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  public var hasScale: Bool {return self._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  public mutating func clearScale() {self._scale = nil}

  public var fileOptions: ExportOption.ExportFileOptions {
    get {return _fileOptions ?? ExportOption.ExportFileOptions()}
    set {_fileOptions = newValue}
  }
  /// Returns true if `fileOptions` has been explicitly set.
  public var hasFileOptions: Bool {return self._fileOptions != nil}
  /// Clears the value of `fileOptions`. Subsequent reads from it will return its default value.
  public mutating func clearFileOptions() {self._fileOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ExportScale {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: ExportOption.ExportScale.ExportScaleType {
      get {return _type ?? .unknownScaleType}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var value: ExportOption.ExportScale.ExportScaleValue {
      get {return _value ?? ExportOption.ExportScale.ExportScaleValue()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ExportScaleType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownScaleType // = 0
      case onTheWhole // = 1
      case widthBased // = 2
      case heightBased // = 3

      public init() {
        self = .unknownScaleType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownScaleType
        case 1: self = .onTheWhole
        case 2: self = .widthBased
        case 3: self = .heightBased
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownScaleType: return 0
        case .onTheWhole: return 1
        case .widthBased: return 2
        case .heightBased: return 3
        }
      }

    }

    public struct ExportScaleValue {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: ExportOption.ExportScale.ExportScaleValue.ExportScaleValueType {
        get {return _type ?? .unknonwnExportscalevalueType}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      /// For values like 0.5x, 2x , 3x etc..
      public var factor: Float {
        get {return _factor ?? 0}
        set {_factor = newValue}
      }
      /// Returns true if `factor` has been explicitly set.
      public var hasFactor: Bool {return self._factor != nil}
      /// Clears the value of `factor`. Subsequent reads from it will return its default value.
      public mutating func clearFactor() {self._factor = nil}

      /// For absolute pixel values , mainly used for height or width based scale type.
      public var absolute: Float {
        get {return _absolute ?? 0}
        set {_absolute = newValue}
      }
      /// Returns true if `absolute` has been explicitly set.
      public var hasAbsolute: Bool {return self._absolute != nil}
      /// Clears the value of `absolute`. Subsequent reads from it will return its default value.
      public mutating func clearAbsolute() {self._absolute = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum ExportScaleValueType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknonwnExportscalevalueType // = 0
        case factor // = 1
        case absolute // = 2

        public init() {
          self = .unknonwnExportscalevalueType
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknonwnExportscalevalueType
          case 1: self = .factor
          case 2: self = .absolute
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknonwnExportscalevalueType: return 0
          case .factor: return 1
          case .absolute: return 2
          }
        }

      }

      public init() {}

      fileprivate var _type: ExportOption.ExportScale.ExportScaleValue.ExportScaleValueType? = nil
      fileprivate var _factor: Float? = nil
      fileprivate var _absolute: Float? = nil
    }

    public init() {}

    fileprivate var _type: ExportOption.ExportScale.ExportScaleType? = nil
    fileprivate var _value: ExportOption.ExportScale.ExportScaleValue? = nil
  }

  public struct ExportFileOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var affix: ExportOption.ExportFileOptions.Affix {
      get {return _affix ?? ExportOption.ExportFileOptions.Affix()}
      set {_affix = newValue}
    }
    /// Returns true if `affix` has been explicitly set.
    public var hasAffix: Bool {return self._affix != nil}
    /// Clears the value of `affix`. Subsequent reads from it will return its default value.
    public mutating func clearAffix() {self._affix = nil}

    public var format: ExportOption.ExportFileOptions.FileFormat {
      get {return _format ?? ExportOption.ExportFileOptions.FileFormat()}
      set {_format = newValue}
    }
    /// Returns true if `format` has been explicitly set.
    public var hasFormat: Bool {return self._format != nil}
    /// Clears the value of `format`. Subsequent reads from it will return its default value.
    public mutating func clearFormat() {self._format = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Affix {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: ExportOption.ExportFileOptions.Affix.AffixType {
        get {return _type ?? .unknownAffix}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var prefix: String {
        get {return _prefix ?? String()}
        set {_prefix = newValue}
      }
      /// Returns true if `prefix` has been explicitly set.
      public var hasPrefix: Bool {return self._prefix != nil}
      /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
      public mutating func clearPrefix() {self._prefix = nil}

      public var suffix: String {
        get {return _suffix ?? String()}
        set {_suffix = newValue}
      }
      /// Returns true if `suffix` has been explicitly set.
      public var hasSuffix: Bool {return self._suffix != nil}
      /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
      public mutating func clearSuffix() {self._suffix = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum AffixType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknownAffix // = 0
        case prefix // = 1
        case suffix // = 2
        case both // = 3

        public init() {
          self = .unknownAffix
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownAffix
          case 1: self = .prefix
          case 2: self = .suffix
          case 3: self = .both
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknownAffix: return 0
          case .prefix: return 1
          case .suffix: return 2
          case .both: return 3
          }
        }

      }

      public init() {}

      fileprivate var _type: ExportOption.ExportFileOptions.Affix.AffixType? = nil
      fileprivate var _prefix: String? = nil
      fileprivate var _suffix: String? = nil
    }

    public struct FileFormat {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: ExportOption.ExportFileOptions.FileFormat.FileFormatType {
        get {return _type ?? .unknownFileFormat}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var pictureFormat: PictureType {
        get {return _pictureFormat ?? .unknownPict}
        set {_pictureFormat = newValue}
      }
      /// Returns true if `pictureFormat` has been explicitly set.
      public var hasPictureFormat: Bool {return self._pictureFormat != nil}
      /// Clears the value of `pictureFormat`. Subsequent reads from it will return its default value.
      public mutating func clearPictureFormat() {self._pictureFormat = nil}

      public var documentFormat: ExportOption.ExportFileOptions.FileFormat.DocumentFormatType {
        get {return _documentFormat ?? .unknownDocumentFormat}
        set {_documentFormat = newValue}
      }
      /// Returns true if `documentFormat` has been explicitly set.
      public var hasDocumentFormat: Bool {return self._documentFormat != nil}
      /// Clears the value of `documentFormat`. Subsequent reads from it will return its default value.
      public mutating func clearDocumentFormat() {self._documentFormat = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum FileFormatType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknownFileFormat // = 0
        case pictureFormat // = 1
        case documentFormat // = 2

        public init() {
          self = .unknownFileFormat
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownFileFormat
          case 1: self = .pictureFormat
          case 2: self = .documentFormat
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknownFileFormat: return 0
          case .pictureFormat: return 1
          case .documentFormat: return 2
          }
        }

      }

      public enum DocumentFormatType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknownDocumentFormat // = 0
        case pdf // = 1
        case html // = 2
        case docx // = 3
        case pptx // = 4

        public init() {
          self = .unknownDocumentFormat
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownDocumentFormat
          case 1: self = .pdf
          case 2: self = .html
          case 3: self = .docx
          case 4: self = .pptx
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknownDocumentFormat: return 0
          case .pdf: return 1
          case .html: return 2
          case .docx: return 3
          case .pptx: return 4
          }
        }

      }

      public init() {}

      fileprivate var _type: ExportOption.ExportFileOptions.FileFormat.FileFormatType? = nil
      fileprivate var _pictureFormat: PictureType? = nil
      fileprivate var _documentFormat: ExportOption.ExportFileOptions.FileFormat.DocumentFormatType? = nil
    }

    public init() {}

    fileprivate var _affix: ExportOption.ExportFileOptions.Affix? = nil
    fileprivate var _format: ExportOption.ExportFileOptions.FileFormat? = nil
  }

  public init() {}

  fileprivate var _scale: ExportOption.ExportScale? = nil
  fileprivate var _fileOptions: ExportOption.ExportFileOptions? = nil
}

#if swift(>=4.2)

extension ExportOption.ExportScale.ExportScaleType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ExportOption.ExportScale.ExportScaleValue.ExportScaleValueType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ExportOption.ExportFileOptions.Affix.AffixType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ExportOption.ExportFileOptions.FileFormat.FileFormatType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ExportOption.ExportFileOptions.FileFormat.DocumentFormatType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension ExportOption: @unchecked Sendable {}
extension ExportOption.ExportScale: @unchecked Sendable {}
extension ExportOption.ExportScale.ExportScaleType: @unchecked Sendable {}
extension ExportOption.ExportScale.ExportScaleValue: @unchecked Sendable {}
extension ExportOption.ExportScale.ExportScaleValue.ExportScaleValueType: @unchecked Sendable {}
extension ExportOption.ExportFileOptions: @unchecked Sendable {}
extension ExportOption.ExportFileOptions.Affix: @unchecked Sendable {}
extension ExportOption.ExportFileOptions.Affix.AffixType: @unchecked Sendable {}
extension ExportOption.ExportFileOptions.FileFormat: @unchecked Sendable {}
extension ExportOption.ExportFileOptions.FileFormat.FileFormatType: @unchecked Sendable {}
extension ExportOption.ExportFileOptions.FileFormat.DocumentFormatType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.common"

extension ExportOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
    2: .same(proto: "fileOptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scale) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fileOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExportOption, rhs: ExportOption) -> Bool {
    if lhs._scale != rhs._scale {return false}
    if lhs._fileOptions != rhs._fileOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExportOption.ExportScale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ExportOption.protoMessageName + ".ExportScale"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExportOption.ExportScale, rhs: ExportOption.ExportScale) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExportOption.ExportScale.ExportScaleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SCALE_TYPE"),
    1: .same(proto: "ON_THE_WHOLE"),
    2: .same(proto: "WIDTH_BASED"),
    3: .same(proto: "HEIGHT_BASED"),
  ]
}

extension ExportOption.ExportScale.ExportScaleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ExportOption.ExportScale.protoMessageName + ".ExportScaleValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "factor"),
    3: .same(proto: "absolute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._factor) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._absolute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._factor {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._absolute {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExportOption.ExportScale.ExportScaleValue, rhs: ExportOption.ExportScale.ExportScaleValue) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._factor != rhs._factor {return false}
    if lhs._absolute != rhs._absolute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExportOption.ExportScale.ExportScaleValue.ExportScaleValueType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNONWN_EXPORTSCALEVALUE_TYPE"),
    1: .same(proto: "FACTOR"),
    2: .same(proto: "ABSOLUTE"),
  ]
}

extension ExportOption.ExportFileOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ExportOption.protoMessageName + ".ExportFileOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "affix"),
    2: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._affix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._affix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExportOption.ExportFileOptions, rhs: ExportOption.ExportFileOptions) -> Bool {
    if lhs._affix != rhs._affix {return false}
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExportOption.ExportFileOptions.Affix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ExportOption.ExportFileOptions.protoMessageName + ".Affix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "prefix"),
    3: .same(proto: "suffix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExportOption.ExportFileOptions.Affix, rhs: ExportOption.ExportFileOptions.Affix) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExportOption.ExportFileOptions.Affix.AffixType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_AFFIX"),
    1: .same(proto: "PREFIX"),
    2: .same(proto: "SUFFIX"),
    3: .same(proto: "BOTH"),
  ]
}

extension ExportOption.ExportFileOptions.FileFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ExportOption.ExportFileOptions.protoMessageName + ".FileFormat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "pictureFormat"),
    3: .same(proto: "documentFormat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._pictureFormat) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._documentFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pictureFormat {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._documentFormat {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExportOption.ExportFileOptions.FileFormat, rhs: ExportOption.ExportFileOptions.FileFormat) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._pictureFormat != rhs._pictureFormat {return false}
    if lhs._documentFormat != rhs._documentFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExportOption.ExportFileOptions.FileFormat.FileFormatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_FILE_FORMAT"),
    1: .same(proto: "PICTURE_FORMAT"),
    2: .same(proto: "DOCUMENT_FORMAT"),
  ]
}

extension ExportOption.ExportFileOptions.FileFormat.DocumentFormatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DOCUMENT_FORMAT"),
    1: .same(proto: "PDF"),
    2: .same(proto: "HTML"),
    3: .same(proto: "DOCX"),
    4: .same(proto: "PPTX"),
  ]
}
