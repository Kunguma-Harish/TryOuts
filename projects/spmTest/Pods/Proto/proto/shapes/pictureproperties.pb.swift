// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pictureproperties.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PictureProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var luminance: PictureProperties.Luminance {
    get {return _luminance ?? PictureProperties.Luminance()}
    set {_luminance = newValue}
  }
  /// Returns true if `luminance` has been explicitly set.
  public var hasLuminance: Bool {return self._luminance != nil}
  /// Clears the value of `luminance`. Subsequent reads from it will return its default value.
  public mutating func clearLuminance() {self._luminance = nil}

  public var colorMode: PictureProperties.ColorMode {
    get {return _colorMode ?? PictureProperties.ColorMode()}
    set {_colorMode = newValue}
  }
  /// Returns true if `colorMode` has been explicitly set.
  public var hasColorMode: Bool {return self._colorMode != nil}
  /// Clears the value of `colorMode`. Subsequent reads from it will return its default value.
  public mutating func clearColorMode() {self._colorMode = nil}

  /// To Change one color in a picture to another color.	
  public var colorChange: PictureProperties.ColorChange {
    get {return _colorChange ?? PictureProperties.ColorChange()}
    set {_colorChange = newValue}
  }
  /// Returns true if `colorChange` has been explicitly set.
  public var hasColorChange: Bool {return self._colorChange != nil}
  /// Clears the value of `colorChange`. Subsequent reads from it will return its default value.
  public mutating func clearColorChange() {self._colorChange = nil}

  /// Preset Color Properties.
  public var preset: PresetProps {
    get {return _preset ?? .defPresetProps}
    set {_preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  public var hasPreset: Bool {return self._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  public mutating func clearPreset() {self._preset = nil}

  /// transparency ranges from 0-1 , 0 indicates none(opaque) , 1 indicates fully transparent.
  public var alpha: Float {
    get {return _alpha ?? 0}
    set {_alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  public var hasAlpha: Bool {return self._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  public mutating func clearAlpha() {self._alpha = nil}

  public var rotate: Int32 {
    get {return _rotate ?? 0}
    set {_rotate = newValue}
  }
  /// Returns true if `rotate` has been explicitly set.
  public var hasRotate: Bool {return self._rotate != nil}
  /// Clears the value of `rotate`. Subsequent reads from it will return its default value.
  public mutating func clearRotate() {self._rotate = nil}

  /// true , if flipped in horizontal axis.
  public var fliph: Bool {
    get {return _fliph ?? false}
    set {_fliph = newValue}
  }
  /// Returns true if `fliph` has been explicitly set.
  public var hasFliph: Bool {return self._fliph != nil}
  /// Clears the value of `fliph`. Subsequent reads from it will return its default value.
  public mutating func clearFliph() {self._fliph = nil}

  /// true , if flipped in vertical axis.
  public var flipv: Bool {
    get {return _flipv ?? false}
    set {_flipv = newValue}
  }
  /// Returns true if `flipv` has been explicitly set.
  public var hasFlipv: Bool {return self._flipv != nil}
  /// Clears the value of `flipv`. Subsequent reads from it will return its default value.
  public mutating func clearFlipv() {self._flipv = nil}

  /// Change Hue , Saturation and luminance of the object.
  public var hsl: HSLTweak {
    get {return _hsl ?? HSLTweak()}
    set {_hsl = newValue}
  }
  /// Returns true if `hsl` has been explicitly set.
  public var hasHsl: Bool {return self._hsl != nil}
  /// Clears the value of `hsl`. Subsequent reads from it will return its default value.
  public mutating func clearHsl() {self._hsl = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Luminance {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ranges from -1 to 1.	
    public var brightness: Float {
      get {return _brightness ?? 0}
      set {_brightness = newValue}
    }
    /// Returns true if `brightness` has been explicitly set.
    public var hasBrightness: Bool {return self._brightness != nil}
    /// Clears the value of `brightness`. Subsequent reads from it will return its default value.
    public mutating func clearBrightness() {self._brightness = nil}

    /// ranges from -1 to 1.	
    public var contrast: Float {
      get {return _contrast ?? 0}
      set {_contrast = newValue}
    }
    /// Returns true if `contrast` has been explicitly set.
    public var hasContrast: Bool {return self._contrast != nil}
    /// Clears the value of `contrast`. Subsequent reads from it will return its default value.
    public mutating func clearContrast() {self._contrast = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _brightness: Float? = nil
    fileprivate var _contrast: Float? = nil
  }

  public struct ColorMode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Color Mode applied to the picture.
    public var mode: PictureProperties.ColorMode.Mode {
      get {return _mode ?? .none}
      set {_mode = newValue}
    }
    /// Returns true if `mode` has been explicitly set.
    public var hasMode: Bool {return self._mode != nil}
    /// Clears the value of `mode`. Subsequent reads from it will return its default value.
    public mutating func clearMode() {self._mode = nil}

    /// Array of colors using which the picture will be recolored , as of now only duotone recoloring is supported i.e. two colors in the array. 
    public var duotone: [Color] = []

    /// Threshold value for bilevel, ranges from 0-1.
    public var bilevel: Float {
      get {return _bilevel ?? 0}
      set {_bilevel = newValue}
    }
    /// Returns true if `bilevel` has been explicitly set.
    public var hasBilevel: Bool {return self._bilevel != nil}
    /// Clears the value of `bilevel`. Subsequent reads from it will return its default value.
    public mutating func clearBilevel() {self._bilevel = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Mode: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// No Recolor
      case none // = 0

      /// turned into GrayScale.
      case grayscale // = 1

      /// turned into BlackAndWhite Image.
      case bilevel // = 2

      /// Sepia Mode
      case sepia // = 3

      /// Apply Duotone filter.
      case duotone // = 4

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .grayscale
        case 2: self = .bilevel
        case 3: self = .sepia
        case 4: self = .duotone
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .grayscale: return 1
        case .bilevel: return 2
        case .sepia: return 3
        case .duotone: return 4
        }
      }

    }

    public init() {}

    fileprivate var _mode: PictureProperties.ColorMode.Mode? = nil
    fileprivate var _bilevel: Float? = nil
  }

  /// Mainly used to make a color transparent.
  public struct ColorChange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var from: Color {
      get {return _storage._from ?? Color()}
      set {_uniqueStorage()._from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    public var hasFrom: Bool {return _storage._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    public mutating func clearFrom() {_uniqueStorage()._from = nil}

    public var to: Color {
      get {return _storage._to ?? Color()}
      set {_uniqueStorage()._to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    public var hasTo: Bool {return _storage._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    public mutating func clearTo() {_uniqueStorage()._to = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _luminance: PictureProperties.Luminance? = nil
  fileprivate var _colorMode: PictureProperties.ColorMode? = nil
  fileprivate var _colorChange: PictureProperties.ColorChange? = nil
  fileprivate var _preset: PresetProps? = nil
  fileprivate var _alpha: Float? = nil
  fileprivate var _rotate: Int32? = nil
  fileprivate var _fliph: Bool? = nil
  fileprivate var _flipv: Bool? = nil
  fileprivate var _hsl: HSLTweak? = nil
}

#if swift(>=4.2)

extension PictureProperties.ColorMode.Mode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension PictureProperties: @unchecked Sendable {}
extension PictureProperties.Luminance: @unchecked Sendable {}
extension PictureProperties.ColorMode: @unchecked Sendable {}
extension PictureProperties.ColorMode.Mode: @unchecked Sendable {}
extension PictureProperties.ColorChange: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension PictureProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "luminance"),
    2: .same(proto: "colorMode"),
    3: .same(proto: "colorChange"),
    4: .same(proto: "preset"),
    5: .same(proto: "alpha"),
    6: .same(proto: "rotate"),
    7: .same(proto: "fliph"),
    8: .same(proto: "flipv"),
    9: .same(proto: "hsl"),
  ]

  public var isInitialized: Bool {
    if let v = self._colorMode, !v.isInitialized {return false}
    if let v = self._colorChange, !v.isInitialized {return false}
    if let v = self._hsl, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._luminance) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._colorMode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._colorChange) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._preset) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._alpha) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._rotate) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._fliph) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._flipv) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._hsl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._luminance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._colorMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._colorChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._preset {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._alpha {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._rotate {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._fliph {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._flipv {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._hsl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureProperties, rhs: PictureProperties) -> Bool {
    if lhs._luminance != rhs._luminance {return false}
    if lhs._colorMode != rhs._colorMode {return false}
    if lhs._colorChange != rhs._colorChange {return false}
    if lhs._preset != rhs._preset {return false}
    if lhs._alpha != rhs._alpha {return false}
    if lhs._rotate != rhs._rotate {return false}
    if lhs._fliph != rhs._fliph {return false}
    if lhs._flipv != rhs._flipv {return false}
    if lhs._hsl != rhs._hsl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureProperties.Luminance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PictureProperties.protoMessageName + ".Luminance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brightness"),
    2: .same(proto: "contrast"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._brightness) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._contrast) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._brightness {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contrast {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureProperties.Luminance, rhs: PictureProperties.Luminance) -> Bool {
    if lhs._brightness != rhs._brightness {return false}
    if lhs._contrast != rhs._contrast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureProperties.ColorMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PictureProperties.protoMessageName + ".ColorMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "duotone"),
    3: .same(proto: "bilevel"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.duotone) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.duotone) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._bilevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.duotone.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.duotone, fieldNumber: 2)
    }
    try { if let v = self._bilevel {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureProperties.ColorMode, rhs: PictureProperties.ColorMode) -> Bool {
    if lhs._mode != rhs._mode {return false}
    if lhs.duotone != rhs.duotone {return false}
    if lhs._bilevel != rhs._bilevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureProperties.ColorMode.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "GRAYSCALE"),
    2: .same(proto: "BILEVEL"),
    3: .same(proto: "SEPIA"),
    4: .same(proto: "DUOTONE"),
  ]
}

extension PictureProperties.ColorChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PictureProperties.protoMessageName + ".ColorChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  fileprivate class _StorageClass {
    var _from: Color? = nil
    var _to: Color? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _from = source._from
      _to = source._to
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._from == nil {return false}
      if _storage._to == nil {return false}
      if let v = _storage._from, !v.isInitialized {return false}
      if let v = _storage._to, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._from) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._to) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureProperties.ColorChange, rhs: PictureProperties.ColorChange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
