// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: uielement.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_uielement_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_uielement_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "userfield.pb.h"
#include "dimension.pb.h"
#include "picturevalue.pb.h"
#include "time.pb.h"
#include "color.pb.h"
#include "colortweaks.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_uielement_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_uielement_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_uielement_2eproto;
namespace com {
namespace zoho {
namespace shapes {
class UIElement;
struct UIElementDefaultTypeInternal;
extern UIElementDefaultTypeInternal _UIElement_default_instance_;
class UIElement_ButtonElement;
struct UIElement_ButtonElementDefaultTypeInternal;
extern UIElement_ButtonElementDefaultTypeInternal _UIElement_ButtonElement_default_instance_;
class UIElement_CalendarElement;
struct UIElement_CalendarElementDefaultTypeInternal;
extern UIElement_CalendarElementDefaultTypeInternal _UIElement_CalendarElement_default_instance_;
class UIElement_CalendarElement_CalendarInput;
struct UIElement_CalendarElement_CalendarInputDefaultTypeInternal;
extern UIElement_CalendarElement_CalendarInputDefaultTypeInternal _UIElement_CalendarElement_CalendarInput_default_instance_;
class UIElement_LabelElement;
struct UIElement_LabelElementDefaultTypeInternal;
extern UIElement_LabelElementDefaultTypeInternal _UIElement_LabelElement_default_instance_;
class UIElement_LabelElement_BGLabel;
struct UIElement_LabelElement_BGLabelDefaultTypeInternal;
extern UIElement_LabelElement_BGLabelDefaultTypeInternal _UIElement_LabelElement_BGLabel_default_instance_;
class UIElement_LabelElement_StatusLabel;
struct UIElement_LabelElement_StatusLabelDefaultTypeInternal;
extern UIElement_LabelElement_StatusLabelDefaultTypeInternal _UIElement_LabelElement_StatusLabel_default_instance_;
class UIElement_LabelElement_StatusLabel_StatusSymbol;
struct UIElement_LabelElement_StatusLabel_StatusSymbolDefaultTypeInternal;
extern UIElement_LabelElement_StatusLabel_StatusSymbolDefaultTypeInternal _UIElement_LabelElement_StatusLabel_StatusSymbol_default_instance_;
class UIElement_ListInput;
struct UIElement_ListInputDefaultTypeInternal;
extern UIElement_ListInputDefaultTypeInternal _UIElement_ListInput_default_instance_;
class UIElement_ListInput_ImageList;
struct UIElement_ListInput_ImageListDefaultTypeInternal;
extern UIElement_ListInput_ImageListDefaultTypeInternal _UIElement_ListInput_ImageList_default_instance_;
class UIElement_ListInput_TextImageList;
struct UIElement_ListInput_TextImageListDefaultTypeInternal;
extern UIElement_ListInput_TextImageListDefaultTypeInternal _UIElement_ListInput_TextImageList_default_instance_;
class UIElement_ListInput_TextImageList_TextImageListItem;
struct UIElement_ListInput_TextImageList_TextImageListItemDefaultTypeInternal;
extern UIElement_ListInput_TextImageList_TextImageListItemDefaultTypeInternal _UIElement_ListInput_TextImageList_TextImageListItem_default_instance_;
class UIElement_ListInput_TextList;
struct UIElement_ListInput_TextListDefaultTypeInternal;
extern UIElement_ListInput_TextListDefaultTypeInternal _UIElement_ListInput_TextList_default_instance_;
class UIElement_ListSelection;
struct UIElement_ListSelectionDefaultTypeInternal;
extern UIElement_ListSelectionDefaultTypeInternal _UIElement_ListSelection_default_instance_;
class UIElement_ListSelection_MultipleSelection;
struct UIElement_ListSelection_MultipleSelectionDefaultTypeInternal;
extern UIElement_ListSelection_MultipleSelectionDefaultTypeInternal _UIElement_ListSelection_MultipleSelection_default_instance_;
class UIElement_ListSelection_SingleSelection;
struct UIElement_ListSelection_SingleSelectionDefaultTypeInternal;
extern UIElement_ListSelection_SingleSelectionDefaultTypeInternal _UIElement_ListSelection_SingleSelection_default_instance_;
class UIElement_RatingElement;
struct UIElement_RatingElementDefaultTypeInternal;
extern UIElement_RatingElementDefaultTypeInternal _UIElement_RatingElement_default_instance_;
class UIElement_RatingElement_RatingInput;
struct UIElement_RatingElement_RatingInputDefaultTypeInternal;
extern UIElement_RatingElement_RatingInputDefaultTypeInternal _UIElement_RatingElement_RatingInput_default_instance_;
class UIElement_SelectionElement;
struct UIElement_SelectionElementDefaultTypeInternal;
extern UIElement_SelectionElementDefaultTypeInternal _UIElement_SelectionElement_default_instance_;
class UIElement_SliderElement;
struct UIElement_SliderElementDefaultTypeInternal;
extern UIElement_SliderElementDefaultTypeInternal _UIElement_SliderElement_default_instance_;
class UIElement_SliderElement_SliderInput;
struct UIElement_SliderElement_SliderInputDefaultTypeInternal;
extern UIElement_SliderElement_SliderInputDefaultTypeInternal _UIElement_SliderElement_SliderInput_default_instance_;
class UIElement_SliderElement_SliderInput_SliderInterval;
struct UIElement_SliderElement_SliderInput_SliderIntervalDefaultTypeInternal;
extern UIElement_SliderElement_SliderInput_SliderIntervalDefaultTypeInternal _UIElement_SliderElement_SliderInput_SliderInterval_default_instance_;
class UIElement_StepperElement;
struct UIElement_StepperElementDefaultTypeInternal;
extern UIElement_StepperElementDefaultTypeInternal _UIElement_StepperElement_default_instance_;
class UIElement_StepperElement_StepperInput;
struct UIElement_StepperElement_StepperInputDefaultTypeInternal;
extern UIElement_StepperElement_StepperInputDefaultTypeInternal _UIElement_StepperElement_StepperInput_default_instance_;
class UIElement_ToggleElement;
struct UIElement_ToggleElementDefaultTypeInternal;
extern UIElement_ToggleElementDefaultTypeInternal _UIElement_ToggleElement_default_instance_;
class UIElement_ToggleElement_ToggleInput;
struct UIElement_ToggleElement_ToggleInputDefaultTypeInternal;
extern UIElement_ToggleElement_ToggleInputDefaultTypeInternal _UIElement_ToggleElement_ToggleInput_default_instance_;
class UIElement_ToggleElement_ToggleInput_DataForState;
struct UIElement_ToggleElement_ToggleInput_DataForStateDefaultTypeInternal;
extern UIElement_ToggleElement_ToggleInput_DataForStateDefaultTypeInternal _UIElement_ToggleElement_ToggleInput_DataForState_default_instance_;
class UIElement_UserElement;
struct UIElement_UserElementDefaultTypeInternal;
extern UIElement_UserElementDefaultTypeInternal _UIElement_UserElement_default_instance_;
class UIElement_UserElement_ProfilePicture;
struct UIElement_UserElement_ProfilePictureDefaultTypeInternal;
extern UIElement_UserElement_ProfilePictureDefaultTypeInternal _UIElement_UserElement_ProfilePicture_default_instance_;
class UIElement_UserElement_UserElementInput;
struct UIElement_UserElement_UserElementInputDefaultTypeInternal;
extern UIElement_UserElement_UserElementInputDefaultTypeInternal _UIElement_UserElement_UserElementInput_default_instance_;
}  // namespace shapes
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace shapes {
enum UIElement_UserElement_ProfilePicture_ProfilePictureType : int {
  UIElement_UserElement_ProfilePicture_ProfilePictureType_UNKNOWN = 0,
  UIElement_UserElement_ProfilePicture_ProfilePictureType_ELLIPTICAL = 1,
  UIElement_UserElement_ProfilePicture_ProfilePictureType_RECTANGLE = 2,
  UIElement_UserElement_ProfilePicture_ProfilePictureType_UIElement_UserElement_ProfilePicture_ProfilePictureType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_UserElement_ProfilePicture_ProfilePictureType_UIElement_UserElement_ProfilePicture_ProfilePictureType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_UserElement_ProfilePicture_ProfilePictureType_IsValid(int value);
extern const uint32_t UIElement_UserElement_ProfilePicture_ProfilePictureType_internal_data_[];
constexpr UIElement_UserElement_ProfilePicture_ProfilePictureType UIElement_UserElement_ProfilePicture_ProfilePictureType_ProfilePictureType_MIN = static_cast<UIElement_UserElement_ProfilePicture_ProfilePictureType>(0);
constexpr UIElement_UserElement_ProfilePicture_ProfilePictureType UIElement_UserElement_ProfilePicture_ProfilePictureType_ProfilePictureType_MAX = static_cast<UIElement_UserElement_ProfilePicture_ProfilePictureType>(2);
constexpr int UIElement_UserElement_ProfilePicture_ProfilePictureType_ProfilePictureType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_UserElement_ProfilePicture_ProfilePictureType_descriptor();
template <typename T>
const std::string& UIElement_UserElement_ProfilePicture_ProfilePictureType_Name(T value) {
  static_assert(std::is_same<T, UIElement_UserElement_ProfilePicture_ProfilePictureType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProfilePictureType_Name().");
  return UIElement_UserElement_ProfilePicture_ProfilePictureType_Name(static_cast<UIElement_UserElement_ProfilePicture_ProfilePictureType>(value));
}
template <>
inline const std::string& UIElement_UserElement_ProfilePicture_ProfilePictureType_Name(UIElement_UserElement_ProfilePicture_ProfilePictureType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_UserElement_ProfilePicture_ProfilePictureType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_UserElement_ProfilePicture_ProfilePictureType_Parse(absl::string_view name, UIElement_UserElement_ProfilePicture_ProfilePictureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_UserElement_ProfilePicture_ProfilePictureType>(
      UIElement_UserElement_ProfilePicture_ProfilePictureType_descriptor(), name, value);
}
enum UIElement_UserElement_UserElementType : int {
  UIElement_UserElement_UserElementType_UNKNOWN = 0,
  UIElement_UserElement_UserElementType_PROFILE_PICTURE = 1,
  UIElement_UserElement_UserElementType_UIElement_UserElement_UserElementType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_UserElement_UserElementType_UIElement_UserElement_UserElementType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_UserElement_UserElementType_IsValid(int value);
extern const uint32_t UIElement_UserElement_UserElementType_internal_data_[];
constexpr UIElement_UserElement_UserElementType UIElement_UserElement_UserElementType_UserElementType_MIN = static_cast<UIElement_UserElement_UserElementType>(0);
constexpr UIElement_UserElement_UserElementType UIElement_UserElement_UserElementType_UserElementType_MAX = static_cast<UIElement_UserElement_UserElementType>(1);
constexpr int UIElement_UserElement_UserElementType_UserElementType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_UserElement_UserElementType_descriptor();
template <typename T>
const std::string& UIElement_UserElement_UserElementType_Name(T value) {
  static_assert(std::is_same<T, UIElement_UserElement_UserElementType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UserElementType_Name().");
  return UIElement_UserElement_UserElementType_Name(static_cast<UIElement_UserElement_UserElementType>(value));
}
template <>
inline const std::string& UIElement_UserElement_UserElementType_Name(UIElement_UserElement_UserElementType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_UserElement_UserElementType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool UIElement_UserElement_UserElementType_Parse(absl::string_view name, UIElement_UserElement_UserElementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_UserElement_UserElementType>(
      UIElement_UserElement_UserElementType_descriptor(), name, value);
}
enum UIElement_ListInput_ListInputType : int {
  UIElement_ListInput_ListInputType_DEFAULT_COMBO_INPUT_TYPE = 0,
  UIElement_ListInput_ListInputType_TEXT = 1,
  UIElement_ListInput_ListInputType_IMAGE = 2,
  UIElement_ListInput_ListInputType_TEXT_IMAGE = 3,
  UIElement_ListInput_ListInputType_UIElement_ListInput_ListInputType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_ListInput_ListInputType_UIElement_ListInput_ListInputType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_ListInput_ListInputType_IsValid(int value);
extern const uint32_t UIElement_ListInput_ListInputType_internal_data_[];
constexpr UIElement_ListInput_ListInputType UIElement_ListInput_ListInputType_ListInputType_MIN = static_cast<UIElement_ListInput_ListInputType>(0);
constexpr UIElement_ListInput_ListInputType UIElement_ListInput_ListInputType_ListInputType_MAX = static_cast<UIElement_ListInput_ListInputType>(3);
constexpr int UIElement_ListInput_ListInputType_ListInputType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_ListInput_ListInputType_descriptor();
template <typename T>
const std::string& UIElement_ListInput_ListInputType_Name(T value) {
  static_assert(std::is_same<T, UIElement_ListInput_ListInputType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ListInputType_Name().");
  return UIElement_ListInput_ListInputType_Name(static_cast<UIElement_ListInput_ListInputType>(value));
}
template <>
inline const std::string& UIElement_ListInput_ListInputType_Name(UIElement_ListInput_ListInputType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_ListInput_ListInputType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UIElement_ListInput_ListInputType_Parse(absl::string_view name, UIElement_ListInput_ListInputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_ListInput_ListInputType>(
      UIElement_ListInput_ListInputType_descriptor(), name, value);
}
enum UIElement_ListSelection_SelectionFunction : int {
  UIElement_ListSelection_SelectionFunction_DEFAULT_FUNCTION = 0,
  UIElement_ListSelection_SelectionFunction_SINGLE = 1,
  UIElement_ListSelection_SelectionFunction_MULTIPLE = 2,
  UIElement_ListSelection_SelectionFunction_UIElement_ListSelection_SelectionFunction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_ListSelection_SelectionFunction_UIElement_ListSelection_SelectionFunction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_ListSelection_SelectionFunction_IsValid(int value);
extern const uint32_t UIElement_ListSelection_SelectionFunction_internal_data_[];
constexpr UIElement_ListSelection_SelectionFunction UIElement_ListSelection_SelectionFunction_SelectionFunction_MIN = static_cast<UIElement_ListSelection_SelectionFunction>(0);
constexpr UIElement_ListSelection_SelectionFunction UIElement_ListSelection_SelectionFunction_SelectionFunction_MAX = static_cast<UIElement_ListSelection_SelectionFunction>(2);
constexpr int UIElement_ListSelection_SelectionFunction_SelectionFunction_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_ListSelection_SelectionFunction_descriptor();
template <typename T>
const std::string& UIElement_ListSelection_SelectionFunction_Name(T value) {
  static_assert(std::is_same<T, UIElement_ListSelection_SelectionFunction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SelectionFunction_Name().");
  return UIElement_ListSelection_SelectionFunction_Name(static_cast<UIElement_ListSelection_SelectionFunction>(value));
}
template <>
inline const std::string& UIElement_ListSelection_SelectionFunction_Name(UIElement_ListSelection_SelectionFunction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_ListSelection_SelectionFunction_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_ListSelection_SelectionFunction_Parse(absl::string_view name, UIElement_ListSelection_SelectionFunction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_ListSelection_SelectionFunction>(
      UIElement_ListSelection_SelectionFunction_descriptor(), name, value);
}
enum UIElement_ListSelection_SelectionFormat : int {
  UIElement_ListSelection_SelectionFormat_DEFAULT_SELECTION_FORMAT = 0,
  UIElement_ListSelection_SelectionFormat_NONE = 1,
  UIElement_ListSelection_SelectionFormat_TICK = 2,
  UIElement_ListSelection_SelectionFormat_SQUARE = 3,
  UIElement_ListSelection_SelectionFormat_CIRCLE = 4,
  UIElement_ListSelection_SelectionFormat_UIElement_ListSelection_SelectionFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_ListSelection_SelectionFormat_UIElement_ListSelection_SelectionFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_ListSelection_SelectionFormat_IsValid(int value);
extern const uint32_t UIElement_ListSelection_SelectionFormat_internal_data_[];
constexpr UIElement_ListSelection_SelectionFormat UIElement_ListSelection_SelectionFormat_SelectionFormat_MIN = static_cast<UIElement_ListSelection_SelectionFormat>(0);
constexpr UIElement_ListSelection_SelectionFormat UIElement_ListSelection_SelectionFormat_SelectionFormat_MAX = static_cast<UIElement_ListSelection_SelectionFormat>(4);
constexpr int UIElement_ListSelection_SelectionFormat_SelectionFormat_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_ListSelection_SelectionFormat_descriptor();
template <typename T>
const std::string& UIElement_ListSelection_SelectionFormat_Name(T value) {
  static_assert(std::is_same<T, UIElement_ListSelection_SelectionFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SelectionFormat_Name().");
  return UIElement_ListSelection_SelectionFormat_Name(static_cast<UIElement_ListSelection_SelectionFormat>(value));
}
template <>
inline const std::string& UIElement_ListSelection_SelectionFormat_Name(UIElement_ListSelection_SelectionFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_ListSelection_SelectionFormat_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool UIElement_ListSelection_SelectionFormat_Parse(absl::string_view name, UIElement_ListSelection_SelectionFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_ListSelection_SelectionFormat>(
      UIElement_ListSelection_SelectionFormat_descriptor(), name, value);
}
enum UIElement_SelectionElement_SelectionElementType : int {
  UIElement_SelectionElement_SelectionElementType_DEFAULT_SELECTION_ELEMENT = 0,
  UIElement_SelectionElement_SelectionElementType_LIST = 1,
  UIElement_SelectionElement_SelectionElementType_COMBO = 2,
  UIElement_SelectionElement_SelectionElementType_UIElement_SelectionElement_SelectionElementType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_SelectionElement_SelectionElementType_UIElement_SelectionElement_SelectionElementType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_SelectionElement_SelectionElementType_IsValid(int value);
extern const uint32_t UIElement_SelectionElement_SelectionElementType_internal_data_[];
constexpr UIElement_SelectionElement_SelectionElementType UIElement_SelectionElement_SelectionElementType_SelectionElementType_MIN = static_cast<UIElement_SelectionElement_SelectionElementType>(0);
constexpr UIElement_SelectionElement_SelectionElementType UIElement_SelectionElement_SelectionElementType_SelectionElementType_MAX = static_cast<UIElement_SelectionElement_SelectionElementType>(2);
constexpr int UIElement_SelectionElement_SelectionElementType_SelectionElementType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_SelectionElement_SelectionElementType_descriptor();
template <typename T>
const std::string& UIElement_SelectionElement_SelectionElementType_Name(T value) {
  static_assert(std::is_same<T, UIElement_SelectionElement_SelectionElementType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SelectionElementType_Name().");
  return UIElement_SelectionElement_SelectionElementType_Name(static_cast<UIElement_SelectionElement_SelectionElementType>(value));
}
template <>
inline const std::string& UIElement_SelectionElement_SelectionElementType_Name(UIElement_SelectionElement_SelectionElementType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_SelectionElement_SelectionElementType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_SelectionElement_SelectionElementType_Parse(absl::string_view name, UIElement_SelectionElement_SelectionElementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_SelectionElement_SelectionElementType>(
      UIElement_SelectionElement_SelectionElementType_descriptor(), name, value);
}
enum UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType : int {
  UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_DEFAULT_SLIDE_INTERVAL = 0,
  UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_MAJOR_INTERVAL = 1,
  UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_MINOR_INTERVAL = 2,
  UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_IsValid(int value);
extern const uint32_t UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_internal_data_[];
constexpr UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_SliderIntervalType_MIN = static_cast<UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType>(0);
constexpr UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_SliderIntervalType_MAX = static_cast<UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType>(2);
constexpr int UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_SliderIntervalType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_descriptor();
template <typename T>
const std::string& UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_Name(T value) {
  static_assert(std::is_same<T, UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SliderIntervalType_Name().");
  return UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_Name(static_cast<UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType>(value));
}
template <>
inline const std::string& UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_Name(UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_Parse(absl::string_view name, UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType>(
      UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_descriptor(), name, value);
}
enum UIElement_SliderElement_SliderType : int {
  UIElement_SliderElement_SliderType_DEFAULT_SLIDER_TYPE = 0,
  UIElement_SliderElement_SliderType_LINEAR = 1,
  UIElement_SliderElement_SliderType_CIRCULAR = 2,
  UIElement_SliderElement_SliderType_UIElement_SliderElement_SliderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_SliderElement_SliderType_UIElement_SliderElement_SliderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_SliderElement_SliderType_IsValid(int value);
extern const uint32_t UIElement_SliderElement_SliderType_internal_data_[];
constexpr UIElement_SliderElement_SliderType UIElement_SliderElement_SliderType_SliderType_MIN = static_cast<UIElement_SliderElement_SliderType>(0);
constexpr UIElement_SliderElement_SliderType UIElement_SliderElement_SliderType_SliderType_MAX = static_cast<UIElement_SliderElement_SliderType>(2);
constexpr int UIElement_SliderElement_SliderType_SliderType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_SliderElement_SliderType_descriptor();
template <typename T>
const std::string& UIElement_SliderElement_SliderType_Name(T value) {
  static_assert(std::is_same<T, UIElement_SliderElement_SliderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SliderType_Name().");
  return UIElement_SliderElement_SliderType_Name(static_cast<UIElement_SliderElement_SliderType>(value));
}
template <>
inline const std::string& UIElement_SliderElement_SliderType_Name(UIElement_SliderElement_SliderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_SliderElement_SliderType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_SliderElement_SliderType_Parse(absl::string_view name, UIElement_SliderElement_SliderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_SliderElement_SliderType>(
      UIElement_SliderElement_SliderType_descriptor(), name, value);
}
enum UIElement_SliderElement_LinearSliderType : int {
  UIElement_SliderElement_LinearSliderType_DEFAULT_LINEAR_SLIDER_TYPE = 0,
  UIElement_SliderElement_LinearSliderType_HORIZONTAL = 1,
  UIElement_SliderElement_LinearSliderType_VERTICAL = 2,
  UIElement_SliderElement_LinearSliderType_UIElement_SliderElement_LinearSliderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_SliderElement_LinearSliderType_UIElement_SliderElement_LinearSliderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_SliderElement_LinearSliderType_IsValid(int value);
extern const uint32_t UIElement_SliderElement_LinearSliderType_internal_data_[];
constexpr UIElement_SliderElement_LinearSliderType UIElement_SliderElement_LinearSliderType_LinearSliderType_MIN = static_cast<UIElement_SliderElement_LinearSliderType>(0);
constexpr UIElement_SliderElement_LinearSliderType UIElement_SliderElement_LinearSliderType_LinearSliderType_MAX = static_cast<UIElement_SliderElement_LinearSliderType>(2);
constexpr int UIElement_SliderElement_LinearSliderType_LinearSliderType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_SliderElement_LinearSliderType_descriptor();
template <typename T>
const std::string& UIElement_SliderElement_LinearSliderType_Name(T value) {
  static_assert(std::is_same<T, UIElement_SliderElement_LinearSliderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LinearSliderType_Name().");
  return UIElement_SliderElement_LinearSliderType_Name(static_cast<UIElement_SliderElement_LinearSliderType>(value));
}
template <>
inline const std::string& UIElement_SliderElement_LinearSliderType_Name(UIElement_SliderElement_LinearSliderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_SliderElement_LinearSliderType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_SliderElement_LinearSliderType_Parse(absl::string_view name, UIElement_SliderElement_LinearSliderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_SliderElement_LinearSliderType>(
      UIElement_SliderElement_LinearSliderType_descriptor(), name, value);
}
enum UIElement_CalendarElement_CalendarType : int {
  UIElement_CalendarElement_CalendarType_DEFAULT_CALENDAR_TYPE = 0,
  UIElement_CalendarElement_CalendarType_DATE_TIME_PICKER = 1,
  UIElement_CalendarElement_CalendarType_DATE_PICKER = 2,
  UIElement_CalendarElement_CalendarType_UIElement_CalendarElement_CalendarType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_CalendarElement_CalendarType_UIElement_CalendarElement_CalendarType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_CalendarElement_CalendarType_IsValid(int value);
extern const uint32_t UIElement_CalendarElement_CalendarType_internal_data_[];
constexpr UIElement_CalendarElement_CalendarType UIElement_CalendarElement_CalendarType_CalendarType_MIN = static_cast<UIElement_CalendarElement_CalendarType>(0);
constexpr UIElement_CalendarElement_CalendarType UIElement_CalendarElement_CalendarType_CalendarType_MAX = static_cast<UIElement_CalendarElement_CalendarType>(2);
constexpr int UIElement_CalendarElement_CalendarType_CalendarType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_CalendarElement_CalendarType_descriptor();
template <typename T>
const std::string& UIElement_CalendarElement_CalendarType_Name(T value) {
  static_assert(std::is_same<T, UIElement_CalendarElement_CalendarType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CalendarType_Name().");
  return UIElement_CalendarElement_CalendarType_Name(static_cast<UIElement_CalendarElement_CalendarType>(value));
}
template <>
inline const std::string& UIElement_CalendarElement_CalendarType_Name(UIElement_CalendarElement_CalendarType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_CalendarElement_CalendarType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_CalendarElement_CalendarType_Parse(absl::string_view name, UIElement_CalendarElement_CalendarType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_CalendarElement_CalendarType>(
      UIElement_CalendarElement_CalendarType_descriptor(), name, value);
}
enum UIElement_CalendarElement_DatePickerFormat : int {
  UIElement_CalendarElement_DatePickerFormat_DEFAULT_DATE_PICKER_FORMAT = 0,
  UIElement_CalendarElement_DatePickerFormat_YEAR_MONTH_DAY = 1,
  UIElement_CalendarElement_DatePickerFormat_YEAR_MONTH = 2,
  UIElement_CalendarElement_DatePickerFormat_UIElement_CalendarElement_DatePickerFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_CalendarElement_DatePickerFormat_UIElement_CalendarElement_DatePickerFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_CalendarElement_DatePickerFormat_IsValid(int value);
extern const uint32_t UIElement_CalendarElement_DatePickerFormat_internal_data_[];
constexpr UIElement_CalendarElement_DatePickerFormat UIElement_CalendarElement_DatePickerFormat_DatePickerFormat_MIN = static_cast<UIElement_CalendarElement_DatePickerFormat>(0);
constexpr UIElement_CalendarElement_DatePickerFormat UIElement_CalendarElement_DatePickerFormat_DatePickerFormat_MAX = static_cast<UIElement_CalendarElement_DatePickerFormat>(2);
constexpr int UIElement_CalendarElement_DatePickerFormat_DatePickerFormat_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_CalendarElement_DatePickerFormat_descriptor();
template <typename T>
const std::string& UIElement_CalendarElement_DatePickerFormat_Name(T value) {
  static_assert(std::is_same<T, UIElement_CalendarElement_DatePickerFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DatePickerFormat_Name().");
  return UIElement_CalendarElement_DatePickerFormat_Name(static_cast<UIElement_CalendarElement_DatePickerFormat>(value));
}
template <>
inline const std::string& UIElement_CalendarElement_DatePickerFormat_Name(UIElement_CalendarElement_DatePickerFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_CalendarElement_DatePickerFormat_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_CalendarElement_DatePickerFormat_Parse(absl::string_view name, UIElement_CalendarElement_DatePickerFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_CalendarElement_DatePickerFormat>(
      UIElement_CalendarElement_DatePickerFormat_descriptor(), name, value);
}
enum UIElement_CalendarElement_TimePickerFormat : int {
  UIElement_CalendarElement_TimePickerFormat_DEFAULT_TIME_PICKER_FORMAT = 0,
  UIElement_CalendarElement_TimePickerFormat_HOUR_MINUTE_SECOND = 1,
  UIElement_CalendarElement_TimePickerFormat_HOUR_MINUTE = 2,
  UIElement_CalendarElement_TimePickerFormat_UIElement_CalendarElement_TimePickerFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_CalendarElement_TimePickerFormat_UIElement_CalendarElement_TimePickerFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_CalendarElement_TimePickerFormat_IsValid(int value);
extern const uint32_t UIElement_CalendarElement_TimePickerFormat_internal_data_[];
constexpr UIElement_CalendarElement_TimePickerFormat UIElement_CalendarElement_TimePickerFormat_TimePickerFormat_MIN = static_cast<UIElement_CalendarElement_TimePickerFormat>(0);
constexpr UIElement_CalendarElement_TimePickerFormat UIElement_CalendarElement_TimePickerFormat_TimePickerFormat_MAX = static_cast<UIElement_CalendarElement_TimePickerFormat>(2);
constexpr int UIElement_CalendarElement_TimePickerFormat_TimePickerFormat_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_CalendarElement_TimePickerFormat_descriptor();
template <typename T>
const std::string& UIElement_CalendarElement_TimePickerFormat_Name(T value) {
  static_assert(std::is_same<T, UIElement_CalendarElement_TimePickerFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TimePickerFormat_Name().");
  return UIElement_CalendarElement_TimePickerFormat_Name(static_cast<UIElement_CalendarElement_TimePickerFormat>(value));
}
template <>
inline const std::string& UIElement_CalendarElement_TimePickerFormat_Name(UIElement_CalendarElement_TimePickerFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_CalendarElement_TimePickerFormat_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_CalendarElement_TimePickerFormat_Parse(absl::string_view name, UIElement_CalendarElement_TimePickerFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_CalendarElement_TimePickerFormat>(
      UIElement_CalendarElement_TimePickerFormat_descriptor(), name, value);
}
enum UIElement_CalendarElement_ClockFormat : int {
  UIElement_CalendarElement_ClockFormat_DEFAULT_TIME_FORMAT = 0,
  UIElement_CalendarElement_ClockFormat_FULL_DAY_HOUR = 1,
  UIElement_CalendarElement_ClockFormat_HALF_DAY_HOUR = 2,
  UIElement_CalendarElement_ClockFormat_UIElement_CalendarElement_ClockFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_CalendarElement_ClockFormat_UIElement_CalendarElement_ClockFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_CalendarElement_ClockFormat_IsValid(int value);
extern const uint32_t UIElement_CalendarElement_ClockFormat_internal_data_[];
constexpr UIElement_CalendarElement_ClockFormat UIElement_CalendarElement_ClockFormat_ClockFormat_MIN = static_cast<UIElement_CalendarElement_ClockFormat>(0);
constexpr UIElement_CalendarElement_ClockFormat UIElement_CalendarElement_ClockFormat_ClockFormat_MAX = static_cast<UIElement_CalendarElement_ClockFormat>(2);
constexpr int UIElement_CalendarElement_ClockFormat_ClockFormat_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_CalendarElement_ClockFormat_descriptor();
template <typename T>
const std::string& UIElement_CalendarElement_ClockFormat_Name(T value) {
  static_assert(std::is_same<T, UIElement_CalendarElement_ClockFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ClockFormat_Name().");
  return UIElement_CalendarElement_ClockFormat_Name(static_cast<UIElement_CalendarElement_ClockFormat>(value));
}
template <>
inline const std::string& UIElement_CalendarElement_ClockFormat_Name(UIElement_CalendarElement_ClockFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_CalendarElement_ClockFormat_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_CalendarElement_ClockFormat_Parse(absl::string_view name, UIElement_CalendarElement_ClockFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_CalendarElement_ClockFormat>(
      UIElement_CalendarElement_ClockFormat_descriptor(), name, value);
}
enum UIElement_ToggleElement_ToggleElementType : int {
  UIElement_ToggleElement_ToggleElementType_DEFAULT_TOGGLE_ELEMENT_TYPE = 0,
  UIElement_ToggleElement_ToggleElementType_CHECKBOX = 1,
  UIElement_ToggleElement_ToggleElementType_SWITCH = 2,
  UIElement_ToggleElement_ToggleElementType_UIElement_ToggleElement_ToggleElementType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_ToggleElement_ToggleElementType_UIElement_ToggleElement_ToggleElementType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_ToggleElement_ToggleElementType_IsValid(int value);
extern const uint32_t UIElement_ToggleElement_ToggleElementType_internal_data_[];
constexpr UIElement_ToggleElement_ToggleElementType UIElement_ToggleElement_ToggleElementType_ToggleElementType_MIN = static_cast<UIElement_ToggleElement_ToggleElementType>(0);
constexpr UIElement_ToggleElement_ToggleElementType UIElement_ToggleElement_ToggleElementType_ToggleElementType_MAX = static_cast<UIElement_ToggleElement_ToggleElementType>(2);
constexpr int UIElement_ToggleElement_ToggleElementType_ToggleElementType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_ToggleElement_ToggleElementType_descriptor();
template <typename T>
const std::string& UIElement_ToggleElement_ToggleElementType_Name(T value) {
  static_assert(std::is_same<T, UIElement_ToggleElement_ToggleElementType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ToggleElementType_Name().");
  return UIElement_ToggleElement_ToggleElementType_Name(static_cast<UIElement_ToggleElement_ToggleElementType>(value));
}
template <>
inline const std::string& UIElement_ToggleElement_ToggleElementType_Name(UIElement_ToggleElement_ToggleElementType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_ToggleElement_ToggleElementType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_ToggleElement_ToggleElementType_Parse(absl::string_view name, UIElement_ToggleElement_ToggleElementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_ToggleElement_ToggleElementType>(
      UIElement_ToggleElement_ToggleElementType_descriptor(), name, value);
}
enum UIElement_ToggleElement_LabelPosition : int {
  UIElement_ToggleElement_LabelPosition_DEFAULT_LABEL_POSITION = 0,
  UIElement_ToggleElement_LabelPosition_INSIDE = 1,
  UIElement_ToggleElement_LabelPosition_OUTSIDE = 2,
  UIElement_ToggleElement_LabelPosition_UIElement_ToggleElement_LabelPosition_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_ToggleElement_LabelPosition_UIElement_ToggleElement_LabelPosition_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_ToggleElement_LabelPosition_IsValid(int value);
extern const uint32_t UIElement_ToggleElement_LabelPosition_internal_data_[];
constexpr UIElement_ToggleElement_LabelPosition UIElement_ToggleElement_LabelPosition_LabelPosition_MIN = static_cast<UIElement_ToggleElement_LabelPosition>(0);
constexpr UIElement_ToggleElement_LabelPosition UIElement_ToggleElement_LabelPosition_LabelPosition_MAX = static_cast<UIElement_ToggleElement_LabelPosition>(2);
constexpr int UIElement_ToggleElement_LabelPosition_LabelPosition_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_ToggleElement_LabelPosition_descriptor();
template <typename T>
const std::string& UIElement_ToggleElement_LabelPosition_Name(T value) {
  static_assert(std::is_same<T, UIElement_ToggleElement_LabelPosition>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LabelPosition_Name().");
  return UIElement_ToggleElement_LabelPosition_Name(static_cast<UIElement_ToggleElement_LabelPosition>(value));
}
template <>
inline const std::string& UIElement_ToggleElement_LabelPosition_Name(UIElement_ToggleElement_LabelPosition value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_ToggleElement_LabelPosition_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_ToggleElement_LabelPosition_Parse(absl::string_view name, UIElement_ToggleElement_LabelPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_ToggleElement_LabelPosition>(
      UIElement_ToggleElement_LabelPosition_descriptor(), name, value);
}
enum UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType : int {
  UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_DEFAULT_STATUS_SYMBOL_TYPE = 0,
  UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_CIRCLE = 1,
  UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_SQUARE = 2,
  UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_STAR = 3,
  UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_IsValid(int value);
extern const uint32_t UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_internal_data_[];
constexpr UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_StatusSymbolType_MIN = static_cast<UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType>(0);
constexpr UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_StatusSymbolType_MAX = static_cast<UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType>(3);
constexpr int UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_StatusSymbolType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_descriptor();
template <typename T>
const std::string& UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_Name(T value) {
  static_assert(std::is_same<T, UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StatusSymbolType_Name().");
  return UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_Name(static_cast<UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType>(value));
}
template <>
inline const std::string& UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_Name(UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_Parse(absl::string_view name, UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType>(
      UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_descriptor(), name, value);
}
enum UIElement_LabelElement_LabelElementType : int {
  UIElement_LabelElement_LabelElementType_DEFAULT_LABEL_ELEMENT = 0,
  UIElement_LabelElement_LabelElementType_BG = 1,
  UIElement_LabelElement_LabelElementType_STATUS = 2,
  UIElement_LabelElement_LabelElementType_UIElement_LabelElement_LabelElementType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_LabelElement_LabelElementType_UIElement_LabelElement_LabelElementType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_LabelElement_LabelElementType_IsValid(int value);
extern const uint32_t UIElement_LabelElement_LabelElementType_internal_data_[];
constexpr UIElement_LabelElement_LabelElementType UIElement_LabelElement_LabelElementType_LabelElementType_MIN = static_cast<UIElement_LabelElement_LabelElementType>(0);
constexpr UIElement_LabelElement_LabelElementType UIElement_LabelElement_LabelElementType_LabelElementType_MAX = static_cast<UIElement_LabelElement_LabelElementType>(2);
constexpr int UIElement_LabelElement_LabelElementType_LabelElementType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_LabelElement_LabelElementType_descriptor();
template <typename T>
const std::string& UIElement_LabelElement_LabelElementType_Name(T value) {
  static_assert(std::is_same<T, UIElement_LabelElement_LabelElementType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LabelElementType_Name().");
  return UIElement_LabelElement_LabelElementType_Name(static_cast<UIElement_LabelElement_LabelElementType>(value));
}
template <>
inline const std::string& UIElement_LabelElement_LabelElementType_Name(UIElement_LabelElement_LabelElementType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_LabelElement_LabelElementType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UIElement_LabelElement_LabelElementType_Parse(absl::string_view name, UIElement_LabelElement_LabelElementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_LabelElement_LabelElementType>(
      UIElement_LabelElement_LabelElementType_descriptor(), name, value);
}
enum UIElement_RatingElement_RatingElementType : int {
  UIElement_RatingElement_RatingElementType_DEFAULT_RATING_ELEMENT = 0,
  UIElement_RatingElement_RatingElementType_STAR = 1,
  UIElement_RatingElement_RatingElementType_HEART = 2,
  UIElement_RatingElement_RatingElementType_SMILEY = 3,
  UIElement_RatingElement_RatingElementType_UIElement_RatingElement_RatingElementType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_RatingElement_RatingElementType_UIElement_RatingElement_RatingElementType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_RatingElement_RatingElementType_IsValid(int value);
extern const uint32_t UIElement_RatingElement_RatingElementType_internal_data_[];
constexpr UIElement_RatingElement_RatingElementType UIElement_RatingElement_RatingElementType_RatingElementType_MIN = static_cast<UIElement_RatingElement_RatingElementType>(0);
constexpr UIElement_RatingElement_RatingElementType UIElement_RatingElement_RatingElementType_RatingElementType_MAX = static_cast<UIElement_RatingElement_RatingElementType>(3);
constexpr int UIElement_RatingElement_RatingElementType_RatingElementType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_RatingElement_RatingElementType_descriptor();
template <typename T>
const std::string& UIElement_RatingElement_RatingElementType_Name(T value) {
  static_assert(std::is_same<T, UIElement_RatingElement_RatingElementType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RatingElementType_Name().");
  return UIElement_RatingElement_RatingElementType_Name(static_cast<UIElement_RatingElement_RatingElementType>(value));
}
template <>
inline const std::string& UIElement_RatingElement_RatingElementType_Name(UIElement_RatingElement_RatingElementType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_RatingElement_RatingElementType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UIElement_RatingElement_RatingElementType_Parse(absl::string_view name, UIElement_RatingElement_RatingElementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_RatingElement_RatingElementType>(
      UIElement_RatingElement_RatingElementType_descriptor(), name, value);
}
enum UIElement_RatingElement_RatingVariable : int {
  UIElement_RatingElement_RatingVariable_DEFAULT_RATING_VARIABLE = 0,
  UIElement_RatingElement_RatingVariable_FULL = 1,
  UIElement_RatingElement_RatingVariable_HALF = 2,
  UIElement_RatingElement_RatingVariable_QUARTER = 3,
  UIElement_RatingElement_RatingVariable_UIElement_RatingElement_RatingVariable_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_RatingElement_RatingVariable_UIElement_RatingElement_RatingVariable_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_RatingElement_RatingVariable_IsValid(int value);
extern const uint32_t UIElement_RatingElement_RatingVariable_internal_data_[];
constexpr UIElement_RatingElement_RatingVariable UIElement_RatingElement_RatingVariable_RatingVariable_MIN = static_cast<UIElement_RatingElement_RatingVariable>(0);
constexpr UIElement_RatingElement_RatingVariable UIElement_RatingElement_RatingVariable_RatingVariable_MAX = static_cast<UIElement_RatingElement_RatingVariable>(3);
constexpr int UIElement_RatingElement_RatingVariable_RatingVariable_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_RatingElement_RatingVariable_descriptor();
template <typename T>
const std::string& UIElement_RatingElement_RatingVariable_Name(T value) {
  static_assert(std::is_same<T, UIElement_RatingElement_RatingVariable>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RatingVariable_Name().");
  return UIElement_RatingElement_RatingVariable_Name(static_cast<UIElement_RatingElement_RatingVariable>(value));
}
template <>
inline const std::string& UIElement_RatingElement_RatingVariable_Name(UIElement_RatingElement_RatingVariable value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_RatingElement_RatingVariable_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UIElement_RatingElement_RatingVariable_Parse(absl::string_view name, UIElement_RatingElement_RatingVariable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_RatingElement_RatingVariable>(
      UIElement_RatingElement_RatingVariable_descriptor(), name, value);
}
enum UIElement_RatingElement_RatingConcept : int {
  UIElement_RatingElement_RatingConcept_DEFAULT_RATING_CONCEPT = 0,
  UIElement_RatingElement_RatingConcept_STATIC = 1,
  UIElement_RatingElement_RatingConcept_ASCENDING = 2,
  UIElement_RatingElement_RatingConcept_DESCENDING = 3,
  UIElement_RatingElement_RatingConcept_UIElement_RatingElement_RatingConcept_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_RatingElement_RatingConcept_UIElement_RatingElement_RatingConcept_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_RatingElement_RatingConcept_IsValid(int value);
extern const uint32_t UIElement_RatingElement_RatingConcept_internal_data_[];
constexpr UIElement_RatingElement_RatingConcept UIElement_RatingElement_RatingConcept_RatingConcept_MIN = static_cast<UIElement_RatingElement_RatingConcept>(0);
constexpr UIElement_RatingElement_RatingConcept UIElement_RatingElement_RatingConcept_RatingConcept_MAX = static_cast<UIElement_RatingElement_RatingConcept>(3);
constexpr int UIElement_RatingElement_RatingConcept_RatingConcept_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_RatingElement_RatingConcept_descriptor();
template <typename T>
const std::string& UIElement_RatingElement_RatingConcept_Name(T value) {
  static_assert(std::is_same<T, UIElement_RatingElement_RatingConcept>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RatingConcept_Name().");
  return UIElement_RatingElement_RatingConcept_Name(static_cast<UIElement_RatingElement_RatingConcept>(value));
}
template <>
inline const std::string& UIElement_RatingElement_RatingConcept_Name(UIElement_RatingElement_RatingConcept value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_RatingElement_RatingConcept_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UIElement_RatingElement_RatingConcept_Parse(absl::string_view name, UIElement_RatingElement_RatingConcept* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_RatingElement_RatingConcept>(
      UIElement_RatingElement_RatingConcept_descriptor(), name, value);
}
enum UIElement_UIElementType : int {
  UIElement_UIElementType_UNKNOWN = 0,
  UIElement_UIElementType_USERELEMENT = 1,
  UIElement_UIElementType_SELECTIONELEMENT = 2,
  UIElement_UIElementType_SLIDER = 3,
  UIElement_UIElementType_CALENDAR = 4,
  UIElement_UIElementType_TOGGLE = 5,
  UIElement_UIElementType_STEPPER = 6,
  UIElement_UIElementType_BUTTON = 7,
  UIElement_UIElementType_LABEL = 8,
  UIElement_UIElementType_RATING = 9,
  UIElement_UIElementType_UIElement_UIElementType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UIElement_UIElementType_UIElement_UIElementType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UIElement_UIElementType_IsValid(int value);
extern const uint32_t UIElement_UIElementType_internal_data_[];
constexpr UIElement_UIElementType UIElement_UIElementType_UIElementType_MIN = static_cast<UIElement_UIElementType>(0);
constexpr UIElement_UIElementType UIElement_UIElementType_UIElementType_MAX = static_cast<UIElement_UIElementType>(9);
constexpr int UIElement_UIElementType_UIElementType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
UIElement_UIElementType_descriptor();
template <typename T>
const std::string& UIElement_UIElementType_Name(T value) {
  static_assert(std::is_same<T, UIElement_UIElementType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UIElementType_Name().");
  return UIElement_UIElementType_Name(static_cast<UIElement_UIElementType>(value));
}
template <>
inline const std::string& UIElement_UIElementType_Name(UIElement_UIElementType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UIElement_UIElementType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool UIElement_UIElementType_Parse(absl::string_view name, UIElement_UIElementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UIElement_UIElementType>(
      UIElement_UIElementType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UIElement_ToggleElement_ToggleInput_DataForState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState) */ {
 public:
  inline UIElement_ToggleElement_ToggleInput_DataForState() : UIElement_ToggleElement_ToggleInput_DataForState(nullptr) {}
  ~UIElement_ToggleElement_ToggleInput_DataForState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ToggleElement_ToggleInput_DataForState(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ToggleElement_ToggleInput_DataForState(const UIElement_ToggleElement_ToggleInput_DataForState& from)
      : UIElement_ToggleElement_ToggleInput_DataForState(nullptr, from) {}
  UIElement_ToggleElement_ToggleInput_DataForState(UIElement_ToggleElement_ToggleInput_DataForState&& from) noexcept
    : UIElement_ToggleElement_ToggleInput_DataForState() {
    *this = ::std::move(from);
  }

  inline UIElement_ToggleElement_ToggleInput_DataForState& operator=(const UIElement_ToggleElement_ToggleInput_DataForState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ToggleElement_ToggleInput_DataForState& operator=(UIElement_ToggleElement_ToggleInput_DataForState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ToggleElement_ToggleInput_DataForState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ToggleElement_ToggleInput_DataForState* internal_default_instance() {
    return reinterpret_cast<const UIElement_ToggleElement_ToggleInput_DataForState*>(
               &_UIElement_ToggleElement_ToggleInput_DataForState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UIElement_ToggleElement_ToggleInput_DataForState& a, UIElement_ToggleElement_ToggleInput_DataForState& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ToggleElement_ToggleInput_DataForState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ToggleElement_ToggleInput_DataForState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ToggleElement_ToggleInput_DataForState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ToggleElement_ToggleInput_DataForState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ToggleElement_ToggleInput_DataForState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ToggleElement_ToggleInput_DataForState& from) {
    UIElement_ToggleElement_ToggleInput_DataForState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ToggleElement_ToggleInput_DataForState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState";
  }
  protected:
  explicit UIElement_ToggleElement_ToggleInput_DataForState(::google::protobuf::Arena* arena);
  UIElement_ToggleElement_ToggleInput_DataForState(::google::protobuf::Arena* arena, const UIElement_ToggleElement_ToggleInput_DataForState& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnStateFieldNumber = 1,
    kOffStateFieldNumber = 2,
  };
  // optional string onState = 1;
  bool has_onstate() const;
  void clear_onstate() ;
  const std::string& onstate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onstate(Arg_&& arg, Args_... args);
  std::string* mutable_onstate();
  PROTOBUF_NODISCARD std::string* release_onstate();
  void set_allocated_onstate(std::string* value);

  private:
  const std::string& _internal_onstate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onstate(
      const std::string& value);
  std::string* _internal_mutable_onstate();

  public:
  // optional string offState = 2;
  bool has_offstate() const;
  void clear_offstate() ;
  const std::string& offstate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_offstate(Arg_&& arg, Args_... args);
  std::string* mutable_offstate();
  PROTOBUF_NODISCARD std::string* release_offstate();
  void set_allocated_offstate(std::string* value);

  private:
  const std::string& _internal_offstate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offstate(
      const std::string& value);
  std::string* _internal_mutable_offstate();

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      88, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr onstate_;
    ::google::protobuf::internal::ArenaStringPtr offstate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_StepperElement_StepperInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.StepperElement.StepperInput) */ {
 public:
  inline UIElement_StepperElement_StepperInput() : UIElement_StepperElement_StepperInput(nullptr) {}
  ~UIElement_StepperElement_StepperInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_StepperElement_StepperInput(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_StepperElement_StepperInput(const UIElement_StepperElement_StepperInput& from)
      : UIElement_StepperElement_StepperInput(nullptr, from) {}
  UIElement_StepperElement_StepperInput(UIElement_StepperElement_StepperInput&& from) noexcept
    : UIElement_StepperElement_StepperInput() {
    *this = ::std::move(from);
  }

  inline UIElement_StepperElement_StepperInput& operator=(const UIElement_StepperElement_StepperInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_StepperElement_StepperInput& operator=(UIElement_StepperElement_StepperInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_StepperElement_StepperInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_StepperElement_StepperInput* internal_default_instance() {
    return reinterpret_cast<const UIElement_StepperElement_StepperInput*>(
               &_UIElement_StepperElement_StepperInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UIElement_StepperElement_StepperInput& a, UIElement_StepperElement_StepperInput& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_StepperElement_StepperInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_StepperElement_StepperInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_StepperElement_StepperInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_StepperElement_StepperInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_StepperElement_StepperInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_StepperElement_StepperInput& from) {
    UIElement_StepperElement_StepperInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_StepperElement_StepperInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.StepperElement.StepperInput";
  }
  protected:
  explicit UIElement_StepperElement_StepperInput(::google::protobuf::Arena* arena);
  UIElement_StepperElement_StepperInput(::google::protobuf::Arena* arena, const UIElement_StepperElement_StepperInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefValFieldNumber = 1,
    kMaxValFieldNumber = 2,
    kMinValFieldNumber = 3,
    kIncermentValFieldNumber = 4,
  };
  // optional float defVal = 1;
  bool has_defval() const;
  void clear_defval() ;
  float defval() const;
  void set_defval(float value);

  private:
  float _internal_defval() const;
  void _internal_set_defval(float value);

  public:
  // optional float maxVal = 2;
  bool has_maxval() const;
  void clear_maxval() ;
  float maxval() const;
  void set_maxval(float value);

  private:
  float _internal_maxval() const;
  void _internal_set_maxval(float value);

  public:
  // optional float minVal = 3;
  bool has_minval() const;
  void clear_minval() ;
  float minval() const;
  void set_minval(float value);

  private:
  float _internal_minval() const;
  void _internal_set_minval(float value);

  public:
  // optional float incermentVal = 4;
  bool has_incermentval() const;
  void clear_incermentval() ;
  float incermentval() const;
  void set_incermentval(float value);

  private:
  float _internal_incermentval() const;
  void _internal_set_incermentval(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.StepperElement.StepperInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float defval_;
    float maxval_;
    float minval_;
    float incermentval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_SliderElement_SliderInput_SliderInterval final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval) */ {
 public:
  inline UIElement_SliderElement_SliderInput_SliderInterval() : UIElement_SliderElement_SliderInput_SliderInterval(nullptr) {}
  ~UIElement_SliderElement_SliderInput_SliderInterval() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_SliderElement_SliderInput_SliderInterval(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_SliderElement_SliderInput_SliderInterval(const UIElement_SliderElement_SliderInput_SliderInterval& from)
      : UIElement_SliderElement_SliderInput_SliderInterval(nullptr, from) {}
  UIElement_SliderElement_SliderInput_SliderInterval(UIElement_SliderElement_SliderInput_SliderInterval&& from) noexcept
    : UIElement_SliderElement_SliderInput_SliderInterval() {
    *this = ::std::move(from);
  }

  inline UIElement_SliderElement_SliderInput_SliderInterval& operator=(const UIElement_SliderElement_SliderInput_SliderInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_SliderElement_SliderInput_SliderInterval& operator=(UIElement_SliderElement_SliderInput_SliderInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_SliderElement_SliderInput_SliderInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_SliderElement_SliderInput_SliderInterval* internal_default_instance() {
    return reinterpret_cast<const UIElement_SliderElement_SliderInput_SliderInterval*>(
               &_UIElement_SliderElement_SliderInput_SliderInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UIElement_SliderElement_SliderInput_SliderInterval& a, UIElement_SliderElement_SliderInput_SliderInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_SliderElement_SliderInput_SliderInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_SliderElement_SliderInput_SliderInterval* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_SliderElement_SliderInput_SliderInterval* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_SliderElement_SliderInput_SliderInterval>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_SliderElement_SliderInput_SliderInterval& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_SliderElement_SliderInput_SliderInterval& from) {
    UIElement_SliderElement_SliderInput_SliderInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_SliderElement_SliderInput_SliderInterval* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval";
  }
  protected:
  explicit UIElement_SliderElement_SliderInput_SliderInterval(::google::protobuf::Arena* arena);
  UIElement_SliderElement_SliderInput_SliderInterval(::google::protobuf::Arena* arena, const UIElement_SliderElement_SliderInput_SliderInterval& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SliderIntervalType = UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType;
  static constexpr SliderIntervalType DEFAULT_SLIDE_INTERVAL = UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_DEFAULT_SLIDE_INTERVAL;
  static constexpr SliderIntervalType MAJOR_INTERVAL = UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_MAJOR_INTERVAL;
  static constexpr SliderIntervalType MINOR_INTERVAL = UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_MINOR_INTERVAL;
  static inline bool SliderIntervalType_IsValid(int value) {
    return UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_IsValid(value);
  }
  static constexpr SliderIntervalType SliderIntervalType_MIN = UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_SliderIntervalType_MIN;
  static constexpr SliderIntervalType SliderIntervalType_MAX = UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_SliderIntervalType_MAX;
  static constexpr int SliderIntervalType_ARRAYSIZE = UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_SliderIntervalType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SliderIntervalType_descriptor() {
    return UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_descriptor();
  }
  template <typename T>
  static inline const std::string& SliderIntervalType_Name(T value) {
    return UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_Name(value);
  }
  static inline bool SliderIntervalType_Parse(absl::string_view name, SliderIntervalType* value) {
    return UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional float interval = 1;
  bool has_interval() const;
  void clear_interval() ;
  float interval() const;
  void set_interval(float value);

  private:
  float _internal_interval() const;
  void _internal_set_interval(float value);

  public:
  // optional .com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval.SliderIntervalType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType type() const;
  void set_type(::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType value);

  private:
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float interval_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_RatingElement_RatingInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.RatingElement.RatingInput) */ {
 public:
  inline UIElement_RatingElement_RatingInput() : UIElement_RatingElement_RatingInput(nullptr) {}
  ~UIElement_RatingElement_RatingInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_RatingElement_RatingInput(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_RatingElement_RatingInput(const UIElement_RatingElement_RatingInput& from)
      : UIElement_RatingElement_RatingInput(nullptr, from) {}
  UIElement_RatingElement_RatingInput(UIElement_RatingElement_RatingInput&& from) noexcept
    : UIElement_RatingElement_RatingInput() {
    *this = ::std::move(from);
  }

  inline UIElement_RatingElement_RatingInput& operator=(const UIElement_RatingElement_RatingInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_RatingElement_RatingInput& operator=(UIElement_RatingElement_RatingInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_RatingElement_RatingInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_RatingElement_RatingInput* internal_default_instance() {
    return reinterpret_cast<const UIElement_RatingElement_RatingInput*>(
               &_UIElement_RatingElement_RatingInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UIElement_RatingElement_RatingInput& a, UIElement_RatingElement_RatingInput& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_RatingElement_RatingInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_RatingElement_RatingInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_RatingElement_RatingInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_RatingElement_RatingInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_RatingElement_RatingInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_RatingElement_RatingInput& from) {
    UIElement_RatingElement_RatingInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_RatingElement_RatingInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.RatingElement.RatingInput";
  }
  protected:
  explicit UIElement_RatingElement_RatingInput(::google::protobuf::Arena* arena);
  UIElement_RatingElement_RatingInput(::google::protobuf::Arena* arena, const UIElement_RatingElement_RatingInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefValFieldNumber = 1,
    kMaxValFieldNumber = 2,
    kMinValFieldNumber = 3,
  };
  // optional float defVal = 1;
  bool has_defval() const;
  void clear_defval() ;
  float defval() const;
  void set_defval(float value);

  private:
  float _internal_defval() const;
  void _internal_set_defval(float value);

  public:
  // optional float maxVal = 2;
  bool has_maxval() const;
  void clear_maxval() ;
  float maxval() const;
  void set_maxval(float value);

  private:
  float _internal_maxval() const;
  void _internal_set_maxval(float value);

  public:
  // optional float minVal = 3;
  bool has_minval() const;
  void clear_minval() ;
  float minval() const;
  void set_minval(float value);

  private:
  float _internal_minval() const;
  void _internal_set_minval(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.RatingElement.RatingInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float defval_;
    float maxval_;
    float minval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListSelection_SingleSelection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListSelection.SingleSelection) */ {
 public:
  inline UIElement_ListSelection_SingleSelection() : UIElement_ListSelection_SingleSelection(nullptr) {}
  ~UIElement_ListSelection_SingleSelection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListSelection_SingleSelection(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListSelection_SingleSelection(const UIElement_ListSelection_SingleSelection& from)
      : UIElement_ListSelection_SingleSelection(nullptr, from) {}
  UIElement_ListSelection_SingleSelection(UIElement_ListSelection_SingleSelection&& from) noexcept
    : UIElement_ListSelection_SingleSelection() {
    *this = ::std::move(from);
  }

  inline UIElement_ListSelection_SingleSelection& operator=(const UIElement_ListSelection_SingleSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListSelection_SingleSelection& operator=(UIElement_ListSelection_SingleSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListSelection_SingleSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListSelection_SingleSelection* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListSelection_SingleSelection*>(
               &_UIElement_ListSelection_SingleSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UIElement_ListSelection_SingleSelection& a, UIElement_ListSelection_SingleSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListSelection_SingleSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListSelection_SingleSelection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListSelection_SingleSelection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListSelection_SingleSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListSelection_SingleSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListSelection_SingleSelection& from) {
    UIElement_ListSelection_SingleSelection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListSelection_SingleSelection* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListSelection.SingleSelection";
  }
  protected:
  explicit UIElement_ListSelection_SingleSelection(::google::protobuf::Arena* arena);
  UIElement_ListSelection_SingleSelection(::google::protobuf::Arena* arena, const UIElement_ListSelection_SingleSelection& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.UIElement.ListSelection.SelectionFormat type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat type() const;
  void set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value);

  private:
  ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListSelection.SingleSelection)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListSelection_MultipleSelection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListSelection.MultipleSelection) */ {
 public:
  inline UIElement_ListSelection_MultipleSelection() : UIElement_ListSelection_MultipleSelection(nullptr) {}
  ~UIElement_ListSelection_MultipleSelection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListSelection_MultipleSelection(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListSelection_MultipleSelection(const UIElement_ListSelection_MultipleSelection& from)
      : UIElement_ListSelection_MultipleSelection(nullptr, from) {}
  UIElement_ListSelection_MultipleSelection(UIElement_ListSelection_MultipleSelection&& from) noexcept
    : UIElement_ListSelection_MultipleSelection() {
    *this = ::std::move(from);
  }

  inline UIElement_ListSelection_MultipleSelection& operator=(const UIElement_ListSelection_MultipleSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListSelection_MultipleSelection& operator=(UIElement_ListSelection_MultipleSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListSelection_MultipleSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListSelection_MultipleSelection* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListSelection_MultipleSelection*>(
               &_UIElement_ListSelection_MultipleSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UIElement_ListSelection_MultipleSelection& a, UIElement_ListSelection_MultipleSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListSelection_MultipleSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListSelection_MultipleSelection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListSelection_MultipleSelection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListSelection_MultipleSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListSelection_MultipleSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListSelection_MultipleSelection& from) {
    UIElement_ListSelection_MultipleSelection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListSelection_MultipleSelection* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListSelection.MultipleSelection";
  }
  protected:
  explicit UIElement_ListSelection_MultipleSelection(::google::protobuf::Arena* arena);
  UIElement_ListSelection_MultipleSelection(::google::protobuf::Arena* arena, const UIElement_ListSelection_MultipleSelection& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.UIElement.ListSelection.SelectionFormat type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat type() const;
  void set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value);

  private:
  ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListSelection.MultipleSelection)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ButtonElement final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ButtonElement) */ {
 public:
  inline UIElement_ButtonElement() : UIElement_ButtonElement(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ButtonElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ButtonElement(const UIElement_ButtonElement& from)
      : UIElement_ButtonElement(nullptr, from) {}
  UIElement_ButtonElement(UIElement_ButtonElement&& from) noexcept
    : UIElement_ButtonElement() {
    *this = ::std::move(from);
  }

  inline UIElement_ButtonElement& operator=(const UIElement_ButtonElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ButtonElement& operator=(UIElement_ButtonElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ButtonElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ButtonElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_ButtonElement*>(
               &_UIElement_ButtonElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UIElement_ButtonElement& a, UIElement_ButtonElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ButtonElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ButtonElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ButtonElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ButtonElement>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UIElement_ButtonElement& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UIElement_ButtonElement& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ButtonElement";
  }
  protected:
  explicit UIElement_ButtonElement(::google::protobuf::Arena* arena);
  UIElement_ButtonElement(::google::protobuf::Arena* arena, const UIElement_ButtonElement& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ButtonElement)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_UserElement_UserElementInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.UserElement.UserElementInput) */ {
 public:
  inline UIElement_UserElement_UserElementInput() : UIElement_UserElement_UserElementInput(nullptr) {}
  ~UIElement_UserElement_UserElementInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_UserElement_UserElementInput(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_UserElement_UserElementInput(const UIElement_UserElement_UserElementInput& from)
      : UIElement_UserElement_UserElementInput(nullptr, from) {}
  UIElement_UserElement_UserElementInput(UIElement_UserElement_UserElementInput&& from) noexcept
    : UIElement_UserElement_UserElementInput() {
    *this = ::std::move(from);
  }

  inline UIElement_UserElement_UserElementInput& operator=(const UIElement_UserElement_UserElementInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_UserElement_UserElementInput& operator=(UIElement_UserElement_UserElementInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_UserElement_UserElementInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_UserElement_UserElementInput* internal_default_instance() {
    return reinterpret_cast<const UIElement_UserElement_UserElementInput*>(
               &_UIElement_UserElement_UserElementInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UIElement_UserElement_UserElementInput& a, UIElement_UserElement_UserElementInput& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_UserElement_UserElementInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_UserElement_UserElementInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_UserElement_UserElementInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_UserElement_UserElementInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_UserElement_UserElementInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_UserElement_UserElementInput& from) {
    UIElement_UserElement_UserElementInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_UserElement_UserElementInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.UserElement.UserElementInput";
  }
  protected:
  explicit UIElement_UserElement_UserElementInput(::google::protobuf::Arena* arena);
  UIElement_UserElement_UserElementInput(::google::protobuf::Arena* arena, const UIElement_UserElement_UserElementInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .com.zoho.common.UserField users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;

  public:
  void clear_users() ;
  ::com::zoho::common::UserField* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::common::UserField >*
      mutable_users();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::common::UserField>& _internal_users() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::common::UserField>* _internal_mutable_users();
  public:
  const ::com::zoho::common::UserField& users(int index) const;
  ::com::zoho::common::UserField* add_users();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::common::UserField >&
      users() const;
  google::protobuf::RepeatedPtrField<com::zoho::common::UserField>* temp_getusers() const {
    return const_cast<com::zoho::shapes::UIElement_UserElement_UserElementInput*>(this)->mutable_users();
  }
  
  void temp_setusers(const google::protobuf::RepeatedPtrField<com::zoho::common::UserField>* users) {
    if(this->mutable_users() != users) {
      const_cast<com::zoho::shapes::UIElement_UserElement_UserElementInput*>(this)->mutable_users()->CopyFrom(*users);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.UserElement.UserElementInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::com::zoho::common::UserField > users_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ToggleElement_ToggleInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ToggleElement.ToggleInput) */ {
 public:
  inline UIElement_ToggleElement_ToggleInput() : UIElement_ToggleElement_ToggleInput(nullptr) {}
  ~UIElement_ToggleElement_ToggleInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ToggleElement_ToggleInput(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ToggleElement_ToggleInput(const UIElement_ToggleElement_ToggleInput& from)
      : UIElement_ToggleElement_ToggleInput(nullptr, from) {}
  UIElement_ToggleElement_ToggleInput(UIElement_ToggleElement_ToggleInput&& from) noexcept
    : UIElement_ToggleElement_ToggleInput() {
    *this = ::std::move(from);
  }

  inline UIElement_ToggleElement_ToggleInput& operator=(const UIElement_ToggleElement_ToggleInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ToggleElement_ToggleInput& operator=(UIElement_ToggleElement_ToggleInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ToggleElement_ToggleInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ToggleElement_ToggleInput* internal_default_instance() {
    return reinterpret_cast<const UIElement_ToggleElement_ToggleInput*>(
               &_UIElement_ToggleElement_ToggleInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UIElement_ToggleElement_ToggleInput& a, UIElement_ToggleElement_ToggleInput& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ToggleElement_ToggleInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ToggleElement_ToggleInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ToggleElement_ToggleInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ToggleElement_ToggleInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ToggleElement_ToggleInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ToggleElement_ToggleInput& from) {
    UIElement_ToggleElement_ToggleInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ToggleElement_ToggleInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ToggleElement.ToggleInput";
  }
  protected:
  explicit UIElement_ToggleElement_ToggleInput(::google::protobuf::Arena* arena);
  UIElement_ToggleElement_ToggleInput(::google::protobuf::Arena* arena, const UIElement_ToggleElement_ToggleInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DataForState = UIElement_ToggleElement_ToggleInput_DataForState;

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 2,
    kIconFieldNumber = 3,
    kStateFieldNumber = 1,
  };
  // optional .com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState label = 2;
  bool has_label() const;
  void clear_label() ;
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& label() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* release_label();
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* mutable_label();
  void set_allocated_label(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value);
  void unsafe_arena_set_allocated_label(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value);
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* unsafe_arena_release_label();

  private:
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& _internal_label() const;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* _internal_mutable_label();

  public:
  // optional .com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState icon = 3;
  bool has_icon() const;
  void clear_icon() ;
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& icon() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* release_icon();
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* mutable_icon();
  void set_allocated_icon(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value);
  void unsafe_arena_set_allocated_icon(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value);
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* unsafe_arena_release_icon();

  private:
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& _internal_icon() const;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* _internal_mutable_icon();

  public:
  // optional bool state = 1;
  bool has_state() const;
  void clear_state() ;
  bool state() const;
  void set_state(bool value);

  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);

  public:
  void temp_setlabel(com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* label) {
    if(&this->label() != label) {
      set_allocated_label(label);
    }
  }
  
  com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* temp_getlabel() const {
    if (has_label()) 
      return (const_cast<com::zoho::shapes::UIElement_ToggleElement_ToggleInput*>(this))->mutable_label();
    return nullptr;
  }
  
  void temp_seticon(com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* icon) {
    if(&this->icon() != icon) {
      set_allocated_icon(icon);
    }
  }
  
  com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* temp_geticon() const {
    if (has_icon()) 
      return (const_cast<com::zoho::shapes::UIElement_ToggleElement_ToggleInput*>(this))->mutable_icon();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ToggleElement.ToggleInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* label_;
    ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* icon_;
    bool state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_StepperElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.StepperElement) */ {
 public:
  inline UIElement_StepperElement() : UIElement_StepperElement(nullptr) {}
  ~UIElement_StepperElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_StepperElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_StepperElement(const UIElement_StepperElement& from)
      : UIElement_StepperElement(nullptr, from) {}
  UIElement_StepperElement(UIElement_StepperElement&& from) noexcept
    : UIElement_StepperElement() {
    *this = ::std::move(from);
  }

  inline UIElement_StepperElement& operator=(const UIElement_StepperElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_StepperElement& operator=(UIElement_StepperElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_StepperElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_StepperElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_StepperElement*>(
               &_UIElement_StepperElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UIElement_StepperElement& a, UIElement_StepperElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_StepperElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_StepperElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_StepperElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_StepperElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_StepperElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_StepperElement& from) {
    UIElement_StepperElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_StepperElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.StepperElement";
  }
  protected:
  explicit UIElement_StepperElement(::google::protobuf::Arena* arena);
  UIElement_StepperElement(::google::protobuf::Arena* arena, const UIElement_StepperElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using StepperInput = UIElement_StepperElement_StepperInput;

  // accessors -------------------------------------------------------

  enum : int {
    kStepperInputFieldNumber = 1,
    kWrapValFieldNumber = 2,
  };
  // optional .com.zoho.shapes.UIElement.StepperElement.StepperInput stepperInput = 1;
  bool has_stepperinput() const;
  void clear_stepperinput() ;
  const ::com::zoho::shapes::UIElement_StepperElement_StepperInput& stepperinput() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_StepperElement_StepperInput* release_stepperinput();
  ::com::zoho::shapes::UIElement_StepperElement_StepperInput* mutable_stepperinput();
  void set_allocated_stepperinput(::com::zoho::shapes::UIElement_StepperElement_StepperInput* value);
  void unsafe_arena_set_allocated_stepperinput(::com::zoho::shapes::UIElement_StepperElement_StepperInput* value);
  ::com::zoho::shapes::UIElement_StepperElement_StepperInput* unsafe_arena_release_stepperinput();

  private:
  const ::com::zoho::shapes::UIElement_StepperElement_StepperInput& _internal_stepperinput() const;
  ::com::zoho::shapes::UIElement_StepperElement_StepperInput* _internal_mutable_stepperinput();

  public:
  // optional bool wrapVal = 2;
  bool has_wrapval() const;
  void clear_wrapval() ;
  bool wrapval() const;
  void set_wrapval(bool value);

  private:
  bool _internal_wrapval() const;
  void _internal_set_wrapval(bool value);

  public:
  void temp_setstepperInput(com::zoho::shapes::UIElement_StepperElement_StepperInput* stepperInput) {
    if(&this->stepperinput() != stepperInput) {
      set_allocated_stepperinput(stepperInput);
    }
  }
  
  com::zoho::shapes::UIElement_StepperElement_StepperInput* temp_getstepperInput() const {
    if (has_stepperinput()) 
      return (const_cast<com::zoho::shapes::UIElement_StepperElement*>(this))->mutable_stepperinput();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.StepperElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_StepperElement_StepperInput* stepperinput_;
    bool wrapval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_SliderElement_SliderInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.SliderElement.SliderInput) */ {
 public:
  inline UIElement_SliderElement_SliderInput() : UIElement_SliderElement_SliderInput(nullptr) {}
  ~UIElement_SliderElement_SliderInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_SliderElement_SliderInput(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_SliderElement_SliderInput(const UIElement_SliderElement_SliderInput& from)
      : UIElement_SliderElement_SliderInput(nullptr, from) {}
  UIElement_SliderElement_SliderInput(UIElement_SliderElement_SliderInput&& from) noexcept
    : UIElement_SliderElement_SliderInput() {
    *this = ::std::move(from);
  }

  inline UIElement_SliderElement_SliderInput& operator=(const UIElement_SliderElement_SliderInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_SliderElement_SliderInput& operator=(UIElement_SliderElement_SliderInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_SliderElement_SliderInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_SliderElement_SliderInput* internal_default_instance() {
    return reinterpret_cast<const UIElement_SliderElement_SliderInput*>(
               &_UIElement_SliderElement_SliderInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UIElement_SliderElement_SliderInput& a, UIElement_SliderElement_SliderInput& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_SliderElement_SliderInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_SliderElement_SliderInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_SliderElement_SliderInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_SliderElement_SliderInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_SliderElement_SliderInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_SliderElement_SliderInput& from) {
    UIElement_SliderElement_SliderInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_SliderElement_SliderInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.SliderElement.SliderInput";
  }
  protected:
  explicit UIElement_SliderElement_SliderInput(::google::protobuf::Arena* arena);
  UIElement_SliderElement_SliderInput(::google::protobuf::Arena* arena, const UIElement_SliderElement_SliderInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SliderInterval = UIElement_SliderElement_SliderInput_SliderInterval;

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalsFieldNumber = 3,
    kMaxValFieldNumber = 1,
    kMinValFieldNumber = 2,
    kIncrementValFieldNumber = 4,
    kDefValFieldNumber = 5,
  };
  // repeated .com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval intervals = 3;
  int intervals_size() const;
  private:
  int _internal_intervals_size() const;

  public:
  void clear_intervals() ;
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval* mutable_intervals(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval >*
      mutable_intervals();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>& _internal_intervals() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>* _internal_mutable_intervals();
  public:
  const ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval& intervals(int index) const;
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval* add_intervals();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval >&
      intervals() const;
  // optional float maxVal = 1;
  bool has_maxval() const;
  void clear_maxval() ;
  float maxval() const;
  void set_maxval(float value);

  private:
  float _internal_maxval() const;
  void _internal_set_maxval(float value);

  public:
  // optional float minVal = 2;
  bool has_minval() const;
  void clear_minval() ;
  float minval() const;
  void set_minval(float value);

  private:
  float _internal_minval() const;
  void _internal_set_minval(float value);

  public:
  // optional float incrementVal = 4;
  bool has_incrementval() const;
  void clear_incrementval() ;
  float incrementval() const;
  void set_incrementval(float value);

  private:
  float _internal_incrementval() const;
  void _internal_set_incrementval(float value);

  public:
  // optional float defVal = 5;
  bool has_defval() const;
  void clear_defval() ;
  float defval() const;
  void set_defval(float value);

  private:
  float _internal_defval() const;
  void _internal_set_defval(float value);

  public:
  google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>* temp_getintervals() const {
    return const_cast<com::zoho::shapes::UIElement_SliderElement_SliderInput*>(this)->mutable_intervals();
  }
  
  void temp_setintervals(const google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>* intervals) {
    if(this->mutable_intervals() != intervals) {
      const_cast<com::zoho::shapes::UIElement_SliderElement_SliderInput*>(this)->mutable_intervals()->CopyFrom(*intervals);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.SliderElement.SliderInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval > intervals_;
    float maxval_;
    float minval_;
    float incrementval_;
    float defval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_RatingElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.RatingElement) */ {
 public:
  inline UIElement_RatingElement() : UIElement_RatingElement(nullptr) {}
  ~UIElement_RatingElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_RatingElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_RatingElement(const UIElement_RatingElement& from)
      : UIElement_RatingElement(nullptr, from) {}
  UIElement_RatingElement(UIElement_RatingElement&& from) noexcept
    : UIElement_RatingElement() {
    *this = ::std::move(from);
  }

  inline UIElement_RatingElement& operator=(const UIElement_RatingElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_RatingElement& operator=(UIElement_RatingElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_RatingElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_RatingElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_RatingElement*>(
               &_UIElement_RatingElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UIElement_RatingElement& a, UIElement_RatingElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_RatingElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_RatingElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_RatingElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_RatingElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_RatingElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_RatingElement& from) {
    UIElement_RatingElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_RatingElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.RatingElement";
  }
  protected:
  explicit UIElement_RatingElement(::google::protobuf::Arena* arena);
  UIElement_RatingElement(::google::protobuf::Arena* arena, const UIElement_RatingElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RatingInput = UIElement_RatingElement_RatingInput;

  using RatingElementType = UIElement_RatingElement_RatingElementType;
  static constexpr RatingElementType DEFAULT_RATING_ELEMENT = UIElement_RatingElement_RatingElementType_DEFAULT_RATING_ELEMENT;
  static constexpr RatingElementType STAR = UIElement_RatingElement_RatingElementType_STAR;
  static constexpr RatingElementType HEART = UIElement_RatingElement_RatingElementType_HEART;
  static constexpr RatingElementType SMILEY = UIElement_RatingElement_RatingElementType_SMILEY;
  static inline bool RatingElementType_IsValid(int value) {
    return UIElement_RatingElement_RatingElementType_IsValid(value);
  }
  static constexpr RatingElementType RatingElementType_MIN = UIElement_RatingElement_RatingElementType_RatingElementType_MIN;
  static constexpr RatingElementType RatingElementType_MAX = UIElement_RatingElement_RatingElementType_RatingElementType_MAX;
  static constexpr int RatingElementType_ARRAYSIZE = UIElement_RatingElement_RatingElementType_RatingElementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RatingElementType_descriptor() {
    return UIElement_RatingElement_RatingElementType_descriptor();
  }
  template <typename T>
  static inline const std::string& RatingElementType_Name(T value) {
    return UIElement_RatingElement_RatingElementType_Name(value);
  }
  static inline bool RatingElementType_Parse(absl::string_view name, RatingElementType* value) {
    return UIElement_RatingElement_RatingElementType_Parse(name, value);
  }

  using RatingVariable = UIElement_RatingElement_RatingVariable;
  static constexpr RatingVariable DEFAULT_RATING_VARIABLE = UIElement_RatingElement_RatingVariable_DEFAULT_RATING_VARIABLE;
  static constexpr RatingVariable FULL = UIElement_RatingElement_RatingVariable_FULL;
  static constexpr RatingVariable HALF = UIElement_RatingElement_RatingVariable_HALF;
  static constexpr RatingVariable QUARTER = UIElement_RatingElement_RatingVariable_QUARTER;
  static inline bool RatingVariable_IsValid(int value) {
    return UIElement_RatingElement_RatingVariable_IsValid(value);
  }
  static constexpr RatingVariable RatingVariable_MIN = UIElement_RatingElement_RatingVariable_RatingVariable_MIN;
  static constexpr RatingVariable RatingVariable_MAX = UIElement_RatingElement_RatingVariable_RatingVariable_MAX;
  static constexpr int RatingVariable_ARRAYSIZE = UIElement_RatingElement_RatingVariable_RatingVariable_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RatingVariable_descriptor() {
    return UIElement_RatingElement_RatingVariable_descriptor();
  }
  template <typename T>
  static inline const std::string& RatingVariable_Name(T value) {
    return UIElement_RatingElement_RatingVariable_Name(value);
  }
  static inline bool RatingVariable_Parse(absl::string_view name, RatingVariable* value) {
    return UIElement_RatingElement_RatingVariable_Parse(name, value);
  }

  using RatingConcept = UIElement_RatingElement_RatingConcept;
  static constexpr RatingConcept DEFAULT_RATING_CONCEPT = UIElement_RatingElement_RatingConcept_DEFAULT_RATING_CONCEPT;
  static constexpr RatingConcept STATIC = UIElement_RatingElement_RatingConcept_STATIC;
  static constexpr RatingConcept ASCENDING = UIElement_RatingElement_RatingConcept_ASCENDING;
  static constexpr RatingConcept DESCENDING = UIElement_RatingElement_RatingConcept_DESCENDING;
  static inline bool RatingConcept_IsValid(int value) {
    return UIElement_RatingElement_RatingConcept_IsValid(value);
  }
  static constexpr RatingConcept RatingConcept_MIN = UIElement_RatingElement_RatingConcept_RatingConcept_MIN;
  static constexpr RatingConcept RatingConcept_MAX = UIElement_RatingElement_RatingConcept_RatingConcept_MAX;
  static constexpr int RatingConcept_ARRAYSIZE = UIElement_RatingElement_RatingConcept_RatingConcept_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RatingConcept_descriptor() {
    return UIElement_RatingElement_RatingConcept_descriptor();
  }
  template <typename T>
  static inline const std::string& RatingConcept_Name(T value) {
    return UIElement_RatingElement_RatingConcept_Name(value);
  }
  static inline bool RatingConcept_Parse(absl::string_view name, RatingConcept* value) {
    return UIElement_RatingElement_RatingConcept_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRatingInputFieldNumber = 1,
    kTypeFieldNumber = 2,
    kNumberOfItemsFieldNumber = 3,
    kAllowedVariableFieldNumber = 4,
    kRatingConceptFieldNumber = 5,
  };
  // optional .com.zoho.shapes.UIElement.RatingElement.RatingInput ratingInput = 1;
  bool has_ratinginput() const;
  void clear_ratinginput() ;
  const ::com::zoho::shapes::UIElement_RatingElement_RatingInput& ratinginput() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_RatingElement_RatingInput* release_ratinginput();
  ::com::zoho::shapes::UIElement_RatingElement_RatingInput* mutable_ratinginput();
  void set_allocated_ratinginput(::com::zoho::shapes::UIElement_RatingElement_RatingInput* value);
  void unsafe_arena_set_allocated_ratinginput(::com::zoho::shapes::UIElement_RatingElement_RatingInput* value);
  ::com::zoho::shapes::UIElement_RatingElement_RatingInput* unsafe_arena_release_ratinginput();

  private:
  const ::com::zoho::shapes::UIElement_RatingElement_RatingInput& _internal_ratinginput() const;
  ::com::zoho::shapes::UIElement_RatingElement_RatingInput* _internal_mutable_ratinginput();

  public:
  // optional .com.zoho.shapes.UIElement.RatingElement.RatingElementType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_RatingElement_RatingElementType type() const;
  void set_type(::com::zoho::shapes::UIElement_RatingElement_RatingElementType value);

  private:
  ::com::zoho::shapes::UIElement_RatingElement_RatingElementType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_RatingElement_RatingElementType value);

  public:
  // optional int32 numberOfItems = 3;
  bool has_numberofitems() const;
  void clear_numberofitems() ;
  ::int32_t numberofitems() const;
  void set_numberofitems(::int32_t value);

  private:
  ::int32_t _internal_numberofitems() const;
  void _internal_set_numberofitems(::int32_t value);

  public:
  // optional .com.zoho.shapes.UIElement.RatingElement.RatingVariable allowedVariable = 4;
  bool has_allowedvariable() const;
  void clear_allowedvariable() ;
  ::com::zoho::shapes::UIElement_RatingElement_RatingVariable allowedvariable() const;
  void set_allowedvariable(::com::zoho::shapes::UIElement_RatingElement_RatingVariable value);

  private:
  ::com::zoho::shapes::UIElement_RatingElement_RatingVariable _internal_allowedvariable() const;
  void _internal_set_allowedvariable(::com::zoho::shapes::UIElement_RatingElement_RatingVariable value);

  public:
  // optional .com.zoho.shapes.UIElement.RatingElement.RatingConcept ratingConcept = 5;
  bool has_ratingconcept() const;
  void clear_ratingconcept() ;
  ::com::zoho::shapes::UIElement_RatingElement_RatingConcept ratingconcept() const;
  void set_ratingconcept(::com::zoho::shapes::UIElement_RatingElement_RatingConcept value);

  private:
  ::com::zoho::shapes::UIElement_RatingElement_RatingConcept _internal_ratingconcept() const;
  void _internal_set_ratingconcept(::com::zoho::shapes::UIElement_RatingElement_RatingConcept value);

  public:
  void temp_setratingInput(com::zoho::shapes::UIElement_RatingElement_RatingInput* ratingInput) {
    if(&this->ratinginput() != ratingInput) {
      set_allocated_ratinginput(ratingInput);
    }
  }
  
  com::zoho::shapes::UIElement_RatingElement_RatingInput* temp_getratingInput() const {
    if (has_ratinginput()) 
      return (const_cast<com::zoho::shapes::UIElement_RatingElement*>(this))->mutable_ratinginput();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.RatingElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_RatingElement_RatingInput* ratinginput_;
    int type_;
    ::int32_t numberofitems_;
    int allowedvariable_;
    int ratingconcept_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListSelection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListSelection) */ {
 public:
  inline UIElement_ListSelection() : UIElement_ListSelection(nullptr) {}
  ~UIElement_ListSelection() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListSelection(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListSelection(const UIElement_ListSelection& from)
      : UIElement_ListSelection(nullptr, from) {}
  UIElement_ListSelection(UIElement_ListSelection&& from) noexcept
    : UIElement_ListSelection() {
    *this = ::std::move(from);
  }

  inline UIElement_ListSelection& operator=(const UIElement_ListSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListSelection& operator=(UIElement_ListSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListSelection* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListSelection*>(
               &_UIElement_ListSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UIElement_ListSelection& a, UIElement_ListSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListSelection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListSelection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListSelection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListSelection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListSelection& from) {
    UIElement_ListSelection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListSelection* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListSelection";
  }
  protected:
  explicit UIElement_ListSelection(::google::protobuf::Arena* arena);
  UIElement_ListSelection(::google::protobuf::Arena* arena, const UIElement_ListSelection& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SingleSelection = UIElement_ListSelection_SingleSelection;
  using MultipleSelection = UIElement_ListSelection_MultipleSelection;

  using SelectionFunction = UIElement_ListSelection_SelectionFunction;
  static constexpr SelectionFunction DEFAULT_FUNCTION = UIElement_ListSelection_SelectionFunction_DEFAULT_FUNCTION;
  static constexpr SelectionFunction SINGLE = UIElement_ListSelection_SelectionFunction_SINGLE;
  static constexpr SelectionFunction MULTIPLE = UIElement_ListSelection_SelectionFunction_MULTIPLE;
  static inline bool SelectionFunction_IsValid(int value) {
    return UIElement_ListSelection_SelectionFunction_IsValid(value);
  }
  static constexpr SelectionFunction SelectionFunction_MIN = UIElement_ListSelection_SelectionFunction_SelectionFunction_MIN;
  static constexpr SelectionFunction SelectionFunction_MAX = UIElement_ListSelection_SelectionFunction_SelectionFunction_MAX;
  static constexpr int SelectionFunction_ARRAYSIZE = UIElement_ListSelection_SelectionFunction_SelectionFunction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SelectionFunction_descriptor() {
    return UIElement_ListSelection_SelectionFunction_descriptor();
  }
  template <typename T>
  static inline const std::string& SelectionFunction_Name(T value) {
    return UIElement_ListSelection_SelectionFunction_Name(value);
  }
  static inline bool SelectionFunction_Parse(absl::string_view name, SelectionFunction* value) {
    return UIElement_ListSelection_SelectionFunction_Parse(name, value);
  }

  using SelectionFormat = UIElement_ListSelection_SelectionFormat;
  static constexpr SelectionFormat DEFAULT_SELECTION_FORMAT = UIElement_ListSelection_SelectionFormat_DEFAULT_SELECTION_FORMAT;
  static constexpr SelectionFormat NONE = UIElement_ListSelection_SelectionFormat_NONE;
  static constexpr SelectionFormat TICK = UIElement_ListSelection_SelectionFormat_TICK;
  static constexpr SelectionFormat SQUARE = UIElement_ListSelection_SelectionFormat_SQUARE;
  static constexpr SelectionFormat CIRCLE = UIElement_ListSelection_SelectionFormat_CIRCLE;
  static inline bool SelectionFormat_IsValid(int value) {
    return UIElement_ListSelection_SelectionFormat_IsValid(value);
  }
  static constexpr SelectionFormat SelectionFormat_MIN = UIElement_ListSelection_SelectionFormat_SelectionFormat_MIN;
  static constexpr SelectionFormat SelectionFormat_MAX = UIElement_ListSelection_SelectionFormat_SelectionFormat_MAX;
  static constexpr int SelectionFormat_ARRAYSIZE = UIElement_ListSelection_SelectionFormat_SelectionFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SelectionFormat_descriptor() {
    return UIElement_ListSelection_SelectionFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& SelectionFormat_Name(T value) {
    return UIElement_ListSelection_SelectionFormat_Name(value);
  }
  static inline bool SelectionFormat_Parse(absl::string_view name, SelectionFormat* value) {
    return UIElement_ListSelection_SelectionFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSingleFieldNumber = 2,
    kMultipleFieldNumber = 3,
    kFunctionFieldNumber = 1,
  };
  // optional .com.zoho.shapes.UIElement.ListSelection.SingleSelection single = 2;
  bool has_single() const;
  void clear_single() ;
  const ::com::zoho::shapes::UIElement_ListSelection_SingleSelection& single() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* release_single();
  ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* mutable_single();
  void set_allocated_single(::com::zoho::shapes::UIElement_ListSelection_SingleSelection* value);
  void unsafe_arena_set_allocated_single(::com::zoho::shapes::UIElement_ListSelection_SingleSelection* value);
  ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* unsafe_arena_release_single();

  private:
  const ::com::zoho::shapes::UIElement_ListSelection_SingleSelection& _internal_single() const;
  ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* _internal_mutable_single();

  public:
  // optional .com.zoho.shapes.UIElement.ListSelection.MultipleSelection multiple = 3;
  bool has_multiple() const;
  void clear_multiple() ;
  const ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection& multiple() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* release_multiple();
  ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* mutable_multiple();
  void set_allocated_multiple(::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* value);
  void unsafe_arena_set_allocated_multiple(::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* value);
  ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* unsafe_arena_release_multiple();

  private:
  const ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection& _internal_multiple() const;
  ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* _internal_mutable_multiple();

  public:
  // optional .com.zoho.shapes.UIElement.ListSelection.SelectionFunction function = 1;
  bool has_function() const;
  void clear_function() ;
  ::com::zoho::shapes::UIElement_ListSelection_SelectionFunction function() const;
  void set_function(::com::zoho::shapes::UIElement_ListSelection_SelectionFunction value);

  private:
  ::com::zoho::shapes::UIElement_ListSelection_SelectionFunction _internal_function() const;
  void _internal_set_function(::com::zoho::shapes::UIElement_ListSelection_SelectionFunction value);

  public:
  void temp_setsingle(com::zoho::shapes::UIElement_ListSelection_SingleSelection* single) {
    if(&this->single() != single) {
      set_allocated_single(single);
    }
  }
  
  com::zoho::shapes::UIElement_ListSelection_SingleSelection* temp_getsingle() const {
    if (has_single()) 
      return (const_cast<com::zoho::shapes::UIElement_ListSelection*>(this))->mutable_single();
    return nullptr;
  }
  
  void temp_setmultiple(com::zoho::shapes::UIElement_ListSelection_MultipleSelection* multiple) {
    if(&this->multiple() != multiple) {
      set_allocated_multiple(multiple);
    }
  }
  
  com::zoho::shapes::UIElement_ListSelection_MultipleSelection* temp_getmultiple() const {
    if (has_multiple()) 
      return (const_cast<com::zoho::shapes::UIElement_ListSelection*>(this))->mutable_multiple();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListSelection)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* single_;
    ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* multiple_;
    int function_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_CalendarElement_CalendarInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.CalendarElement.CalendarInput) */ {
 public:
  inline UIElement_CalendarElement_CalendarInput() : UIElement_CalendarElement_CalendarInput(nullptr) {}
  ~UIElement_CalendarElement_CalendarInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_CalendarElement_CalendarInput(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_CalendarElement_CalendarInput(const UIElement_CalendarElement_CalendarInput& from)
      : UIElement_CalendarElement_CalendarInput(nullptr, from) {}
  UIElement_CalendarElement_CalendarInput(UIElement_CalendarElement_CalendarInput&& from) noexcept
    : UIElement_CalendarElement_CalendarInput() {
    *this = ::std::move(from);
  }

  inline UIElement_CalendarElement_CalendarInput& operator=(const UIElement_CalendarElement_CalendarInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_CalendarElement_CalendarInput& operator=(UIElement_CalendarElement_CalendarInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_CalendarElement_CalendarInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_CalendarElement_CalendarInput* internal_default_instance() {
    return reinterpret_cast<const UIElement_CalendarElement_CalendarInput*>(
               &_UIElement_CalendarElement_CalendarInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UIElement_CalendarElement_CalendarInput& a, UIElement_CalendarElement_CalendarInput& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_CalendarElement_CalendarInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_CalendarElement_CalendarInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_CalendarElement_CalendarInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_CalendarElement_CalendarInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_CalendarElement_CalendarInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_CalendarElement_CalendarInput& from) {
    UIElement_CalendarElement_CalendarInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_CalendarElement_CalendarInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.CalendarElement.CalendarInput";
  }
  protected:
  explicit UIElement_CalendarElement_CalendarInput(::google::protobuf::Arena* arena);
  UIElement_CalendarElement_CalendarInput(::google::protobuf::Arena* arena, const UIElement_CalendarElement_CalendarInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDateFieldNumber = 1,
    kMaxDateFieldNumber = 2,
    kMinDateFieldNumber = 3,
  };
  // optional .com.zoho.common.Time date = 1;
  bool has_date() const;
  void clear_date() ;
  const ::com::zoho::common::Time& date() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Time* release_date();
  ::com::zoho::common::Time* mutable_date();
  void set_allocated_date(::com::zoho::common::Time* value);
  void unsafe_arena_set_allocated_date(::com::zoho::common::Time* value);
  ::com::zoho::common::Time* unsafe_arena_release_date();

  private:
  const ::com::zoho::common::Time& _internal_date() const;
  ::com::zoho::common::Time* _internal_mutable_date();

  public:
  // optional .com.zoho.common.Time maxDate = 2;
  bool has_maxdate() const;
  void clear_maxdate() ;
  const ::com::zoho::common::Time& maxdate() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Time* release_maxdate();
  ::com::zoho::common::Time* mutable_maxdate();
  void set_allocated_maxdate(::com::zoho::common::Time* value);
  void unsafe_arena_set_allocated_maxdate(::com::zoho::common::Time* value);
  ::com::zoho::common::Time* unsafe_arena_release_maxdate();

  private:
  const ::com::zoho::common::Time& _internal_maxdate() const;
  ::com::zoho::common::Time* _internal_mutable_maxdate();

  public:
  // optional .com.zoho.common.Time minDate = 3;
  bool has_mindate() const;
  void clear_mindate() ;
  const ::com::zoho::common::Time& mindate() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Time* release_mindate();
  ::com::zoho::common::Time* mutable_mindate();
  void set_allocated_mindate(::com::zoho::common::Time* value);
  void unsafe_arena_set_allocated_mindate(::com::zoho::common::Time* value);
  ::com::zoho::common::Time* unsafe_arena_release_mindate();

  private:
  const ::com::zoho::common::Time& _internal_mindate() const;
  ::com::zoho::common::Time* _internal_mutable_mindate();

  public:
  void temp_setdate(com::zoho::common::Time* date) {
    if(&this->date() != date) {
      set_allocated_date(date);
    }
  }
  
  com::zoho::common::Time* temp_getdate() const {
    if (has_date()) 
      return (const_cast<com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(this))->mutable_date();
    return nullptr;
  }
  
  void temp_setmaxDate(com::zoho::common::Time* maxDate) {
    if(&this->maxdate() != maxDate) {
      set_allocated_maxdate(maxDate);
    }
  }
  
  com::zoho::common::Time* temp_getmaxDate() const {
    if (has_maxdate()) 
      return (const_cast<com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(this))->mutable_maxdate();
    return nullptr;
  }
  
  void temp_setminDate(com::zoho::common::Time* minDate) {
    if(&this->mindate() != minDate) {
      set_allocated_mindate(minDate);
    }
  }
  
  com::zoho::common::Time* temp_getminDate() const {
    if (has_mindate()) 
      return (const_cast<com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(this))->mutable_mindate();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.CalendarElement.CalendarInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::Time* date_;
    ::com::zoho::common::Time* maxdate_;
    ::com::zoho::common::Time* mindate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ToggleElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ToggleElement) */ {
 public:
  inline UIElement_ToggleElement() : UIElement_ToggleElement(nullptr) {}
  ~UIElement_ToggleElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ToggleElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ToggleElement(const UIElement_ToggleElement& from)
      : UIElement_ToggleElement(nullptr, from) {}
  UIElement_ToggleElement(UIElement_ToggleElement&& from) noexcept
    : UIElement_ToggleElement() {
    *this = ::std::move(from);
  }

  inline UIElement_ToggleElement& operator=(const UIElement_ToggleElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ToggleElement& operator=(UIElement_ToggleElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ToggleElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ToggleElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_ToggleElement*>(
               &_UIElement_ToggleElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UIElement_ToggleElement& a, UIElement_ToggleElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ToggleElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ToggleElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ToggleElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ToggleElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ToggleElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ToggleElement& from) {
    UIElement_ToggleElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ToggleElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ToggleElement";
  }
  protected:
  explicit UIElement_ToggleElement(::google::protobuf::Arena* arena);
  UIElement_ToggleElement(::google::protobuf::Arena* arena, const UIElement_ToggleElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ToggleInput = UIElement_ToggleElement_ToggleInput;

  using ToggleElementType = UIElement_ToggleElement_ToggleElementType;
  static constexpr ToggleElementType DEFAULT_TOGGLE_ELEMENT_TYPE = UIElement_ToggleElement_ToggleElementType_DEFAULT_TOGGLE_ELEMENT_TYPE;
  static constexpr ToggleElementType CHECKBOX = UIElement_ToggleElement_ToggleElementType_CHECKBOX;
  static constexpr ToggleElementType SWITCH = UIElement_ToggleElement_ToggleElementType_SWITCH;
  static inline bool ToggleElementType_IsValid(int value) {
    return UIElement_ToggleElement_ToggleElementType_IsValid(value);
  }
  static constexpr ToggleElementType ToggleElementType_MIN = UIElement_ToggleElement_ToggleElementType_ToggleElementType_MIN;
  static constexpr ToggleElementType ToggleElementType_MAX = UIElement_ToggleElement_ToggleElementType_ToggleElementType_MAX;
  static constexpr int ToggleElementType_ARRAYSIZE = UIElement_ToggleElement_ToggleElementType_ToggleElementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ToggleElementType_descriptor() {
    return UIElement_ToggleElement_ToggleElementType_descriptor();
  }
  template <typename T>
  static inline const std::string& ToggleElementType_Name(T value) {
    return UIElement_ToggleElement_ToggleElementType_Name(value);
  }
  static inline bool ToggleElementType_Parse(absl::string_view name, ToggleElementType* value) {
    return UIElement_ToggleElement_ToggleElementType_Parse(name, value);
  }

  using LabelPosition = UIElement_ToggleElement_LabelPosition;
  static constexpr LabelPosition DEFAULT_LABEL_POSITION = UIElement_ToggleElement_LabelPosition_DEFAULT_LABEL_POSITION;
  static constexpr LabelPosition INSIDE = UIElement_ToggleElement_LabelPosition_INSIDE;
  static constexpr LabelPosition OUTSIDE = UIElement_ToggleElement_LabelPosition_OUTSIDE;
  static inline bool LabelPosition_IsValid(int value) {
    return UIElement_ToggleElement_LabelPosition_IsValid(value);
  }
  static constexpr LabelPosition LabelPosition_MIN = UIElement_ToggleElement_LabelPosition_LabelPosition_MIN;
  static constexpr LabelPosition LabelPosition_MAX = UIElement_ToggleElement_LabelPosition_LabelPosition_MAX;
  static constexpr int LabelPosition_ARRAYSIZE = UIElement_ToggleElement_LabelPosition_LabelPosition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LabelPosition_descriptor() {
    return UIElement_ToggleElement_LabelPosition_descriptor();
  }
  template <typename T>
  static inline const std::string& LabelPosition_Name(T value) {
    return UIElement_ToggleElement_LabelPosition_Name(value);
  }
  static inline bool LabelPosition_Parse(absl::string_view name, LabelPosition* value) {
    return UIElement_ToggleElement_LabelPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kToggleInputFieldNumber = 5,
    kTypeFieldNumber = 1,
    kLabelPosFieldNumber = 3,
    kLabelFieldNumber = 2,
    kIconFieldNumber = 4,
  };
  // optional .com.zoho.shapes.UIElement.ToggleElement.ToggleInput toggleInput = 5;
  bool has_toggleinput() const;
  void clear_toggleinput() ;
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput& toggleinput() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* release_toggleinput();
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* mutable_toggleinput();
  void set_allocated_toggleinput(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* value);
  void unsafe_arena_set_allocated_toggleinput(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* value);
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* unsafe_arena_release_toggleinput();

  private:
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput& _internal_toggleinput() const;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* _internal_mutable_toggleinput();

  public:
  // optional .com.zoho.shapes.UIElement.ToggleElement.ToggleElementType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType type() const;
  void set_type(::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType value);

  private:
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType value);

  public:
  // optional .com.zoho.shapes.UIElement.ToggleElement.LabelPosition labelPos = 3;
  bool has_labelpos() const;
  void clear_labelpos() ;
  ::com::zoho::shapes::UIElement_ToggleElement_LabelPosition labelpos() const;
  void set_labelpos(::com::zoho::shapes::UIElement_ToggleElement_LabelPosition value);

  private:
  ::com::zoho::shapes::UIElement_ToggleElement_LabelPosition _internal_labelpos() const;
  void _internal_set_labelpos(::com::zoho::shapes::UIElement_ToggleElement_LabelPosition value);

  public:
  // optional bool label = 2;
  bool has_label() const;
  void clear_label() ;
  bool label() const;
  void set_label(bool value);

  private:
  bool _internal_label() const;
  void _internal_set_label(bool value);

  public:
  // optional bool icon = 4;
  bool has_icon() const;
  void clear_icon() ;
  bool icon() const;
  void set_icon(bool value);

  private:
  bool _internal_icon() const;
  void _internal_set_icon(bool value);

  public:
  void temp_settoggleInput(com::zoho::shapes::UIElement_ToggleElement_ToggleInput* toggleInput) {
    if(&this->toggleinput() != toggleInput) {
      set_allocated_toggleinput(toggleInput);
    }
  }
  
  com::zoho::shapes::UIElement_ToggleElement_ToggleInput* temp_gettoggleInput() const {
    if (has_toggleinput()) 
      return (const_cast<com::zoho::shapes::UIElement_ToggleElement*>(this))->mutable_toggleinput();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ToggleElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* toggleinput_;
    int type_;
    int labelpos_;
    bool label_;
    bool icon_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_SliderElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.SliderElement) */ {
 public:
  inline UIElement_SliderElement() : UIElement_SliderElement(nullptr) {}
  ~UIElement_SliderElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_SliderElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_SliderElement(const UIElement_SliderElement& from)
      : UIElement_SliderElement(nullptr, from) {}
  UIElement_SliderElement(UIElement_SliderElement&& from) noexcept
    : UIElement_SliderElement() {
    *this = ::std::move(from);
  }

  inline UIElement_SliderElement& operator=(const UIElement_SliderElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_SliderElement& operator=(UIElement_SliderElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_SliderElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_SliderElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_SliderElement*>(
               &_UIElement_SliderElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UIElement_SliderElement& a, UIElement_SliderElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_SliderElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_SliderElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_SliderElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_SliderElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_SliderElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_SliderElement& from) {
    UIElement_SliderElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_SliderElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.SliderElement";
  }
  protected:
  explicit UIElement_SliderElement(::google::protobuf::Arena* arena);
  UIElement_SliderElement(::google::protobuf::Arena* arena, const UIElement_SliderElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SliderInput = UIElement_SliderElement_SliderInput;

  using SliderType = UIElement_SliderElement_SliderType;
  static constexpr SliderType DEFAULT_SLIDER_TYPE = UIElement_SliderElement_SliderType_DEFAULT_SLIDER_TYPE;
  static constexpr SliderType LINEAR = UIElement_SliderElement_SliderType_LINEAR;
  static constexpr SliderType CIRCULAR = UIElement_SliderElement_SliderType_CIRCULAR;
  static inline bool SliderType_IsValid(int value) {
    return UIElement_SliderElement_SliderType_IsValid(value);
  }
  static constexpr SliderType SliderType_MIN = UIElement_SliderElement_SliderType_SliderType_MIN;
  static constexpr SliderType SliderType_MAX = UIElement_SliderElement_SliderType_SliderType_MAX;
  static constexpr int SliderType_ARRAYSIZE = UIElement_SliderElement_SliderType_SliderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SliderType_descriptor() {
    return UIElement_SliderElement_SliderType_descriptor();
  }
  template <typename T>
  static inline const std::string& SliderType_Name(T value) {
    return UIElement_SliderElement_SliderType_Name(value);
  }
  static inline bool SliderType_Parse(absl::string_view name, SliderType* value) {
    return UIElement_SliderElement_SliderType_Parse(name, value);
  }

  using LinearSliderType = UIElement_SliderElement_LinearSliderType;
  static constexpr LinearSliderType DEFAULT_LINEAR_SLIDER_TYPE = UIElement_SliderElement_LinearSliderType_DEFAULT_LINEAR_SLIDER_TYPE;
  static constexpr LinearSliderType HORIZONTAL = UIElement_SliderElement_LinearSliderType_HORIZONTAL;
  static constexpr LinearSliderType VERTICAL = UIElement_SliderElement_LinearSliderType_VERTICAL;
  static inline bool LinearSliderType_IsValid(int value) {
    return UIElement_SliderElement_LinearSliderType_IsValid(value);
  }
  static constexpr LinearSliderType LinearSliderType_MIN = UIElement_SliderElement_LinearSliderType_LinearSliderType_MIN;
  static constexpr LinearSliderType LinearSliderType_MAX = UIElement_SliderElement_LinearSliderType_LinearSliderType_MAX;
  static constexpr int LinearSliderType_ARRAYSIZE = UIElement_SliderElement_LinearSliderType_LinearSliderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LinearSliderType_descriptor() {
    return UIElement_SliderElement_LinearSliderType_descriptor();
  }
  template <typename T>
  static inline const std::string& LinearSliderType_Name(T value) {
    return UIElement_SliderElement_LinearSliderType_Name(value);
  }
  static inline bool LinearSliderType_Parse(absl::string_view name, LinearSliderType* value) {
    return UIElement_SliderElement_LinearSliderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSliderInputFieldNumber = 2,
    kTypeFieldNumber = 1,
    kLinearTypeFieldNumber = 3,
  };
  // optional .com.zoho.shapes.UIElement.SliderElement.SliderInput sliderInput = 2;
  bool has_sliderinput() const;
  void clear_sliderinput() ;
  const ::com::zoho::shapes::UIElement_SliderElement_SliderInput& sliderinput() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_SliderElement_SliderInput* release_sliderinput();
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput* mutable_sliderinput();
  void set_allocated_sliderinput(::com::zoho::shapes::UIElement_SliderElement_SliderInput* value);
  void unsafe_arena_set_allocated_sliderinput(::com::zoho::shapes::UIElement_SliderElement_SliderInput* value);
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput* unsafe_arena_release_sliderinput();

  private:
  const ::com::zoho::shapes::UIElement_SliderElement_SliderInput& _internal_sliderinput() const;
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput* _internal_mutable_sliderinput();

  public:
  // optional .com.zoho.shapes.UIElement.SliderElement.SliderType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_SliderElement_SliderType type() const;
  void set_type(::com::zoho::shapes::UIElement_SliderElement_SliderType value);

  private:
  ::com::zoho::shapes::UIElement_SliderElement_SliderType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_SliderElement_SliderType value);

  public:
  // optional .com.zoho.shapes.UIElement.SliderElement.LinearSliderType linearType = 3;
  bool has_lineartype() const;
  void clear_lineartype() ;
  ::com::zoho::shapes::UIElement_SliderElement_LinearSliderType lineartype() const;
  void set_lineartype(::com::zoho::shapes::UIElement_SliderElement_LinearSliderType value);

  private:
  ::com::zoho::shapes::UIElement_SliderElement_LinearSliderType _internal_lineartype() const;
  void _internal_set_lineartype(::com::zoho::shapes::UIElement_SliderElement_LinearSliderType value);

  public:
  void temp_setsliderInput(com::zoho::shapes::UIElement_SliderElement_SliderInput* sliderInput) {
    if(&this->sliderinput() != sliderInput) {
      set_allocated_sliderinput(sliderInput);
    }
  }
  
  com::zoho::shapes::UIElement_SliderElement_SliderInput* temp_getsliderInput() const {
    if (has_sliderinput()) 
      return (const_cast<com::zoho::shapes::UIElement_SliderElement*>(this))->mutable_sliderinput();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.SliderElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_SliderElement_SliderInput* sliderinput_;
    int type_;
    int lineartype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_CalendarElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.CalendarElement) */ {
 public:
  inline UIElement_CalendarElement() : UIElement_CalendarElement(nullptr) {}
  ~UIElement_CalendarElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_CalendarElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_CalendarElement(const UIElement_CalendarElement& from)
      : UIElement_CalendarElement(nullptr, from) {}
  UIElement_CalendarElement(UIElement_CalendarElement&& from) noexcept
    : UIElement_CalendarElement() {
    *this = ::std::move(from);
  }

  inline UIElement_CalendarElement& operator=(const UIElement_CalendarElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_CalendarElement& operator=(UIElement_CalendarElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_CalendarElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_CalendarElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_CalendarElement*>(
               &_UIElement_CalendarElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UIElement_CalendarElement& a, UIElement_CalendarElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_CalendarElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_CalendarElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_CalendarElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_CalendarElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_CalendarElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_CalendarElement& from) {
    UIElement_CalendarElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_CalendarElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.CalendarElement";
  }
  protected:
  explicit UIElement_CalendarElement(::google::protobuf::Arena* arena);
  UIElement_CalendarElement(::google::protobuf::Arena* arena, const UIElement_CalendarElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CalendarInput = UIElement_CalendarElement_CalendarInput;

  using CalendarType = UIElement_CalendarElement_CalendarType;
  static constexpr CalendarType DEFAULT_CALENDAR_TYPE = UIElement_CalendarElement_CalendarType_DEFAULT_CALENDAR_TYPE;
  static constexpr CalendarType DATE_TIME_PICKER = UIElement_CalendarElement_CalendarType_DATE_TIME_PICKER;
  static constexpr CalendarType DATE_PICKER = UIElement_CalendarElement_CalendarType_DATE_PICKER;
  static inline bool CalendarType_IsValid(int value) {
    return UIElement_CalendarElement_CalendarType_IsValid(value);
  }
  static constexpr CalendarType CalendarType_MIN = UIElement_CalendarElement_CalendarType_CalendarType_MIN;
  static constexpr CalendarType CalendarType_MAX = UIElement_CalendarElement_CalendarType_CalendarType_MAX;
  static constexpr int CalendarType_ARRAYSIZE = UIElement_CalendarElement_CalendarType_CalendarType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CalendarType_descriptor() {
    return UIElement_CalendarElement_CalendarType_descriptor();
  }
  template <typename T>
  static inline const std::string& CalendarType_Name(T value) {
    return UIElement_CalendarElement_CalendarType_Name(value);
  }
  static inline bool CalendarType_Parse(absl::string_view name, CalendarType* value) {
    return UIElement_CalendarElement_CalendarType_Parse(name, value);
  }

  using DatePickerFormat = UIElement_CalendarElement_DatePickerFormat;
  static constexpr DatePickerFormat DEFAULT_DATE_PICKER_FORMAT = UIElement_CalendarElement_DatePickerFormat_DEFAULT_DATE_PICKER_FORMAT;
  static constexpr DatePickerFormat YEAR_MONTH_DAY = UIElement_CalendarElement_DatePickerFormat_YEAR_MONTH_DAY;
  static constexpr DatePickerFormat YEAR_MONTH = UIElement_CalendarElement_DatePickerFormat_YEAR_MONTH;
  static inline bool DatePickerFormat_IsValid(int value) {
    return UIElement_CalendarElement_DatePickerFormat_IsValid(value);
  }
  static constexpr DatePickerFormat DatePickerFormat_MIN = UIElement_CalendarElement_DatePickerFormat_DatePickerFormat_MIN;
  static constexpr DatePickerFormat DatePickerFormat_MAX = UIElement_CalendarElement_DatePickerFormat_DatePickerFormat_MAX;
  static constexpr int DatePickerFormat_ARRAYSIZE = UIElement_CalendarElement_DatePickerFormat_DatePickerFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DatePickerFormat_descriptor() {
    return UIElement_CalendarElement_DatePickerFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& DatePickerFormat_Name(T value) {
    return UIElement_CalendarElement_DatePickerFormat_Name(value);
  }
  static inline bool DatePickerFormat_Parse(absl::string_view name, DatePickerFormat* value) {
    return UIElement_CalendarElement_DatePickerFormat_Parse(name, value);
  }

  using TimePickerFormat = UIElement_CalendarElement_TimePickerFormat;
  static constexpr TimePickerFormat DEFAULT_TIME_PICKER_FORMAT = UIElement_CalendarElement_TimePickerFormat_DEFAULT_TIME_PICKER_FORMAT;
  static constexpr TimePickerFormat HOUR_MINUTE_SECOND = UIElement_CalendarElement_TimePickerFormat_HOUR_MINUTE_SECOND;
  static constexpr TimePickerFormat HOUR_MINUTE = UIElement_CalendarElement_TimePickerFormat_HOUR_MINUTE;
  static inline bool TimePickerFormat_IsValid(int value) {
    return UIElement_CalendarElement_TimePickerFormat_IsValid(value);
  }
  static constexpr TimePickerFormat TimePickerFormat_MIN = UIElement_CalendarElement_TimePickerFormat_TimePickerFormat_MIN;
  static constexpr TimePickerFormat TimePickerFormat_MAX = UIElement_CalendarElement_TimePickerFormat_TimePickerFormat_MAX;
  static constexpr int TimePickerFormat_ARRAYSIZE = UIElement_CalendarElement_TimePickerFormat_TimePickerFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TimePickerFormat_descriptor() {
    return UIElement_CalendarElement_TimePickerFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& TimePickerFormat_Name(T value) {
    return UIElement_CalendarElement_TimePickerFormat_Name(value);
  }
  static inline bool TimePickerFormat_Parse(absl::string_view name, TimePickerFormat* value) {
    return UIElement_CalendarElement_TimePickerFormat_Parse(name, value);
  }

  using ClockFormat = UIElement_CalendarElement_ClockFormat;
  static constexpr ClockFormat DEFAULT_TIME_FORMAT = UIElement_CalendarElement_ClockFormat_DEFAULT_TIME_FORMAT;
  static constexpr ClockFormat FULL_DAY_HOUR = UIElement_CalendarElement_ClockFormat_FULL_DAY_HOUR;
  static constexpr ClockFormat HALF_DAY_HOUR = UIElement_CalendarElement_ClockFormat_HALF_DAY_HOUR;
  static inline bool ClockFormat_IsValid(int value) {
    return UIElement_CalendarElement_ClockFormat_IsValid(value);
  }
  static constexpr ClockFormat ClockFormat_MIN = UIElement_CalendarElement_ClockFormat_ClockFormat_MIN;
  static constexpr ClockFormat ClockFormat_MAX = UIElement_CalendarElement_ClockFormat_ClockFormat_MAX;
  static constexpr int ClockFormat_ARRAYSIZE = UIElement_CalendarElement_ClockFormat_ClockFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ClockFormat_descriptor() {
    return UIElement_CalendarElement_ClockFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& ClockFormat_Name(T value) {
    return UIElement_CalendarElement_ClockFormat_Name(value);
  }
  static inline bool ClockFormat_Parse(absl::string_view name, ClockFormat* value) {
    return UIElement_CalendarElement_ClockFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCalendarInputFieldNumber = 5,
    kTypeFieldNumber = 1,
    kDateFormatFieldNumber = 2,
    kTimeFormatFieldNumber = 3,
    kClockFormatFieldNumber = 4,
  };
  // optional .com.zoho.shapes.UIElement.CalendarElement.CalendarInput calendarInput = 5;
  bool has_calendarinput() const;
  void clear_calendarinput() ;
  const ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput& calendarinput() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* release_calendarinput();
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* mutable_calendarinput();
  void set_allocated_calendarinput(::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* value);
  void unsafe_arena_set_allocated_calendarinput(::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* value);
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* unsafe_arena_release_calendarinput();

  private:
  const ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput& _internal_calendarinput() const;
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* _internal_mutable_calendarinput();

  public:
  // optional .com.zoho.shapes.UIElement.CalendarElement.CalendarType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarType type() const;
  void set_type(::com::zoho::shapes::UIElement_CalendarElement_CalendarType value);

  private:
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_CalendarElement_CalendarType value);

  public:
  // optional .com.zoho.shapes.UIElement.CalendarElement.DatePickerFormat dateFormat = 2;
  bool has_dateformat() const;
  void clear_dateformat() ;
  ::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat dateformat() const;
  void set_dateformat(::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat value);

  private:
  ::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat _internal_dateformat() const;
  void _internal_set_dateformat(::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat value);

  public:
  // optional .com.zoho.shapes.UIElement.CalendarElement.TimePickerFormat timeFormat = 3;
  bool has_timeformat() const;
  void clear_timeformat() ;
  ::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat timeformat() const;
  void set_timeformat(::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat value);

  private:
  ::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat _internal_timeformat() const;
  void _internal_set_timeformat(::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat value);

  public:
  // optional .com.zoho.shapes.UIElement.CalendarElement.ClockFormat clockFormat = 4;
  bool has_clockformat() const;
  void clear_clockformat() ;
  ::com::zoho::shapes::UIElement_CalendarElement_ClockFormat clockformat() const;
  void set_clockformat(::com::zoho::shapes::UIElement_CalendarElement_ClockFormat value);

  private:
  ::com::zoho::shapes::UIElement_CalendarElement_ClockFormat _internal_clockformat() const;
  void _internal_set_clockformat(::com::zoho::shapes::UIElement_CalendarElement_ClockFormat value);

  public:
  void temp_setcalendarInput(com::zoho::shapes::UIElement_CalendarElement_CalendarInput* calendarInput) {
    if(&this->calendarinput() != calendarInput) {
      set_allocated_calendarinput(calendarInput);
    }
  }
  
  com::zoho::shapes::UIElement_CalendarElement_CalendarInput* temp_getcalendarInput() const {
    if (has_calendarinput()) 
      return (const_cast<com::zoho::shapes::UIElement_CalendarElement*>(this))->mutable_calendarinput();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.CalendarElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* calendarinput_;
    int type_;
    int dateformat_;
    int timeformat_;
    int clockformat_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_UserElement_ProfilePicture final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.UserElement.ProfilePicture) */ {
 public:
  inline UIElement_UserElement_ProfilePicture() : UIElement_UserElement_ProfilePicture(nullptr) {}
  ~UIElement_UserElement_ProfilePicture() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_UserElement_ProfilePicture(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_UserElement_ProfilePicture(const UIElement_UserElement_ProfilePicture& from)
      : UIElement_UserElement_ProfilePicture(nullptr, from) {}
  UIElement_UserElement_ProfilePicture(UIElement_UserElement_ProfilePicture&& from) noexcept
    : UIElement_UserElement_ProfilePicture() {
    *this = ::std::move(from);
  }

  inline UIElement_UserElement_ProfilePicture& operator=(const UIElement_UserElement_ProfilePicture& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_UserElement_ProfilePicture& operator=(UIElement_UserElement_ProfilePicture&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_UserElement_ProfilePicture& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_UserElement_ProfilePicture* internal_default_instance() {
    return reinterpret_cast<const UIElement_UserElement_ProfilePicture*>(
               &_UIElement_UserElement_ProfilePicture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UIElement_UserElement_ProfilePicture& a, UIElement_UserElement_ProfilePicture& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_UserElement_ProfilePicture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_UserElement_ProfilePicture* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_UserElement_ProfilePicture* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_UserElement_ProfilePicture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_UserElement_ProfilePicture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_UserElement_ProfilePicture& from) {
    UIElement_UserElement_ProfilePicture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_UserElement_ProfilePicture* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.UserElement.ProfilePicture";
  }
  protected:
  explicit UIElement_UserElement_ProfilePicture(::google::protobuf::Arena* arena);
  UIElement_UserElement_ProfilePicture(::google::protobuf::Arena* arena, const UIElement_UserElement_ProfilePicture& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ProfilePictureType = UIElement_UserElement_ProfilePicture_ProfilePictureType;
  static constexpr ProfilePictureType UNKNOWN = UIElement_UserElement_ProfilePicture_ProfilePictureType_UNKNOWN;
  static constexpr ProfilePictureType ELLIPTICAL = UIElement_UserElement_ProfilePicture_ProfilePictureType_ELLIPTICAL;
  static constexpr ProfilePictureType RECTANGLE = UIElement_UserElement_ProfilePicture_ProfilePictureType_RECTANGLE;
  static inline bool ProfilePictureType_IsValid(int value) {
    return UIElement_UserElement_ProfilePicture_ProfilePictureType_IsValid(value);
  }
  static constexpr ProfilePictureType ProfilePictureType_MIN = UIElement_UserElement_ProfilePicture_ProfilePictureType_ProfilePictureType_MIN;
  static constexpr ProfilePictureType ProfilePictureType_MAX = UIElement_UserElement_ProfilePicture_ProfilePictureType_ProfilePictureType_MAX;
  static constexpr int ProfilePictureType_ARRAYSIZE = UIElement_UserElement_ProfilePicture_ProfilePictureType_ProfilePictureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ProfilePictureType_descriptor() {
    return UIElement_UserElement_ProfilePicture_ProfilePictureType_descriptor();
  }
  template <typename T>
  static inline const std::string& ProfilePictureType_Name(T value) {
    return UIElement_UserElement_ProfilePicture_ProfilePictureType_Name(value);
  }
  static inline bool ProfilePictureType_Parse(absl::string_view name, ProfilePictureType* value) {
    return UIElement_UserElement_ProfilePicture_ProfilePictureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.common.Dimension dim = 2;
  bool has_dim() const;
  void clear_dim() ;
  const ::com::zoho::common::Dimension& dim() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Dimension* release_dim();
  ::com::zoho::common::Dimension* mutable_dim();
  void set_allocated_dim(::com::zoho::common::Dimension* value);
  void unsafe_arena_set_allocated_dim(::com::zoho::common::Dimension* value);
  ::com::zoho::common::Dimension* unsafe_arena_release_dim();

  private:
  const ::com::zoho::common::Dimension& _internal_dim() const;
  ::com::zoho::common::Dimension* _internal_mutable_dim();

  public:
  // optional .com.zoho.shapes.UIElement.UserElement.ProfilePicture.ProfilePictureType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType type() const;
  void set_type(::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType value);

  private:
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType value);

  public:
  void temp_setdim(com::zoho::common::Dimension* dim) {
    if(&this->dim() != dim) {
      set_allocated_dim(dim);
    }
  }
  
  com::zoho::common::Dimension* temp_getdim() const {
    if (has_dim()) 
      return (const_cast<com::zoho::shapes::UIElement_UserElement_ProfilePicture*>(this))->mutable_dim();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.UserElement.ProfilePicture)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::Dimension* dim_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_LabelElement_StatusLabel_StatusSymbol final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol) */ {
 public:
  inline UIElement_LabelElement_StatusLabel_StatusSymbol() : UIElement_LabelElement_StatusLabel_StatusSymbol(nullptr) {}
  ~UIElement_LabelElement_StatusLabel_StatusSymbol() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_LabelElement_StatusLabel_StatusSymbol(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_LabelElement_StatusLabel_StatusSymbol(const UIElement_LabelElement_StatusLabel_StatusSymbol& from)
      : UIElement_LabelElement_StatusLabel_StatusSymbol(nullptr, from) {}
  UIElement_LabelElement_StatusLabel_StatusSymbol(UIElement_LabelElement_StatusLabel_StatusSymbol&& from) noexcept
    : UIElement_LabelElement_StatusLabel_StatusSymbol() {
    *this = ::std::move(from);
  }

  inline UIElement_LabelElement_StatusLabel_StatusSymbol& operator=(const UIElement_LabelElement_StatusLabel_StatusSymbol& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_LabelElement_StatusLabel_StatusSymbol& operator=(UIElement_LabelElement_StatusLabel_StatusSymbol&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_LabelElement_StatusLabel_StatusSymbol& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_LabelElement_StatusLabel_StatusSymbol* internal_default_instance() {
    return reinterpret_cast<const UIElement_LabelElement_StatusLabel_StatusSymbol*>(
               &_UIElement_LabelElement_StatusLabel_StatusSymbol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UIElement_LabelElement_StatusLabel_StatusSymbol& a, UIElement_LabelElement_StatusLabel_StatusSymbol& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_LabelElement_StatusLabel_StatusSymbol* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_LabelElement_StatusLabel_StatusSymbol* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_LabelElement_StatusLabel_StatusSymbol* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_LabelElement_StatusLabel_StatusSymbol>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_LabelElement_StatusLabel_StatusSymbol& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_LabelElement_StatusLabel_StatusSymbol& from) {
    UIElement_LabelElement_StatusLabel_StatusSymbol::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_LabelElement_StatusLabel_StatusSymbol* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol";
  }
  protected:
  explicit UIElement_LabelElement_StatusLabel_StatusSymbol(::google::protobuf::Arena* arena);
  UIElement_LabelElement_StatusLabel_StatusSymbol(::google::protobuf::Arena* arena, const UIElement_LabelElement_StatusLabel_StatusSymbol& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using StatusSymbolType = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType;
  static constexpr StatusSymbolType DEFAULT_STATUS_SYMBOL_TYPE = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_DEFAULT_STATUS_SYMBOL_TYPE;
  static constexpr StatusSymbolType CIRCLE = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_CIRCLE;
  static constexpr StatusSymbolType SQUARE = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_SQUARE;
  static constexpr StatusSymbolType STAR = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_STAR;
  static inline bool StatusSymbolType_IsValid(int value) {
    return UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_IsValid(value);
  }
  static constexpr StatusSymbolType StatusSymbolType_MIN = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_StatusSymbolType_MIN;
  static constexpr StatusSymbolType StatusSymbolType_MAX = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_StatusSymbolType_MAX;
  static constexpr int StatusSymbolType_ARRAYSIZE = UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_StatusSymbolType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StatusSymbolType_descriptor() {
    return UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_descriptor();
  }
  template <typename T>
  static inline const std::string& StatusSymbolType_Name(T value) {
    return UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_Name(value);
  }
  static inline bool StatusSymbolType_Parse(absl::string_view name, StatusSymbolType* value) {
    return UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTweaksFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.ColorTweaks tweaks = 2;
  bool has_tweaks() const;
  void clear_tweaks() ;
  const ::com::zoho::shapes::ColorTweaks& tweaks() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::ColorTweaks* release_tweaks();
  ::com::zoho::shapes::ColorTweaks* mutable_tweaks();
  void set_allocated_tweaks(::com::zoho::shapes::ColorTweaks* value);
  void unsafe_arena_set_allocated_tweaks(::com::zoho::shapes::ColorTweaks* value);
  ::com::zoho::shapes::ColorTweaks* unsafe_arena_release_tweaks();

  private:
  const ::com::zoho::shapes::ColorTweaks& _internal_tweaks() const;
  ::com::zoho::shapes::ColorTweaks* _internal_mutable_tweaks();

  public:
  // optional .com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.StatusSymbolType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType type() const;
  void set_type(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType value);

  private:
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType value);

  public:
  void temp_settweaks(com::zoho::shapes::ColorTweaks* tweaks) {
    if(&this->tweaks() != tweaks) {
      set_allocated_tweaks(tweaks);
    }
  }
  
  com::zoho::shapes::ColorTweaks* temp_gettweaks() const {
    if (has_tweaks()) 
      return (const_cast<com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol*>(this))->mutable_tweaks();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::ColorTweaks* tweaks_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_UserElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.UserElement) */ {
 public:
  inline UIElement_UserElement() : UIElement_UserElement(nullptr) {}
  ~UIElement_UserElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_UserElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_UserElement(const UIElement_UserElement& from)
      : UIElement_UserElement(nullptr, from) {}
  UIElement_UserElement(UIElement_UserElement&& from) noexcept
    : UIElement_UserElement() {
    *this = ::std::move(from);
  }

  inline UIElement_UserElement& operator=(const UIElement_UserElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_UserElement& operator=(UIElement_UserElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_UserElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_UserElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_UserElement*>(
               &_UIElement_UserElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UIElement_UserElement& a, UIElement_UserElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_UserElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_UserElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_UserElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_UserElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_UserElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_UserElement& from) {
    UIElement_UserElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_UserElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.UserElement";
  }
  protected:
  explicit UIElement_UserElement(::google::protobuf::Arena* arena);
  UIElement_UserElement(::google::protobuf::Arena* arena, const UIElement_UserElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ProfilePicture = UIElement_UserElement_ProfilePicture;
  using UserElementInput = UIElement_UserElement_UserElementInput;

  using UserElementType = UIElement_UserElement_UserElementType;
  static constexpr UserElementType UNKNOWN = UIElement_UserElement_UserElementType_UNKNOWN;
  static constexpr UserElementType PROFILE_PICTURE = UIElement_UserElement_UserElementType_PROFILE_PICTURE;
  static inline bool UserElementType_IsValid(int value) {
    return UIElement_UserElement_UserElementType_IsValid(value);
  }
  static constexpr UserElementType UserElementType_MIN = UIElement_UserElement_UserElementType_UserElementType_MIN;
  static constexpr UserElementType UserElementType_MAX = UIElement_UserElement_UserElementType_UserElementType_MAX;
  static constexpr int UserElementType_ARRAYSIZE = UIElement_UserElement_UserElementType_UserElementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UserElementType_descriptor() {
    return UIElement_UserElement_UserElementType_descriptor();
  }
  template <typename T>
  static inline const std::string& UserElementType_Name(T value) {
    return UIElement_UserElement_UserElementType_Name(value);
  }
  static inline bool UserElementType_Parse(absl::string_view name, UserElementType* value) {
    return UIElement_UserElement_UserElementType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProfilePictureFieldNumber = 2,
    kInputFieldNumber = 4,
    kTypeFieldNumber = 1,
    kMaxUsersToBeShownFieldNumber = 3,
  };
  // optional .com.zoho.shapes.UIElement.UserElement.ProfilePicture profilePicture = 2;
  bool has_profilepicture() const;
  void clear_profilepicture() ;
  const ::com::zoho::shapes::UIElement_UserElement_ProfilePicture& profilepicture() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* release_profilepicture();
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* mutable_profilepicture();
  void set_allocated_profilepicture(::com::zoho::shapes::UIElement_UserElement_ProfilePicture* value);
  void unsafe_arena_set_allocated_profilepicture(::com::zoho::shapes::UIElement_UserElement_ProfilePicture* value);
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* unsafe_arena_release_profilepicture();

  private:
  const ::com::zoho::shapes::UIElement_UserElement_ProfilePicture& _internal_profilepicture() const;
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* _internal_mutable_profilepicture();

  public:
  // optional .com.zoho.shapes.UIElement.UserElement.UserElementInput input = 4;
  bool has_input() const;
  void clear_input() ;
  const ::com::zoho::shapes::UIElement_UserElement_UserElementInput& input() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_UserElement_UserElementInput* release_input();
  ::com::zoho::shapes::UIElement_UserElement_UserElementInput* mutable_input();
  void set_allocated_input(::com::zoho::shapes::UIElement_UserElement_UserElementInput* value);
  void unsafe_arena_set_allocated_input(::com::zoho::shapes::UIElement_UserElement_UserElementInput* value);
  ::com::zoho::shapes::UIElement_UserElement_UserElementInput* unsafe_arena_release_input();

  private:
  const ::com::zoho::shapes::UIElement_UserElement_UserElementInput& _internal_input() const;
  ::com::zoho::shapes::UIElement_UserElement_UserElementInput* _internal_mutable_input();

  public:
  // optional .com.zoho.shapes.UIElement.UserElement.UserElementType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_UserElement_UserElementType type() const;
  void set_type(::com::zoho::shapes::UIElement_UserElement_UserElementType value);

  private:
  ::com::zoho::shapes::UIElement_UserElement_UserElementType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_UserElement_UserElementType value);

  public:
  // optional int32 maxUsersToBeShown = 3;
  bool has_maxuserstobeshown() const;
  void clear_maxuserstobeshown() ;
  ::int32_t maxuserstobeshown() const;
  void set_maxuserstobeshown(::int32_t value);

  private:
  ::int32_t _internal_maxuserstobeshown() const;
  void _internal_set_maxuserstobeshown(::int32_t value);

  public:
  void temp_setprofilePicture(com::zoho::shapes::UIElement_UserElement_ProfilePicture* profilePicture) {
    if(&this->profilepicture() != profilePicture) {
      set_allocated_profilepicture(profilePicture);
    }
  }
  
  com::zoho::shapes::UIElement_UserElement_ProfilePicture* temp_getprofilePicture() const {
    if (has_profilepicture()) 
      return (const_cast<com::zoho::shapes::UIElement_UserElement*>(this))->mutable_profilepicture();
    return nullptr;
  }
  
  void temp_setinput(com::zoho::shapes::UIElement_UserElement_UserElementInput* input) {
    if(&this->input() != input) {
      set_allocated_input(input);
    }
  }
  
  com::zoho::shapes::UIElement_UserElement_UserElementInput* temp_getinput() const {
    if (has_input()) 
      return (const_cast<com::zoho::shapes::UIElement_UserElement*>(this))->mutable_input();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.UserElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* profilepicture_;
    ::com::zoho::shapes::UIElement_UserElement_UserElementInput* input_;
    int type_;
    ::int32_t maxuserstobeshown_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_LabelElement_StatusLabel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.LabelElement.StatusLabel) */ {
 public:
  inline UIElement_LabelElement_StatusLabel() : UIElement_LabelElement_StatusLabel(nullptr) {}
  ~UIElement_LabelElement_StatusLabel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_LabelElement_StatusLabel(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_LabelElement_StatusLabel(const UIElement_LabelElement_StatusLabel& from)
      : UIElement_LabelElement_StatusLabel(nullptr, from) {}
  UIElement_LabelElement_StatusLabel(UIElement_LabelElement_StatusLabel&& from) noexcept
    : UIElement_LabelElement_StatusLabel() {
    *this = ::std::move(from);
  }

  inline UIElement_LabelElement_StatusLabel& operator=(const UIElement_LabelElement_StatusLabel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_LabelElement_StatusLabel& operator=(UIElement_LabelElement_StatusLabel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_LabelElement_StatusLabel& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_LabelElement_StatusLabel* internal_default_instance() {
    return reinterpret_cast<const UIElement_LabelElement_StatusLabel*>(
               &_UIElement_LabelElement_StatusLabel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UIElement_LabelElement_StatusLabel& a, UIElement_LabelElement_StatusLabel& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_LabelElement_StatusLabel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_LabelElement_StatusLabel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_LabelElement_StatusLabel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_LabelElement_StatusLabel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_LabelElement_StatusLabel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_LabelElement_StatusLabel& from) {
    UIElement_LabelElement_StatusLabel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_LabelElement_StatusLabel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.LabelElement.StatusLabel";
  }
  protected:
  explicit UIElement_LabelElement_StatusLabel(::google::protobuf::Arena* arena);
  UIElement_LabelElement_StatusLabel(::google::protobuf::Arena* arena, const UIElement_LabelElement_StatusLabel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using StatusSymbol = UIElement_LabelElement_StatusLabel_StatusSymbol;

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kSymbolFieldNumber = 2,
  };
  // optional .com.zoho.shapes.Color color = 1;
  bool has_color() const;
  void clear_color() ;
  const ::com::zoho::shapes::Color& color() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Color* release_color();
  ::com::zoho::shapes::Color* mutable_color();
  void set_allocated_color(::com::zoho::shapes::Color* value);
  void unsafe_arena_set_allocated_color(::com::zoho::shapes::Color* value);
  ::com::zoho::shapes::Color* unsafe_arena_release_color();

  private:
  const ::com::zoho::shapes::Color& _internal_color() const;
  ::com::zoho::shapes::Color* _internal_mutable_color();

  public:
  // optional .com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol symbol = 2;
  bool has_symbol() const;
  void clear_symbol() ;
  const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol& symbol() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* release_symbol();
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* mutable_symbol();
  void set_allocated_symbol(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* value);
  void unsafe_arena_set_allocated_symbol(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* value);
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* unsafe_arena_release_symbol();

  private:
  const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol& _internal_symbol() const;
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* _internal_mutable_symbol();

  public:
  void temp_setcolor(com::zoho::shapes::Color* color) {
    if(&this->color() != color) {
      set_allocated_color(color);
    }
  }
  
  com::zoho::shapes::Color* temp_getcolor() const {
    if (has_color()) 
      return (const_cast<com::zoho::shapes::UIElement_LabelElement_StatusLabel*>(this))->mutable_color();
    return nullptr;
  }
  
  void temp_setsymbol(com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* symbol) {
    if(&this->symbol() != symbol) {
      set_allocated_symbol(symbol);
    }
  }
  
  com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* temp_getsymbol() const {
    if (has_symbol()) 
      return (const_cast<com::zoho::shapes::UIElement_LabelElement_StatusLabel*>(this))->mutable_symbol();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.LabelElement.StatusLabel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::Color* color_;
    ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* symbol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_LabelElement_BGLabel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.LabelElement.BGLabel) */ {
 public:
  inline UIElement_LabelElement_BGLabel() : UIElement_LabelElement_BGLabel(nullptr) {}
  ~UIElement_LabelElement_BGLabel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_LabelElement_BGLabel(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_LabelElement_BGLabel(const UIElement_LabelElement_BGLabel& from)
      : UIElement_LabelElement_BGLabel(nullptr, from) {}
  UIElement_LabelElement_BGLabel(UIElement_LabelElement_BGLabel&& from) noexcept
    : UIElement_LabelElement_BGLabel() {
    *this = ::std::move(from);
  }

  inline UIElement_LabelElement_BGLabel& operator=(const UIElement_LabelElement_BGLabel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_LabelElement_BGLabel& operator=(UIElement_LabelElement_BGLabel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_LabelElement_BGLabel& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_LabelElement_BGLabel* internal_default_instance() {
    return reinterpret_cast<const UIElement_LabelElement_BGLabel*>(
               &_UIElement_LabelElement_BGLabel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UIElement_LabelElement_BGLabel& a, UIElement_LabelElement_BGLabel& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_LabelElement_BGLabel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_LabelElement_BGLabel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_LabelElement_BGLabel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_LabelElement_BGLabel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_LabelElement_BGLabel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_LabelElement_BGLabel& from) {
    UIElement_LabelElement_BGLabel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_LabelElement_BGLabel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.LabelElement.BGLabel";
  }
  protected:
  explicit UIElement_LabelElement_BGLabel(::google::protobuf::Arena* arena);
  UIElement_LabelElement_BGLabel(::google::protobuf::Arena* arena, const UIElement_LabelElement_BGLabel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // optional .com.zoho.shapes.Color color = 1;
  bool has_color() const;
  void clear_color() ;
  const ::com::zoho::shapes::Color& color() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Color* release_color();
  ::com::zoho::shapes::Color* mutable_color();
  void set_allocated_color(::com::zoho::shapes::Color* value);
  void unsafe_arena_set_allocated_color(::com::zoho::shapes::Color* value);
  ::com::zoho::shapes::Color* unsafe_arena_release_color();

  private:
  const ::com::zoho::shapes::Color& _internal_color() const;
  ::com::zoho::shapes::Color* _internal_mutable_color();

  public:
  void temp_setcolor(com::zoho::shapes::Color* color) {
    if(&this->color() != color) {
      set_allocated_color(color);
    }
  }
  
  com::zoho::shapes::Color* temp_getcolor() const {
    if (has_color()) 
      return (const_cast<com::zoho::shapes::UIElement_LabelElement_BGLabel*>(this))->mutable_color();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.LabelElement.BGLabel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::Color* color_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListInput_ImageList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListInput.ImageList) */ {
 public:
  inline UIElement_ListInput_ImageList() : UIElement_ListInput_ImageList(nullptr) {}
  ~UIElement_ListInput_ImageList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListInput_ImageList(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListInput_ImageList(const UIElement_ListInput_ImageList& from)
      : UIElement_ListInput_ImageList(nullptr, from) {}
  UIElement_ListInput_ImageList(UIElement_ListInput_ImageList&& from) noexcept
    : UIElement_ListInput_ImageList() {
    *this = ::std::move(from);
  }

  inline UIElement_ListInput_ImageList& operator=(const UIElement_ListInput_ImageList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListInput_ImageList& operator=(UIElement_ListInput_ImageList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListInput_ImageList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListInput_ImageList* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListInput_ImageList*>(
               &_UIElement_ListInput_ImageList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UIElement_ListInput_ImageList& a, UIElement_ListInput_ImageList& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListInput_ImageList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListInput_ImageList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListInput_ImageList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListInput_ImageList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListInput_ImageList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListInput_ImageList& from) {
    UIElement_ListInput_ImageList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListInput_ImageList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListInput.ImageList";
  }
  protected:
  explicit UIElement_ListInput_ImageList(::google::protobuf::Arena* arena);
  UIElement_ListInput_ImageList(::google::protobuf::Arena* arena, const UIElement_ListInput_ImageList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPictureFieldNumber = 1,
    kDefFieldNumber = 2,
  };
  // optional .com.zoho.shapes.PictureValue picture = 1;
  bool has_picture() const;
  void clear_picture() ;
  const ::com::zoho::shapes::PictureValue& picture() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PictureValue* release_picture();
  ::com::zoho::shapes::PictureValue* mutable_picture();
  void set_allocated_picture(::com::zoho::shapes::PictureValue* value);
  void unsafe_arena_set_allocated_picture(::com::zoho::shapes::PictureValue* value);
  ::com::zoho::shapes::PictureValue* unsafe_arena_release_picture();

  private:
  const ::com::zoho::shapes::PictureValue& _internal_picture() const;
  ::com::zoho::shapes::PictureValue* _internal_mutable_picture();

  public:
  // optional bool def = 2;
  bool has_def() const;
  void clear_def() ;
  bool def() const;
  void set_def(bool value);

  private:
  bool _internal_def() const;
  void _internal_set_def(bool value);

  public:
  void temp_setpicture(com::zoho::shapes::PictureValue* picture) {
    if(&this->picture() != picture) {
      set_allocated_picture(picture);
    }
  }
  
  com::zoho::shapes::PictureValue* temp_getpicture() const {
    if (has_picture()) 
      return (const_cast<com::zoho::shapes::UIElement_ListInput_ImageList*>(this))->mutable_picture();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListInput.ImageList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::PictureValue* picture_;
    bool def_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_LabelElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.LabelElement) */ {
 public:
  inline UIElement_LabelElement() : UIElement_LabelElement(nullptr) {}
  ~UIElement_LabelElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_LabelElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_LabelElement(const UIElement_LabelElement& from)
      : UIElement_LabelElement(nullptr, from) {}
  UIElement_LabelElement(UIElement_LabelElement&& from) noexcept
    : UIElement_LabelElement() {
    *this = ::std::move(from);
  }

  inline UIElement_LabelElement& operator=(const UIElement_LabelElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_LabelElement& operator=(UIElement_LabelElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_LabelElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_LabelElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_LabelElement*>(
               &_UIElement_LabelElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UIElement_LabelElement& a, UIElement_LabelElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_LabelElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_LabelElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_LabelElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_LabelElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_LabelElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_LabelElement& from) {
    UIElement_LabelElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_LabelElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.LabelElement";
  }
  protected:
  explicit UIElement_LabelElement(::google::protobuf::Arena* arena);
  UIElement_LabelElement(::google::protobuf::Arena* arena, const UIElement_LabelElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using BGLabel = UIElement_LabelElement_BGLabel;
  using StatusLabel = UIElement_LabelElement_StatusLabel;

  using LabelElementType = UIElement_LabelElement_LabelElementType;
  static constexpr LabelElementType DEFAULT_LABEL_ELEMENT = UIElement_LabelElement_LabelElementType_DEFAULT_LABEL_ELEMENT;
  static constexpr LabelElementType BG = UIElement_LabelElement_LabelElementType_BG;
  static constexpr LabelElementType STATUS = UIElement_LabelElement_LabelElementType_STATUS;
  static inline bool LabelElementType_IsValid(int value) {
    return UIElement_LabelElement_LabelElementType_IsValid(value);
  }
  static constexpr LabelElementType LabelElementType_MIN = UIElement_LabelElement_LabelElementType_LabelElementType_MIN;
  static constexpr LabelElementType LabelElementType_MAX = UIElement_LabelElement_LabelElementType_LabelElementType_MAX;
  static constexpr int LabelElementType_ARRAYSIZE = UIElement_LabelElement_LabelElementType_LabelElementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LabelElementType_descriptor() {
    return UIElement_LabelElement_LabelElementType_descriptor();
  }
  template <typename T>
  static inline const std::string& LabelElementType_Name(T value) {
    return UIElement_LabelElement_LabelElementType_Name(value);
  }
  static inline bool LabelElementType_Parse(absl::string_view name, LabelElementType* value) {
    return UIElement_LabelElement_LabelElementType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kBgLabelFieldNumber = 3,
    kStatusLabelFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional string text = 2;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional .com.zoho.shapes.UIElement.LabelElement.BGLabel bgLabel = 3;
  bool has_bglabel() const;
  void clear_bglabel() ;
  const ::com::zoho::shapes::UIElement_LabelElement_BGLabel& bglabel() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_LabelElement_BGLabel* release_bglabel();
  ::com::zoho::shapes::UIElement_LabelElement_BGLabel* mutable_bglabel();
  void set_allocated_bglabel(::com::zoho::shapes::UIElement_LabelElement_BGLabel* value);
  void unsafe_arena_set_allocated_bglabel(::com::zoho::shapes::UIElement_LabelElement_BGLabel* value);
  ::com::zoho::shapes::UIElement_LabelElement_BGLabel* unsafe_arena_release_bglabel();

  private:
  const ::com::zoho::shapes::UIElement_LabelElement_BGLabel& _internal_bglabel() const;
  ::com::zoho::shapes::UIElement_LabelElement_BGLabel* _internal_mutable_bglabel();

  public:
  // optional .com.zoho.shapes.UIElement.LabelElement.StatusLabel statusLabel = 4;
  bool has_statuslabel() const;
  void clear_statuslabel() ;
  const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel& statuslabel() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* release_statuslabel();
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* mutable_statuslabel();
  void set_allocated_statuslabel(::com::zoho::shapes::UIElement_LabelElement_StatusLabel* value);
  void unsafe_arena_set_allocated_statuslabel(::com::zoho::shapes::UIElement_LabelElement_StatusLabel* value);
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* unsafe_arena_release_statuslabel();

  private:
  const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel& _internal_statuslabel() const;
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* _internal_mutable_statuslabel();

  public:
  // optional .com.zoho.shapes.UIElement.LabelElement.LabelElementType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_LabelElement_LabelElementType type() const;
  void set_type(::com::zoho::shapes::UIElement_LabelElement_LabelElementType value);

  private:
  ::com::zoho::shapes::UIElement_LabelElement_LabelElementType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_LabelElement_LabelElementType value);

  public:
  void temp_setbgLabel(com::zoho::shapes::UIElement_LabelElement_BGLabel* bgLabel) {
    if(&this->bglabel() != bgLabel) {
      set_allocated_bglabel(bgLabel);
    }
  }
  
  com::zoho::shapes::UIElement_LabelElement_BGLabel* temp_getbgLabel() const {
    if (has_bglabel()) 
      return (const_cast<com::zoho::shapes::UIElement_LabelElement*>(this))->mutable_bglabel();
    return nullptr;
  }
  
  void temp_setstatusLabel(com::zoho::shapes::UIElement_LabelElement_StatusLabel* statusLabel) {
    if(&this->statuslabel() != statusLabel) {
      set_allocated_statuslabel(statusLabel);
    }
  }
  
  com::zoho::shapes::UIElement_LabelElement_StatusLabel* temp_getstatusLabel() const {
    if (has_statuslabel()) 
      return (const_cast<com::zoho::shapes::UIElement_LabelElement*>(this))->mutable_statuslabel();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.LabelElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::com::zoho::shapes::UIElement_LabelElement_BGLabel* bglabel_;
    ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* statuslabel_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListInput_TextList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListInput.TextList) */ {
 public:
  inline UIElement_ListInput_TextList() : UIElement_ListInput_TextList(nullptr) {}
  ~UIElement_ListInput_TextList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListInput_TextList(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListInput_TextList(const UIElement_ListInput_TextList& from)
      : UIElement_ListInput_TextList(nullptr, from) {}
  UIElement_ListInput_TextList(UIElement_ListInput_TextList&& from) noexcept
    : UIElement_ListInput_TextList() {
    *this = ::std::move(from);
  }

  inline UIElement_ListInput_TextList& operator=(const UIElement_ListInput_TextList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListInput_TextList& operator=(UIElement_ListInput_TextList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListInput_TextList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListInput_TextList* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListInput_TextList*>(
               &_UIElement_ListInput_TextList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UIElement_ListInput_TextList& a, UIElement_ListInput_TextList& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListInput_TextList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListInput_TextList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListInput_TextList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListInput_TextList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListInput_TextList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListInput_TextList& from) {
    UIElement_ListInput_TextList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListInput_TextList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListInput.TextList";
  }
  protected:
  explicit UIElement_ListInput_TextList(::google::protobuf::Arena* arena);
  UIElement_ListInput_TextList(::google::protobuf::Arena* arena, const UIElement_ListInput_TextList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kDefFieldNumber = 2,
  };
  // optional .com.zoho.shapes.UIElement.LabelElement label = 1;
  bool has_label() const;
  void clear_label() ;
  const ::com::zoho::shapes::UIElement_LabelElement& label() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_LabelElement* release_label();
  ::com::zoho::shapes::UIElement_LabelElement* mutable_label();
  void set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value);
  void unsafe_arena_set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value);
  ::com::zoho::shapes::UIElement_LabelElement* unsafe_arena_release_label();

  private:
  const ::com::zoho::shapes::UIElement_LabelElement& _internal_label() const;
  ::com::zoho::shapes::UIElement_LabelElement* _internal_mutable_label();

  public:
  // optional bool def = 2;
  bool has_def() const;
  void clear_def() ;
  bool def() const;
  void set_def(bool value);

  private:
  bool _internal_def() const;
  void _internal_set_def(bool value);

  public:
  void temp_setlabel(com::zoho::shapes::UIElement_LabelElement* label) {
    if(&this->label() != label) {
      set_allocated_label(label);
    }
  }
  
  com::zoho::shapes::UIElement_LabelElement* temp_getlabel() const {
    if (has_label()) 
      return (const_cast<com::zoho::shapes::UIElement_ListInput_TextList*>(this))->mutable_label();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListInput.TextList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_LabelElement* label_;
    bool def_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListInput_TextImageList_TextImageListItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem) */ {
 public:
  inline UIElement_ListInput_TextImageList_TextImageListItem() : UIElement_ListInput_TextImageList_TextImageListItem(nullptr) {}
  ~UIElement_ListInput_TextImageList_TextImageListItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListInput_TextImageList_TextImageListItem(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListInput_TextImageList_TextImageListItem(const UIElement_ListInput_TextImageList_TextImageListItem& from)
      : UIElement_ListInput_TextImageList_TextImageListItem(nullptr, from) {}
  UIElement_ListInput_TextImageList_TextImageListItem(UIElement_ListInput_TextImageList_TextImageListItem&& from) noexcept
    : UIElement_ListInput_TextImageList_TextImageListItem() {
    *this = ::std::move(from);
  }

  inline UIElement_ListInput_TextImageList_TextImageListItem& operator=(const UIElement_ListInput_TextImageList_TextImageListItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListInput_TextImageList_TextImageListItem& operator=(UIElement_ListInput_TextImageList_TextImageListItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListInput_TextImageList_TextImageListItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListInput_TextImageList_TextImageListItem* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListInput_TextImageList_TextImageListItem*>(
               &_UIElement_ListInput_TextImageList_TextImageListItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UIElement_ListInput_TextImageList_TextImageListItem& a, UIElement_ListInput_TextImageList_TextImageListItem& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListInput_TextImageList_TextImageListItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListInput_TextImageList_TextImageListItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListInput_TextImageList_TextImageListItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListInput_TextImageList_TextImageListItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListInput_TextImageList_TextImageListItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListInput_TextImageList_TextImageListItem& from) {
    UIElement_ListInput_TextImageList_TextImageListItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListInput_TextImageList_TextImageListItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem";
  }
  protected:
  explicit UIElement_ListInput_TextImageList_TextImageListItem(::google::protobuf::Arena* arena);
  UIElement_ListInput_TextImageList_TextImageListItem(::google::protobuf::Arena* arena, const UIElement_ListInput_TextImageList_TextImageListItem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kPictureFieldNumber = 2,
    kDefFieldNumber = 3,
  };
  // optional .com.zoho.shapes.UIElement.LabelElement label = 1;
  bool has_label() const;
  void clear_label() ;
  const ::com::zoho::shapes::UIElement_LabelElement& label() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_LabelElement* release_label();
  ::com::zoho::shapes::UIElement_LabelElement* mutable_label();
  void set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value);
  void unsafe_arena_set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value);
  ::com::zoho::shapes::UIElement_LabelElement* unsafe_arena_release_label();

  private:
  const ::com::zoho::shapes::UIElement_LabelElement& _internal_label() const;
  ::com::zoho::shapes::UIElement_LabelElement* _internal_mutable_label();

  public:
  // optional .com.zoho.shapes.PictureValue picture = 2;
  bool has_picture() const;
  void clear_picture() ;
  const ::com::zoho::shapes::PictureValue& picture() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::PictureValue* release_picture();
  ::com::zoho::shapes::PictureValue* mutable_picture();
  void set_allocated_picture(::com::zoho::shapes::PictureValue* value);
  void unsafe_arena_set_allocated_picture(::com::zoho::shapes::PictureValue* value);
  ::com::zoho::shapes::PictureValue* unsafe_arena_release_picture();

  private:
  const ::com::zoho::shapes::PictureValue& _internal_picture() const;
  ::com::zoho::shapes::PictureValue* _internal_mutable_picture();

  public:
  // optional bool def = 3;
  bool has_def() const;
  void clear_def() ;
  bool def() const;
  void set_def(bool value);

  private:
  bool _internal_def() const;
  void _internal_set_def(bool value);

  public:
  void temp_setlabel(com::zoho::shapes::UIElement_LabelElement* label) {
    if(&this->label() != label) {
      set_allocated_label(label);
    }
  }
  
  com::zoho::shapes::UIElement_LabelElement* temp_getlabel() const {
    if (has_label()) 
      return (const_cast<com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem*>(this))->mutable_label();
    return nullptr;
  }
  
  void temp_setpicture(com::zoho::shapes::PictureValue* picture) {
    if(&this->picture() != picture) {
      set_allocated_picture(picture);
    }
  }
  
  com::zoho::shapes::PictureValue* temp_getpicture() const {
    if (has_picture()) 
      return (const_cast<com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem*>(this))->mutable_picture();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_LabelElement* label_;
    ::com::zoho::shapes::PictureValue* picture_;
    bool def_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListInput_TextImageList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListInput.TextImageList) */ {
 public:
  inline UIElement_ListInput_TextImageList() : UIElement_ListInput_TextImageList(nullptr) {}
  ~UIElement_ListInput_TextImageList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListInput_TextImageList(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListInput_TextImageList(const UIElement_ListInput_TextImageList& from)
      : UIElement_ListInput_TextImageList(nullptr, from) {}
  UIElement_ListInput_TextImageList(UIElement_ListInput_TextImageList&& from) noexcept
    : UIElement_ListInput_TextImageList() {
    *this = ::std::move(from);
  }

  inline UIElement_ListInput_TextImageList& operator=(const UIElement_ListInput_TextImageList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListInput_TextImageList& operator=(UIElement_ListInput_TextImageList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListInput_TextImageList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListInput_TextImageList* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListInput_TextImageList*>(
               &_UIElement_ListInput_TextImageList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UIElement_ListInput_TextImageList& a, UIElement_ListInput_TextImageList& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListInput_TextImageList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListInput_TextImageList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListInput_TextImageList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListInput_TextImageList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListInput_TextImageList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListInput_TextImageList& from) {
    UIElement_ListInput_TextImageList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListInput_TextImageList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListInput.TextImageList";
  }
  protected:
  explicit UIElement_ListInput_TextImageList(::google::protobuf::Arena* arena);
  UIElement_ListInput_TextImageList(::google::protobuf::Arena* arena, const UIElement_ListInput_TextImageList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TextImageListItem = UIElement_ListInput_TextImageList_TextImageListItem;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kStartWithPictureFieldNumber = 2,
  };
  // repeated .com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>* _internal_mutable_items();
  public:
  const ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem& items(int index) const;
  ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem >&
      items() const;
  // optional bool startWithPicture = 2;
  bool has_startwithpicture() const;
  void clear_startwithpicture() ;
  bool startwithpicture() const;
  void set_startwithpicture(bool value);

  private:
  bool _internal_startwithpicture() const;
  void _internal_set_startwithpicture(bool value);

  public:
  google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>* temp_getitems() const {
    return const_cast<com::zoho::shapes::UIElement_ListInput_TextImageList*>(this)->mutable_items();
  }
  
  void temp_setitems(const google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>* items) {
    if(this->mutable_items() != items) {
      const_cast<com::zoho::shapes::UIElement_ListInput_TextImageList*>(this)->mutable_items()->CopyFrom(*items);
    }}
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListInput.TextImageList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem > items_;
    bool startwithpicture_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_ListInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.ListInput) */ {
 public:
  inline UIElement_ListInput() : UIElement_ListInput(nullptr) {}
  ~UIElement_ListInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_ListInput(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_ListInput(const UIElement_ListInput& from)
      : UIElement_ListInput(nullptr, from) {}
  UIElement_ListInput(UIElement_ListInput&& from) noexcept
    : UIElement_ListInput() {
    *this = ::std::move(from);
  }

  inline UIElement_ListInput& operator=(const UIElement_ListInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_ListInput& operator=(UIElement_ListInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_ListInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_ListInput* internal_default_instance() {
    return reinterpret_cast<const UIElement_ListInput*>(
               &_UIElement_ListInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UIElement_ListInput& a, UIElement_ListInput& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_ListInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_ListInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_ListInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_ListInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_ListInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_ListInput& from) {
    UIElement_ListInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_ListInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.ListInput";
  }
  protected:
  explicit UIElement_ListInput(::google::protobuf::Arena* arena);
  UIElement_ListInput(::google::protobuf::Arena* arena, const UIElement_ListInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TextList = UIElement_ListInput_TextList;
  using ImageList = UIElement_ListInput_ImageList;
  using TextImageList = UIElement_ListInput_TextImageList;

  using ListInputType = UIElement_ListInput_ListInputType;
  static constexpr ListInputType DEFAULT_COMBO_INPUT_TYPE = UIElement_ListInput_ListInputType_DEFAULT_COMBO_INPUT_TYPE;
  static constexpr ListInputType TEXT = UIElement_ListInput_ListInputType_TEXT;
  static constexpr ListInputType IMAGE = UIElement_ListInput_ListInputType_IMAGE;
  static constexpr ListInputType TEXT_IMAGE = UIElement_ListInput_ListInputType_TEXT_IMAGE;
  static inline bool ListInputType_IsValid(int value) {
    return UIElement_ListInput_ListInputType_IsValid(value);
  }
  static constexpr ListInputType ListInputType_MIN = UIElement_ListInput_ListInputType_ListInputType_MIN;
  static constexpr ListInputType ListInputType_MAX = UIElement_ListInput_ListInputType_ListInputType_MAX;
  static constexpr int ListInputType_ARRAYSIZE = UIElement_ListInput_ListInputType_ListInputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ListInputType_descriptor() {
    return UIElement_ListInput_ListInputType_descriptor();
  }
  template <typename T>
  static inline const std::string& ListInputType_Name(T value) {
    return UIElement_ListInput_ListInputType_Name(value);
  }
  static inline bool ListInputType_Parse(absl::string_view name, ListInputType* value) {
    return UIElement_ListInput_ListInputType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextListsFieldNumber = 2,
    kImageListsFieldNumber = 3,
    kTextImageListFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated .com.zoho.shapes.UIElement.ListInput.TextList textLists = 2;
  int textlists_size() const;
  private:
  int _internal_textlists_size() const;

  public:
  void clear_textlists() ;
  ::com::zoho::shapes::UIElement_ListInput_TextList* mutable_textlists(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_TextList >*
      mutable_textlists();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextList>& _internal_textlists() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextList>* _internal_mutable_textlists();
  public:
  const ::com::zoho::shapes::UIElement_ListInput_TextList& textlists(int index) const;
  ::com::zoho::shapes::UIElement_ListInput_TextList* add_textlists();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_TextList >&
      textlists() const;
  // repeated .com.zoho.shapes.UIElement.ListInput.ImageList imageLists = 3;
  int imagelists_size() const;
  private:
  int _internal_imagelists_size() const;

  public:
  void clear_imagelists() ;
  ::com::zoho::shapes::UIElement_ListInput_ImageList* mutable_imagelists(int index);
  ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_ImageList >*
      mutable_imagelists();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_ImageList>& _internal_imagelists() const;
  ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_ImageList>* _internal_mutable_imagelists();
  public:
  const ::com::zoho::shapes::UIElement_ListInput_ImageList& imagelists(int index) const;
  ::com::zoho::shapes::UIElement_ListInput_ImageList* add_imagelists();
  const ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_ImageList >&
      imagelists() const;
  // optional .com.zoho.shapes.UIElement.ListInput.TextImageList textImageList = 4;
  bool has_textimagelist() const;
  void clear_textimagelist() ;
  const ::com::zoho::shapes::UIElement_ListInput_TextImageList& textimagelist() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ListInput_TextImageList* release_textimagelist();
  ::com::zoho::shapes::UIElement_ListInput_TextImageList* mutable_textimagelist();
  void set_allocated_textimagelist(::com::zoho::shapes::UIElement_ListInput_TextImageList* value);
  void unsafe_arena_set_allocated_textimagelist(::com::zoho::shapes::UIElement_ListInput_TextImageList* value);
  ::com::zoho::shapes::UIElement_ListInput_TextImageList* unsafe_arena_release_textimagelist();

  private:
  const ::com::zoho::shapes::UIElement_ListInput_TextImageList& _internal_textimagelist() const;
  ::com::zoho::shapes::UIElement_ListInput_TextImageList* _internal_mutable_textimagelist();

  public:
  // optional .com.zoho.shapes.UIElement.ListInput.ListInputType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_ListInput_ListInputType type() const;
  void set_type(::com::zoho::shapes::UIElement_ListInput_ListInputType value);

  private:
  ::com::zoho::shapes::UIElement_ListInput_ListInputType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_ListInput_ListInputType value);

  public:
  google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_ListInput_TextList>* temp_gettextLists() const {
    return const_cast<com::zoho::shapes::UIElement_ListInput*>(this)->mutable_textlists();
  }
  
  void temp_settextLists(const google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_ListInput_TextList>* textLists) {
    if(this->mutable_textlists() != textLists) {
      const_cast<com::zoho::shapes::UIElement_ListInput*>(this)->mutable_textlists()->CopyFrom(*textLists);
    }}
  
  google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_ListInput_ImageList>* temp_getimageLists() const {
    return const_cast<com::zoho::shapes::UIElement_ListInput*>(this)->mutable_imagelists();
  }
  
  void temp_setimageLists(const google::protobuf::RepeatedPtrField<com::zoho::shapes::UIElement_ListInput_ImageList>* imageLists) {
    if(this->mutable_imagelists() != imageLists) {
      const_cast<com::zoho::shapes::UIElement_ListInput*>(this)->mutable_imagelists()->CopyFrom(*imageLists);
    }}
  
  void temp_settextImageList(com::zoho::shapes::UIElement_ListInput_TextImageList* textImageList) {
    if(&this->textimagelist() != textImageList) {
      set_allocated_textimagelist(textImageList);
    }
  }
  
  com::zoho::shapes::UIElement_ListInput_TextImageList* temp_gettextImageList() const {
    if (has_textimagelist()) 
      return (const_cast<com::zoho::shapes::UIElement_ListInput*>(this))->mutable_textimagelist();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.ListInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_TextList > textlists_;
    ::google::protobuf::RepeatedPtrField< ::com::zoho::shapes::UIElement_ListInput_ImageList > imagelists_;
    ::com::zoho::shapes::UIElement_ListInput_TextImageList* textimagelist_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement_SelectionElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement.SelectionElement) */ {
 public:
  inline UIElement_SelectionElement() : UIElement_SelectionElement(nullptr) {}
  ~UIElement_SelectionElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement_SelectionElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement_SelectionElement(const UIElement_SelectionElement& from)
      : UIElement_SelectionElement(nullptr, from) {}
  UIElement_SelectionElement(UIElement_SelectionElement&& from) noexcept
    : UIElement_SelectionElement() {
    *this = ::std::move(from);
  }

  inline UIElement_SelectionElement& operator=(const UIElement_SelectionElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement_SelectionElement& operator=(UIElement_SelectionElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement_SelectionElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement_SelectionElement* internal_default_instance() {
    return reinterpret_cast<const UIElement_SelectionElement*>(
               &_UIElement_SelectionElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UIElement_SelectionElement& a, UIElement_SelectionElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement_SelectionElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement_SelectionElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement_SelectionElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement_SelectionElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement_SelectionElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement_SelectionElement& from) {
    UIElement_SelectionElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement_SelectionElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement.SelectionElement";
  }
  protected:
  explicit UIElement_SelectionElement(::google::protobuf::Arena* arena);
  UIElement_SelectionElement(::google::protobuf::Arena* arena, const UIElement_SelectionElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SelectionElementType = UIElement_SelectionElement_SelectionElementType;
  static constexpr SelectionElementType DEFAULT_SELECTION_ELEMENT = UIElement_SelectionElement_SelectionElementType_DEFAULT_SELECTION_ELEMENT;
  static constexpr SelectionElementType LIST = UIElement_SelectionElement_SelectionElementType_LIST;
  static constexpr SelectionElementType COMBO = UIElement_SelectionElement_SelectionElementType_COMBO;
  static inline bool SelectionElementType_IsValid(int value) {
    return UIElement_SelectionElement_SelectionElementType_IsValid(value);
  }
  static constexpr SelectionElementType SelectionElementType_MIN = UIElement_SelectionElement_SelectionElementType_SelectionElementType_MIN;
  static constexpr SelectionElementType SelectionElementType_MAX = UIElement_SelectionElement_SelectionElementType_SelectionElementType_MAX;
  static constexpr int SelectionElementType_ARRAYSIZE = UIElement_SelectionElement_SelectionElementType_SelectionElementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SelectionElementType_descriptor() {
    return UIElement_SelectionElement_SelectionElementType_descriptor();
  }
  template <typename T>
  static inline const std::string& SelectionElementType_Name(T value) {
    return UIElement_SelectionElement_SelectionElementType_Name(value);
  }
  static inline bool SelectionElementType_Parse(absl::string_view name, SelectionElementType* value) {
    return UIElement_SelectionElement_SelectionElementType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 2,
    kSelectionInputFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.shapes.UIElement.ListSelection list = 2;
  bool has_list() const;
  void clear_list() ;
  const ::com::zoho::shapes::UIElement_ListSelection& list() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ListSelection* release_list();
  ::com::zoho::shapes::UIElement_ListSelection* mutable_list();
  void set_allocated_list(::com::zoho::shapes::UIElement_ListSelection* value);
  void unsafe_arena_set_allocated_list(::com::zoho::shapes::UIElement_ListSelection* value);
  ::com::zoho::shapes::UIElement_ListSelection* unsafe_arena_release_list();

  private:
  const ::com::zoho::shapes::UIElement_ListSelection& _internal_list() const;
  ::com::zoho::shapes::UIElement_ListSelection* _internal_mutable_list();

  public:
  // optional .com.zoho.shapes.UIElement.ListInput selectionInput = 3;
  bool has_selectioninput() const;
  void clear_selectioninput() ;
  const ::com::zoho::shapes::UIElement_ListInput& selectioninput() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ListInput* release_selectioninput();
  ::com::zoho::shapes::UIElement_ListInput* mutable_selectioninput();
  void set_allocated_selectioninput(::com::zoho::shapes::UIElement_ListInput* value);
  void unsafe_arena_set_allocated_selectioninput(::com::zoho::shapes::UIElement_ListInput* value);
  ::com::zoho::shapes::UIElement_ListInput* unsafe_arena_release_selectioninput();

  private:
  const ::com::zoho::shapes::UIElement_ListInput& _internal_selectioninput() const;
  ::com::zoho::shapes::UIElement_ListInput* _internal_mutable_selectioninput();

  public:
  // optional .com.zoho.shapes.UIElement.SelectionElement.SelectionElementType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType type() const;
  void set_type(::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType value);

  private:
  ::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType value);

  public:
  void temp_setlist(com::zoho::shapes::UIElement_ListSelection* list) {
    if(&this->list() != list) {
      set_allocated_list(list);
    }
  }
  
  com::zoho::shapes::UIElement_ListSelection* temp_getlist() const {
    if (has_list()) 
      return (const_cast<com::zoho::shapes::UIElement_SelectionElement*>(this))->mutable_list();
    return nullptr;
  }
  
  void temp_setselectionInput(com::zoho::shapes::UIElement_ListInput* selectionInput) {
    if(&this->selectioninput() != selectionInput) {
      set_allocated_selectioninput(selectionInput);
    }
  }
  
  com::zoho::shapes::UIElement_ListInput* temp_getselectionInput() const {
    if (has_selectioninput()) 
      return (const_cast<com::zoho::shapes::UIElement_SelectionElement*>(this))->mutable_selectioninput();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement.SelectionElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::shapes::UIElement_ListSelection* list_;
    ::com::zoho::shapes::UIElement_ListInput* selectioninput_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};// -------------------------------------------------------------------

class UIElement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.shapes.UIElement) */ {
 public:
  inline UIElement() : UIElement(nullptr) {}
  ~UIElement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UIElement(::google::protobuf::internal::ConstantInitialized);

  inline UIElement(const UIElement& from)
      : UIElement(nullptr, from) {}
  UIElement(UIElement&& from) noexcept
    : UIElement() {
    *this = ::std::move(from);
  }

  inline UIElement& operator=(const UIElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement& operator=(UIElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement* internal_default_instance() {
    return reinterpret_cast<const UIElement*>(
               &_UIElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UIElement& a, UIElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UIElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UIElement& from) {
    UIElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UIElement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.shapes.UIElement";
  }
  protected:
  explicit UIElement(::google::protobuf::Arena* arena);
  UIElement(::google::protobuf::Arena* arena, const UIElement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UserElement = UIElement_UserElement;
  using ListInput = UIElement_ListInput;
  using ListSelection = UIElement_ListSelection;
  using SelectionElement = UIElement_SelectionElement;
  using SliderElement = UIElement_SliderElement;
  using CalendarElement = UIElement_CalendarElement;
  using ToggleElement = UIElement_ToggleElement;
  using StepperElement = UIElement_StepperElement;
  using LabelElement = UIElement_LabelElement;
  using RatingElement = UIElement_RatingElement;
  using ButtonElement = UIElement_ButtonElement;

  using UIElementType = UIElement_UIElementType;
  static constexpr UIElementType UNKNOWN = UIElement_UIElementType_UNKNOWN;
  static constexpr UIElementType USERELEMENT = UIElement_UIElementType_USERELEMENT;
  static constexpr UIElementType SELECTIONELEMENT = UIElement_UIElementType_SELECTIONELEMENT;
  static constexpr UIElementType SLIDER = UIElement_UIElementType_SLIDER;
  static constexpr UIElementType CALENDAR = UIElement_UIElementType_CALENDAR;
  static constexpr UIElementType TOGGLE = UIElement_UIElementType_TOGGLE;
  static constexpr UIElementType STEPPER = UIElement_UIElementType_STEPPER;
  static constexpr UIElementType BUTTON = UIElement_UIElementType_BUTTON;
  static constexpr UIElementType LABEL = UIElement_UIElementType_LABEL;
  static constexpr UIElementType RATING = UIElement_UIElementType_RATING;
  static inline bool UIElementType_IsValid(int value) {
    return UIElement_UIElementType_IsValid(value);
  }
  static constexpr UIElementType UIElementType_MIN = UIElement_UIElementType_UIElementType_MIN;
  static constexpr UIElementType UIElementType_MAX = UIElement_UIElementType_UIElementType_MAX;
  static constexpr int UIElementType_ARRAYSIZE = UIElement_UIElementType_UIElementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UIElementType_descriptor() {
    return UIElement_UIElementType_descriptor();
  }
  template <typename T>
  static inline const std::string& UIElementType_Name(T value) {
    return UIElement_UIElementType_Name(value);
  }
  static inline bool UIElementType_Parse(absl::string_view name, UIElementType* value) {
    return UIElement_UIElementType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 2,
    kUserElementFieldNumber = 3,
    kSelectionElementFieldNumber = 4,
    kSliderElementFieldNumber = 5,
    kCalendarElementFieldNumber = 6,
    kToggleElementFieldNumber = 7,
    kStepperElementFieldNumber = 8,
    kLabelElementFieldNumber = 9,
    kRatingElementFieldNumber = 10,
    kButtonElementFieldNumber = 11,
    kTypeFieldNumber = 1,
  };
  // optional .com.zoho.common.Dimension dim = 2;
  bool has_dim() const;
  void clear_dim() ;
  const ::com::zoho::common::Dimension& dim() const;
  PROTOBUF_NODISCARD ::com::zoho::common::Dimension* release_dim();
  ::com::zoho::common::Dimension* mutable_dim();
  void set_allocated_dim(::com::zoho::common::Dimension* value);
  void unsafe_arena_set_allocated_dim(::com::zoho::common::Dimension* value);
  ::com::zoho::common::Dimension* unsafe_arena_release_dim();

  private:
  const ::com::zoho::common::Dimension& _internal_dim() const;
  ::com::zoho::common::Dimension* _internal_mutable_dim();

  public:
  // optional .com.zoho.shapes.UIElement.UserElement userElement = 3;
  bool has_userelement() const;
  void clear_userelement() ;
  const ::com::zoho::shapes::UIElement_UserElement& userelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_UserElement* release_userelement();
  ::com::zoho::shapes::UIElement_UserElement* mutable_userelement();
  void set_allocated_userelement(::com::zoho::shapes::UIElement_UserElement* value);
  void unsafe_arena_set_allocated_userelement(::com::zoho::shapes::UIElement_UserElement* value);
  ::com::zoho::shapes::UIElement_UserElement* unsafe_arena_release_userelement();

  private:
  const ::com::zoho::shapes::UIElement_UserElement& _internal_userelement() const;
  ::com::zoho::shapes::UIElement_UserElement* _internal_mutable_userelement();

  public:
  // optional .com.zoho.shapes.UIElement.SelectionElement selectionElement = 4;
  bool has_selectionelement() const;
  void clear_selectionelement() ;
  const ::com::zoho::shapes::UIElement_SelectionElement& selectionelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_SelectionElement* release_selectionelement();
  ::com::zoho::shapes::UIElement_SelectionElement* mutable_selectionelement();
  void set_allocated_selectionelement(::com::zoho::shapes::UIElement_SelectionElement* value);
  void unsafe_arena_set_allocated_selectionelement(::com::zoho::shapes::UIElement_SelectionElement* value);
  ::com::zoho::shapes::UIElement_SelectionElement* unsafe_arena_release_selectionelement();

  private:
  const ::com::zoho::shapes::UIElement_SelectionElement& _internal_selectionelement() const;
  ::com::zoho::shapes::UIElement_SelectionElement* _internal_mutable_selectionelement();

  public:
  // optional .com.zoho.shapes.UIElement.SliderElement sliderElement = 5;
  bool has_sliderelement() const;
  void clear_sliderelement() ;
  const ::com::zoho::shapes::UIElement_SliderElement& sliderelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_SliderElement* release_sliderelement();
  ::com::zoho::shapes::UIElement_SliderElement* mutable_sliderelement();
  void set_allocated_sliderelement(::com::zoho::shapes::UIElement_SliderElement* value);
  void unsafe_arena_set_allocated_sliderelement(::com::zoho::shapes::UIElement_SliderElement* value);
  ::com::zoho::shapes::UIElement_SliderElement* unsafe_arena_release_sliderelement();

  private:
  const ::com::zoho::shapes::UIElement_SliderElement& _internal_sliderelement() const;
  ::com::zoho::shapes::UIElement_SliderElement* _internal_mutable_sliderelement();

  public:
  // optional .com.zoho.shapes.UIElement.CalendarElement calendarElement = 6;
  bool has_calendarelement() const;
  void clear_calendarelement() ;
  const ::com::zoho::shapes::UIElement_CalendarElement& calendarelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_CalendarElement* release_calendarelement();
  ::com::zoho::shapes::UIElement_CalendarElement* mutable_calendarelement();
  void set_allocated_calendarelement(::com::zoho::shapes::UIElement_CalendarElement* value);
  void unsafe_arena_set_allocated_calendarelement(::com::zoho::shapes::UIElement_CalendarElement* value);
  ::com::zoho::shapes::UIElement_CalendarElement* unsafe_arena_release_calendarelement();

  private:
  const ::com::zoho::shapes::UIElement_CalendarElement& _internal_calendarelement() const;
  ::com::zoho::shapes::UIElement_CalendarElement* _internal_mutable_calendarelement();

  public:
  // optional .com.zoho.shapes.UIElement.ToggleElement toggleElement = 7;
  bool has_toggleelement() const;
  void clear_toggleelement() ;
  const ::com::zoho::shapes::UIElement_ToggleElement& toggleelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ToggleElement* release_toggleelement();
  ::com::zoho::shapes::UIElement_ToggleElement* mutable_toggleelement();
  void set_allocated_toggleelement(::com::zoho::shapes::UIElement_ToggleElement* value);
  void unsafe_arena_set_allocated_toggleelement(::com::zoho::shapes::UIElement_ToggleElement* value);
  ::com::zoho::shapes::UIElement_ToggleElement* unsafe_arena_release_toggleelement();

  private:
  const ::com::zoho::shapes::UIElement_ToggleElement& _internal_toggleelement() const;
  ::com::zoho::shapes::UIElement_ToggleElement* _internal_mutable_toggleelement();

  public:
  // optional .com.zoho.shapes.UIElement.StepperElement stepperElement = 8;
  bool has_stepperelement() const;
  void clear_stepperelement() ;
  const ::com::zoho::shapes::UIElement_StepperElement& stepperelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_StepperElement* release_stepperelement();
  ::com::zoho::shapes::UIElement_StepperElement* mutable_stepperelement();
  void set_allocated_stepperelement(::com::zoho::shapes::UIElement_StepperElement* value);
  void unsafe_arena_set_allocated_stepperelement(::com::zoho::shapes::UIElement_StepperElement* value);
  ::com::zoho::shapes::UIElement_StepperElement* unsafe_arena_release_stepperelement();

  private:
  const ::com::zoho::shapes::UIElement_StepperElement& _internal_stepperelement() const;
  ::com::zoho::shapes::UIElement_StepperElement* _internal_mutable_stepperelement();

  public:
  // optional .com.zoho.shapes.UIElement.LabelElement labelElement = 9;
  bool has_labelelement() const;
  void clear_labelelement() ;
  const ::com::zoho::shapes::UIElement_LabelElement& labelelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_LabelElement* release_labelelement();
  ::com::zoho::shapes::UIElement_LabelElement* mutable_labelelement();
  void set_allocated_labelelement(::com::zoho::shapes::UIElement_LabelElement* value);
  void unsafe_arena_set_allocated_labelelement(::com::zoho::shapes::UIElement_LabelElement* value);
  ::com::zoho::shapes::UIElement_LabelElement* unsafe_arena_release_labelelement();

  private:
  const ::com::zoho::shapes::UIElement_LabelElement& _internal_labelelement() const;
  ::com::zoho::shapes::UIElement_LabelElement* _internal_mutable_labelelement();

  public:
  // optional .com.zoho.shapes.UIElement.RatingElement ratingElement = 10;
  bool has_ratingelement() const;
  void clear_ratingelement() ;
  const ::com::zoho::shapes::UIElement_RatingElement& ratingelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_RatingElement* release_ratingelement();
  ::com::zoho::shapes::UIElement_RatingElement* mutable_ratingelement();
  void set_allocated_ratingelement(::com::zoho::shapes::UIElement_RatingElement* value);
  void unsafe_arena_set_allocated_ratingelement(::com::zoho::shapes::UIElement_RatingElement* value);
  ::com::zoho::shapes::UIElement_RatingElement* unsafe_arena_release_ratingelement();

  private:
  const ::com::zoho::shapes::UIElement_RatingElement& _internal_ratingelement() const;
  ::com::zoho::shapes::UIElement_RatingElement* _internal_mutable_ratingelement();

  public:
  // optional .com.zoho.shapes.UIElement.ButtonElement buttonElement = 11;
  bool has_buttonelement() const;
  void clear_buttonelement() ;
  const ::com::zoho::shapes::UIElement_ButtonElement& buttonelement() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::UIElement_ButtonElement* release_buttonelement();
  ::com::zoho::shapes::UIElement_ButtonElement* mutable_buttonelement();
  void set_allocated_buttonelement(::com::zoho::shapes::UIElement_ButtonElement* value);
  void unsafe_arena_set_allocated_buttonelement(::com::zoho::shapes::UIElement_ButtonElement* value);
  ::com::zoho::shapes::UIElement_ButtonElement* unsafe_arena_release_buttonelement();

  private:
  const ::com::zoho::shapes::UIElement_ButtonElement& _internal_buttonelement() const;
  ::com::zoho::shapes::UIElement_ButtonElement* _internal_mutable_buttonelement();

  public:
  // optional .com.zoho.shapes.UIElement.UIElementType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::shapes::UIElement_UIElementType type() const;
  void set_type(::com::zoho::shapes::UIElement_UIElementType value);

  private:
  ::com::zoho::shapes::UIElement_UIElementType _internal_type() const;
  void _internal_set_type(::com::zoho::shapes::UIElement_UIElementType value);

  public:
  void temp_setdim(com::zoho::common::Dimension* dim) {
    if(&this->dim() != dim) {
      set_allocated_dim(dim);
    }
  }
  
  com::zoho::common::Dimension* temp_getdim() const {
    if (has_dim()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_dim();
    return nullptr;
  }
  
  void temp_setuserElement(com::zoho::shapes::UIElement_UserElement* userElement) {
    if(&this->userelement() != userElement) {
      set_allocated_userelement(userElement);
    }
  }
  
  com::zoho::shapes::UIElement_UserElement* temp_getuserElement() const {
    if (has_userelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_userelement();
    return nullptr;
  }
  
  void temp_setselectionElement(com::zoho::shapes::UIElement_SelectionElement* selectionElement) {
    if(&this->selectionelement() != selectionElement) {
      set_allocated_selectionelement(selectionElement);
    }
  }
  
  com::zoho::shapes::UIElement_SelectionElement* temp_getselectionElement() const {
    if (has_selectionelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_selectionelement();
    return nullptr;
  }
  
  void temp_setsliderElement(com::zoho::shapes::UIElement_SliderElement* sliderElement) {
    if(&this->sliderelement() != sliderElement) {
      set_allocated_sliderelement(sliderElement);
    }
  }
  
  com::zoho::shapes::UIElement_SliderElement* temp_getsliderElement() const {
    if (has_sliderelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_sliderelement();
    return nullptr;
  }
  
  void temp_setcalendarElement(com::zoho::shapes::UIElement_CalendarElement* calendarElement) {
    if(&this->calendarelement() != calendarElement) {
      set_allocated_calendarelement(calendarElement);
    }
  }
  
  com::zoho::shapes::UIElement_CalendarElement* temp_getcalendarElement() const {
    if (has_calendarelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_calendarelement();
    return nullptr;
  }
  
  void temp_settoggleElement(com::zoho::shapes::UIElement_ToggleElement* toggleElement) {
    if(&this->toggleelement() != toggleElement) {
      set_allocated_toggleelement(toggleElement);
    }
  }
  
  com::zoho::shapes::UIElement_ToggleElement* temp_gettoggleElement() const {
    if (has_toggleelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_toggleelement();
    return nullptr;
  }
  
  void temp_setstepperElement(com::zoho::shapes::UIElement_StepperElement* stepperElement) {
    if(&this->stepperelement() != stepperElement) {
      set_allocated_stepperelement(stepperElement);
    }
  }
  
  com::zoho::shapes::UIElement_StepperElement* temp_getstepperElement() const {
    if (has_stepperelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_stepperelement();
    return nullptr;
  }
  
  void temp_setlabelElement(com::zoho::shapes::UIElement_LabelElement* labelElement) {
    if(&this->labelelement() != labelElement) {
      set_allocated_labelelement(labelElement);
    }
  }
  
  com::zoho::shapes::UIElement_LabelElement* temp_getlabelElement() const {
    if (has_labelelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_labelelement();
    return nullptr;
  }
  
  void temp_setratingElement(com::zoho::shapes::UIElement_RatingElement* ratingElement) {
    if(&this->ratingelement() != ratingElement) {
      set_allocated_ratingelement(ratingElement);
    }
  }
  
  com::zoho::shapes::UIElement_RatingElement* temp_getratingElement() const {
    if (has_ratingelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_ratingelement();
    return nullptr;
  }
  
  void temp_setbuttonElement(com::zoho::shapes::UIElement_ButtonElement* buttonElement) {
    if(&this->buttonelement() != buttonElement) {
      set_allocated_buttonelement(buttonElement);
    }
  }
  
  com::zoho::shapes::UIElement_ButtonElement* temp_getbuttonElement() const {
    if (has_buttonelement()) 
      return (const_cast<com::zoho::shapes::UIElement*>(this))->mutable_buttonelement();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.shapes.UIElement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 10,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::common::Dimension* dim_;
    ::com::zoho::shapes::UIElement_UserElement* userelement_;
    ::com::zoho::shapes::UIElement_SelectionElement* selectionelement_;
    ::com::zoho::shapes::UIElement_SliderElement* sliderelement_;
    ::com::zoho::shapes::UIElement_CalendarElement* calendarelement_;
    ::com::zoho::shapes::UIElement_ToggleElement* toggleelement_;
    ::com::zoho::shapes::UIElement_StepperElement* stepperelement_;
    ::com::zoho::shapes::UIElement_LabelElement* labelelement_;
    ::com::zoho::shapes::UIElement_RatingElement* ratingelement_;
    ::com::zoho::shapes::UIElement_ButtonElement* buttonelement_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uielement_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UIElement_UserElement_ProfilePicture

// optional .com.zoho.shapes.UIElement.UserElement.ProfilePicture.ProfilePictureType type = 1;
inline bool UIElement_UserElement_ProfilePicture::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_UserElement_ProfilePicture::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType UIElement_UserElement_ProfilePicture::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.UserElement.ProfilePicture.type)
  return _internal_type();
}
inline void UIElement_UserElement_ProfilePicture::set_type(::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.UserElement.ProfilePicture.type)
}
inline ::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType UIElement_UserElement_ProfilePicture::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType>(_impl_.type_);
}
inline void UIElement_UserElement_ProfilePicture::_internal_set_type(::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .com.zoho.common.Dimension dim = 2;
inline bool UIElement_UserElement_ProfilePicture::has_dim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dim_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Dimension& UIElement_UserElement_ProfilePicture::_internal_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Dimension* p = _impl_.dim_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Dimension&>(::com::zoho::common::_Dimension_default_instance_);
}
inline const ::com::zoho::common::Dimension& UIElement_UserElement_ProfilePicture::dim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.UserElement.ProfilePicture.dim)
  return _internal_dim();
}
inline void UIElement_UserElement_ProfilePicture::unsafe_arena_set_allocated_dim(::com::zoho::common::Dimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dim_);
  }
  _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.UserElement.ProfilePicture.dim)
}
inline ::com::zoho::common::Dimension* UIElement_UserElement_ProfilePicture::release_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* released = _impl_.dim_;
  _impl_.dim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Dimension* UIElement_UserElement_ProfilePicture::unsafe_arena_release_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.UserElement.ProfilePicture.dim)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Dimension* UIElement_UserElement_ProfilePicture::_internal_mutable_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dim_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Dimension>(GetArena());
    _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(p);
  }
  return _impl_.dim_;
}
inline ::com::zoho::common::Dimension* UIElement_UserElement_ProfilePicture::mutable_dim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Dimension* _msg = _internal_mutable_dim();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.UserElement.ProfilePicture.dim)
  return _msg;
}
inline void UIElement_UserElement_ProfilePicture::set_allocated_dim(::com::zoho::common::Dimension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.UserElement.ProfilePicture.dim)
}

// -------------------------------------------------------------------

// UIElement_UserElement_UserElementInput

// repeated .com.zoho.common.UserField users = 1;
inline int UIElement_UserElement_UserElementInput::_internal_users_size() const {
  return _internal_users().size();
}
inline int UIElement_UserElement_UserElementInput::users_size() const {
  return _internal_users_size();
}
inline ::com::zoho::common::UserField* UIElement_UserElement_UserElementInput::mutable_users(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.UserElement.UserElementInput.users)
  return _internal_mutable_users()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::common::UserField>* UIElement_UserElement_UserElementInput::mutable_users()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.UIElement.UserElement.UserElementInput.users)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_users();
}
inline const ::com::zoho::common::UserField& UIElement_UserElement_UserElementInput::users(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.UserElement.UserElementInput.users)
  return _internal_users().Get(index);
}
inline ::com::zoho::common::UserField* UIElement_UserElement_UserElementInput::add_users() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::common::UserField* _add = _internal_mutable_users()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.UIElement.UserElement.UserElementInput.users)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::common::UserField>& UIElement_UserElement_UserElementInput::users() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.UIElement.UserElement.UserElementInput.users)
  return _internal_users();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::common::UserField>&
UIElement_UserElement_UserElementInput::_internal_users() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.users_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::common::UserField>*
UIElement_UserElement_UserElementInput::_internal_mutable_users() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.users_;
}

// -------------------------------------------------------------------

// UIElement_UserElement

// optional .com.zoho.shapes.UIElement.UserElement.UserElementType type = 1;
inline bool UIElement_UserElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_UserElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::shapes::UIElement_UserElement_UserElementType UIElement_UserElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.UserElement.type)
  return _internal_type();
}
inline void UIElement_UserElement::set_type(::com::zoho::shapes::UIElement_UserElement_UserElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.UserElement.type)
}
inline ::com::zoho::shapes::UIElement_UserElement_UserElementType UIElement_UserElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_UserElement_UserElementType>(_impl_.type_);
}
inline void UIElement_UserElement::_internal_set_type(::com::zoho::shapes::UIElement_UserElement_UserElementType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.UIElement.UserElement.ProfilePicture profilePicture = 2;
inline bool UIElement_UserElement::has_profilepicture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profilepicture_ != nullptr);
  return value;
}
inline void UIElement_UserElement::clear_profilepicture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.profilepicture_ != nullptr) _impl_.profilepicture_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_UserElement_ProfilePicture& UIElement_UserElement::_internal_profilepicture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* p = _impl_.profilepicture_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_UserElement_ProfilePicture&>(::com::zoho::shapes::_UIElement_UserElement_ProfilePicture_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_UserElement_ProfilePicture& UIElement_UserElement::profilepicture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.UserElement.profilePicture)
  return _internal_profilepicture();
}
inline void UIElement_UserElement::unsafe_arena_set_allocated_profilepicture(::com::zoho::shapes::UIElement_UserElement_ProfilePicture* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.profilepicture_);
  }
  _impl_.profilepicture_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_ProfilePicture*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.UserElement.profilePicture)
}
inline ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* UIElement_UserElement::release_profilepicture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* released = _impl_.profilepicture_;
  _impl_.profilepicture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* UIElement_UserElement::unsafe_arena_release_profilepicture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.UserElement.profilePicture)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* temp = _impl_.profilepicture_;
  _impl_.profilepicture_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* UIElement_UserElement::_internal_mutable_profilepicture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.profilepicture_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_UserElement_ProfilePicture>(GetArena());
    _impl_.profilepicture_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_ProfilePicture*>(p);
  }
  return _impl_.profilepicture_;
}
inline ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* UIElement_UserElement::mutable_profilepicture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_UserElement_ProfilePicture* _msg = _internal_mutable_profilepicture();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.UserElement.profilePicture)
  return _msg;
}
inline void UIElement_UserElement::set_allocated_profilepicture(::com::zoho::shapes::UIElement_UserElement_ProfilePicture* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_ProfilePicture*>(_impl_.profilepicture_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_ProfilePicture*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.profilepicture_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_ProfilePicture*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.UserElement.profilePicture)
}

// optional int32 maxUsersToBeShown = 3;
inline bool UIElement_UserElement::has_maxuserstobeshown() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UIElement_UserElement::clear_maxuserstobeshown() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxuserstobeshown_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t UIElement_UserElement::maxuserstobeshown() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.UserElement.maxUsersToBeShown)
  return _internal_maxuserstobeshown();
}
inline void UIElement_UserElement::set_maxuserstobeshown(::int32_t value) {
  _internal_set_maxuserstobeshown(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.UserElement.maxUsersToBeShown)
}
inline ::int32_t UIElement_UserElement::_internal_maxuserstobeshown() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxuserstobeshown_;
}
inline void UIElement_UserElement::_internal_set_maxuserstobeshown(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.maxuserstobeshown_ = value;
}

// optional .com.zoho.shapes.UIElement.UserElement.UserElementInput input = 4;
inline bool UIElement_UserElement::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void UIElement_UserElement::clear_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::UIElement_UserElement_UserElementInput& UIElement_UserElement::_internal_input() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_UserElement_UserElementInput* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_UserElement_UserElementInput&>(::com::zoho::shapes::_UIElement_UserElement_UserElementInput_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_UserElement_UserElementInput& UIElement_UserElement::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.UserElement.input)
  return _internal_input();
}
inline void UIElement_UserElement::unsafe_arena_set_allocated_input(::com::zoho::shapes::UIElement_UserElement_UserElementInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_UserElementInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.UserElement.input)
}
inline ::com::zoho::shapes::UIElement_UserElement_UserElementInput* UIElement_UserElement::release_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_UserElement_UserElementInput* released = _impl_.input_;
  _impl_.input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_UserElement_UserElementInput* UIElement_UserElement::unsafe_arena_release_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.UserElement.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_UserElement_UserElementInput* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_UserElement_UserElementInput* UIElement_UserElement::_internal_mutable_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.input_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_UserElement_UserElementInput>(GetArena());
    _impl_.input_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_UserElementInput*>(p);
  }
  return _impl_.input_;
}
inline ::com::zoho::shapes::UIElement_UserElement_UserElementInput* UIElement_UserElement::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_UserElement_UserElementInput* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.UserElement.input)
  return _msg;
}
inline void UIElement_UserElement::set_allocated_input(::com::zoho::shapes::UIElement_UserElement_UserElementInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_UserElementInput*>(_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_UserElementInput*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement_UserElementInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.UserElement.input)
}

// -------------------------------------------------------------------

// UIElement_ListInput_TextList

// optional .com.zoho.shapes.UIElement.LabelElement label = 1;
inline bool UIElement_ListInput_TextList::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.label_ != nullptr);
  return value;
}
inline void UIElement_ListInput_TextList::clear_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.label_ != nullptr) _impl_.label_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_LabelElement& UIElement_ListInput_TextList::_internal_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_LabelElement* p = _impl_.label_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_LabelElement&>(::com::zoho::shapes::_UIElement_LabelElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_LabelElement& UIElement_ListInput_TextList::label() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.TextList.label)
  return _internal_label();
}
inline void UIElement_ListInput_TextList::unsafe_arena_set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.label_);
  }
  _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ListInput.TextList.label)
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextList::release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_LabelElement* released = _impl_.label_;
  _impl_.label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextList::unsafe_arena_release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ListInput.TextList.label)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_LabelElement* temp = _impl_.label_;
  _impl_.label_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextList::_internal_mutable_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.label_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_LabelElement>(GetArena());
    _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(p);
  }
  return _impl_.label_;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextList::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_LabelElement* _msg = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.TextList.label)
  return _msg;
}
inline void UIElement_ListInput_TextList::set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(_impl_.label_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ListInput.TextList.label)
}

// optional bool def = 2;
inline bool UIElement_ListInput_TextList::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_ListInput_TextList::clear_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.def_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UIElement_ListInput_TextList::def() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.TextList.def)
  return _internal_def();
}
inline void UIElement_ListInput_TextList::set_def(bool value) {
  _internal_set_def(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListInput.TextList.def)
}
inline bool UIElement_ListInput_TextList::_internal_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.def_;
}
inline void UIElement_ListInput_TextList::_internal_set_def(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.def_ = value;
}

// -------------------------------------------------------------------

// UIElement_ListInput_ImageList

// optional .com.zoho.shapes.PictureValue picture = 1;
inline bool UIElement_ListInput_ImageList::has_picture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.picture_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::PictureValue& UIElement_ListInput_ImageList::_internal_picture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PictureValue* p = _impl_.picture_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PictureValue&>(::com::zoho::shapes::_PictureValue_default_instance_);
}
inline const ::com::zoho::shapes::PictureValue& UIElement_ListInput_ImageList::picture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.ImageList.picture)
  return _internal_picture();
}
inline void UIElement_ListInput_ImageList::unsafe_arena_set_allocated_picture(::com::zoho::shapes::PictureValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.picture_);
  }
  _impl_.picture_ = reinterpret_cast<::com::zoho::shapes::PictureValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ListInput.ImageList.picture)
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_ImageList::release_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::PictureValue* released = _impl_.picture_;
  _impl_.picture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_ImageList::unsafe_arena_release_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ListInput.ImageList.picture)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::PictureValue* temp = _impl_.picture_;
  _impl_.picture_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_ImageList::_internal_mutable_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.picture_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PictureValue>(GetArena());
    _impl_.picture_ = reinterpret_cast<::com::zoho::shapes::PictureValue*>(p);
  }
  return _impl_.picture_;
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_ImageList::mutable_picture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PictureValue* _msg = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.ImageList.picture)
  return _msg;
}
inline void UIElement_ListInput_ImageList::set_allocated_picture(::com::zoho::shapes::PictureValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.picture_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.picture_ = reinterpret_cast<::com::zoho::shapes::PictureValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ListInput.ImageList.picture)
}

// optional bool def = 2;
inline bool UIElement_ListInput_ImageList::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_ListInput_ImageList::clear_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.def_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UIElement_ListInput_ImageList::def() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.ImageList.def)
  return _internal_def();
}
inline void UIElement_ListInput_ImageList::set_def(bool value) {
  _internal_set_def(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListInput.ImageList.def)
}
inline bool UIElement_ListInput_ImageList::_internal_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.def_;
}
inline void UIElement_ListInput_ImageList::_internal_set_def(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.def_ = value;
}

// -------------------------------------------------------------------

// UIElement_ListInput_TextImageList_TextImageListItem

// optional .com.zoho.shapes.UIElement.LabelElement label = 1;
inline bool UIElement_ListInput_TextImageList_TextImageListItem::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.label_ != nullptr);
  return value;
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::clear_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.label_ != nullptr) _impl_.label_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_LabelElement& UIElement_ListInput_TextImageList_TextImageListItem::_internal_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_LabelElement* p = _impl_.label_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_LabelElement&>(::com::zoho::shapes::_UIElement_LabelElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_LabelElement& UIElement_ListInput_TextImageList_TextImageListItem::label() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.label)
  return _internal_label();
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::unsafe_arena_set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.label_);
  }
  _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.label)
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextImageList_TextImageListItem::release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_LabelElement* released = _impl_.label_;
  _impl_.label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextImageList_TextImageListItem::unsafe_arena_release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.label)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_LabelElement* temp = _impl_.label_;
  _impl_.label_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextImageList_TextImageListItem::_internal_mutable_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.label_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_LabelElement>(GetArena());
    _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(p);
  }
  return _impl_.label_;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement_ListInput_TextImageList_TextImageListItem::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_LabelElement* _msg = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.label)
  return _msg;
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::set_allocated_label(::com::zoho::shapes::UIElement_LabelElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(_impl_.label_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.label)
}

// optional .com.zoho.shapes.PictureValue picture = 2;
inline bool UIElement_ListInput_TextImageList_TextImageListItem::has_picture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.picture_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::PictureValue& UIElement_ListInput_TextImageList_TextImageListItem::_internal_picture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::PictureValue* p = _impl_.picture_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::PictureValue&>(::com::zoho::shapes::_PictureValue_default_instance_);
}
inline const ::com::zoho::shapes::PictureValue& UIElement_ListInput_TextImageList_TextImageListItem::picture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.picture)
  return _internal_picture();
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::unsafe_arena_set_allocated_picture(::com::zoho::shapes::PictureValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.picture_);
  }
  _impl_.picture_ = reinterpret_cast<::com::zoho::shapes::PictureValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.picture)
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_TextImageList_TextImageListItem::release_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PictureValue* released = _impl_.picture_;
  _impl_.picture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_TextImageList_TextImageListItem::unsafe_arena_release_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.picture)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::PictureValue* temp = _impl_.picture_;
  _impl_.picture_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_TextImageList_TextImageListItem::_internal_mutable_picture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.picture_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::PictureValue>(GetArena());
    _impl_.picture_ = reinterpret_cast<::com::zoho::shapes::PictureValue*>(p);
  }
  return _impl_.picture_;
}
inline ::com::zoho::shapes::PictureValue* UIElement_ListInput_TextImageList_TextImageListItem::mutable_picture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::PictureValue* _msg = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.picture)
  return _msg;
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::set_allocated_picture(::com::zoho::shapes::PictureValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.picture_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.picture_ = reinterpret_cast<::com::zoho::shapes::PictureValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.picture)
}

// optional bool def = 3;
inline bool UIElement_ListInput_TextImageList_TextImageListItem::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::clear_def() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.def_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool UIElement_ListInput_TextImageList_TextImageListItem::def() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.def)
  return _internal_def();
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::set_def(bool value) {
  _internal_set_def(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem.def)
}
inline bool UIElement_ListInput_TextImageList_TextImageListItem::_internal_def() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.def_;
}
inline void UIElement_ListInput_TextImageList_TextImageListItem::_internal_set_def(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.def_ = value;
}

// -------------------------------------------------------------------

// UIElement_ListInput_TextImageList

// repeated .com.zoho.shapes.UIElement.ListInput.TextImageList.TextImageListItem items = 1;
inline int UIElement_ListInput_TextImageList::_internal_items_size() const {
  return _internal_items().size();
}
inline int UIElement_ListInput_TextImageList::items_size() const {
  return _internal_items_size();
}
inline void UIElement_ListInput_TextImageList::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem* UIElement_ListInput_TextImageList::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.TextImageList.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>* UIElement_ListInput_TextImageList::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.UIElement.ListInput.TextImageList.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem& UIElement_ListInput_TextImageList::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.TextImageList.items)
  return _internal_items().Get(index);
}
inline ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem* UIElement_ListInput_TextImageList::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.UIElement.ListInput.TextImageList.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>& UIElement_ListInput_TextImageList::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.UIElement.ListInput.TextImageList.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>&
UIElement_ListInput_TextImageList::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextImageList_TextImageListItem>*
UIElement_ListInput_TextImageList::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// optional bool startWithPicture = 2;
inline bool UIElement_ListInput_TextImageList::has_startwithpicture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_ListInput_TextImageList::clear_startwithpicture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.startwithpicture_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UIElement_ListInput_TextImageList::startwithpicture() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.TextImageList.startWithPicture)
  return _internal_startwithpicture();
}
inline void UIElement_ListInput_TextImageList::set_startwithpicture(bool value) {
  _internal_set_startwithpicture(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListInput.TextImageList.startWithPicture)
}
inline bool UIElement_ListInput_TextImageList::_internal_startwithpicture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startwithpicture_;
}
inline void UIElement_ListInput_TextImageList::_internal_set_startwithpicture(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.startwithpicture_ = value;
}

// -------------------------------------------------------------------

// UIElement_ListInput

// optional .com.zoho.shapes.UIElement.ListInput.ListInputType type = 1;
inline bool UIElement_ListInput::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_ListInput::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_ListInput_ListInputType UIElement_ListInput::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.type)
  return _internal_type();
}
inline void UIElement_ListInput::set_type(::com::zoho::shapes::UIElement_ListInput_ListInputType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListInput.type)
}
inline ::com::zoho::shapes::UIElement_ListInput_ListInputType UIElement_ListInput::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_ListInput_ListInputType>(_impl_.type_);
}
inline void UIElement_ListInput::_internal_set_type(::com::zoho::shapes::UIElement_ListInput_ListInputType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// repeated .com.zoho.shapes.UIElement.ListInput.TextList textLists = 2;
inline int UIElement_ListInput::_internal_textlists_size() const {
  return _internal_textlists().size();
}
inline int UIElement_ListInput::textlists_size() const {
  return _internal_textlists_size();
}
inline void UIElement_ListInput::clear_textlists() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.textlists_.Clear();
}
inline ::com::zoho::shapes::UIElement_ListInput_TextList* UIElement_ListInput::mutable_textlists(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.textLists)
  return _internal_mutable_textlists()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextList>* UIElement_ListInput::mutable_textlists()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.UIElement.ListInput.textLists)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_textlists();
}
inline const ::com::zoho::shapes::UIElement_ListInput_TextList& UIElement_ListInput::textlists(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.textLists)
  return _internal_textlists().Get(index);
}
inline ::com::zoho::shapes::UIElement_ListInput_TextList* UIElement_ListInput::add_textlists() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::UIElement_ListInput_TextList* _add = _internal_mutable_textlists()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.UIElement.ListInput.textLists)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextList>& UIElement_ListInput::textlists() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.UIElement.ListInput.textLists)
  return _internal_textlists();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextList>&
UIElement_ListInput::_internal_textlists() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.textlists_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_TextList>*
UIElement_ListInput::_internal_mutable_textlists() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.textlists_;
}

// repeated .com.zoho.shapes.UIElement.ListInput.ImageList imageLists = 3;
inline int UIElement_ListInput::_internal_imagelists_size() const {
  return _internal_imagelists().size();
}
inline int UIElement_ListInput::imagelists_size() const {
  return _internal_imagelists_size();
}
inline void UIElement_ListInput::clear_imagelists() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imagelists_.Clear();
}
inline ::com::zoho::shapes::UIElement_ListInput_ImageList* UIElement_ListInput::mutable_imagelists(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.imageLists)
  return _internal_mutable_imagelists()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_ImageList>* UIElement_ListInput::mutable_imagelists()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.UIElement.ListInput.imageLists)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_imagelists();
}
inline const ::com::zoho::shapes::UIElement_ListInput_ImageList& UIElement_ListInput::imagelists(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.imageLists)
  return _internal_imagelists().Get(index);
}
inline ::com::zoho::shapes::UIElement_ListInput_ImageList* UIElement_ListInput::add_imagelists() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::UIElement_ListInput_ImageList* _add = _internal_mutable_imagelists()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.UIElement.ListInput.imageLists)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_ImageList>& UIElement_ListInput::imagelists() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.UIElement.ListInput.imageLists)
  return _internal_imagelists();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_ImageList>&
UIElement_ListInput::_internal_imagelists() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.imagelists_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_ListInput_ImageList>*
UIElement_ListInput::_internal_mutable_imagelists() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.imagelists_;
}

// optional .com.zoho.shapes.UIElement.ListInput.TextImageList textImageList = 4;
inline bool UIElement_ListInput::has_textimagelist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.textimagelist_ != nullptr);
  return value;
}
inline void UIElement_ListInput::clear_textimagelist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.textimagelist_ != nullptr) _impl_.textimagelist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_ListInput_TextImageList& UIElement_ListInput::_internal_textimagelist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ListInput_TextImageList* p = _impl_.textimagelist_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ListInput_TextImageList&>(::com::zoho::shapes::_UIElement_ListInput_TextImageList_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ListInput_TextImageList& UIElement_ListInput::textimagelist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListInput.textImageList)
  return _internal_textimagelist();
}
inline void UIElement_ListInput::unsafe_arena_set_allocated_textimagelist(::com::zoho::shapes::UIElement_ListInput_TextImageList* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textimagelist_);
  }
  _impl_.textimagelist_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput_TextImageList*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ListInput.textImageList)
}
inline ::com::zoho::shapes::UIElement_ListInput_TextImageList* UIElement_ListInput::release_textimagelist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ListInput_TextImageList* released = _impl_.textimagelist_;
  _impl_.textimagelist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ListInput_TextImageList* UIElement_ListInput::unsafe_arena_release_textimagelist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ListInput.textImageList)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ListInput_TextImageList* temp = _impl_.textimagelist_;
  _impl_.textimagelist_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ListInput_TextImageList* UIElement_ListInput::_internal_mutable_textimagelist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.textimagelist_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ListInput_TextImageList>(GetArena());
    _impl_.textimagelist_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput_TextImageList*>(p);
  }
  return _impl_.textimagelist_;
}
inline ::com::zoho::shapes::UIElement_ListInput_TextImageList* UIElement_ListInput::mutable_textimagelist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ListInput_TextImageList* _msg = _internal_mutable_textimagelist();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListInput.textImageList)
  return _msg;
}
inline void UIElement_ListInput::set_allocated_textimagelist(::com::zoho::shapes::UIElement_ListInput_TextImageList* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ListInput_TextImageList*>(_impl_.textimagelist_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput_TextImageList*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.textimagelist_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput_TextImageList*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ListInput.textImageList)
}

// -------------------------------------------------------------------

// UIElement_ListSelection_SingleSelection

// optional .com.zoho.shapes.UIElement.ListSelection.SelectionFormat type = 1;
inline bool UIElement_ListSelection_SingleSelection::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_ListSelection_SingleSelection::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat UIElement_ListSelection_SingleSelection::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListSelection.SingleSelection.type)
  return _internal_type();
}
inline void UIElement_ListSelection_SingleSelection::set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListSelection.SingleSelection.type)
}
inline ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat UIElement_ListSelection_SingleSelection::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_ListSelection_SelectionFormat>(_impl_.type_);
}
inline void UIElement_ListSelection_SingleSelection::_internal_set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// UIElement_ListSelection_MultipleSelection

// optional .com.zoho.shapes.UIElement.ListSelection.SelectionFormat type = 1;
inline bool UIElement_ListSelection_MultipleSelection::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_ListSelection_MultipleSelection::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat UIElement_ListSelection_MultipleSelection::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListSelection.MultipleSelection.type)
  return _internal_type();
}
inline void UIElement_ListSelection_MultipleSelection::set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListSelection.MultipleSelection.type)
}
inline ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat UIElement_ListSelection_MultipleSelection::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_ListSelection_SelectionFormat>(_impl_.type_);
}
inline void UIElement_ListSelection_MultipleSelection::_internal_set_type(::com::zoho::shapes::UIElement_ListSelection_SelectionFormat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// UIElement_ListSelection

// optional .com.zoho.shapes.UIElement.ListSelection.SelectionFunction function = 1;
inline bool UIElement_ListSelection::has_function() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_ListSelection::clear_function() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.function_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::shapes::UIElement_ListSelection_SelectionFunction UIElement_ListSelection::function() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListSelection.function)
  return _internal_function();
}
inline void UIElement_ListSelection::set_function(::com::zoho::shapes::UIElement_ListSelection_SelectionFunction value) {
  _internal_set_function(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ListSelection.function)
}
inline ::com::zoho::shapes::UIElement_ListSelection_SelectionFunction UIElement_ListSelection::_internal_function() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_ListSelection_SelectionFunction>(_impl_.function_);
}
inline void UIElement_ListSelection::_internal_set_function(::com::zoho::shapes::UIElement_ListSelection_SelectionFunction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.function_ = value;
}

// optional .com.zoho.shapes.UIElement.ListSelection.SingleSelection single = 2;
inline bool UIElement_ListSelection::has_single() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.single_ != nullptr);
  return value;
}
inline void UIElement_ListSelection::clear_single() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.single_ != nullptr) _impl_.single_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_ListSelection_SingleSelection& UIElement_ListSelection::_internal_single() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* p = _impl_.single_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ListSelection_SingleSelection&>(::com::zoho::shapes::_UIElement_ListSelection_SingleSelection_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ListSelection_SingleSelection& UIElement_ListSelection::single() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListSelection.single)
  return _internal_single();
}
inline void UIElement_ListSelection::unsafe_arena_set_allocated_single(::com::zoho::shapes::UIElement_ListSelection_SingleSelection* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.single_);
  }
  _impl_.single_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_SingleSelection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ListSelection.single)
}
inline ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* UIElement_ListSelection::release_single() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* released = _impl_.single_;
  _impl_.single_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* UIElement_ListSelection::unsafe_arena_release_single() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ListSelection.single)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* temp = _impl_.single_;
  _impl_.single_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* UIElement_ListSelection::_internal_mutable_single() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.single_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ListSelection_SingleSelection>(GetArena());
    _impl_.single_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_SingleSelection*>(p);
  }
  return _impl_.single_;
}
inline ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* UIElement_ListSelection::mutable_single() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ListSelection_SingleSelection* _msg = _internal_mutable_single();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListSelection.single)
  return _msg;
}
inline void UIElement_ListSelection::set_allocated_single(::com::zoho::shapes::UIElement_ListSelection_SingleSelection* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_SingleSelection*>(_impl_.single_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_SingleSelection*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.single_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_SingleSelection*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ListSelection.single)
}

// optional .com.zoho.shapes.UIElement.ListSelection.MultipleSelection multiple = 3;
inline bool UIElement_ListSelection::has_multiple() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multiple_ != nullptr);
  return value;
}
inline void UIElement_ListSelection::clear_multiple() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.multiple_ != nullptr) _impl_.multiple_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection& UIElement_ListSelection::_internal_multiple() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* p = _impl_.multiple_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection&>(::com::zoho::shapes::_UIElement_ListSelection_MultipleSelection_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection& UIElement_ListSelection::multiple() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ListSelection.multiple)
  return _internal_multiple();
}
inline void UIElement_ListSelection::unsafe_arena_set_allocated_multiple(::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.multiple_);
  }
  _impl_.multiple_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_MultipleSelection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ListSelection.multiple)
}
inline ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* UIElement_ListSelection::release_multiple() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* released = _impl_.multiple_;
  _impl_.multiple_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* UIElement_ListSelection::unsafe_arena_release_multiple() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ListSelection.multiple)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* temp = _impl_.multiple_;
  _impl_.multiple_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* UIElement_ListSelection::_internal_mutable_multiple() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.multiple_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ListSelection_MultipleSelection>(GetArena());
    _impl_.multiple_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_MultipleSelection*>(p);
  }
  return _impl_.multiple_;
}
inline ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* UIElement_ListSelection::mutable_multiple() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* _msg = _internal_mutable_multiple();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ListSelection.multiple)
  return _msg;
}
inline void UIElement_ListSelection::set_allocated_multiple(::com::zoho::shapes::UIElement_ListSelection_MultipleSelection* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_MultipleSelection*>(_impl_.multiple_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_MultipleSelection*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.multiple_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection_MultipleSelection*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ListSelection.multiple)
}

// -------------------------------------------------------------------

// UIElement_SelectionElement

// optional .com.zoho.shapes.UIElement.SelectionElement.SelectionElementType type = 1;
inline bool UIElement_SelectionElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_SelectionElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType UIElement_SelectionElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SelectionElement.type)
  return _internal_type();
}
inline void UIElement_SelectionElement::set_type(::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SelectionElement.type)
}
inline ::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType UIElement_SelectionElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType>(_impl_.type_);
}
inline void UIElement_SelectionElement::_internal_set_type(::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.UIElement.ListSelection list = 2;
inline bool UIElement_SelectionElement::has_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.list_ != nullptr);
  return value;
}
inline void UIElement_SelectionElement::clear_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.list_ != nullptr) _impl_.list_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_ListSelection& UIElement_SelectionElement::_internal_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ListSelection* p = _impl_.list_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ListSelection&>(::com::zoho::shapes::_UIElement_ListSelection_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ListSelection& UIElement_SelectionElement::list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SelectionElement.list)
  return _internal_list();
}
inline void UIElement_SelectionElement::unsafe_arena_set_allocated_list(::com::zoho::shapes::UIElement_ListSelection* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.list_);
  }
  _impl_.list_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.SelectionElement.list)
}
inline ::com::zoho::shapes::UIElement_ListSelection* UIElement_SelectionElement::release_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ListSelection* released = _impl_.list_;
  _impl_.list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ListSelection* UIElement_SelectionElement::unsafe_arena_release_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.SelectionElement.list)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ListSelection* temp = _impl_.list_;
  _impl_.list_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ListSelection* UIElement_SelectionElement::_internal_mutable_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.list_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ListSelection>(GetArena());
    _impl_.list_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection*>(p);
  }
  return _impl_.list_;
}
inline ::com::zoho::shapes::UIElement_ListSelection* UIElement_SelectionElement::mutable_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ListSelection* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.SelectionElement.list)
  return _msg;
}
inline void UIElement_SelectionElement::set_allocated_list(::com::zoho::shapes::UIElement_ListSelection* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection*>(_impl_.list_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.list_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListSelection*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.SelectionElement.list)
}

// optional .com.zoho.shapes.UIElement.ListInput selectionInput = 3;
inline bool UIElement_SelectionElement::has_selectioninput() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selectioninput_ != nullptr);
  return value;
}
inline void UIElement_SelectionElement::clear_selectioninput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.selectioninput_ != nullptr) _impl_.selectioninput_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::UIElement_ListInput& UIElement_SelectionElement::_internal_selectioninput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ListInput* p = _impl_.selectioninput_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ListInput&>(::com::zoho::shapes::_UIElement_ListInput_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ListInput& UIElement_SelectionElement::selectioninput() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SelectionElement.selectionInput)
  return _internal_selectioninput();
}
inline void UIElement_SelectionElement::unsafe_arena_set_allocated_selectioninput(::com::zoho::shapes::UIElement_ListInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.selectioninput_);
  }
  _impl_.selectioninput_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.SelectionElement.selectionInput)
}
inline ::com::zoho::shapes::UIElement_ListInput* UIElement_SelectionElement::release_selectioninput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_ListInput* released = _impl_.selectioninput_;
  _impl_.selectioninput_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ListInput* UIElement_SelectionElement::unsafe_arena_release_selectioninput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.SelectionElement.selectionInput)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_ListInput* temp = _impl_.selectioninput_;
  _impl_.selectioninput_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ListInput* UIElement_SelectionElement::_internal_mutable_selectioninput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.selectioninput_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ListInput>(GetArena());
    _impl_.selectioninput_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput*>(p);
  }
  return _impl_.selectioninput_;
}
inline ::com::zoho::shapes::UIElement_ListInput* UIElement_SelectionElement::mutable_selectioninput() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ListInput* _msg = _internal_mutable_selectioninput();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.SelectionElement.selectionInput)
  return _msg;
}
inline void UIElement_SelectionElement::set_allocated_selectioninput(::com::zoho::shapes::UIElement_ListInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ListInput*>(_impl_.selectioninput_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.selectioninput_ = reinterpret_cast<::com::zoho::shapes::UIElement_ListInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.SelectionElement.selectionInput)
}

// -------------------------------------------------------------------

// UIElement_SliderElement_SliderInput_SliderInterval

// optional float interval = 1;
inline bool UIElement_SliderElement_SliderInput_SliderInterval::has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_SliderElement_SliderInput_SliderInterval::clear_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float UIElement_SliderElement_SliderInput_SliderInterval::interval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval.interval)
  return _internal_interval();
}
inline void UIElement_SliderElement_SliderInput_SliderInterval::set_interval(float value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval.interval)
}
inline float UIElement_SliderElement_SliderInput_SliderInterval::_internal_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interval_;
}
inline void UIElement_SliderElement_SliderInput_SliderInterval::_internal_set_interval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.interval_ = value;
}

// optional .com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval.SliderIntervalType type = 2;
inline bool UIElement_SliderElement_SliderInput_SliderInterval::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_SliderElement_SliderInput_SliderInterval::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType UIElement_SliderElement_SliderInput_SliderInterval::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval.type)
  return _internal_type();
}
inline void UIElement_SliderElement_SliderInput_SliderInterval::set_type(::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval.type)
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType UIElement_SliderElement_SliderInput_SliderInterval::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType>(_impl_.type_);
}
inline void UIElement_SliderElement_SliderInput_SliderInterval::_internal_set_type(::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// UIElement_SliderElement_SliderInput

// optional float maxVal = 1;
inline bool UIElement_SliderElement_SliderInput::has_maxval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_SliderElement_SliderInput::clear_maxval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float UIElement_SliderElement_SliderInput::maxval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.SliderInput.maxVal)
  return _internal_maxval();
}
inline void UIElement_SliderElement_SliderInput::set_maxval(float value) {
  _internal_set_maxval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.SliderInput.maxVal)
}
inline float UIElement_SliderElement_SliderInput::_internal_maxval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxval_;
}
inline void UIElement_SliderElement_SliderInput::_internal_set_maxval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.maxval_ = value;
}

// optional float minVal = 2;
inline bool UIElement_SliderElement_SliderInput::has_minval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_SliderElement_SliderInput::clear_minval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float UIElement_SliderElement_SliderInput::minval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.SliderInput.minVal)
  return _internal_minval();
}
inline void UIElement_SliderElement_SliderInput::set_minval(float value) {
  _internal_set_minval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.SliderInput.minVal)
}
inline float UIElement_SliderElement_SliderInput::_internal_minval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minval_;
}
inline void UIElement_SliderElement_SliderInput::_internal_set_minval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.minval_ = value;
}

// repeated .com.zoho.shapes.UIElement.SliderElement.SliderInput.SliderInterval intervals = 3;
inline int UIElement_SliderElement_SliderInput::_internal_intervals_size() const {
  return _internal_intervals().size();
}
inline int UIElement_SliderElement_SliderInput::intervals_size() const {
  return _internal_intervals_size();
}
inline void UIElement_SliderElement_SliderInput::clear_intervals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.intervals_.Clear();
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval* UIElement_SliderElement_SliderInput::mutable_intervals(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.SliderElement.SliderInput.intervals)
  return _internal_mutable_intervals()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>* UIElement_SliderElement_SliderInput::mutable_intervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.zoho.shapes.UIElement.SliderElement.SliderInput.intervals)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_intervals();
}
inline const ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval& UIElement_SliderElement_SliderInput::intervals(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.SliderInput.intervals)
  return _internal_intervals().Get(index);
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval* UIElement_SliderElement_SliderInput::add_intervals() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval* _add = _internal_mutable_intervals()->Add();
  // @@protoc_insertion_point(field_add:com.zoho.shapes.UIElement.SliderElement.SliderInput.intervals)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>& UIElement_SliderElement_SliderInput::intervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.zoho.shapes.UIElement.SliderElement.SliderInput.intervals)
  return _internal_intervals();
}
inline const ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>&
UIElement_SliderElement_SliderInput::_internal_intervals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.intervals_;
}
inline ::google::protobuf::RepeatedPtrField<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval>*
UIElement_SliderElement_SliderInput::_internal_mutable_intervals() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.intervals_;
}

// optional float incrementVal = 4;
inline bool UIElement_SliderElement_SliderInput::has_incrementval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_SliderElement_SliderInput::clear_incrementval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.incrementval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float UIElement_SliderElement_SliderInput::incrementval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.SliderInput.incrementVal)
  return _internal_incrementval();
}
inline void UIElement_SliderElement_SliderInput::set_incrementval(float value) {
  _internal_set_incrementval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.SliderInput.incrementVal)
}
inline float UIElement_SliderElement_SliderInput::_internal_incrementval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.incrementval_;
}
inline void UIElement_SliderElement_SliderInput::_internal_set_incrementval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.incrementval_ = value;
}

// optional float defVal = 5;
inline bool UIElement_SliderElement_SliderInput::has_defval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UIElement_SliderElement_SliderInput::clear_defval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.defval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float UIElement_SliderElement_SliderInput::defval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.SliderInput.defVal)
  return _internal_defval();
}
inline void UIElement_SliderElement_SliderInput::set_defval(float value) {
  _internal_set_defval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.SliderInput.defVal)
}
inline float UIElement_SliderElement_SliderInput::_internal_defval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defval_;
}
inline void UIElement_SliderElement_SliderInput::_internal_set_defval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.defval_ = value;
}

// -------------------------------------------------------------------

// UIElement_SliderElement

// optional .com.zoho.shapes.UIElement.SliderElement.SliderType type = 1;
inline bool UIElement_SliderElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_SliderElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderType UIElement_SliderElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.type)
  return _internal_type();
}
inline void UIElement_SliderElement::set_type(::com::zoho::shapes::UIElement_SliderElement_SliderType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.type)
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderType UIElement_SliderElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_SliderElement_SliderType>(_impl_.type_);
}
inline void UIElement_SliderElement::_internal_set_type(::com::zoho::shapes::UIElement_SliderElement_SliderType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.UIElement.SliderElement.SliderInput sliderInput = 2;
inline bool UIElement_SliderElement::has_sliderinput() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sliderinput_ != nullptr);
  return value;
}
inline void UIElement_SliderElement::clear_sliderinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sliderinput_ != nullptr) _impl_.sliderinput_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_SliderElement_SliderInput& UIElement_SliderElement::_internal_sliderinput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_SliderElement_SliderInput* p = _impl_.sliderinput_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_SliderElement_SliderInput&>(::com::zoho::shapes::_UIElement_SliderElement_SliderInput_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_SliderElement_SliderInput& UIElement_SliderElement::sliderinput() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.sliderInput)
  return _internal_sliderinput();
}
inline void UIElement_SliderElement::unsafe_arena_set_allocated_sliderinput(::com::zoho::shapes::UIElement_SliderElement_SliderInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sliderinput_);
  }
  _impl_.sliderinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement_SliderInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.SliderElement.sliderInput)
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput* UIElement_SliderElement::release_sliderinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput* released = _impl_.sliderinput_;
  _impl_.sliderinput_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput* UIElement_SliderElement::unsafe_arena_release_sliderinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.SliderElement.sliderInput)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput* temp = _impl_.sliderinput_;
  _impl_.sliderinput_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput* UIElement_SliderElement::_internal_mutable_sliderinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sliderinput_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_SliderElement_SliderInput>(GetArena());
    _impl_.sliderinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement_SliderInput*>(p);
  }
  return _impl_.sliderinput_;
}
inline ::com::zoho::shapes::UIElement_SliderElement_SliderInput* UIElement_SliderElement::mutable_sliderinput() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_SliderElement_SliderInput* _msg = _internal_mutable_sliderinput();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.SliderElement.sliderInput)
  return _msg;
}
inline void UIElement_SliderElement::set_allocated_sliderinput(::com::zoho::shapes::UIElement_SliderElement_SliderInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement_SliderInput*>(_impl_.sliderinput_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement_SliderInput*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sliderinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement_SliderInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.SliderElement.sliderInput)
}

// optional .com.zoho.shapes.UIElement.SliderElement.LinearSliderType linearType = 3;
inline bool UIElement_SliderElement::has_lineartype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_SliderElement::clear_lineartype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lineartype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::shapes::UIElement_SliderElement_LinearSliderType UIElement_SliderElement::lineartype() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.SliderElement.linearType)
  return _internal_lineartype();
}
inline void UIElement_SliderElement::set_lineartype(::com::zoho::shapes::UIElement_SliderElement_LinearSliderType value) {
  _internal_set_lineartype(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.SliderElement.linearType)
}
inline ::com::zoho::shapes::UIElement_SliderElement_LinearSliderType UIElement_SliderElement::_internal_lineartype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_SliderElement_LinearSliderType>(_impl_.lineartype_);
}
inline void UIElement_SliderElement::_internal_set_lineartype(::com::zoho::shapes::UIElement_SliderElement_LinearSliderType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lineartype_ = value;
}

// -------------------------------------------------------------------

// UIElement_CalendarElement_CalendarInput

// optional .com.zoho.common.Time date = 1;
inline bool UIElement_CalendarElement_CalendarInput::has_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.date_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Time& UIElement_CalendarElement_CalendarInput::_internal_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Time* p = _impl_.date_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Time&>(::com::zoho::common::_Time_default_instance_);
}
inline const ::com::zoho::common::Time& UIElement_CalendarElement_CalendarInput::date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.date)
  return _internal_date();
}
inline void UIElement_CalendarElement_CalendarInput::unsafe_arena_set_allocated_date(::com::zoho::common::Time* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.date_);
  }
  _impl_.date_ = reinterpret_cast<::com::zoho::common::Time*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.date)
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::release_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Time* released = _impl_.date_;
  _impl_.date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::unsafe_arena_release_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.date)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Time* temp = _impl_.date_;
  _impl_.date_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::_internal_mutable_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.date_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Time>(GetArena());
    _impl_.date_ = reinterpret_cast<::com::zoho::common::Time*>(p);
  }
  return _impl_.date_;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::mutable_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Time* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.date)
  return _msg;
}
inline void UIElement_CalendarElement_CalendarInput::set_allocated_date(::com::zoho::common::Time* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.date_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.date_ = reinterpret_cast<::com::zoho::common::Time*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.date)
}

// optional .com.zoho.common.Time maxDate = 2;
inline bool UIElement_CalendarElement_CalendarInput::has_maxdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maxdate_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Time& UIElement_CalendarElement_CalendarInput::_internal_maxdate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Time* p = _impl_.maxdate_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Time&>(::com::zoho::common::_Time_default_instance_);
}
inline const ::com::zoho::common::Time& UIElement_CalendarElement_CalendarInput::maxdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.maxDate)
  return _internal_maxdate();
}
inline void UIElement_CalendarElement_CalendarInput::unsafe_arena_set_allocated_maxdate(::com::zoho::common::Time* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maxdate_);
  }
  _impl_.maxdate_ = reinterpret_cast<::com::zoho::common::Time*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.maxDate)
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::release_maxdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::Time* released = _impl_.maxdate_;
  _impl_.maxdate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::unsafe_arena_release_maxdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.maxDate)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::common::Time* temp = _impl_.maxdate_;
  _impl_.maxdate_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::_internal_mutable_maxdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.maxdate_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Time>(GetArena());
    _impl_.maxdate_ = reinterpret_cast<::com::zoho::common::Time*>(p);
  }
  return _impl_.maxdate_;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::mutable_maxdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Time* _msg = _internal_mutable_maxdate();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.maxDate)
  return _msg;
}
inline void UIElement_CalendarElement_CalendarInput::set_allocated_maxdate(::com::zoho::common::Time* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maxdate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.maxdate_ = reinterpret_cast<::com::zoho::common::Time*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.maxDate)
}

// optional .com.zoho.common.Time minDate = 3;
inline bool UIElement_CalendarElement_CalendarInput::has_mindate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mindate_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Time& UIElement_CalendarElement_CalendarInput::_internal_mindate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Time* p = _impl_.mindate_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Time&>(::com::zoho::common::_Time_default_instance_);
}
inline const ::com::zoho::common::Time& UIElement_CalendarElement_CalendarInput::mindate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.minDate)
  return _internal_mindate();
}
inline void UIElement_CalendarElement_CalendarInput::unsafe_arena_set_allocated_mindate(::com::zoho::common::Time* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mindate_);
  }
  _impl_.mindate_ = reinterpret_cast<::com::zoho::common::Time*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.minDate)
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::release_mindate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::common::Time* released = _impl_.mindate_;
  _impl_.mindate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::unsafe_arena_release_mindate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.minDate)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::common::Time* temp = _impl_.mindate_;
  _impl_.mindate_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::_internal_mutable_mindate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.mindate_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Time>(GetArena());
    _impl_.mindate_ = reinterpret_cast<::com::zoho::common::Time*>(p);
  }
  return _impl_.mindate_;
}
inline ::com::zoho::common::Time* UIElement_CalendarElement_CalendarInput::mutable_mindate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Time* _msg = _internal_mutable_mindate();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.minDate)
  return _msg;
}
inline void UIElement_CalendarElement_CalendarInput::set_allocated_mindate(::com::zoho::common::Time* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mindate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.mindate_ = reinterpret_cast<::com::zoho::common::Time*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.CalendarElement.CalendarInput.minDate)
}

// -------------------------------------------------------------------

// UIElement_CalendarElement

// optional .com.zoho.shapes.UIElement.CalendarElement.CalendarType type = 1;
inline bool UIElement_CalendarElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_CalendarElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_CalendarElement_CalendarType UIElement_CalendarElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.type)
  return _internal_type();
}
inline void UIElement_CalendarElement::set_type(::com::zoho::shapes::UIElement_CalendarElement_CalendarType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.CalendarElement.type)
}
inline ::com::zoho::shapes::UIElement_CalendarElement_CalendarType UIElement_CalendarElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_CalendarElement_CalendarType>(_impl_.type_);
}
inline void UIElement_CalendarElement::_internal_set_type(::com::zoho::shapes::UIElement_CalendarElement_CalendarType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.UIElement.CalendarElement.DatePickerFormat dateFormat = 2;
inline bool UIElement_CalendarElement::has_dateformat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_CalendarElement::clear_dateformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dateformat_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat UIElement_CalendarElement::dateformat() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.dateFormat)
  return _internal_dateformat();
}
inline void UIElement_CalendarElement::set_dateformat(::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat value) {
  _internal_set_dateformat(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.CalendarElement.dateFormat)
}
inline ::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat UIElement_CalendarElement::_internal_dateformat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat>(_impl_.dateformat_);
}
inline void UIElement_CalendarElement::_internal_set_dateformat(::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dateformat_ = value;
}

// optional .com.zoho.shapes.UIElement.CalendarElement.TimePickerFormat timeFormat = 3;
inline bool UIElement_CalendarElement::has_timeformat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UIElement_CalendarElement::clear_timeformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeformat_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat UIElement_CalendarElement::timeformat() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.timeFormat)
  return _internal_timeformat();
}
inline void UIElement_CalendarElement::set_timeformat(::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat value) {
  _internal_set_timeformat(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.CalendarElement.timeFormat)
}
inline ::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat UIElement_CalendarElement::_internal_timeformat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat>(_impl_.timeformat_);
}
inline void UIElement_CalendarElement::_internal_set_timeformat(::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timeformat_ = value;
}

// optional .com.zoho.shapes.UIElement.CalendarElement.ClockFormat clockFormat = 4;
inline bool UIElement_CalendarElement::has_clockformat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UIElement_CalendarElement::clear_clockformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clockformat_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::com::zoho::shapes::UIElement_CalendarElement_ClockFormat UIElement_CalendarElement::clockformat() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.clockFormat)
  return _internal_clockformat();
}
inline void UIElement_CalendarElement::set_clockformat(::com::zoho::shapes::UIElement_CalendarElement_ClockFormat value) {
  _internal_set_clockformat(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.CalendarElement.clockFormat)
}
inline ::com::zoho::shapes::UIElement_CalendarElement_ClockFormat UIElement_CalendarElement::_internal_clockformat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_CalendarElement_ClockFormat>(_impl_.clockformat_);
}
inline void UIElement_CalendarElement::_internal_set_clockformat(::com::zoho::shapes::UIElement_CalendarElement_ClockFormat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.clockformat_ = value;
}

// optional .com.zoho.shapes.UIElement.CalendarElement.CalendarInput calendarInput = 5;
inline bool UIElement_CalendarElement::has_calendarinput() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.calendarinput_ != nullptr);
  return value;
}
inline void UIElement_CalendarElement::clear_calendarinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.calendarinput_ != nullptr) _impl_.calendarinput_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput& UIElement_CalendarElement::_internal_calendarinput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* p = _impl_.calendarinput_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput&>(::com::zoho::shapes::_UIElement_CalendarElement_CalendarInput_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput& UIElement_CalendarElement::calendarinput() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.CalendarElement.calendarInput)
  return _internal_calendarinput();
}
inline void UIElement_CalendarElement::unsafe_arena_set_allocated_calendarinput(::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.calendarinput_);
  }
  _impl_.calendarinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.CalendarElement.calendarInput)
}
inline ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* UIElement_CalendarElement::release_calendarinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* released = _impl_.calendarinput_;
  _impl_.calendarinput_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* UIElement_CalendarElement::unsafe_arena_release_calendarinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.CalendarElement.calendarInput)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* temp = _impl_.calendarinput_;
  _impl_.calendarinput_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* UIElement_CalendarElement::_internal_mutable_calendarinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.calendarinput_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_CalendarElement_CalendarInput>(GetArena());
    _impl_.calendarinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(p);
  }
  return _impl_.calendarinput_;
}
inline ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* UIElement_CalendarElement::mutable_calendarinput() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* _msg = _internal_mutable_calendarinput();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.CalendarElement.calendarInput)
  return _msg;
}
inline void UIElement_CalendarElement::set_allocated_calendarinput(::com::zoho::shapes::UIElement_CalendarElement_CalendarInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(_impl_.calendarinput_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.calendarinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement_CalendarInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.CalendarElement.calendarInput)
}

// -------------------------------------------------------------------

// UIElement_ToggleElement_ToggleInput_DataForState

// optional string onState = 1;
inline bool UIElement_ToggleElement_ToggleInput_DataForState::has_onstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_ToggleElement_ToggleInput_DataForState::clear_onstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onstate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UIElement_ToggleElement_ToggleInput_DataForState::onstate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.onState)
  return _internal_onstate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UIElement_ToggleElement_ToggleInput_DataForState::set_onstate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.onstate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.onState)
}
inline std::string* UIElement_ToggleElement_ToggleInput_DataForState::mutable_onstate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_onstate();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.onState)
  return _s;
}
inline const std::string& UIElement_ToggleElement_ToggleInput_DataForState::_internal_onstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.onstate_.Get();
}
inline void UIElement_ToggleElement_ToggleInput_DataForState::_internal_set_onstate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.onstate_.Set(value, GetArena());
}
inline std::string* UIElement_ToggleElement_ToggleInput_DataForState::_internal_mutable_onstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.onstate_.Mutable( GetArena());
}
inline std::string* UIElement_ToggleElement_ToggleInput_DataForState::release_onstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.onState)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.onstate_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.onstate_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UIElement_ToggleElement_ToggleInput_DataForState::set_allocated_onstate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.onstate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onstate_.IsDefault()) {
          _impl_.onstate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.onState)
}

// optional string offState = 2;
inline bool UIElement_ToggleElement_ToggleInput_DataForState::has_offstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_ToggleElement_ToggleInput_DataForState::clear_offstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offstate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UIElement_ToggleElement_ToggleInput_DataForState::offstate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.offState)
  return _internal_offstate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UIElement_ToggleElement_ToggleInput_DataForState::set_offstate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offstate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.offState)
}
inline std::string* UIElement_ToggleElement_ToggleInput_DataForState::mutable_offstate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_offstate();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.offState)
  return _s;
}
inline const std::string& UIElement_ToggleElement_ToggleInput_DataForState::_internal_offstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offstate_.Get();
}
inline void UIElement_ToggleElement_ToggleInput_DataForState::_internal_set_offstate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offstate_.Set(value, GetArena());
}
inline std::string* UIElement_ToggleElement_ToggleInput_DataForState::_internal_mutable_offstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.offstate_.Mutable( GetArena());
}
inline std::string* UIElement_ToggleElement_ToggleInput_DataForState::release_offstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.offState)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.offstate_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.offstate_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UIElement_ToggleElement_ToggleInput_DataForState::set_allocated_offstate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.offstate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.offstate_.IsDefault()) {
          _impl_.offstate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState.offState)
}

// -------------------------------------------------------------------

// UIElement_ToggleElement_ToggleInput

// optional bool state = 1;
inline bool UIElement_ToggleElement_ToggleInput::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_ToggleElement_ToggleInput::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool UIElement_ToggleElement_ToggleInput::state() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.state)
  return _internal_state();
}
inline void UIElement_ToggleElement_ToggleInput::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.state)
}
inline bool UIElement_ToggleElement_ToggleInput::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void UIElement_ToggleElement_ToggleInput::_internal_set_state(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.state_ = value;
}

// optional .com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState label = 2;
inline bool UIElement_ToggleElement_ToggleInput::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.label_ != nullptr);
  return value;
}
inline void UIElement_ToggleElement_ToggleInput::clear_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.label_ != nullptr) _impl_.label_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& UIElement_ToggleElement_ToggleInput::_internal_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* p = _impl_.label_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState&>(::com::zoho::shapes::_UIElement_ToggleElement_ToggleInput_DataForState_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& UIElement_ToggleElement_ToggleInput::label() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.label)
  return _internal_label();
}
inline void UIElement_ToggleElement_ToggleInput::unsafe_arena_set_allocated_label(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.label_);
  }
  _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.label)
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* released = _impl_.label_;
  _impl_.label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::unsafe_arena_release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.label)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* temp = _impl_.label_;
  _impl_.label_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::_internal_mutable_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.label_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState>(GetArena());
    _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(p);
  }
  return _impl_.label_;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* _msg = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.label)
  return _msg;
}
inline void UIElement_ToggleElement_ToggleInput::set_allocated_label(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(_impl_.label_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.label_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.label)
}

// optional .com.zoho.shapes.UIElement.ToggleElement.ToggleInput.DataForState icon = 3;
inline bool UIElement_ToggleElement_ToggleInput::has_icon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.icon_ != nullptr);
  return value;
}
inline void UIElement_ToggleElement_ToggleInput::clear_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.icon_ != nullptr) _impl_.icon_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& UIElement_ToggleElement_ToggleInput::_internal_icon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* p = _impl_.icon_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState&>(::com::zoho::shapes::_UIElement_ToggleElement_ToggleInput_DataForState_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState& UIElement_ToggleElement_ToggleInput::icon() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.icon)
  return _internal_icon();
}
inline void UIElement_ToggleElement_ToggleInput::unsafe_arena_set_allocated_icon(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.icon_);
  }
  _impl_.icon_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.icon)
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::release_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* released = _impl_.icon_;
  _impl_.icon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::unsafe_arena_release_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.icon)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* temp = _impl_.icon_;
  _impl_.icon_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::_internal_mutable_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.icon_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState>(GetArena());
    _impl_.icon_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(p);
  }
  return _impl_.icon_;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* UIElement_ToggleElement_ToggleInput::mutable_icon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* _msg = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.icon)
  return _msg;
}
inline void UIElement_ToggleElement_ToggleInput::set_allocated_icon(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(_impl_.icon_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.icon_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput_DataForState*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ToggleElement.ToggleInput.icon)
}

// -------------------------------------------------------------------

// UIElement_ToggleElement

// optional .com.zoho.shapes.UIElement.ToggleElement.ToggleElementType type = 1;
inline bool UIElement_ToggleElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_ToggleElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType UIElement_ToggleElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.type)
  return _internal_type();
}
inline void UIElement_ToggleElement::set_type(::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ToggleElement.type)
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType UIElement_ToggleElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType>(_impl_.type_);
}
inline void UIElement_ToggleElement::_internal_set_type(::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional bool label = 2;
inline bool UIElement_ToggleElement::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UIElement_ToggleElement::clear_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.label_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool UIElement_ToggleElement::label() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.label)
  return _internal_label();
}
inline void UIElement_ToggleElement::set_label(bool value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ToggleElement.label)
}
inline bool UIElement_ToggleElement::_internal_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.label_;
}
inline void UIElement_ToggleElement::_internal_set_label(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.label_ = value;
}

// optional .com.zoho.shapes.UIElement.ToggleElement.LabelPosition labelPos = 3;
inline bool UIElement_ToggleElement::has_labelpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_ToggleElement::clear_labelpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.labelpos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_LabelPosition UIElement_ToggleElement::labelpos() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.labelPos)
  return _internal_labelpos();
}
inline void UIElement_ToggleElement::set_labelpos(::com::zoho::shapes::UIElement_ToggleElement_LabelPosition value) {
  _internal_set_labelpos(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ToggleElement.labelPos)
}
inline ::com::zoho::shapes::UIElement_ToggleElement_LabelPosition UIElement_ToggleElement::_internal_labelpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_ToggleElement_LabelPosition>(_impl_.labelpos_);
}
inline void UIElement_ToggleElement::_internal_set_labelpos(::com::zoho::shapes::UIElement_ToggleElement_LabelPosition value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.labelpos_ = value;
}

// optional bool icon = 4;
inline bool UIElement_ToggleElement::has_icon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UIElement_ToggleElement::clear_icon() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool UIElement_ToggleElement::icon() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.icon)
  return _internal_icon();
}
inline void UIElement_ToggleElement::set_icon(bool value) {
  _internal_set_icon(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.ToggleElement.icon)
}
inline bool UIElement_ToggleElement::_internal_icon() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.icon_;
}
inline void UIElement_ToggleElement::_internal_set_icon(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.icon_ = value;
}

// optional .com.zoho.shapes.UIElement.ToggleElement.ToggleInput toggleInput = 5;
inline bool UIElement_ToggleElement::has_toggleinput() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.toggleinput_ != nullptr);
  return value;
}
inline void UIElement_ToggleElement::clear_toggleinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.toggleinput_ != nullptr) _impl_.toggleinput_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput& UIElement_ToggleElement::_internal_toggleinput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* p = _impl_.toggleinput_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput&>(::com::zoho::shapes::_UIElement_ToggleElement_ToggleInput_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput& UIElement_ToggleElement::toggleinput() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ToggleElement.toggleInput)
  return _internal_toggleinput();
}
inline void UIElement_ToggleElement::unsafe_arena_set_allocated_toggleinput(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.toggleinput_);
  }
  _impl_.toggleinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ToggleElement.toggleInput)
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* UIElement_ToggleElement::release_toggleinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* released = _impl_.toggleinput_;
  _impl_.toggleinput_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* UIElement_ToggleElement::unsafe_arena_release_toggleinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ToggleElement.toggleInput)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* temp = _impl_.toggleinput_;
  _impl_.toggleinput_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* UIElement_ToggleElement::_internal_mutable_toggleinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.toggleinput_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput>(GetArena());
    _impl_.toggleinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput*>(p);
  }
  return _impl_.toggleinput_;
}
inline ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* UIElement_ToggleElement::mutable_toggleinput() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* _msg = _internal_mutable_toggleinput();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ToggleElement.toggleInput)
  return _msg;
}
inline void UIElement_ToggleElement::set_allocated_toggleinput(::com::zoho::shapes::UIElement_ToggleElement_ToggleInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput*>(_impl_.toggleinput_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.toggleinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement_ToggleInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ToggleElement.toggleInput)
}

// -------------------------------------------------------------------

// UIElement_StepperElement_StepperInput

// optional float defVal = 1;
inline bool UIElement_StepperElement_StepperInput::has_defval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_StepperElement_StepperInput::clear_defval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.defval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float UIElement_StepperElement_StepperInput::defval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.StepperElement.StepperInput.defVal)
  return _internal_defval();
}
inline void UIElement_StepperElement_StepperInput::set_defval(float value) {
  _internal_set_defval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.StepperElement.StepperInput.defVal)
}
inline float UIElement_StepperElement_StepperInput::_internal_defval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defval_;
}
inline void UIElement_StepperElement_StepperInput::_internal_set_defval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.defval_ = value;
}

// optional float maxVal = 2;
inline bool UIElement_StepperElement_StepperInput::has_maxval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_StepperElement_StepperInput::clear_maxval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float UIElement_StepperElement_StepperInput::maxval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.StepperElement.StepperInput.maxVal)
  return _internal_maxval();
}
inline void UIElement_StepperElement_StepperInput::set_maxval(float value) {
  _internal_set_maxval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.StepperElement.StepperInput.maxVal)
}
inline float UIElement_StepperElement_StepperInput::_internal_maxval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxval_;
}
inline void UIElement_StepperElement_StepperInput::_internal_set_maxval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maxval_ = value;
}

// optional float minVal = 3;
inline bool UIElement_StepperElement_StepperInput::has_minval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_StepperElement_StepperInput::clear_minval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float UIElement_StepperElement_StepperInput::minval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.StepperElement.StepperInput.minVal)
  return _internal_minval();
}
inline void UIElement_StepperElement_StepperInput::set_minval(float value) {
  _internal_set_minval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.StepperElement.StepperInput.minVal)
}
inline float UIElement_StepperElement_StepperInput::_internal_minval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minval_;
}
inline void UIElement_StepperElement_StepperInput::_internal_set_minval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.minval_ = value;
}

// optional float incermentVal = 4;
inline bool UIElement_StepperElement_StepperInput::has_incermentval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UIElement_StepperElement_StepperInput::clear_incermentval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.incermentval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float UIElement_StepperElement_StepperInput::incermentval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.StepperElement.StepperInput.incermentVal)
  return _internal_incermentval();
}
inline void UIElement_StepperElement_StepperInput::set_incermentval(float value) {
  _internal_set_incermentval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.StepperElement.StepperInput.incermentVal)
}
inline float UIElement_StepperElement_StepperInput::_internal_incermentval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.incermentval_;
}
inline void UIElement_StepperElement_StepperInput::_internal_set_incermentval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.incermentval_ = value;
}

// -------------------------------------------------------------------

// UIElement_StepperElement

// optional .com.zoho.shapes.UIElement.StepperElement.StepperInput stepperInput = 1;
inline bool UIElement_StepperElement::has_stepperinput() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stepperinput_ != nullptr);
  return value;
}
inline void UIElement_StepperElement::clear_stepperinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stepperinput_ != nullptr) _impl_.stepperinput_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_StepperElement_StepperInput& UIElement_StepperElement::_internal_stepperinput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_StepperElement_StepperInput* p = _impl_.stepperinput_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_StepperElement_StepperInput&>(::com::zoho::shapes::_UIElement_StepperElement_StepperInput_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_StepperElement_StepperInput& UIElement_StepperElement::stepperinput() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.StepperElement.stepperInput)
  return _internal_stepperinput();
}
inline void UIElement_StepperElement::unsafe_arena_set_allocated_stepperinput(::com::zoho::shapes::UIElement_StepperElement_StepperInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stepperinput_);
  }
  _impl_.stepperinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement_StepperInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.StepperElement.stepperInput)
}
inline ::com::zoho::shapes::UIElement_StepperElement_StepperInput* UIElement_StepperElement::release_stepperinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_StepperElement_StepperInput* released = _impl_.stepperinput_;
  _impl_.stepperinput_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_StepperElement_StepperInput* UIElement_StepperElement::unsafe_arena_release_stepperinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.StepperElement.stepperInput)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_StepperElement_StepperInput* temp = _impl_.stepperinput_;
  _impl_.stepperinput_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_StepperElement_StepperInput* UIElement_StepperElement::_internal_mutable_stepperinput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stepperinput_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_StepperElement_StepperInput>(GetArena());
    _impl_.stepperinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement_StepperInput*>(p);
  }
  return _impl_.stepperinput_;
}
inline ::com::zoho::shapes::UIElement_StepperElement_StepperInput* UIElement_StepperElement::mutable_stepperinput() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_StepperElement_StepperInput* _msg = _internal_mutable_stepperinput();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.StepperElement.stepperInput)
  return _msg;
}
inline void UIElement_StepperElement::set_allocated_stepperinput(::com::zoho::shapes::UIElement_StepperElement_StepperInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement_StepperInput*>(_impl_.stepperinput_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement_StepperInput*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stepperinput_ = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement_StepperInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.StepperElement.stepperInput)
}

// optional bool wrapVal = 2;
inline bool UIElement_StepperElement::has_wrapval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_StepperElement::clear_wrapval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wrapval_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UIElement_StepperElement::wrapval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.StepperElement.wrapVal)
  return _internal_wrapval();
}
inline void UIElement_StepperElement::set_wrapval(bool value) {
  _internal_set_wrapval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.StepperElement.wrapVal)
}
inline bool UIElement_StepperElement::_internal_wrapval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wrapval_;
}
inline void UIElement_StepperElement::_internal_set_wrapval(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wrapval_ = value;
}

// -------------------------------------------------------------------

// UIElement_LabelElement_BGLabel

// optional .com.zoho.shapes.Color color = 1;
inline bool UIElement_LabelElement_BGLabel::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Color& UIElement_LabelElement_BGLabel::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Color&>(::com::zoho::shapes::_Color_default_instance_);
}
inline const ::com::zoho::shapes::Color& UIElement_LabelElement_BGLabel::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.BGLabel.color)
  return _internal_color();
}
inline void UIElement_LabelElement_BGLabel::unsafe_arena_set_allocated_color(::com::zoho::shapes::Color* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::com::zoho::shapes::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.LabelElement.BGLabel.color)
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_BGLabel::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::Color* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_BGLabel::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.LabelElement.BGLabel.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_BGLabel::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Color>(GetArena());
    _impl_.color_ = reinterpret_cast<::com::zoho::shapes::Color*>(p);
  }
  return _impl_.color_;
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_BGLabel::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.LabelElement.BGLabel.color)
  return _msg;
}
inline void UIElement_LabelElement_BGLabel::set_allocated_color(::com::zoho::shapes::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::com::zoho::shapes::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.LabelElement.BGLabel.color)
}

// -------------------------------------------------------------------

// UIElement_LabelElement_StatusLabel_StatusSymbol

// optional .com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.StatusSymbolType type = 1;
inline bool UIElement_LabelElement_StatusLabel_StatusSymbol::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_LabelElement_StatusLabel_StatusSymbol::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType UIElement_LabelElement_StatusLabel_StatusSymbol::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.type)
  return _internal_type();
}
inline void UIElement_LabelElement_StatusLabel_StatusSymbol::set_type(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.type)
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType UIElement_LabelElement_StatusLabel_StatusSymbol::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType>(_impl_.type_);
}
inline void UIElement_LabelElement_StatusLabel_StatusSymbol::_internal_set_type(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .com.zoho.shapes.ColorTweaks tweaks = 2;
inline bool UIElement_LabelElement_StatusLabel_StatusSymbol::has_tweaks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tweaks_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::ColorTweaks& UIElement_LabelElement_StatusLabel_StatusSymbol::_internal_tweaks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::ColorTweaks* p = _impl_.tweaks_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::ColorTweaks&>(::com::zoho::shapes::_ColorTweaks_default_instance_);
}
inline const ::com::zoho::shapes::ColorTweaks& UIElement_LabelElement_StatusLabel_StatusSymbol::tweaks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.tweaks)
  return _internal_tweaks();
}
inline void UIElement_LabelElement_StatusLabel_StatusSymbol::unsafe_arena_set_allocated_tweaks(::com::zoho::shapes::ColorTweaks* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tweaks_);
  }
  _impl_.tweaks_ = reinterpret_cast<::com::zoho::shapes::ColorTweaks*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.tweaks)
}
inline ::com::zoho::shapes::ColorTweaks* UIElement_LabelElement_StatusLabel_StatusSymbol::release_tweaks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::ColorTweaks* released = _impl_.tweaks_;
  _impl_.tweaks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::ColorTweaks* UIElement_LabelElement_StatusLabel_StatusSymbol::unsafe_arena_release_tweaks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.tweaks)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::ColorTweaks* temp = _impl_.tweaks_;
  _impl_.tweaks_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::ColorTweaks* UIElement_LabelElement_StatusLabel_StatusSymbol::_internal_mutable_tweaks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tweaks_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::ColorTweaks>(GetArena());
    _impl_.tweaks_ = reinterpret_cast<::com::zoho::shapes::ColorTweaks*>(p);
  }
  return _impl_.tweaks_;
}
inline ::com::zoho::shapes::ColorTweaks* UIElement_LabelElement_StatusLabel_StatusSymbol::mutable_tweaks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::ColorTweaks* _msg = _internal_mutable_tweaks();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.tweaks)
  return _msg;
}
inline void UIElement_LabelElement_StatusLabel_StatusSymbol::set_allocated_tweaks(::com::zoho::shapes::ColorTweaks* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tweaks_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tweaks_ = reinterpret_cast<::com::zoho::shapes::ColorTweaks*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol.tweaks)
}

// -------------------------------------------------------------------

// UIElement_LabelElement_StatusLabel

// optional .com.zoho.shapes.Color color = 1;
inline bool UIElement_LabelElement_StatusLabel::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Color& UIElement_LabelElement_StatusLabel::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Color&>(::com::zoho::shapes::_Color_default_instance_);
}
inline const ::com::zoho::shapes::Color& UIElement_LabelElement_StatusLabel::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.StatusLabel.color)
  return _internal_color();
}
inline void UIElement_LabelElement_StatusLabel::unsafe_arena_set_allocated_color(::com::zoho::shapes::Color* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::com::zoho::shapes::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.LabelElement.StatusLabel.color)
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_StatusLabel::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::Color* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_StatusLabel::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.LabelElement.StatusLabel.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_StatusLabel::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Color>(GetArena());
    _impl_.color_ = reinterpret_cast<::com::zoho::shapes::Color*>(p);
  }
  return _impl_.color_;
}
inline ::com::zoho::shapes::Color* UIElement_LabelElement_StatusLabel::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.LabelElement.StatusLabel.color)
  return _msg;
}
inline void UIElement_LabelElement_StatusLabel::set_allocated_color(::com::zoho::shapes::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::com::zoho::shapes::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.LabelElement.StatusLabel.color)
}

// optional .com.zoho.shapes.UIElement.LabelElement.StatusLabel.StatusSymbol symbol = 2;
inline bool UIElement_LabelElement_StatusLabel::has_symbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.symbol_ != nullptr);
  return value;
}
inline void UIElement_LabelElement_StatusLabel::clear_symbol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.symbol_ != nullptr) _impl_.symbol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol& UIElement_LabelElement_StatusLabel::_internal_symbol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* p = _impl_.symbol_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol&>(::com::zoho::shapes::_UIElement_LabelElement_StatusLabel_StatusSymbol_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol& UIElement_LabelElement_StatusLabel::symbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.StatusLabel.symbol)
  return _internal_symbol();
}
inline void UIElement_LabelElement_StatusLabel::unsafe_arena_set_allocated_symbol(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.symbol_);
  }
  _impl_.symbol_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.LabelElement.StatusLabel.symbol)
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* UIElement_LabelElement_StatusLabel::release_symbol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* released = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* UIElement_LabelElement_StatusLabel::unsafe_arena_release_symbol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.LabelElement.StatusLabel.symbol)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* temp = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* UIElement_LabelElement_StatusLabel::_internal_mutable_symbol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.symbol_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol>(GetArena());
    _impl_.symbol_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol*>(p);
  }
  return _impl_.symbol_;
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* UIElement_LabelElement_StatusLabel::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* _msg = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.LabelElement.StatusLabel.symbol)
  return _msg;
}
inline void UIElement_LabelElement_StatusLabel::set_allocated_symbol(::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol*>(_impl_.symbol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.symbol_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.LabelElement.StatusLabel.symbol)
}

// -------------------------------------------------------------------

// UIElement_LabelElement

// optional .com.zoho.shapes.UIElement.LabelElement.LabelElementType type = 1;
inline bool UIElement_LabelElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UIElement_LabelElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::shapes::UIElement_LabelElement_LabelElementType UIElement_LabelElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.type)
  return _internal_type();
}
inline void UIElement_LabelElement::set_type(::com::zoho::shapes::UIElement_LabelElement_LabelElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.LabelElement.type)
}
inline ::com::zoho::shapes::UIElement_LabelElement_LabelElementType UIElement_LabelElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_LabelElement_LabelElementType>(_impl_.type_);
}
inline void UIElement_LabelElement::_internal_set_type(::com::zoho::shapes::UIElement_LabelElement_LabelElementType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional string text = 2;
inline bool UIElement_LabelElement::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_LabelElement::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UIElement_LabelElement::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UIElement_LabelElement::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.LabelElement.text)
}
inline std::string* UIElement_LabelElement::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.LabelElement.text)
  return _s;
}
inline const std::string& UIElement_LabelElement::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void UIElement_LabelElement::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* UIElement_LabelElement::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* UIElement_LabelElement::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.LabelElement.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UIElement_LabelElement::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.LabelElement.text)
}

// optional .com.zoho.shapes.UIElement.LabelElement.BGLabel bgLabel = 3;
inline bool UIElement_LabelElement::has_bglabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bglabel_ != nullptr);
  return value;
}
inline void UIElement_LabelElement::clear_bglabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bglabel_ != nullptr) _impl_.bglabel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::UIElement_LabelElement_BGLabel& UIElement_LabelElement::_internal_bglabel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_LabelElement_BGLabel* p = _impl_.bglabel_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_LabelElement_BGLabel&>(::com::zoho::shapes::_UIElement_LabelElement_BGLabel_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_LabelElement_BGLabel& UIElement_LabelElement::bglabel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.bgLabel)
  return _internal_bglabel();
}
inline void UIElement_LabelElement::unsafe_arena_set_allocated_bglabel(::com::zoho::shapes::UIElement_LabelElement_BGLabel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bglabel_);
  }
  _impl_.bglabel_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_BGLabel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.LabelElement.bgLabel)
}
inline ::com::zoho::shapes::UIElement_LabelElement_BGLabel* UIElement_LabelElement::release_bglabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_LabelElement_BGLabel* released = _impl_.bglabel_;
  _impl_.bglabel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_LabelElement_BGLabel* UIElement_LabelElement::unsafe_arena_release_bglabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.LabelElement.bgLabel)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_LabelElement_BGLabel* temp = _impl_.bglabel_;
  _impl_.bglabel_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_LabelElement_BGLabel* UIElement_LabelElement::_internal_mutable_bglabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.bglabel_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_LabelElement_BGLabel>(GetArena());
    _impl_.bglabel_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_BGLabel*>(p);
  }
  return _impl_.bglabel_;
}
inline ::com::zoho::shapes::UIElement_LabelElement_BGLabel* UIElement_LabelElement::mutable_bglabel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_LabelElement_BGLabel* _msg = _internal_mutable_bglabel();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.LabelElement.bgLabel)
  return _msg;
}
inline void UIElement_LabelElement::set_allocated_bglabel(::com::zoho::shapes::UIElement_LabelElement_BGLabel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_BGLabel*>(_impl_.bglabel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_BGLabel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.bglabel_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_BGLabel*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.LabelElement.bgLabel)
}

// optional .com.zoho.shapes.UIElement.LabelElement.StatusLabel statusLabel = 4;
inline bool UIElement_LabelElement::has_statuslabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statuslabel_ != nullptr);
  return value;
}
inline void UIElement_LabelElement::clear_statuslabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.statuslabel_ != nullptr) _impl_.statuslabel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel& UIElement_LabelElement::_internal_statuslabel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* p = _impl_.statuslabel_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel&>(::com::zoho::shapes::_UIElement_LabelElement_StatusLabel_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_LabelElement_StatusLabel& UIElement_LabelElement::statuslabel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.LabelElement.statusLabel)
  return _internal_statuslabel();
}
inline void UIElement_LabelElement::unsafe_arena_set_allocated_statuslabel(::com::zoho::shapes::UIElement_LabelElement_StatusLabel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.statuslabel_);
  }
  _impl_.statuslabel_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.LabelElement.statusLabel)
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* UIElement_LabelElement::release_statuslabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* released = _impl_.statuslabel_;
  _impl_.statuslabel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* UIElement_LabelElement::unsafe_arena_release_statuslabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.LabelElement.statusLabel)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* temp = _impl_.statuslabel_;
  _impl_.statuslabel_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* UIElement_LabelElement::_internal_mutable_statuslabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.statuslabel_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_LabelElement_StatusLabel>(GetArena());
    _impl_.statuslabel_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel*>(p);
  }
  return _impl_.statuslabel_;
}
inline ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* UIElement_LabelElement::mutable_statuslabel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_LabelElement_StatusLabel* _msg = _internal_mutable_statuslabel();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.LabelElement.statusLabel)
  return _msg;
}
inline void UIElement_LabelElement::set_allocated_statuslabel(::com::zoho::shapes::UIElement_LabelElement_StatusLabel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel*>(_impl_.statuslabel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.statuslabel_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement_StatusLabel*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.LabelElement.statusLabel)
}

// -------------------------------------------------------------------

// UIElement_RatingElement_RatingInput

// optional float defVal = 1;
inline bool UIElement_RatingElement_RatingInput::has_defval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UIElement_RatingElement_RatingInput::clear_defval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.defval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float UIElement_RatingElement_RatingInput::defval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.RatingInput.defVal)
  return _internal_defval();
}
inline void UIElement_RatingElement_RatingInput::set_defval(float value) {
  _internal_set_defval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.RatingElement.RatingInput.defVal)
}
inline float UIElement_RatingElement_RatingInput::_internal_defval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defval_;
}
inline void UIElement_RatingElement_RatingInput::_internal_set_defval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.defval_ = value;
}

// optional float maxVal = 2;
inline bool UIElement_RatingElement_RatingInput::has_maxval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_RatingElement_RatingInput::clear_maxval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float UIElement_RatingElement_RatingInput::maxval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.RatingInput.maxVal)
  return _internal_maxval();
}
inline void UIElement_RatingElement_RatingInput::set_maxval(float value) {
  _internal_set_maxval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.RatingElement.RatingInput.maxVal)
}
inline float UIElement_RatingElement_RatingInput::_internal_maxval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxval_;
}
inline void UIElement_RatingElement_RatingInput::_internal_set_maxval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maxval_ = value;
}

// optional float minVal = 3;
inline bool UIElement_RatingElement_RatingInput::has_minval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_RatingElement_RatingInput::clear_minval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float UIElement_RatingElement_RatingInput::minval() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.RatingInput.minVal)
  return _internal_minval();
}
inline void UIElement_RatingElement_RatingInput::set_minval(float value) {
  _internal_set_minval(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.RatingElement.RatingInput.minVal)
}
inline float UIElement_RatingElement_RatingInput::_internal_minval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minval_;
}
inline void UIElement_RatingElement_RatingInput::_internal_set_minval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.minval_ = value;
}

// -------------------------------------------------------------------

// UIElement_RatingElement

// optional .com.zoho.shapes.UIElement.RatingElement.RatingInput ratingInput = 1;
inline bool UIElement_RatingElement::has_ratinginput() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ratinginput_ != nullptr);
  return value;
}
inline void UIElement_RatingElement::clear_ratinginput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ratinginput_ != nullptr) _impl_.ratinginput_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::shapes::UIElement_RatingElement_RatingInput& UIElement_RatingElement::_internal_ratinginput() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_RatingElement_RatingInput* p = _impl_.ratinginput_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_RatingElement_RatingInput&>(::com::zoho::shapes::_UIElement_RatingElement_RatingInput_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_RatingElement_RatingInput& UIElement_RatingElement::ratinginput() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.ratingInput)
  return _internal_ratinginput();
}
inline void UIElement_RatingElement::unsafe_arena_set_allocated_ratinginput(::com::zoho::shapes::UIElement_RatingElement_RatingInput* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ratinginput_);
  }
  _impl_.ratinginput_ = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement_RatingInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.RatingElement.ratingInput)
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingInput* UIElement_RatingElement::release_ratinginput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_RatingElement_RatingInput* released = _impl_.ratinginput_;
  _impl_.ratinginput_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingInput* UIElement_RatingElement::unsafe_arena_release_ratinginput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.RatingElement.ratingInput)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::shapes::UIElement_RatingElement_RatingInput* temp = _impl_.ratinginput_;
  _impl_.ratinginput_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingInput* UIElement_RatingElement::_internal_mutable_ratinginput() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ratinginput_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_RatingElement_RatingInput>(GetArena());
    _impl_.ratinginput_ = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement_RatingInput*>(p);
  }
  return _impl_.ratinginput_;
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingInput* UIElement_RatingElement::mutable_ratinginput() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_RatingElement_RatingInput* _msg = _internal_mutable_ratinginput();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.RatingElement.ratingInput)
  return _msg;
}
inline void UIElement_RatingElement::set_allocated_ratinginput(::com::zoho::shapes::UIElement_RatingElement_RatingInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement_RatingInput*>(_impl_.ratinginput_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement_RatingInput*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ratinginput_ = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement_RatingInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.RatingElement.ratingInput)
}

// optional .com.zoho.shapes.UIElement.RatingElement.RatingElementType type = 2;
inline bool UIElement_RatingElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UIElement_RatingElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingElementType UIElement_RatingElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.type)
  return _internal_type();
}
inline void UIElement_RatingElement::set_type(::com::zoho::shapes::UIElement_RatingElement_RatingElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.RatingElement.type)
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingElementType UIElement_RatingElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_RatingElement_RatingElementType>(_impl_.type_);
}
inline void UIElement_RatingElement::_internal_set_type(::com::zoho::shapes::UIElement_RatingElement_RatingElementType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional int32 numberOfItems = 3;
inline bool UIElement_RatingElement::has_numberofitems() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UIElement_RatingElement::clear_numberofitems() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numberofitems_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t UIElement_RatingElement::numberofitems() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.numberOfItems)
  return _internal_numberofitems();
}
inline void UIElement_RatingElement::set_numberofitems(::int32_t value) {
  _internal_set_numberofitems(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.RatingElement.numberOfItems)
}
inline ::int32_t UIElement_RatingElement::_internal_numberofitems() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numberofitems_;
}
inline void UIElement_RatingElement::_internal_set_numberofitems(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.numberofitems_ = value;
}

// optional .com.zoho.shapes.UIElement.RatingElement.RatingVariable allowedVariable = 4;
inline bool UIElement_RatingElement::has_allowedvariable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UIElement_RatingElement::clear_allowedvariable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allowedvariable_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingVariable UIElement_RatingElement::allowedvariable() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.allowedVariable)
  return _internal_allowedvariable();
}
inline void UIElement_RatingElement::set_allowedvariable(::com::zoho::shapes::UIElement_RatingElement_RatingVariable value) {
  _internal_set_allowedvariable(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.RatingElement.allowedVariable)
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingVariable UIElement_RatingElement::_internal_allowedvariable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_RatingElement_RatingVariable>(_impl_.allowedvariable_);
}
inline void UIElement_RatingElement::_internal_set_allowedvariable(::com::zoho::shapes::UIElement_RatingElement_RatingVariable value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.allowedvariable_ = value;
}

// optional .com.zoho.shapes.UIElement.RatingElement.RatingConcept ratingConcept = 5;
inline bool UIElement_RatingElement::has_ratingconcept() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UIElement_RatingElement::clear_ratingconcept() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ratingconcept_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingConcept UIElement_RatingElement::ratingconcept() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.RatingElement.ratingConcept)
  return _internal_ratingconcept();
}
inline void UIElement_RatingElement::set_ratingconcept(::com::zoho::shapes::UIElement_RatingElement_RatingConcept value) {
  _internal_set_ratingconcept(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.RatingElement.ratingConcept)
}
inline ::com::zoho::shapes::UIElement_RatingElement_RatingConcept UIElement_RatingElement::_internal_ratingconcept() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_RatingElement_RatingConcept>(_impl_.ratingconcept_);
}
inline void UIElement_RatingElement::_internal_set_ratingconcept(::com::zoho::shapes::UIElement_RatingElement_RatingConcept value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ratingconcept_ = value;
}

// -------------------------------------------------------------------

// UIElement_ButtonElement

// -------------------------------------------------------------------

// UIElement

// optional .com.zoho.shapes.UIElement.UIElementType type = 1;
inline bool UIElement::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void UIElement::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::com::zoho::shapes::UIElement_UIElementType UIElement::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.type)
  return _internal_type();
}
inline void UIElement::set_type(::com::zoho::shapes::UIElement_UIElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.shapes.UIElement.type)
}
inline ::com::zoho::shapes::UIElement_UIElementType UIElement::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::shapes::UIElement_UIElementType>(_impl_.type_);
}
inline void UIElement::_internal_set_type(::com::zoho::shapes::UIElement_UIElementType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.type_ = value;
}

// optional .com.zoho.common.Dimension dim = 2;
inline bool UIElement::has_dim() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dim_ != nullptr);
  return value;
}
inline const ::com::zoho::common::Dimension& UIElement::_internal_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::Dimension* p = _impl_.dim_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::Dimension&>(::com::zoho::common::_Dimension_default_instance_);
}
inline const ::com::zoho::common::Dimension& UIElement::dim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.dim)
  return _internal_dim();
}
inline void UIElement::unsafe_arena_set_allocated_dim(::com::zoho::common::Dimension* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dim_);
  }
  _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.dim)
}
inline ::com::zoho::common::Dimension* UIElement::release_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* released = _impl_.dim_;
  _impl_.dim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::Dimension* UIElement::unsafe_arena_release_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.dim)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::common::Dimension* temp = _impl_.dim_;
  _impl_.dim_ = nullptr;
  return temp;
}
inline ::com::zoho::common::Dimension* UIElement::_internal_mutable_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dim_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::Dimension>(GetArena());
    _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(p);
  }
  return _impl_.dim_;
}
inline ::com::zoho::common::Dimension* UIElement::mutable_dim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::Dimension* _msg = _internal_mutable_dim();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.dim)
  return _msg;
}
inline void UIElement::set_allocated_dim(::com::zoho::common::Dimension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dim_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dim_ = reinterpret_cast<::com::zoho::common::Dimension*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.dim)
}

// optional .com.zoho.shapes.UIElement.UserElement userElement = 3;
inline bool UIElement::has_userelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.userelement_ != nullptr);
  return value;
}
inline void UIElement::clear_userelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.userelement_ != nullptr) _impl_.userelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::shapes::UIElement_UserElement& UIElement::_internal_userelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_UserElement* p = _impl_.userelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_UserElement&>(::com::zoho::shapes::_UIElement_UserElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_UserElement& UIElement::userelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.userElement)
  return _internal_userelement();
}
inline void UIElement::unsafe_arena_set_allocated_userelement(::com::zoho::shapes::UIElement_UserElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.userelement_);
  }
  _impl_.userelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.userElement)
}
inline ::com::zoho::shapes::UIElement_UserElement* UIElement::release_userelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_UserElement* released = _impl_.userelement_;
  _impl_.userelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_UserElement* UIElement::unsafe_arena_release_userelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.userElement)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::shapes::UIElement_UserElement* temp = _impl_.userelement_;
  _impl_.userelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_UserElement* UIElement::_internal_mutable_userelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.userelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_UserElement>(GetArena());
    _impl_.userelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement*>(p);
  }
  return _impl_.userelement_;
}
inline ::com::zoho::shapes::UIElement_UserElement* UIElement::mutable_userelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_UserElement* _msg = _internal_mutable_userelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.userElement)
  return _msg;
}
inline void UIElement::set_allocated_userelement(::com::zoho::shapes::UIElement_UserElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_UserElement*>(_impl_.userelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.userelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_UserElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.userElement)
}

// optional .com.zoho.shapes.UIElement.SelectionElement selectionElement = 4;
inline bool UIElement::has_selectionelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selectionelement_ != nullptr);
  return value;
}
inline void UIElement::clear_selectionelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.selectionelement_ != nullptr) _impl_.selectionelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::shapes::UIElement_SelectionElement& UIElement::_internal_selectionelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_SelectionElement* p = _impl_.selectionelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_SelectionElement&>(::com::zoho::shapes::_UIElement_SelectionElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_SelectionElement& UIElement::selectionelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.selectionElement)
  return _internal_selectionelement();
}
inline void UIElement::unsafe_arena_set_allocated_selectionelement(::com::zoho::shapes::UIElement_SelectionElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.selectionelement_);
  }
  _impl_.selectionelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_SelectionElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.selectionElement)
}
inline ::com::zoho::shapes::UIElement_SelectionElement* UIElement::release_selectionelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::UIElement_SelectionElement* released = _impl_.selectionelement_;
  _impl_.selectionelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_SelectionElement* UIElement::unsafe_arena_release_selectionelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.selectionElement)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::shapes::UIElement_SelectionElement* temp = _impl_.selectionelement_;
  _impl_.selectionelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_SelectionElement* UIElement::_internal_mutable_selectionelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.selectionelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_SelectionElement>(GetArena());
    _impl_.selectionelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_SelectionElement*>(p);
  }
  return _impl_.selectionelement_;
}
inline ::com::zoho::shapes::UIElement_SelectionElement* UIElement::mutable_selectionelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_SelectionElement* _msg = _internal_mutable_selectionelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.selectionElement)
  return _msg;
}
inline void UIElement::set_allocated_selectionelement(::com::zoho::shapes::UIElement_SelectionElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_SelectionElement*>(_impl_.selectionelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_SelectionElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.selectionelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_SelectionElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.selectionElement)
}

// optional .com.zoho.shapes.UIElement.SliderElement sliderElement = 5;
inline bool UIElement::has_sliderelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sliderelement_ != nullptr);
  return value;
}
inline void UIElement::clear_sliderelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.sliderelement_ != nullptr) _impl_.sliderelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::com::zoho::shapes::UIElement_SliderElement& UIElement::_internal_sliderelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_SliderElement* p = _impl_.sliderelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_SliderElement&>(::com::zoho::shapes::_UIElement_SliderElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_SliderElement& UIElement::sliderelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.sliderElement)
  return _internal_sliderelement();
}
inline void UIElement::unsafe_arena_set_allocated_sliderelement(::com::zoho::shapes::UIElement_SliderElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sliderelement_);
  }
  _impl_.sliderelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.sliderElement)
}
inline ::com::zoho::shapes::UIElement_SliderElement* UIElement::release_sliderelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::UIElement_SliderElement* released = _impl_.sliderelement_;
  _impl_.sliderelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_SliderElement* UIElement::unsafe_arena_release_sliderelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.sliderElement)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::shapes::UIElement_SliderElement* temp = _impl_.sliderelement_;
  _impl_.sliderelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_SliderElement* UIElement::_internal_mutable_sliderelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.sliderelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_SliderElement>(GetArena());
    _impl_.sliderelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement*>(p);
  }
  return _impl_.sliderelement_;
}
inline ::com::zoho::shapes::UIElement_SliderElement* UIElement::mutable_sliderelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_SliderElement* _msg = _internal_mutable_sliderelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.sliderElement)
  return _msg;
}
inline void UIElement::set_allocated_sliderelement(::com::zoho::shapes::UIElement_SliderElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement*>(_impl_.sliderelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.sliderelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_SliderElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.sliderElement)
}

// optional .com.zoho.shapes.UIElement.CalendarElement calendarElement = 6;
inline bool UIElement::has_calendarelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.calendarelement_ != nullptr);
  return value;
}
inline void UIElement::clear_calendarelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.calendarelement_ != nullptr) _impl_.calendarelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::com::zoho::shapes::UIElement_CalendarElement& UIElement::_internal_calendarelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_CalendarElement* p = _impl_.calendarelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_CalendarElement&>(::com::zoho::shapes::_UIElement_CalendarElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_CalendarElement& UIElement::calendarelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.calendarElement)
  return _internal_calendarelement();
}
inline void UIElement::unsafe_arena_set_allocated_calendarelement(::com::zoho::shapes::UIElement_CalendarElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.calendarelement_);
  }
  _impl_.calendarelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.calendarElement)
}
inline ::com::zoho::shapes::UIElement_CalendarElement* UIElement::release_calendarelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::UIElement_CalendarElement* released = _impl_.calendarelement_;
  _impl_.calendarelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_CalendarElement* UIElement::unsafe_arena_release_calendarelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.calendarElement)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::shapes::UIElement_CalendarElement* temp = _impl_.calendarelement_;
  _impl_.calendarelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_CalendarElement* UIElement::_internal_mutable_calendarelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.calendarelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_CalendarElement>(GetArena());
    _impl_.calendarelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement*>(p);
  }
  return _impl_.calendarelement_;
}
inline ::com::zoho::shapes::UIElement_CalendarElement* UIElement::mutable_calendarelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_CalendarElement* _msg = _internal_mutable_calendarelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.calendarElement)
  return _msg;
}
inline void UIElement::set_allocated_calendarelement(::com::zoho::shapes::UIElement_CalendarElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement*>(_impl_.calendarelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.calendarelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_CalendarElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.calendarElement)
}

// optional .com.zoho.shapes.UIElement.ToggleElement toggleElement = 7;
inline bool UIElement::has_toggleelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.toggleelement_ != nullptr);
  return value;
}
inline void UIElement::clear_toggleelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.toggleelement_ != nullptr) _impl_.toggleelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::com::zoho::shapes::UIElement_ToggleElement& UIElement::_internal_toggleelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ToggleElement* p = _impl_.toggleelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ToggleElement&>(::com::zoho::shapes::_UIElement_ToggleElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ToggleElement& UIElement::toggleelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.toggleElement)
  return _internal_toggleelement();
}
inline void UIElement::unsafe_arena_set_allocated_toggleelement(::com::zoho::shapes::UIElement_ToggleElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.toggleelement_);
  }
  _impl_.toggleelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.toggleElement)
}
inline ::com::zoho::shapes::UIElement_ToggleElement* UIElement::release_toggleelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::UIElement_ToggleElement* released = _impl_.toggleelement_;
  _impl_.toggleelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ToggleElement* UIElement::unsafe_arena_release_toggleelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.toggleElement)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::UIElement_ToggleElement* temp = _impl_.toggleelement_;
  _impl_.toggleelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ToggleElement* UIElement::_internal_mutable_toggleelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.toggleelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ToggleElement>(GetArena());
    _impl_.toggleelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement*>(p);
  }
  return _impl_.toggleelement_;
}
inline ::com::zoho::shapes::UIElement_ToggleElement* UIElement::mutable_toggleelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ToggleElement* _msg = _internal_mutable_toggleelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.toggleElement)
  return _msg;
}
inline void UIElement::set_allocated_toggleelement(::com::zoho::shapes::UIElement_ToggleElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement*>(_impl_.toggleelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.toggleelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_ToggleElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.toggleElement)
}

// optional .com.zoho.shapes.UIElement.StepperElement stepperElement = 8;
inline bool UIElement::has_stepperelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stepperelement_ != nullptr);
  return value;
}
inline void UIElement::clear_stepperelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stepperelement_ != nullptr) _impl_.stepperelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::com::zoho::shapes::UIElement_StepperElement& UIElement::_internal_stepperelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_StepperElement* p = _impl_.stepperelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_StepperElement&>(::com::zoho::shapes::_UIElement_StepperElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_StepperElement& UIElement::stepperelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.stepperElement)
  return _internal_stepperelement();
}
inline void UIElement::unsafe_arena_set_allocated_stepperelement(::com::zoho::shapes::UIElement_StepperElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stepperelement_);
  }
  _impl_.stepperelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.stepperElement)
}
inline ::com::zoho::shapes::UIElement_StepperElement* UIElement::release_stepperelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::shapes::UIElement_StepperElement* released = _impl_.stepperelement_;
  _impl_.stepperelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_StepperElement* UIElement::unsafe_arena_release_stepperelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.stepperElement)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::shapes::UIElement_StepperElement* temp = _impl_.stepperelement_;
  _impl_.stepperelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_StepperElement* UIElement::_internal_mutable_stepperelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.stepperelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_StepperElement>(GetArena());
    _impl_.stepperelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement*>(p);
  }
  return _impl_.stepperelement_;
}
inline ::com::zoho::shapes::UIElement_StepperElement* UIElement::mutable_stepperelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_StepperElement* _msg = _internal_mutable_stepperelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.stepperElement)
  return _msg;
}
inline void UIElement::set_allocated_stepperelement(::com::zoho::shapes::UIElement_StepperElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement*>(_impl_.stepperelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.stepperelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_StepperElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.stepperElement)
}

// optional .com.zoho.shapes.UIElement.LabelElement labelElement = 9;
inline bool UIElement::has_labelelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.labelelement_ != nullptr);
  return value;
}
inline void UIElement::clear_labelelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.labelelement_ != nullptr) _impl_.labelelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::com::zoho::shapes::UIElement_LabelElement& UIElement::_internal_labelelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_LabelElement* p = _impl_.labelelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_LabelElement&>(::com::zoho::shapes::_UIElement_LabelElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_LabelElement& UIElement::labelelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.labelElement)
  return _internal_labelelement();
}
inline void UIElement::unsafe_arena_set_allocated_labelelement(::com::zoho::shapes::UIElement_LabelElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.labelelement_);
  }
  _impl_.labelelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.labelElement)
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement::release_labelelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::shapes::UIElement_LabelElement* released = _impl_.labelelement_;
  _impl_.labelelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement::unsafe_arena_release_labelelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.labelElement)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::shapes::UIElement_LabelElement* temp = _impl_.labelelement_;
  _impl_.labelelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement::_internal_mutable_labelelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.labelelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_LabelElement>(GetArena());
    _impl_.labelelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(p);
  }
  return _impl_.labelelement_;
}
inline ::com::zoho::shapes::UIElement_LabelElement* UIElement::mutable_labelelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_LabelElement* _msg = _internal_mutable_labelelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.labelElement)
  return _msg;
}
inline void UIElement::set_allocated_labelelement(::com::zoho::shapes::UIElement_LabelElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(_impl_.labelelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.labelelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_LabelElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.labelElement)
}

// optional .com.zoho.shapes.UIElement.RatingElement ratingElement = 10;
inline bool UIElement::has_ratingelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ratingelement_ != nullptr);
  return value;
}
inline void UIElement::clear_ratingelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ratingelement_ != nullptr) _impl_.ratingelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::com::zoho::shapes::UIElement_RatingElement& UIElement::_internal_ratingelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_RatingElement* p = _impl_.ratingelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_RatingElement&>(::com::zoho::shapes::_UIElement_RatingElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_RatingElement& UIElement::ratingelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.ratingElement)
  return _internal_ratingelement();
}
inline void UIElement::unsafe_arena_set_allocated_ratingelement(::com::zoho::shapes::UIElement_RatingElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ratingelement_);
  }
  _impl_.ratingelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.ratingElement)
}
inline ::com::zoho::shapes::UIElement_RatingElement* UIElement::release_ratingelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::com::zoho::shapes::UIElement_RatingElement* released = _impl_.ratingelement_;
  _impl_.ratingelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_RatingElement* UIElement::unsafe_arena_release_ratingelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.ratingElement)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::com::zoho::shapes::UIElement_RatingElement* temp = _impl_.ratingelement_;
  _impl_.ratingelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_RatingElement* UIElement::_internal_mutable_ratingelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.ratingelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_RatingElement>(GetArena());
    _impl_.ratingelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement*>(p);
  }
  return _impl_.ratingelement_;
}
inline ::com::zoho::shapes::UIElement_RatingElement* UIElement::mutable_ratingelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_RatingElement* _msg = _internal_mutable_ratingelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.ratingElement)
  return _msg;
}
inline void UIElement::set_allocated_ratingelement(::com::zoho::shapes::UIElement_RatingElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement*>(_impl_.ratingelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.ratingelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_RatingElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.ratingElement)
}

// optional .com.zoho.shapes.UIElement.ButtonElement buttonElement = 11;
inline bool UIElement::has_buttonelement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buttonelement_ != nullptr);
  return value;
}
inline void UIElement::clear_buttonelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.buttonelement_ != nullptr) _impl_.buttonelement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::com::zoho::shapes::UIElement_ButtonElement& UIElement::_internal_buttonelement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::UIElement_ButtonElement* p = _impl_.buttonelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::UIElement_ButtonElement&>(::com::zoho::shapes::_UIElement_ButtonElement_default_instance_);
}
inline const ::com::zoho::shapes::UIElement_ButtonElement& UIElement::buttonelement() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.shapes.UIElement.buttonElement)
  return _internal_buttonelement();
}
inline void UIElement::unsafe_arena_set_allocated_buttonelement(::com::zoho::shapes::UIElement_ButtonElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.buttonelement_);
  }
  _impl_.buttonelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_ButtonElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.shapes.UIElement.buttonElement)
}
inline ::com::zoho::shapes::UIElement_ButtonElement* UIElement::release_buttonelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::com::zoho::shapes::UIElement_ButtonElement* released = _impl_.buttonelement_;
  _impl_.buttonelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::UIElement_ButtonElement* UIElement::unsafe_arena_release_buttonelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.shapes.UIElement.buttonElement)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::com::zoho::shapes::UIElement_ButtonElement* temp = _impl_.buttonelement_;
  _impl_.buttonelement_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::UIElement_ButtonElement* UIElement::_internal_mutable_buttonelement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.buttonelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::UIElement_ButtonElement>(GetArena());
    _impl_.buttonelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_ButtonElement*>(p);
  }
  return _impl_.buttonelement_;
}
inline ::com::zoho::shapes::UIElement_ButtonElement* UIElement::mutable_buttonelement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::UIElement_ButtonElement* _msg = _internal_mutable_buttonelement();
  // @@protoc_insertion_point(field_mutable:com.zoho.shapes.UIElement.buttonElement)
  return _msg;
}
inline void UIElement::set_allocated_buttonelement(::com::zoho::shapes::UIElement_ButtonElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::shapes::UIElement_ButtonElement*>(_impl_.buttonelement_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::shapes::UIElement_ButtonElement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.buttonelement_ = reinterpret_cast<::com::zoho::shapes::UIElement_ButtonElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.shapes.UIElement.buttonElement)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shapes
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType>() {
  return ::com::zoho::shapes::UIElement_UserElement_ProfilePicture_ProfilePictureType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_UserElement_UserElementType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_UserElement_UserElementType>() {
  return ::com::zoho::shapes::UIElement_UserElement_UserElementType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_ListInput_ListInputType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_ListInput_ListInputType>() {
  return ::com::zoho::shapes::UIElement_ListInput_ListInputType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_ListSelection_SelectionFunction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_ListSelection_SelectionFunction>() {
  return ::com::zoho::shapes::UIElement_ListSelection_SelectionFunction_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_ListSelection_SelectionFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_ListSelection_SelectionFormat>() {
  return ::com::zoho::shapes::UIElement_ListSelection_SelectionFormat_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType>() {
  return ::com::zoho::shapes::UIElement_SelectionElement_SelectionElementType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType>() {
  return ::com::zoho::shapes::UIElement_SliderElement_SliderInput_SliderInterval_SliderIntervalType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_SliderElement_SliderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_SliderElement_SliderType>() {
  return ::com::zoho::shapes::UIElement_SliderElement_SliderType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_SliderElement_LinearSliderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_SliderElement_LinearSliderType>() {
  return ::com::zoho::shapes::UIElement_SliderElement_LinearSliderType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_CalendarElement_CalendarType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_CalendarElement_CalendarType>() {
  return ::com::zoho::shapes::UIElement_CalendarElement_CalendarType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat>() {
  return ::com::zoho::shapes::UIElement_CalendarElement_DatePickerFormat_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat>() {
  return ::com::zoho::shapes::UIElement_CalendarElement_TimePickerFormat_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_CalendarElement_ClockFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_CalendarElement_ClockFormat>() {
  return ::com::zoho::shapes::UIElement_CalendarElement_ClockFormat_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType>() {
  return ::com::zoho::shapes::UIElement_ToggleElement_ToggleElementType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_ToggleElement_LabelPosition> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_ToggleElement_LabelPosition>() {
  return ::com::zoho::shapes::UIElement_ToggleElement_LabelPosition_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType>() {
  return ::com::zoho::shapes::UIElement_LabelElement_StatusLabel_StatusSymbol_StatusSymbolType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_LabelElement_LabelElementType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_LabelElement_LabelElementType>() {
  return ::com::zoho::shapes::UIElement_LabelElement_LabelElementType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_RatingElement_RatingElementType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_RatingElement_RatingElementType>() {
  return ::com::zoho::shapes::UIElement_RatingElement_RatingElementType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_RatingElement_RatingVariable> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_RatingElement_RatingVariable>() {
  return ::com::zoho::shapes::UIElement_RatingElement_RatingVariable_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_RatingElement_RatingConcept> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_RatingElement_RatingConcept>() {
  return ::com::zoho::shapes::UIElement_RatingElement_RatingConcept_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::shapes::UIElement_UIElementType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::shapes::UIElement_UIElementType>() {
  return ::com::zoho::shapes::UIElement_UIElementType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_uielement_2eproto_2epb_2eh
