// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chartlayout.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ChartLayout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: ChartLayout.ChartLayoutPosition {
    get {return _storage._title ?? ChartLayout.ChartLayoutPosition()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {_uniqueStorage()._title = nil}

  public var legend: ChartLayout.ChartLayoutPosition {
    get {return _storage._legend ?? ChartLayout.ChartLayoutPosition()}
    set {_uniqueStorage()._legend = newValue}
  }
  /// Returns true if `legend` has been explicitly set.
  public var hasLegend: Bool {return _storage._legend != nil}
  /// Clears the value of `legend`. Subsequent reads from it will return its default value.
  public mutating func clearLegend() {_uniqueStorage()._legend = nil}

  public var axis: [ChartLayout.AxisLayoutData] {
    get {return _storage._axis}
    set {_uniqueStorage()._axis = newValue}
  }

  public var chart: [ChartLayout.ChartTypeSpecificData] {
    get {return _storage._chart}
    set {_uniqueStorage()._chart = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct AxisLayoutData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var axisID: String {
      get {return _storage._axisID ?? String()}
      set {_uniqueStorage()._axisID = newValue}
    }
    /// Returns true if `axisID` has been explicitly set.
    public var hasAxisID: Bool {return _storage._axisID != nil}
    /// Clears the value of `axisID`. Subsequent reads from it will return its default value.
    public mutating func clearAxisID() {_uniqueStorage()._axisID = nil}

    public var axPos: ChartField.PositionElement {
      get {return _storage._axPos ?? .t}
      set {_uniqueStorage()._axPos = newValue}
    }
    /// Returns true if `axPos` has been explicitly set.
    public var hasAxPos: Bool {return _storage._axPos != nil}
    /// Clears the value of `axPos`. Subsequent reads from it will return its default value.
    public mutating func clearAxPos() {_uniqueStorage()._axPos = nil}

    public var title: ChartLayout.ChartLayoutPosition {
      get {return _storage._title ?? ChartLayout.ChartLayoutPosition()}
      set {_uniqueStorage()._title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    public var hasTitle: Bool {return _storage._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    public mutating func clearTitle() {_uniqueStorage()._title = nil}

    public var majorGrid: Bool {
      get {return _storage._majorGrid ?? false}
      set {_uniqueStorage()._majorGrid = newValue}
    }
    /// Returns true if `majorGrid` has been explicitly set.
    public var hasMajorGrid: Bool {return _storage._majorGrid != nil}
    /// Clears the value of `majorGrid`. Subsequent reads from it will return its default value.
    public mutating func clearMajorGrid() {_uniqueStorage()._majorGrid = nil}

    public var minorGrid: Bool {
      get {return _storage._minorGrid ?? false}
      set {_uniqueStorage()._minorGrid = newValue}
    }
    /// Returns true if `minorGrid` has been explicitly set.
    public var hasMinorGrid: Bool {return _storage._minorGrid != nil}
    /// Clears the value of `minorGrid`. Subsequent reads from it will return its default value.
    public mutating func clearMinorGrid() {_uniqueStorage()._minorGrid = nil}

    public var majorTickMark: ChartField.TickMarkType {
      get {return _storage._majorTickMark ?? .none}
      set {_uniqueStorage()._majorTickMark = newValue}
    }
    /// Returns true if `majorTickMark` has been explicitly set.
    public var hasMajorTickMark: Bool {return _storage._majorTickMark != nil}
    /// Clears the value of `majorTickMark`. Subsequent reads from it will return its default value.
    public mutating func clearMajorTickMark() {_uniqueStorage()._majorTickMark = nil}

    public var minorTickMark: ChartField.TickMarkType {
      get {return _storage._minorTickMark ?? .none}
      set {_uniqueStorage()._minorTickMark = newValue}
    }
    /// Returns true if `minorTickMark` has been explicitly set.
    public var hasMinorTickMark: Bool {return _storage._minorTickMark != nil}
    /// Clears the value of `minorTickMark`. Subsequent reads from it will return its default value.
    public mutating func clearMinorTickMark() {_uniqueStorage()._minorTickMark = nil}

    public var labelPos: ChartField.LabelPos {
      get {return _storage._labelPos ?? .nil}
      set {_uniqueStorage()._labelPos = newValue}
    }
    /// Returns true if `labelPos` has been explicitly set.
    public var hasLabelPos: Bool {return _storage._labelPos != nil}
    /// Clears the value of `labelPos`. Subsequent reads from it will return its default value.
    public mutating func clearLabelPos() {_uniqueStorage()._labelPos = nil}

    public var hidden: Bool {
      get {return _storage._hidden ?? false}
      set {_uniqueStorage()._hidden = newValue}
    }
    /// Returns true if `hidden` has been explicitly set.
    public var hasHidden: Bool {return _storage._hidden != nil}
    /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
    public mutating func clearHidden() {_uniqueStorage()._hidden = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ChartTypeSpecificData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: ChartField.ChartType {
      get {return _storage._type ?? .bar}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    public var bar: ChartLayout.ChartTypeSpecificData.BarChartSpecific {
      get {return _storage._bar ?? ChartLayout.ChartTypeSpecificData.BarChartSpecific()}
      set {_uniqueStorage()._bar = newValue}
    }
    /// Returns true if `bar` has been explicitly set.
    public var hasBar: Bool {return _storage._bar != nil}
    /// Clears the value of `bar`. Subsequent reads from it will return its default value.
    public mutating func clearBar() {_uniqueStorage()._bar = nil}

    public var line: ChartLayout.ChartTypeSpecificData.LineChartSpecific {
      get {return _storage._line ?? ChartLayout.ChartTypeSpecificData.LineChartSpecific()}
      set {_uniqueStorage()._line = newValue}
    }
    /// Returns true if `line` has been explicitly set.
    public var hasLine: Bool {return _storage._line != nil}
    /// Clears the value of `line`. Subsequent reads from it will return its default value.
    public mutating func clearLine() {_uniqueStorage()._line = nil}

    public var area: ChartLayout.ChartTypeSpecificData.AreaChartSpecific {
      get {return _storage._area ?? ChartLayout.ChartTypeSpecificData.AreaChartSpecific()}
      set {_uniqueStorage()._area = newValue}
    }
    /// Returns true if `area` has been explicitly set.
    public var hasArea: Bool {return _storage._area != nil}
    /// Clears the value of `area`. Subsequent reads from it will return its default value.
    public mutating func clearArea() {_uniqueStorage()._area = nil}

    public var pie: ChartLayout.ChartTypeSpecificData.PieChartSpecific {
      get {return _storage._pie ?? ChartLayout.ChartTypeSpecificData.PieChartSpecific()}
      set {_uniqueStorage()._pie = newValue}
    }
    /// Returns true if `pie` has been explicitly set.
    public var hasPie: Bool {return _storage._pie != nil}
    /// Clears the value of `pie`. Subsequent reads from it will return its default value.
    public mutating func clearPie() {_uniqueStorage()._pie = nil}

    public var doughnut: ChartLayout.ChartTypeSpecificData.DoughnutChartSpecific {
      get {return _storage._doughnut ?? ChartLayout.ChartTypeSpecificData.DoughnutChartSpecific()}
      set {_uniqueStorage()._doughnut = newValue}
    }
    /// Returns true if `doughnut` has been explicitly set.
    public var hasDoughnut: Bool {return _storage._doughnut != nil}
    /// Clears the value of `doughnut`. Subsequent reads from it will return its default value.
    public mutating func clearDoughnut() {_uniqueStorage()._doughnut = nil}

    public var reppie: ChartLayout.ChartTypeSpecificData.RepresentivePieChartSpecific {
      get {return _storage._reppie ?? ChartLayout.ChartTypeSpecificData.RepresentivePieChartSpecific()}
      set {_uniqueStorage()._reppie = newValue}
    }
    /// Returns true if `reppie` has been explicitly set.
    public var hasReppie: Bool {return _storage._reppie != nil}
    /// Clears the value of `reppie`. Subsequent reads from it will return its default value.
    public mutating func clearReppie() {_uniqueStorage()._reppie = nil}

    /// Do not set textbody and properties data , rendering application relies on ChartStyle to provide styling informations. 
    public var datalabel: DataLabelDetails {
      get {return _storage._datalabel ?? DataLabelDetails()}
      set {_uniqueStorage()._datalabel = newValue}
    }
    /// Returns true if `datalabel` has been explicitly set.
    public var hasDatalabel: Bool {return _storage._datalabel != nil}
    /// Clears the value of `datalabel`. Subsequent reads from it will return its default value.
    public mutating func clearDatalabel() {_uniqueStorage()._datalabel = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct BarChartSpecific {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var gap: Float {
        get {return _gap ?? 0}
        set {_gap = newValue}
      }
      /// Returns true if `gap` has been explicitly set.
      public var hasGap: Bool {return self._gap != nil}
      /// Clears the value of `gap`. Subsequent reads from it will return its default value.
      public mutating func clearGap() {self._gap = nil}

      public var overlap: Float {
        get {return _overlap ?? 0}
        set {_overlap = newValue}
      }
      /// Returns true if `overlap` has been explicitly set.
      public var hasOverlap: Bool {return self._overlap != nil}
      /// Clears the value of `overlap`. Subsequent reads from it will return its default value.
      public mutating func clearOverlap() {self._overlap = nil}

      public var showSeriesLine: Bool {
        get {return _showSeriesLine ?? false}
        set {_showSeriesLine = newValue}
      }
      /// Returns true if `showSeriesLine` has been explicitly set.
      public var hasShowSeriesLine: Bool {return self._showSeriesLine != nil}
      /// Clears the value of `showSeriesLine`. Subsequent reads from it will return its default value.
      public mutating func clearShowSeriesLine() {self._showSeriesLine = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _gap: Float? = nil
      fileprivate var _overlap: Float? = nil
      fileprivate var _showSeriesLine: Bool? = nil
    }

    public struct LineChartSpecific {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var showUpDownBars: Bool {
        get {return _showUpDownBars ?? false}
        set {_showUpDownBars = newValue}
      }
      /// Returns true if `showUpDownBars` has been explicitly set.
      public var hasShowUpDownBars: Bool {return self._showUpDownBars != nil}
      /// Clears the value of `showUpDownBars`. Subsequent reads from it will return its default value.
      public mutating func clearShowUpDownBars() {self._showUpDownBars = nil}

      public var showHighLowLines: Bool {
        get {return _showHighLowLines ?? false}
        set {_showHighLowLines = newValue}
      }
      /// Returns true if `showHighLowLines` has been explicitly set.
      public var hasShowHighLowLines: Bool {return self._showHighLowLines != nil}
      /// Clears the value of `showHighLowLines`. Subsequent reads from it will return its default value.
      public mutating func clearShowHighLowLines() {self._showHighLowLines = nil}

      public var showMarker: Bool {
        get {return _showMarker ?? false}
        set {_showMarker = newValue}
      }
      /// Returns true if `showMarker` has been explicitly set.
      public var hasShowMarker: Bool {return self._showMarker != nil}
      /// Clears the value of `showMarker`. Subsequent reads from it will return its default value.
      public mutating func clearShowMarker() {self._showMarker = nil}

      public var smooth: Bool {
        get {return _smooth ?? false}
        set {_smooth = newValue}
      }
      /// Returns true if `smooth` has been explicitly set.
      public var hasSmooth: Bool {return self._smooth != nil}
      /// Clears the value of `smooth`. Subsequent reads from it will return its default value.
      public mutating func clearSmooth() {self._smooth = nil}

      public var showDropLines: Bool {
        get {return _showDropLines ?? false}
        set {_showDropLines = newValue}
      }
      /// Returns true if `showDropLines` has been explicitly set.
      public var hasShowDropLines: Bool {return self._showDropLines != nil}
      /// Clears the value of `showDropLines`. Subsequent reads from it will return its default value.
      public mutating func clearShowDropLines() {self._showDropLines = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _showUpDownBars: Bool? = nil
      fileprivate var _showHighLowLines: Bool? = nil
      fileprivate var _showMarker: Bool? = nil
      fileprivate var _smooth: Bool? = nil
      fileprivate var _showDropLines: Bool? = nil
    }

    public struct AreaChartSpecific {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var showDropLines: Bool {
        get {return _showDropLines ?? false}
        set {_showDropLines = newValue}
      }
      /// Returns true if `showDropLines` has been explicitly set.
      public var hasShowDropLines: Bool {return self._showDropLines != nil}
      /// Clears the value of `showDropLines`. Subsequent reads from it will return its default value.
      public mutating func clearShowDropLines() {self._showDropLines = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _showDropLines: Bool? = nil
    }

    public struct PieChartSpecific {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var firstSlideAngle: Int32 {
        get {return _firstSlideAngle ?? 0}
        set {_firstSlideAngle = newValue}
      }
      /// Returns true if `firstSlideAngle` has been explicitly set.
      public var hasFirstSlideAngle: Bool {return self._firstSlideAngle != nil}
      /// Clears the value of `firstSlideAngle`. Subsequent reads from it will return its default value.
      public mutating func clearFirstSlideAngle() {self._firstSlideAngle = nil}

      public var explosion: Float {
        get {return _explosion ?? 0}
        set {_explosion = newValue}
      }
      /// Returns true if `explosion` has been explicitly set.
      public var hasExplosion: Bool {return self._explosion != nil}
      /// Clears the value of `explosion`. Subsequent reads from it will return its default value.
      public mutating func clearExplosion() {self._explosion = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _firstSlideAngle: Int32? = nil
      fileprivate var _explosion: Float? = nil
    }

    public struct DoughnutChartSpecific {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var firstSlideAngle: Int32 {
        get {return _firstSlideAngle ?? 0}
        set {_firstSlideAngle = newValue}
      }
      /// Returns true if `firstSlideAngle` has been explicitly set.
      public var hasFirstSlideAngle: Bool {return self._firstSlideAngle != nil}
      /// Clears the value of `firstSlideAngle`. Subsequent reads from it will return its default value.
      public mutating func clearFirstSlideAngle() {self._firstSlideAngle = nil}

      public var holeSize: Int32 {
        get {return _holeSize ?? 0}
        set {_holeSize = newValue}
      }
      /// Returns true if `holeSize` has been explicitly set.
      public var hasHoleSize: Bool {return self._holeSize != nil}
      /// Clears the value of `holeSize`. Subsequent reads from it will return its default value.
      public mutating func clearHoleSize() {self._holeSize = nil}

      /// Distance the data point should be moved from the center of the pie. 
      public var explosion: Float {
        get {return _explosion ?? 0}
        set {_explosion = newValue}
      }
      /// Returns true if `explosion` has been explicitly set.
      public var hasExplosion: Bool {return self._explosion != nil}
      /// Clears the value of `explosion`. Subsequent reads from it will return its default value.
      public mutating func clearExplosion() {self._explosion = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _firstSlideAngle: Int32? = nil
      fileprivate var _holeSize: Int32? = nil
      fileprivate var _explosion: Float? = nil
    }

    public struct RepresentivePieChartSpecific {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Gap size.
      public var gap: Float {
        get {return _gap ?? 0}
        set {_gap = newValue}
      }
      /// Returns true if `gap` has been explicitly set.
      public var hasGap: Bool {return self._gap != nil}
      /// Clears the value of `gap`. Subsequent reads from it will return its default value.
      public mutating func clearGap() {self._gap = nil}

      /// Distance the data point should be moved from the center of the pie. 
      public var explosion: Float {
        get {return _explosion ?? 0}
        set {_explosion = newValue}
      }
      /// Returns true if `explosion` has been explicitly set.
      public var hasExplosion: Bool {return self._explosion != nil}
      /// Clears the value of `explosion`. Subsequent reads from it will return its default value.
      public mutating func clearExplosion() {self._explosion = nil}

      /// Size of the representive pie in Percentage.
      public var secondPlotSize: Int32 {
        get {return _secondPlotSize ?? 0}
        set {_secondPlotSize = newValue}
      }
      /// Returns true if `secondPlotSize` has been explicitly set.
      public var hasSecondPlotSize: Bool {return self._secondPlotSize != nil}
      /// Clears the value of `secondPlotSize`. Subsequent reads from it will return its default value.
      public mutating func clearSecondPlotSize() {self._secondPlotSize = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _gap: Float? = nil
      fileprivate var _explosion: Float? = nil
      fileprivate var _secondPlotSize: Int32? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ChartLayoutPosition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pos: ChartField.PositionElement {
      get {return _pos ?? .t}
      set {_pos = newValue}
    }
    /// Returns true if `pos` has been explicitly set.
    public var hasPos: Bool {return self._pos != nil}
    /// Clears the value of `pos`. Subsequent reads from it will return its default value.
    public mutating func clearPos() {self._pos = nil}

    /// Specified whether this element shall overlap the other elements.
    public var overlay: Bool {
      get {return _overlay ?? false}
      set {_overlay = newValue}
    }
    /// Returns true if `overlay` has been explicitly set.
    public var hasOverlay: Bool {return self._overlay != nil}
    /// Clears the value of `overlay`. Subsequent reads from it will return its default value.
    public mutating func clearOverlay() {self._overlay = nil}

    /// If the legend is manually placed , we will have this entry.
    public var layout: ManualLayout {
      get {return _layout ?? ManualLayout()}
      set {_layout = newValue}
    }
    /// Returns true if `layout` has been explicitly set.
    public var hasLayout: Bool {return self._layout != nil}
    /// Clears the value of `layout`. Subsequent reads from it will return its default value.
    public mutating func clearLayout() {self._layout = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pos: ChartField.PositionElement? = nil
    fileprivate var _overlay: Bool? = nil
    fileprivate var _layout: ManualLayout? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ChartLayout: @unchecked Sendable {}
extension ChartLayout.AxisLayoutData: @unchecked Sendable {}
extension ChartLayout.ChartTypeSpecificData: @unchecked Sendable {}
extension ChartLayout.ChartTypeSpecificData.BarChartSpecific: @unchecked Sendable {}
extension ChartLayout.ChartTypeSpecificData.LineChartSpecific: @unchecked Sendable {}
extension ChartLayout.ChartTypeSpecificData.AreaChartSpecific: @unchecked Sendable {}
extension ChartLayout.ChartTypeSpecificData.PieChartSpecific: @unchecked Sendable {}
extension ChartLayout.ChartTypeSpecificData.DoughnutChartSpecific: @unchecked Sendable {}
extension ChartLayout.ChartTypeSpecificData.RepresentivePieChartSpecific: @unchecked Sendable {}
extension ChartLayout.ChartLayoutPosition: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.chart"

extension ChartLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChartLayout"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "legend"),
    3: .same(proto: "axis"),
    4: .same(proto: "chart"),
  ]

  fileprivate class _StorageClass {
    var _title: ChartLayout.ChartLayoutPosition? = nil
    var _legend: ChartLayout.ChartLayoutPosition? = nil
    var _axis: [ChartLayout.AxisLayoutData] = []
    var _chart: [ChartLayout.ChartTypeSpecificData] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _legend = source._legend
      _axis = source._axis
      _chart = source._chart
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._axis) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chart) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._legend) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._axis) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._chart) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._legend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._axis.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._axis, fieldNumber: 3)
      }
      if !_storage._chart.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chart, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout, rhs: ChartLayout) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._legend != rhs_storage._legend {return false}
        if _storage._axis != rhs_storage._axis {return false}
        if _storage._chart != rhs_storage._chart {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.AxisLayoutData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.protoMessageName + ".AxisLayoutData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axisId"),
    2: .same(proto: "axPos"),
    3: .same(proto: "title"),
    4: .same(proto: "majorGrid"),
    5: .same(proto: "minorGrid"),
    6: .same(proto: "majorTickMark"),
    7: .same(proto: "minorTickMark"),
    8: .same(proto: "labelPos"),
    9: .same(proto: "hidden"),
  ]

  fileprivate class _StorageClass {
    var _axisID: String? = nil
    var _axPos: ChartField.PositionElement? = nil
    var _title: ChartLayout.ChartLayoutPosition? = nil
    var _majorGrid: Bool? = nil
    var _minorGrid: Bool? = nil
    var _majorTickMark: ChartField.TickMarkType? = nil
    var _minorTickMark: ChartField.TickMarkType? = nil
    var _labelPos: ChartField.LabelPos? = nil
    var _hidden: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _axisID = source._axisID
      _axPos = source._axPos
      _title = source._title
      _majorGrid = source._majorGrid
      _minorGrid = source._minorGrid
      _majorTickMark = source._majorTickMark
      _minorTickMark = source._minorTickMark
      _labelPos = source._labelPos
      _hidden = source._hidden
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._axisID == nil {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._axisID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._axPos) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._majorGrid) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._minorGrid) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._majorTickMark) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._minorTickMark) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._labelPos) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._hidden) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._axisID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._axPos {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._majorGrid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._minorGrid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._majorTickMark {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._minorTickMark {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._labelPos {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._hidden {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.AxisLayoutData, rhs: ChartLayout.AxisLayoutData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._axisID != rhs_storage._axisID {return false}
        if _storage._axPos != rhs_storage._axPos {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._majorGrid != rhs_storage._majorGrid {return false}
        if _storage._minorGrid != rhs_storage._minorGrid {return false}
        if _storage._majorTickMark != rhs_storage._majorTickMark {return false}
        if _storage._minorTickMark != rhs_storage._minorTickMark {return false}
        if _storage._labelPos != rhs_storage._labelPos {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartTypeSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.protoMessageName + ".ChartTypeSpecificData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "bar"),
    3: .same(proto: "line"),
    4: .same(proto: "area"),
    5: .same(proto: "pie"),
    6: .same(proto: "doughnut"),
    7: .same(proto: "reppie"),
    8: .same(proto: "datalabel"),
  ]

  fileprivate class _StorageClass {
    var _type: ChartField.ChartType? = nil
    var _bar: ChartLayout.ChartTypeSpecificData.BarChartSpecific? = nil
    var _line: ChartLayout.ChartTypeSpecificData.LineChartSpecific? = nil
    var _area: ChartLayout.ChartTypeSpecificData.AreaChartSpecific? = nil
    var _pie: ChartLayout.ChartTypeSpecificData.PieChartSpecific? = nil
    var _doughnut: ChartLayout.ChartTypeSpecificData.DoughnutChartSpecific? = nil
    var _reppie: ChartLayout.ChartTypeSpecificData.RepresentivePieChartSpecific? = nil
    var _datalabel: DataLabelDetails? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _bar = source._bar
      _line = source._line
      _area = source._area
      _pie = source._pie
      _doughnut = source._doughnut
      _reppie = source._reppie
      _datalabel = source._datalabel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._datalabel, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._bar) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._line) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._area) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._pie) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._doughnut) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._reppie) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._datalabel) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._bar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._line {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._area {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._pie {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._doughnut {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._reppie {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._datalabel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartTypeSpecificData, rhs: ChartLayout.ChartTypeSpecificData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._bar != rhs_storage._bar {return false}
        if _storage._line != rhs_storage._line {return false}
        if _storage._area != rhs_storage._area {return false}
        if _storage._pie != rhs_storage._pie {return false}
        if _storage._doughnut != rhs_storage._doughnut {return false}
        if _storage._reppie != rhs_storage._reppie {return false}
        if _storage._datalabel != rhs_storage._datalabel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartTypeSpecificData.BarChartSpecific: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.ChartTypeSpecificData.protoMessageName + ".BarChartSpecific"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gap"),
    2: .same(proto: "overlap"),
    3: .same(proto: "showSeriesLine"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._gap) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._overlap) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._showSeriesLine) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gap {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overlap {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._showSeriesLine {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartTypeSpecificData.BarChartSpecific, rhs: ChartLayout.ChartTypeSpecificData.BarChartSpecific) -> Bool {
    if lhs._gap != rhs._gap {return false}
    if lhs._overlap != rhs._overlap {return false}
    if lhs._showSeriesLine != rhs._showSeriesLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartTypeSpecificData.LineChartSpecific: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.ChartTypeSpecificData.protoMessageName + ".LineChartSpecific"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "showUpDownBars"),
    2: .same(proto: "showHighLowLines"),
    3: .same(proto: "showMarker"),
    4: .same(proto: "smooth"),
    5: .same(proto: "showDropLines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._showUpDownBars) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._showHighLowLines) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._showMarker) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._smooth) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._showDropLines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._showUpDownBars {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._showHighLowLines {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._showMarker {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._smooth {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._showDropLines {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartTypeSpecificData.LineChartSpecific, rhs: ChartLayout.ChartTypeSpecificData.LineChartSpecific) -> Bool {
    if lhs._showUpDownBars != rhs._showUpDownBars {return false}
    if lhs._showHighLowLines != rhs._showHighLowLines {return false}
    if lhs._showMarker != rhs._showMarker {return false}
    if lhs._smooth != rhs._smooth {return false}
    if lhs._showDropLines != rhs._showDropLines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartTypeSpecificData.AreaChartSpecific: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.ChartTypeSpecificData.protoMessageName + ".AreaChartSpecific"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "showDropLines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._showDropLines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._showDropLines {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartTypeSpecificData.AreaChartSpecific, rhs: ChartLayout.ChartTypeSpecificData.AreaChartSpecific) -> Bool {
    if lhs._showDropLines != rhs._showDropLines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartTypeSpecificData.PieChartSpecific: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.ChartTypeSpecificData.protoMessageName + ".PieChartSpecific"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "firstSlideAngle"),
    2: .same(proto: "explosion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._firstSlideAngle) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._explosion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._firstSlideAngle {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._explosion {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartTypeSpecificData.PieChartSpecific, rhs: ChartLayout.ChartTypeSpecificData.PieChartSpecific) -> Bool {
    if lhs._firstSlideAngle != rhs._firstSlideAngle {return false}
    if lhs._explosion != rhs._explosion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartTypeSpecificData.DoughnutChartSpecific: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.ChartTypeSpecificData.protoMessageName + ".DoughnutChartSpecific"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "firstSlideAngle"),
    2: .same(proto: "holeSize"),
    3: .same(proto: "explosion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._firstSlideAngle) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._holeSize) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._explosion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._firstSlideAngle {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._holeSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._explosion {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartTypeSpecificData.DoughnutChartSpecific, rhs: ChartLayout.ChartTypeSpecificData.DoughnutChartSpecific) -> Bool {
    if lhs._firstSlideAngle != rhs._firstSlideAngle {return false}
    if lhs._holeSize != rhs._holeSize {return false}
    if lhs._explosion != rhs._explosion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartTypeSpecificData.RepresentivePieChartSpecific: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.ChartTypeSpecificData.protoMessageName + ".RepresentivePieChartSpecific"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gap"),
    2: .same(proto: "explosion"),
    3: .same(proto: "secondPlotSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._gap) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._explosion) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._secondPlotSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gap {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._explosion {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._secondPlotSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartTypeSpecificData.RepresentivePieChartSpecific, rhs: ChartLayout.ChartTypeSpecificData.RepresentivePieChartSpecific) -> Bool {
    if lhs._gap != rhs._gap {return false}
    if lhs._explosion != rhs._explosion {return false}
    if lhs._secondPlotSize != rhs._secondPlotSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartLayout.ChartLayoutPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartLayout.protoMessageName + ".ChartLayoutPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    3: .same(proto: "overlay"),
    4: .same(proto: "layout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._pos) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._overlay) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._layout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overlay {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._layout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartLayout.ChartLayoutPosition, rhs: ChartLayout.ChartLayoutPosition) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs._overlay != rhs._overlay {return false}
    if lhs._layout != rhs._layout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
