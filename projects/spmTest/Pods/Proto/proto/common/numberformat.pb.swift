// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: numberformat.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct NumberFormat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: NumberFormat.NumberFormatType {
    get {return _type ?? .unknownNumberformatType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var thousandSeperatorType: NumberFormat.ThousandSeparatorType {
    get {return _thousandSeperatorType ?? .unknownThousandseparatorType}
    set {_thousandSeperatorType = newValue}
  }
  /// Returns true if `thousandSeperatorType` has been explicitly set.
  public var hasThousandSeperatorType: Bool {return self._thousandSeperatorType != nil}
  /// Clears the value of `thousandSeperatorType`. Subsequent reads from it will return its default value.
  public mutating func clearThousandSeperatorType() {self._thousandSeperatorType = nil}

  public var separateByThousand: Bool {
    get {return _separateByThousand ?? false}
    set {_separateByThousand = newValue}
  }
  /// Returns true if `separateByThousand` has been explicitly set.
  public var hasSeparateByThousand: Bool {return self._separateByThousand != nil}
  /// Clears the value of `separateByThousand`. Subsequent reads from it will return its default value.
  public mutating func clearSeparateByThousand() {self._separateByThousand = nil}

  public var decimalPlaces: Int32 {
    get {return _decimalPlaces ?? 0}
    set {_decimalPlaces = newValue}
  }
  /// Returns true if `decimalPlaces` has been explicitly set.
  public var hasDecimalPlaces: Bool {return self._decimalPlaces != nil}
  /// Clears the value of `decimalPlaces`. Subsequent reads from it will return its default value.
  public mutating func clearDecimalPlaces() {self._decimalPlaces = nil}

  public var currency: NumberFormat.Currency {
    get {return _currency ?? NumberFormat.Currency()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  public var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  public mutating func clearCurrency() {self._currency = nil}

  public var fractionFormat: NumberFormat.FractionFormat {
    get {return _fractionFormat ?? NumberFormat.FractionFormat()}
    set {_fractionFormat = newValue}
  }
  /// Returns true if `fractionFormat` has been explicitly set.
  public var hasFractionFormat: Bool {return self._fractionFormat != nil}
  /// Clears the value of `fractionFormat`. Subsequent reads from it will return its default value.
  public mutating func clearFractionFormat() {self._fractionFormat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum NumberFormatType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownNumberformatType // = 0

    /// 2 is just 2 , 
    case regular // = 1

    /// 2 becomes 2.0
    case decimalNumber // = 2

    /// 2.2 beomes "2 1/5" or "2 10/50" or "2 100/500"
    case fraction // = 3

    /// 2.2 becomes 220%
    case percentage // = 4

    public init() {
      self = .unknownNumberformatType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownNumberformatType
      case 1: self = .regular
      case 2: self = .decimalNumber
      case 3: self = .fraction
      case 4: self = .percentage
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownNumberformatType: return 0
      case .regular: return 1
      case .decimalNumber: return 2
      case .fraction: return 3
      case .percentage: return 4
      }
    }

  }

  public enum ThousandSeparatorType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownThousandseparatorType // = 0
    case indian // = 1
    case international // = 2

    public init() {
      self = .unknownThousandseparatorType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownThousandseparatorType
      case 1: self = .indian
      case 2: self = .international
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownThousandseparatorType: return 0
      case .indian: return 1
      case .international: return 2
      }
    }

  }

  public struct Currency {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var currencyOfCountry: NumberFormat.Currency.CurrencyOfCountry {
      get {return _currencyOfCountry ?? .unknownCountry}
      set {_currencyOfCountry = newValue}
    }
    /// Returns true if `currencyOfCountry` has been explicitly set.
    public var hasCurrencyOfCountry: Bool {return self._currencyOfCountry != nil}
    /// Clears the value of `currencyOfCountry`. Subsequent reads from it will return its default value.
    public mutating func clearCurrencyOfCountry() {self._currencyOfCountry = nil}

    /// To be attached before value
    public var beforeValue: NumberFormat.Currency.CurrencyRepresentation {
      get {return _beforeValue ?? .unknownCurrencyRepresentation}
      set {_beforeValue = newValue}
    }
    /// Returns true if `beforeValue` has been explicitly set.
    public var hasBeforeValue: Bool {return self._beforeValue != nil}
    /// Clears the value of `beforeValue`. Subsequent reads from it will return its default value.
    public mutating func clearBeforeValue() {self._beforeValue = nil}

    /// To be attached after value.
    public var afterValue: NumberFormat.Currency.CurrencyRepresentation {
      get {return _afterValue ?? .unknownCurrencyRepresentation}
      set {_afterValue = newValue}
    }
    /// Returns true if `afterValue` has been explicitly set.
    public var hasAfterValue: Bool {return self._afterValue != nil}
    /// Clears the value of `afterValue`. Subsequent reads from it will return its default value.
    public mutating func clearAfterValue() {self._afterValue = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum CurrencyOfCountry: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownCountry // = 0
      case india // = 1
      case unitedStates // = 2
      case europe // = 3
      case unitedKingdom // = 4

      public init() {
        self = .unknownCountry
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownCountry
        case 1: self = .india
        case 2: self = .unitedStates
        case 3: self = .europe
        case 4: self = .unitedKingdom
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownCountry: return 0
        case .india: return 1
        case .unitedStates: return 2
        case .europe: return 3
        case .unitedKingdom: return 4
        }
      }

    }

    public enum CurrencyRepresentation: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownCurrencyRepresentation // = 0
      case currencyCode // = 1
      case symbol // = 2

      public init() {
        self = .unknownCurrencyRepresentation
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownCurrencyRepresentation
        case 1: self = .currencyCode
        case 2: self = .symbol
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownCurrencyRepresentation: return 0
        case .currencyCode: return 1
        case .symbol: return 2
        }
      }

    }

    public init() {}

    fileprivate var _currencyOfCountry: NumberFormat.Currency.CurrencyOfCountry? = nil
    fileprivate var _beforeValue: NumberFormat.Currency.CurrencyRepresentation? = nil
    fileprivate var _afterValue: NumberFormat.Currency.CurrencyRepresentation? = nil
  }

  public struct FractionFormat {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: NumberFormat.FractionFormat.FractionFormatType {
      get {return _type ?? .unknownFractionformatType}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum FractionFormatType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownFractionformatType // = 0

      /// 1/5
      case oneDigit // = 1

      /// 10/50
      case twoDigits // = 2

      /// 100/500
      case threeDigits // = 3

      public init() {
        self = .unknownFractionformatType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownFractionformatType
        case 1: self = .oneDigit
        case 2: self = .twoDigits
        case 3: self = .threeDigits
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownFractionformatType: return 0
        case .oneDigit: return 1
        case .twoDigits: return 2
        case .threeDigits: return 3
        }
      }

    }

    public init() {}

    fileprivate var _type: NumberFormat.FractionFormat.FractionFormatType? = nil
  }

  public init() {}

  fileprivate var _type: NumberFormat.NumberFormatType? = nil
  fileprivate var _thousandSeperatorType: NumberFormat.ThousandSeparatorType? = nil
  fileprivate var _separateByThousand: Bool? = nil
  fileprivate var _decimalPlaces: Int32? = nil
  fileprivate var _currency: NumberFormat.Currency? = nil
  fileprivate var _fractionFormat: NumberFormat.FractionFormat? = nil
}

#if swift(>=4.2)

extension NumberFormat.NumberFormatType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NumberFormat.ThousandSeparatorType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NumberFormat.Currency.CurrencyOfCountry: CaseIterable {
  // Support synthesized by the compiler.
}

extension NumberFormat.Currency.CurrencyRepresentation: CaseIterable {
  // Support synthesized by the compiler.
}

extension NumberFormat.FractionFormat.FractionFormatType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension NumberFormat: @unchecked Sendable {}
extension NumberFormat.NumberFormatType: @unchecked Sendable {}
extension NumberFormat.ThousandSeparatorType: @unchecked Sendable {}
extension NumberFormat.Currency: @unchecked Sendable {}
extension NumberFormat.Currency.CurrencyOfCountry: @unchecked Sendable {}
extension NumberFormat.Currency.CurrencyRepresentation: @unchecked Sendable {}
extension NumberFormat.FractionFormat: @unchecked Sendable {}
extension NumberFormat.FractionFormat.FractionFormatType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.common"

extension NumberFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberFormat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "thousandSeperatorType"),
    3: .same(proto: "separateByThousand"),
    4: .same(proto: "decimalPlaces"),
    5: .same(proto: "currency"),
    6: .same(proto: "fractionFormat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._thousandSeperatorType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._separateByThousand) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._decimalPlaces) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._currency) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._fractionFormat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._thousandSeperatorType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._separateByThousand {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._decimalPlaces {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._currency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._fractionFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NumberFormat, rhs: NumberFormat) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._thousandSeperatorType != rhs._thousandSeperatorType {return false}
    if lhs._separateByThousand != rhs._separateByThousand {return false}
    if lhs._decimalPlaces != rhs._decimalPlaces {return false}
    if lhs._currency != rhs._currency {return false}
    if lhs._fractionFormat != rhs._fractionFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NumberFormat.NumberFormatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_NUMBERFORMAT_TYPE"),
    1: .same(proto: "REGULAR"),
    2: .same(proto: "DECIMAL_NUMBER"),
    3: .same(proto: "FRACTION"),
    4: .same(proto: "PERCENTAGE"),
  ]
}

extension NumberFormat.ThousandSeparatorType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_THOUSANDSEPARATOR_TYPE"),
    1: .same(proto: "INDIAN"),
    2: .same(proto: "INTERNATIONAL"),
  ]
}

extension NumberFormat.Currency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NumberFormat.protoMessageName + ".Currency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currencyOfCountry"),
    2: .same(proto: "beforeValue"),
    3: .same(proto: "afterValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._currencyOfCountry) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._beforeValue) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._afterValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currencyOfCountry {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._beforeValue {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._afterValue {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NumberFormat.Currency, rhs: NumberFormat.Currency) -> Bool {
    if lhs._currencyOfCountry != rhs._currencyOfCountry {return false}
    if lhs._beforeValue != rhs._beforeValue {return false}
    if lhs._afterValue != rhs._afterValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NumberFormat.Currency.CurrencyOfCountry: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_COUNTRY"),
    1: .same(proto: "INDIA"),
    2: .same(proto: "UNITED_STATES"),
    3: .same(proto: "EUROPE"),
    4: .same(proto: "UNITED_KINGDOM"),
  ]
}

extension NumberFormat.Currency.CurrencyRepresentation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CURRENCY_REPRESENTATION"),
    1: .same(proto: "CURRENCY_CODE"),
    2: .same(proto: "SYMBOL"),
  ]
}

extension NumberFormat.FractionFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NumberFormat.protoMessageName + ".FractionFormat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NumberFormat.FractionFormat, rhs: NumberFormat.FractionFormat) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NumberFormat.FractionFormat.FractionFormatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_FRACTIONFORMAT_TYPE"),
    1: .same(proto: "ONE_DIGIT"),
    2: .same(proto: "TWO_DIGITS"),
    3: .same(proto: "THREE_DIGITS"),
  ]
}
