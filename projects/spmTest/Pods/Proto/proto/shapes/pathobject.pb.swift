// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pathobject.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PathObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: PathObject.PathType {
    get {return _storage._type ?? .m}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// move to this point
  public var m: PathObject.Point {
    get {return _storage._m ?? PathObject.Point()}
    set {_uniqueStorage()._m = newValue}
  }
  /// Returns true if `m` has been explicitly set.
  public var hasM: Bool {return _storage._m != nil}
  /// Clears the value of `m`. Subsequent reads from it will return its default value.
  public mutating func clearM() {_uniqueStorage()._m = nil}

  /// draw line to this point
  public var l: PathObject.Point {
    get {return _storage._l ?? PathObject.Point()}
    set {_uniqueStorage()._l = newValue}
  }
  /// Returns true if `l` has been explicitly set.
  public var hasL: Bool {return _storage._l != nil}
  /// Clears the value of `l`. Subsequent reads from it will return its default value.
  public mutating func clearL() {_uniqueStorage()._l = nil}

  /// Cubic Curve , carries three points -> Control point 1 , Control Point 2 , End Point.
  public var cc: [PathObject.Point] {
    get {return _storage._cc}
    set {_uniqueStorage()._cc = newValue}
  }

  /// Quadratic Curve , carries two points -> Control Point1 , End Point.
  public var qc: [PathObject.Point] {
    get {return _storage._qc}
    set {_uniqueStorage()._qc = newValue}
  }

  /// Close the path
  public var c: Bool {
    get {return _storage._c ?? false}
    set {_uniqueStorage()._c = newValue}
  }
  /// Returns true if `c` has been explicitly set.
  public var hasC: Bool {return _storage._c != nil}
  /// Clears the value of `c`. Subsequent reads from it will return its default value.
  public mutating func clearC() {_uniqueStorage()._c = nil}

  public var ea: PathObject.EllipticalArc {
    get {return _storage._ea ?? PathObject.EllipticalArc()}
    set {_uniqueStorage()._ea = newValue}
  }
  /// Returns true if `ea` has been explicitly set.
  public var hasEa: Bool {return _storage._ea != nil}
  /// Clears the value of `ea`. Subsequent reads from it will return its default value.
  public mutating func clearEa() {_uniqueStorage()._ea = nil}

  /// Symmetric Cubic Curve - Contains two Points -> Control Point 1, End Point. The First Control point is assumed to be the reflection of the second control point of the previous command or the current point
  public var scc: [PathObject.Point] {
    get {return _storage._scc}
    set {_uniqueStorage()._scc = newValue}
  }

  /// Symmetric Quadratic Curve - Contains one Point -> End point. The Control point is assumed to be the reflection of the control point of the previous command or the current point.
  public var sqc: [PathObject.Point] {
    get {return _storage._sqc}
    set {_uniqueStorage()._sqc = newValue}
  }

  /// Indicates the presence of control along with path values - mainly used by M and QC types.
  public var editControlPoint: Bool {
    get {return _storage._editControlPoint ?? false}
    set {_uniqueStorage()._editControlPoint = newValue}
  }
  /// Returns true if `editControlPoint` has been explicitly set.
  public var hasEditControlPoint: Bool {return _storage._editControlPoint != nil}
  /// Clears the value of `editControlPoint`. Subsequent reads from it will return its default value.
  public mutating func clearEditControlPoint() {_uniqueStorage()._editControlPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PathType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case m // = 0
    case l // = 1
    case cc // = 2
    case qc // = 3
    case c // = 4
    case ea // = 5
    case scc // = 6
    case sqc // = 7

    public init() {
      self = .m
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .m
      case 1: self = .l
      case 2: self = .cc
      case 3: self = .qc
      case 4: self = .c
      case 5: self = .ea
      case 6: self = .scc
      case 7: self = .sqc
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .m: return 0
      case .l: return 1
      case .cc: return 2
      case .qc: return 3
      case .c: return 4
      case .ea: return 5
      case .scc: return 6
      case .sqc: return 7
      }
    }

  }

  public struct Point {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var x: Float {
      get {return _x ?? 0}
      set {_x = newValue}
    }
    /// Returns true if `x` has been explicitly set.
    public var hasX: Bool {return self._x != nil}
    /// Clears the value of `x`. Subsequent reads from it will return its default value.
    public mutating func clearX() {self._x = nil}

    public var y: Float {
      get {return _y ?? 0}
      set {_y = newValue}
    }
    /// Returns true if `y` has been explicitly set.
    public var hasY: Bool {return self._y != nil}
    /// Clears the value of `y`. Subsequent reads from it will return its default value.
    public mutating func clearY() {self._y = nil}

    public var radius: Float {
      get {return _radius ?? 0}
      set {_radius = newValue}
    }
    /// Returns true if `radius` has been explicitly set.
    public var hasRadius: Bool {return self._radius != nil}
    /// Clears the value of `radius`. Subsequent reads from it will return its default value.
    public mutating func clearRadius() {self._radius = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _x: Float? = nil
    fileprivate var _y: Float? = nil
    fileprivate var _radius: Float? = nil
  }

  public struct EllipticalArc {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// X Radius 
    public var xRadius: Float {
      get {return _xRadius ?? 0}
      set {_xRadius = newValue}
    }
    /// Returns true if `xRadius` has been explicitly set.
    public var hasXRadius: Bool {return self._xRadius != nil}
    /// Clears the value of `xRadius`. Subsequent reads from it will return its default value.
    public mutating func clearXRadius() {self._xRadius = nil}

    /// Y Radius 
    public var yRadius: Float {
      get {return _yRadius ?? 0}
      set {_yRadius = newValue}
    }
    /// Returns true if `yRadius` has been explicitly set.
    public var hasYRadius: Bool {return self._yRadius != nil}
    /// Clears the value of `yRadius`. Subsequent reads from it will return its default value.
    public mutating func clearYRadius() {self._yRadius = nil}

    /// Starting Angle 
    public var stAngle: Float {
      get {return _stAngle ?? 0}
      set {_stAngle = newValue}
    }
    /// Returns true if `stAngle` has been explicitly set.
    public var hasStAngle: Bool {return self._stAngle != nil}
    /// Clears the value of `stAngle`. Subsequent reads from it will return its default value.
    public mutating func clearStAngle() {self._stAngle = nil}

    /// Sweep Angle in clockwise direction.
    public var swAngle: Float {
      get {return _swAngle ?? 0}
      set {_swAngle = newValue}
    }
    /// Returns true if `swAngle` has been explicitly set.
    public var hasSwAngle: Bool {return self._swAngle != nil}
    /// Clears the value of `swAngle`. Subsequent reads from it will return its default value.
    public mutating func clearSwAngle() {self._swAngle = nil}

    /// End point for the Arc
    public var end: PathObject.Point {
      get {return _end ?? PathObject.Point()}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    public var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    public mutating func clearEnd() {self._end = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _xRadius: Float? = nil
    fileprivate var _yRadius: Float? = nil
    fileprivate var _stAngle: Float? = nil
    fileprivate var _swAngle: Float? = nil
    fileprivate var _end: PathObject.Point? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension PathObject.PathType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension PathObject: @unchecked Sendable {}
extension PathObject.PathType: @unchecked Sendable {}
extension PathObject.Point: @unchecked Sendable {}
extension PathObject.EllipticalArc: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension PathObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PathObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "m"),
    3: .same(proto: "l"),
    4: .same(proto: "cc"),
    5: .same(proto: "qc"),
    6: .same(proto: "c"),
    7: .same(proto: "ea"),
    8: .same(proto: "scc"),
    9: .same(proto: "sqc"),
    10: .same(proto: "editControlPoint"),
  ]

  fileprivate class _StorageClass {
    var _type: PathObject.PathType? = nil
    var _m: PathObject.Point? = nil
    var _l: PathObject.Point? = nil
    var _cc: [PathObject.Point] = []
    var _qc: [PathObject.Point] = []
    var _c: Bool? = nil
    var _ea: PathObject.EllipticalArc? = nil
    var _scc: [PathObject.Point] = []
    var _sqc: [PathObject.Point] = []
    var _editControlPoint: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _m = source._m
      _l = source._l
      _cc = source._cc
      _qc = source._qc
      _c = source._c
      _ea = source._ea
      _scc = source._scc
      _sqc = source._sqc
      _editControlPoint = source._editControlPoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._m, !v.isInitialized {return false}
      if let v = _storage._l, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._cc) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._qc) {return false}
      if let v = _storage._ea, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._scc) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sqc) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._m) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._l) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._cc) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._qc) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._c) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._ea) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._scc) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._sqc) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._editControlPoint) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._m {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._l {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._cc.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cc, fieldNumber: 4)
      }
      if !_storage._qc.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._qc, fieldNumber: 5)
      }
      try { if let v = _storage._c {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._ea {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._scc.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._scc, fieldNumber: 8)
      }
      if !_storage._sqc.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sqc, fieldNumber: 9)
      }
      try { if let v = _storage._editControlPoint {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PathObject, rhs: PathObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._m != rhs_storage._m {return false}
        if _storage._l != rhs_storage._l {return false}
        if _storage._cc != rhs_storage._cc {return false}
        if _storage._qc != rhs_storage._qc {return false}
        if _storage._c != rhs_storage._c {return false}
        if _storage._ea != rhs_storage._ea {return false}
        if _storage._scc != rhs_storage._scc {return false}
        if _storage._sqc != rhs_storage._sqc {return false}
        if _storage._editControlPoint != rhs_storage._editControlPoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PathObject.PathType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "M"),
    1: .same(proto: "L"),
    2: .same(proto: "CC"),
    3: .same(proto: "QC"),
    4: .same(proto: "C"),
    5: .same(proto: "EA"),
    6: .same(proto: "SCC"),
    7: .same(proto: "SQC"),
  ]
}

extension PathObject.Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PathObject.protoMessageName + ".Point"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "radius"),
  ]

  public var isInitialized: Bool {
    if self._x == nil {return false}
    if self._y == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._radius) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._x {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._y {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._radius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PathObject.Point, rhs: PathObject.Point) -> Bool {
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs._radius != rhs._radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PathObject.EllipticalArc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PathObject.protoMessageName + ".EllipticalArc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "xRadius"),
    2: .same(proto: "yRadius"),
    3: .same(proto: "stAngle"),
    4: .same(proto: "swAngle"),
    5: .same(proto: "end"),
  ]

  public var isInitialized: Bool {
    if self._xRadius == nil {return false}
    if self._yRadius == nil {return false}
    if self._stAngle == nil {return false}
    if self._swAngle == nil {return false}
    if let v = self._end, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._xRadius) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._yRadius) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._stAngle) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._swAngle) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._xRadius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._yRadius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stAngle {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._swAngle {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PathObject.EllipticalArc, rhs: PathObject.EllipticalArc) -> Bool {
    if lhs._xRadius != rhs._xRadius {return false}
    if lhs._yRadius != rhs._yRadius {return false}
    if lhs._stAngle != rhs._stAngle {return false}
    if lhs._swAngle != rhs._swAngle {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
