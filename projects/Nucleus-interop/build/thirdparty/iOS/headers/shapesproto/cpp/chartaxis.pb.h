// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chartaxis.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_chartaxis_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_chartaxis_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "titleelement.pb.h"
#include "horizontalaligntype.pb.h"
#include "properties.pb.h"
#include "textbody.pb.h"
#include "google/protobuf/protoextensions.pb.h"
#include "fields.pb.h"
#include "numberformat.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_chartaxis_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_chartaxis_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_chartaxis_2eproto;
namespace com {
namespace zoho {
namespace chart {
class ChartAxis;
struct ChartAxisDefaultTypeInternal;
extern ChartAxisDefaultTypeInternal _ChartAxis_default_instance_;
class ChartAxis_AxisDetails;
struct ChartAxis_AxisDetailsDefaultTypeInternal;
extern ChartAxis_AxisDetailsDefaultTypeInternal _ChartAxis_AxisDetails_default_instance_;
class ChartAxis_AxisDetails_Cross;
struct ChartAxis_AxisDetails_CrossDefaultTypeInternal;
extern ChartAxis_AxisDetails_CrossDefaultTypeInternal _ChartAxis_AxisDetails_Cross_default_instance_;
class ChartAxis_AxisDetails_Scaling;
struct ChartAxis_AxisDetails_ScalingDefaultTypeInternal;
extern ChartAxis_AxisDetails_ScalingDefaultTypeInternal _ChartAxis_AxisDetails_Scaling_default_instance_;
class ChartAxis_CategoryAxis;
struct ChartAxis_CategoryAxisDefaultTypeInternal;
extern ChartAxis_CategoryAxisDefaultTypeInternal _ChartAxis_CategoryAxis_default_instance_;
class ChartAxis_DateAxis;
struct ChartAxis_DateAxisDefaultTypeInternal;
extern ChartAxis_DateAxisDefaultTypeInternal _ChartAxis_DateAxis_default_instance_;
class ChartAxis_SeriesAxis;
struct ChartAxis_SeriesAxisDefaultTypeInternal;
extern ChartAxis_SeriesAxisDefaultTypeInternal _ChartAxis_SeriesAxis_default_instance_;
class ChartAxis_ValueAxis;
struct ChartAxis_ValueAxisDefaultTypeInternal;
extern ChartAxis_ValueAxisDefaultTypeInternal _ChartAxis_ValueAxis_default_instance_;
class ChartAxis_ValueAxis_DisplayUnit;
struct ChartAxis_ValueAxis_DisplayUnitDefaultTypeInternal;
extern ChartAxis_ValueAxis_DisplayUnitDefaultTypeInternal _ChartAxis_ValueAxis_DisplayUnit_default_instance_;
}  // namespace chart
}  // namespace zoho
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace zoho {
namespace chart {
enum ChartAxis_AxisDetails_Scaling_Orientation : int {
  ChartAxis_AxisDetails_Scaling_Orientation_MINMAX = 0,
  ChartAxis_AxisDetails_Scaling_Orientation_MAXMIN = 1,
  ChartAxis_AxisDetails_Scaling_Orientation_ChartAxis_AxisDetails_Scaling_Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartAxis_AxisDetails_Scaling_Orientation_ChartAxis_AxisDetails_Scaling_Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartAxis_AxisDetails_Scaling_Orientation_IsValid(int value);
extern const uint32_t ChartAxis_AxisDetails_Scaling_Orientation_internal_data_[];
constexpr ChartAxis_AxisDetails_Scaling_Orientation ChartAxis_AxisDetails_Scaling_Orientation_Orientation_MIN = static_cast<ChartAxis_AxisDetails_Scaling_Orientation>(0);
constexpr ChartAxis_AxisDetails_Scaling_Orientation ChartAxis_AxisDetails_Scaling_Orientation_Orientation_MAX = static_cast<ChartAxis_AxisDetails_Scaling_Orientation>(1);
constexpr int ChartAxis_AxisDetails_Scaling_Orientation_Orientation_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ChartAxis_AxisDetails_Scaling_Orientation_descriptor();
template <typename T>
const std::string& ChartAxis_AxisDetails_Scaling_Orientation_Name(T value) {
  static_assert(std::is_same<T, ChartAxis_AxisDetails_Scaling_Orientation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Orientation_Name().");
  return ChartAxis_AxisDetails_Scaling_Orientation_Name(static_cast<ChartAxis_AxisDetails_Scaling_Orientation>(value));
}
template <>
inline const std::string& ChartAxis_AxisDetails_Scaling_Orientation_Name(ChartAxis_AxisDetails_Scaling_Orientation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartAxis_AxisDetails_Scaling_Orientation_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ChartAxis_AxisDetails_Scaling_Orientation_Parse(absl::string_view name, ChartAxis_AxisDetails_Scaling_Orientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartAxis_AxisDetails_Scaling_Orientation>(
      ChartAxis_AxisDetails_Scaling_Orientation_descriptor(), name, value);
}
enum ChartAxis_AxisDetails_Cross_CrossType : int {
  ChartAxis_AxisDetails_Cross_CrossType_AUTOZERO = 0,
  ChartAxis_AxisDetails_Cross_CrossType_MIN = 1,
  ChartAxis_AxisDetails_Cross_CrossType_MAX = 2,
  ChartAxis_AxisDetails_Cross_CrossType_MANUAL = 3,
  ChartAxis_AxisDetails_Cross_CrossType_ChartAxis_AxisDetails_Cross_CrossType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartAxis_AxisDetails_Cross_CrossType_ChartAxis_AxisDetails_Cross_CrossType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartAxis_AxisDetails_Cross_CrossType_IsValid(int value);
extern const uint32_t ChartAxis_AxisDetails_Cross_CrossType_internal_data_[];
constexpr ChartAxis_AxisDetails_Cross_CrossType ChartAxis_AxisDetails_Cross_CrossType_CrossType_MIN = static_cast<ChartAxis_AxisDetails_Cross_CrossType>(0);
constexpr ChartAxis_AxisDetails_Cross_CrossType ChartAxis_AxisDetails_Cross_CrossType_CrossType_MAX = static_cast<ChartAxis_AxisDetails_Cross_CrossType>(3);
constexpr int ChartAxis_AxisDetails_Cross_CrossType_CrossType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChartAxis_AxisDetails_Cross_CrossType_descriptor();
template <typename T>
const std::string& ChartAxis_AxisDetails_Cross_CrossType_Name(T value) {
  static_assert(std::is_same<T, ChartAxis_AxisDetails_Cross_CrossType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CrossType_Name().");
  return ChartAxis_AxisDetails_Cross_CrossType_Name(static_cast<ChartAxis_AxisDetails_Cross_CrossType>(value));
}
template <>
inline const std::string& ChartAxis_AxisDetails_Cross_CrossType_Name(ChartAxis_AxisDetails_Cross_CrossType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartAxis_AxisDetails_Cross_CrossType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ChartAxis_AxisDetails_Cross_CrossType_Parse(absl::string_view name, ChartAxis_AxisDetails_Cross_CrossType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartAxis_AxisDetails_Cross_CrossType>(
      ChartAxis_AxisDetails_Cross_CrossType_descriptor(), name, value);
}
enum ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType : int {
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_NONE = 0,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_HUNDREDS = 1,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_THOUSANDS = 2,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_TENTHOUSANDS = 3,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_HUNDREDTHOUSANDS = 4,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_MILLIONS = 5,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_TENMILLIONS = 6,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_HUNDREDMILLIONS = 7,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_BILLIONS = 8,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_TRILLIONS = 9,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_CUSTOM = 10,
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_IsValid(int value);
extern const uint32_t ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_internal_data_[];
constexpr ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_DisplayUnitType_MIN = static_cast<ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType>(0);
constexpr ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_DisplayUnitType_MAX = static_cast<ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType>(10);
constexpr int ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_DisplayUnitType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_descriptor();
template <typename T>
const std::string& ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Name(T value) {
  static_assert(std::is_same<T, ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DisplayUnitType_Name().");
  return ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Name(static_cast<ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType>(value));
}
template <>
inline const std::string& ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Name(ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Parse(absl::string_view name, ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType>(
      ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_descriptor(), name, value);
}
enum ChartAxis_ValueAxis_CrossBetween : int {
  ChartAxis_ValueAxis_CrossBetween_DEFAULT = 0,
  ChartAxis_ValueAxis_CrossBetween_MIDCAT = 1,
  ChartAxis_ValueAxis_CrossBetween_ChartAxis_ValueAxis_CrossBetween_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartAxis_ValueAxis_CrossBetween_ChartAxis_ValueAxis_CrossBetween_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartAxis_ValueAxis_CrossBetween_IsValid(int value);
extern const uint32_t ChartAxis_ValueAxis_CrossBetween_internal_data_[];
constexpr ChartAxis_ValueAxis_CrossBetween ChartAxis_ValueAxis_CrossBetween_CrossBetween_MIN = static_cast<ChartAxis_ValueAxis_CrossBetween>(0);
constexpr ChartAxis_ValueAxis_CrossBetween ChartAxis_ValueAxis_CrossBetween_CrossBetween_MAX = static_cast<ChartAxis_ValueAxis_CrossBetween>(1);
constexpr int ChartAxis_ValueAxis_CrossBetween_CrossBetween_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ChartAxis_ValueAxis_CrossBetween_descriptor();
template <typename T>
const std::string& ChartAxis_ValueAxis_CrossBetween_Name(T value) {
  static_assert(std::is_same<T, ChartAxis_ValueAxis_CrossBetween>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CrossBetween_Name().");
  return ChartAxis_ValueAxis_CrossBetween_Name(static_cast<ChartAxis_ValueAxis_CrossBetween>(value));
}
template <>
inline const std::string& ChartAxis_ValueAxis_CrossBetween_Name(ChartAxis_ValueAxis_CrossBetween value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartAxis_ValueAxis_CrossBetween_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ChartAxis_ValueAxis_CrossBetween_Parse(absl::string_view name, ChartAxis_ValueAxis_CrossBetween* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartAxis_ValueAxis_CrossBetween>(
      ChartAxis_ValueAxis_CrossBetween_descriptor(), name, value);
}
enum ChartAxis_DateAxis_TimeUnit : int {
  ChartAxis_DateAxis_TimeUnit_DAYS = 0,
  ChartAxis_DateAxis_TimeUnit_MONTHS = 1,
  ChartAxis_DateAxis_TimeUnit_YEARS = 2,
  ChartAxis_DateAxis_TimeUnit_ChartAxis_DateAxis_TimeUnit_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartAxis_DateAxis_TimeUnit_ChartAxis_DateAxis_TimeUnit_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartAxis_DateAxis_TimeUnit_IsValid(int value);
extern const uint32_t ChartAxis_DateAxis_TimeUnit_internal_data_[];
constexpr ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis_TimeUnit_TimeUnit_MIN = static_cast<ChartAxis_DateAxis_TimeUnit>(0);
constexpr ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis_TimeUnit_TimeUnit_MAX = static_cast<ChartAxis_DateAxis_TimeUnit>(2);
constexpr int ChartAxis_DateAxis_TimeUnit_TimeUnit_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ChartAxis_DateAxis_TimeUnit_descriptor();
template <typename T>
const std::string& ChartAxis_DateAxis_TimeUnit_Name(T value) {
  static_assert(std::is_same<T, ChartAxis_DateAxis_TimeUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TimeUnit_Name().");
  return ChartAxis_DateAxis_TimeUnit_Name(static_cast<ChartAxis_DateAxis_TimeUnit>(value));
}
template <>
inline const std::string& ChartAxis_DateAxis_TimeUnit_Name(ChartAxis_DateAxis_TimeUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartAxis_DateAxis_TimeUnit_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ChartAxis_DateAxis_TimeUnit_Parse(absl::string_view name, ChartAxis_DateAxis_TimeUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartAxis_DateAxis_TimeUnit>(
      ChartAxis_DateAxis_TimeUnit_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ChartAxis_AxisDetails_Scaling final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.AxisDetails.Scaling) */ {
 public:
  inline ChartAxis_AxisDetails_Scaling() : ChartAxis_AxisDetails_Scaling(nullptr) {}
  ~ChartAxis_AxisDetails_Scaling() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_AxisDetails_Scaling(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_AxisDetails_Scaling(const ChartAxis_AxisDetails_Scaling& from)
      : ChartAxis_AxisDetails_Scaling(nullptr, from) {}
  ChartAxis_AxisDetails_Scaling(ChartAxis_AxisDetails_Scaling&& from) noexcept
    : ChartAxis_AxisDetails_Scaling() {
    *this = ::std::move(from);
  }

  inline ChartAxis_AxisDetails_Scaling& operator=(const ChartAxis_AxisDetails_Scaling& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_AxisDetails_Scaling& operator=(ChartAxis_AxisDetails_Scaling&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_AxisDetails_Scaling& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_AxisDetails_Scaling* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_AxisDetails_Scaling*>(
               &_ChartAxis_AxisDetails_Scaling_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChartAxis_AxisDetails_Scaling& a, ChartAxis_AxisDetails_Scaling& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_AxisDetails_Scaling* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_AxisDetails_Scaling* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_AxisDetails_Scaling* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_AxisDetails_Scaling>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_AxisDetails_Scaling& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_AxisDetails_Scaling& from) {
    ChartAxis_AxisDetails_Scaling::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_AxisDetails_Scaling* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.AxisDetails.Scaling";
  }
  protected:
  explicit ChartAxis_AxisDetails_Scaling(::google::protobuf::Arena* arena);
  ChartAxis_AxisDetails_Scaling(::google::protobuf::Arena* arena, const ChartAxis_AxisDetails_Scaling& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Orientation = ChartAxis_AxisDetails_Scaling_Orientation;
  static constexpr Orientation MINMAX = ChartAxis_AxisDetails_Scaling_Orientation_MINMAX;
  static constexpr Orientation MAXMIN = ChartAxis_AxisDetails_Scaling_Orientation_MAXMIN;
  static inline bool Orientation_IsValid(int value) {
    return ChartAxis_AxisDetails_Scaling_Orientation_IsValid(value);
  }
  static constexpr Orientation Orientation_MIN = ChartAxis_AxisDetails_Scaling_Orientation_Orientation_MIN;
  static constexpr Orientation Orientation_MAX = ChartAxis_AxisDetails_Scaling_Orientation_Orientation_MAX;
  static constexpr int Orientation_ARRAYSIZE = ChartAxis_AxisDetails_Scaling_Orientation_Orientation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Orientation_descriptor() {
    return ChartAxis_AxisDetails_Scaling_Orientation_descriptor();
  }
  template <typename T>
  static inline const std::string& Orientation_Name(T value) {
    return ChartAxis_AxisDetails_Scaling_Orientation_Name(value);
  }
  static inline bool Orientation_Parse(absl::string_view name, Orientation* value) {
    return ChartAxis_AxisDetails_Scaling_Orientation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOrientFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  // optional .com.zoho.chart.ChartAxis.AxisDetails.Scaling.Orientation orient = 1;
  bool has_orient() const;
  void clear_orient() ;
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation orient() const;
  void set_orient(::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation value);

  private:
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation _internal_orient() const;
  void _internal_set_orient(::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation value);

  public:
  // optional float min = 2;
  bool has_min() const;
  void clear_min() ;
  float min() const;
  void set_min(float value);

  private:
  float _internal_min() const;
  void _internal_set_min(float value);

  public:
  // optional float max = 3;
  bool has_max() const;
  void clear_max() ;
  float max() const;
  void set_max(float value);

  private:
  float _internal_max() const;
  void _internal_set_max(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.AxisDetails.Scaling)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int orient_;
    float min_;
    float max_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis_AxisDetails_Cross final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.AxisDetails.Cross) */ {
 public:
  inline ChartAxis_AxisDetails_Cross() : ChartAxis_AxisDetails_Cross(nullptr) {}
  ~ChartAxis_AxisDetails_Cross() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_AxisDetails_Cross(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_AxisDetails_Cross(const ChartAxis_AxisDetails_Cross& from)
      : ChartAxis_AxisDetails_Cross(nullptr, from) {}
  ChartAxis_AxisDetails_Cross(ChartAxis_AxisDetails_Cross&& from) noexcept
    : ChartAxis_AxisDetails_Cross() {
    *this = ::std::move(from);
  }

  inline ChartAxis_AxisDetails_Cross& operator=(const ChartAxis_AxisDetails_Cross& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_AxisDetails_Cross& operator=(ChartAxis_AxisDetails_Cross&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_AxisDetails_Cross& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_AxisDetails_Cross* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_AxisDetails_Cross*>(
               &_ChartAxis_AxisDetails_Cross_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChartAxis_AxisDetails_Cross& a, ChartAxis_AxisDetails_Cross& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_AxisDetails_Cross* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_AxisDetails_Cross* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_AxisDetails_Cross* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_AxisDetails_Cross>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_AxisDetails_Cross& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_AxisDetails_Cross& from) {
    ChartAxis_AxisDetails_Cross::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_AxisDetails_Cross* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.AxisDetails.Cross";
  }
  protected:
  explicit ChartAxis_AxisDetails_Cross(::google::protobuf::Arena* arena);
  ChartAxis_AxisDetails_Cross(::google::protobuf::Arena* arena, const ChartAxis_AxisDetails_Cross& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CrossType = ChartAxis_AxisDetails_Cross_CrossType;
  static constexpr CrossType AUTOZERO = ChartAxis_AxisDetails_Cross_CrossType_AUTOZERO;
  static constexpr CrossType MIN = ChartAxis_AxisDetails_Cross_CrossType_MIN;
  static constexpr CrossType MAX = ChartAxis_AxisDetails_Cross_CrossType_MAX;
  static constexpr CrossType MANUAL = ChartAxis_AxisDetails_Cross_CrossType_MANUAL;
  static inline bool CrossType_IsValid(int value) {
    return ChartAxis_AxisDetails_Cross_CrossType_IsValid(value);
  }
  static constexpr CrossType CrossType_MIN = ChartAxis_AxisDetails_Cross_CrossType_CrossType_MIN;
  static constexpr CrossType CrossType_MAX = ChartAxis_AxisDetails_Cross_CrossType_CrossType_MAX;
  static constexpr int CrossType_ARRAYSIZE = ChartAxis_AxisDetails_Cross_CrossType_CrossType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CrossType_descriptor() {
    return ChartAxis_AxisDetails_Cross_CrossType_descriptor();
  }
  template <typename T>
  static inline const std::string& CrossType_Name(T value) {
    return ChartAxis_AxisDetails_Cross_CrossType_Name(value);
  }
  static inline bool CrossType_Parse(absl::string_view name, CrossType* value) {
    return ChartAxis_AxisDetails_Cross_CrossType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 4,
    kValueFieldNumber = 5,
  };
  // optional .com.zoho.chart.ChartAxis.AxisDetails.Cross.CrossType type = 4;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType type() const;
  void set_type(::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType value);

  private:
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType _internal_type() const;
  void _internal_set_type(::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType value);

  public:
  // optional float value = 5;
  bool has_value() const;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.AxisDetails.Cross)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    float value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis_ValueAxis_DisplayUnit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit) */ {
 public:
  inline ChartAxis_ValueAxis_DisplayUnit() : ChartAxis_ValueAxis_DisplayUnit(nullptr) {}
  ~ChartAxis_ValueAxis_DisplayUnit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_ValueAxis_DisplayUnit(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_ValueAxis_DisplayUnit(const ChartAxis_ValueAxis_DisplayUnit& from)
      : ChartAxis_ValueAxis_DisplayUnit(nullptr, from) {}
  ChartAxis_ValueAxis_DisplayUnit(ChartAxis_ValueAxis_DisplayUnit&& from) noexcept
    : ChartAxis_ValueAxis_DisplayUnit() {
    *this = ::std::move(from);
  }

  inline ChartAxis_ValueAxis_DisplayUnit& operator=(const ChartAxis_ValueAxis_DisplayUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_ValueAxis_DisplayUnit& operator=(ChartAxis_ValueAxis_DisplayUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_ValueAxis_DisplayUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_ValueAxis_DisplayUnit* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_ValueAxis_DisplayUnit*>(
               &_ChartAxis_ValueAxis_DisplayUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChartAxis_ValueAxis_DisplayUnit& a, ChartAxis_ValueAxis_DisplayUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_ValueAxis_DisplayUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_ValueAxis_DisplayUnit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_ValueAxis_DisplayUnit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_ValueAxis_DisplayUnit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_ValueAxis_DisplayUnit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_ValueAxis_DisplayUnit& from) {
    ChartAxis_ValueAxis_DisplayUnit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_ValueAxis_DisplayUnit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit";
  }
  protected:
  explicit ChartAxis_ValueAxis_DisplayUnit(::google::protobuf::Arena* arena);
  ChartAxis_ValueAxis_DisplayUnit(::google::protobuf::Arena* arena, const ChartAxis_ValueAxis_DisplayUnit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DisplayUnitType = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType;
  static constexpr DisplayUnitType NONE = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_NONE;
  static constexpr DisplayUnitType HUNDREDS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_HUNDREDS;
  static constexpr DisplayUnitType THOUSANDS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_THOUSANDS;
  static constexpr DisplayUnitType TENTHOUSANDS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_TENTHOUSANDS;
  static constexpr DisplayUnitType HUNDREDTHOUSANDS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_HUNDREDTHOUSANDS;
  static constexpr DisplayUnitType MILLIONS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_MILLIONS;
  static constexpr DisplayUnitType TENMILLIONS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_TENMILLIONS;
  static constexpr DisplayUnitType HUNDREDMILLIONS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_HUNDREDMILLIONS;
  static constexpr DisplayUnitType BILLIONS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_BILLIONS;
  static constexpr DisplayUnitType TRILLIONS = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_TRILLIONS;
  static constexpr DisplayUnitType CUSTOM = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_CUSTOM;
  static inline bool DisplayUnitType_IsValid(int value) {
    return ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_IsValid(value);
  }
  static constexpr DisplayUnitType DisplayUnitType_MIN = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_DisplayUnitType_MIN;
  static constexpr DisplayUnitType DisplayUnitType_MAX = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_DisplayUnitType_MAX;
  static constexpr int DisplayUnitType_ARRAYSIZE = ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_DisplayUnitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DisplayUnitType_descriptor() {
    return ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_descriptor();
  }
  template <typename T>
  static inline const std::string& DisplayUnitType_Name(T value) {
    return ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Name(value);
  }
  static inline bool DisplayUnitType_Parse(absl::string_view name, DisplayUnitType* value) {
    return ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 3,
    kTypeFieldNumber = 1,
    kCustomFieldNumber = 2,
  };
  // optional .com.zoho.chart.TitleElement label = 3;
  bool has_label() const;
  void clear_label() ;
  const ::com::zoho::chart::TitleElement& label() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::TitleElement* release_label();
  ::com::zoho::chart::TitleElement* mutable_label();
  void set_allocated_label(::com::zoho::chart::TitleElement* value);
  void unsafe_arena_set_allocated_label(::com::zoho::chart::TitleElement* value);
  ::com::zoho::chart::TitleElement* unsafe_arena_release_label();

  private:
  const ::com::zoho::chart::TitleElement& _internal_label() const;
  ::com::zoho::chart::TitleElement* _internal_mutable_label();

  public:
  // optional .com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.DisplayUnitType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType type() const;
  void set_type(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType value);

  private:
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType _internal_type() const;
  void _internal_set_type(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType value);

  public:
  // optional float custom = 2;
  bool has_custom() const;
  void clear_custom() ;
  float custom() const;
  void set_custom(float value);

  private:
  float _internal_custom() const;
  void _internal_set_custom(float value);

  public:
  void temp_setlabel(com::zoho::chart::TitleElement* label) {
    if(&this->label() != label) {
      set_allocated_label(label);
    }
  }
  
  com::zoho::chart::TitleElement* temp_getlabel() const {
    if (has_label()) 
      return (const_cast<com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit*>(this))->mutable_label();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::chart::TitleElement* label_;
    int type_;
    float custom_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis_AxisDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.AxisDetails) */ {
 public:
  inline ChartAxis_AxisDetails() : ChartAxis_AxisDetails(nullptr) {}
  ~ChartAxis_AxisDetails() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_AxisDetails(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_AxisDetails(const ChartAxis_AxisDetails& from)
      : ChartAxis_AxisDetails(nullptr, from) {}
  ChartAxis_AxisDetails(ChartAxis_AxisDetails&& from) noexcept
    : ChartAxis_AxisDetails() {
    *this = ::std::move(from);
  }

  inline ChartAxis_AxisDetails& operator=(const ChartAxis_AxisDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_AxisDetails& operator=(ChartAxis_AxisDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_AxisDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_AxisDetails* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_AxisDetails*>(
               &_ChartAxis_AxisDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChartAxis_AxisDetails& a, ChartAxis_AxisDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_AxisDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_AxisDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_AxisDetails* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_AxisDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_AxisDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_AxisDetails& from) {
    ChartAxis_AxisDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_AxisDetails* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.AxisDetails";
  }
  protected:
  explicit ChartAxis_AxisDetails(::google::protobuf::Arena* arena);
  ChartAxis_AxisDetails(::google::protobuf::Arena* arena, const ChartAxis_AxisDetails& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Scaling = ChartAxis_AxisDetails_Scaling;
  using Cross = ChartAxis_AxisDetails_Cross;

  // accessors -------------------------------------------------------

  enum : int {
    kAxisIdFieldNumber = 1,
    kCrossAxisIdFieldNumber = 3,
    kScalingFieldNumber = 4,
    kCrossFieldNumber = 5,
    kTitleFieldNumber = 6,
    kMajorGridFieldNumber = 7,
    kMinorGridFieldNumber = 8,
    kPropsFieldNumber = 12,
    kTextBodyFieldNumber = 13,
    kNumberFormatFieldNumber = 15,
    kAxPosFieldNumber = 2,
    kMajorTickMarkFieldNumber = 9,
    kMinorTickMarkFieldNumber = 10,
    kLabelPosFieldNumber = 11,
    kHiddenFieldNumber = 14,
  };
  // optional string axisId = 1 [(.com.zoho.common.customOptions) = {
  bool has_axisid() const;
  void clear_axisid() ;
  const std::string& axisid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_axisid(Arg_&& arg, Args_... args);
  std::string* mutable_axisid();
  PROTOBUF_NODISCARD std::string* release_axisid();
  void set_allocated_axisid(std::string* value);

  private:
  const std::string& _internal_axisid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_axisid(
      const std::string& value);
  std::string* _internal_mutable_axisid();

  public:
  // optional string crossAxisId = 3 [(.com.zoho.common.customOptions) = {
  bool has_crossaxisid() const;
  void clear_crossaxisid() ;
  const std::string& crossaxisid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_crossaxisid(Arg_&& arg, Args_... args);
  std::string* mutable_crossaxisid();
  PROTOBUF_NODISCARD std::string* release_crossaxisid();
  void set_allocated_crossaxisid(std::string* value);

  private:
  const std::string& _internal_crossaxisid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crossaxisid(
      const std::string& value);
  std::string* _internal_mutable_crossaxisid();

  public:
  // optional .com.zoho.chart.ChartAxis.AxisDetails.Scaling scaling = 4;
  bool has_scaling() const;
  void clear_scaling() ;
  const ::com::zoho::chart::ChartAxis_AxisDetails_Scaling& scaling() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* release_scaling();
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* mutable_scaling();
  void set_allocated_scaling(::com::zoho::chart::ChartAxis_AxisDetails_Scaling* value);
  void unsafe_arena_set_allocated_scaling(::com::zoho::chart::ChartAxis_AxisDetails_Scaling* value);
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* unsafe_arena_release_scaling();

  private:
  const ::com::zoho::chart::ChartAxis_AxisDetails_Scaling& _internal_scaling() const;
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* _internal_mutable_scaling();

  public:
  // optional .com.zoho.chart.ChartAxis.AxisDetails.Cross cross = 5;
  bool has_cross() const;
  void clear_cross() ;
  const ::com::zoho::chart::ChartAxis_AxisDetails_Cross& cross() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_AxisDetails_Cross* release_cross();
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross* mutable_cross();
  void set_allocated_cross(::com::zoho::chart::ChartAxis_AxisDetails_Cross* value);
  void unsafe_arena_set_allocated_cross(::com::zoho::chart::ChartAxis_AxisDetails_Cross* value);
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross* unsafe_arena_release_cross();

  private:
  const ::com::zoho::chart::ChartAxis_AxisDetails_Cross& _internal_cross() const;
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross* _internal_mutable_cross();

  public:
  // optional .com.zoho.chart.TitleElement title = 6;
  bool has_title() const;
  void clear_title() ;
  const ::com::zoho::chart::TitleElement& title() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::TitleElement* release_title();
  ::com::zoho::chart::TitleElement* mutable_title();
  void set_allocated_title(::com::zoho::chart::TitleElement* value);
  void unsafe_arena_set_allocated_title(::com::zoho::chart::TitleElement* value);
  ::com::zoho::chart::TitleElement* unsafe_arena_release_title();

  private:
  const ::com::zoho::chart::TitleElement& _internal_title() const;
  ::com::zoho::chart::TitleElement* _internal_mutable_title();

  public:
  // optional .com.zoho.shapes.Properties majorGrid = 7;
  bool has_majorgrid() const;
  void clear_majorgrid() ;
  const ::com::zoho::shapes::Properties& majorgrid() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Properties* release_majorgrid();
  ::com::zoho::shapes::Properties* mutable_majorgrid();
  void set_allocated_majorgrid(::com::zoho::shapes::Properties* value);
  void unsafe_arena_set_allocated_majorgrid(::com::zoho::shapes::Properties* value);
  ::com::zoho::shapes::Properties* unsafe_arena_release_majorgrid();

  private:
  const ::com::zoho::shapes::Properties& _internal_majorgrid() const;
  ::com::zoho::shapes::Properties* _internal_mutable_majorgrid();

  public:
  // optional .com.zoho.shapes.Properties minorGrid = 8;
  bool has_minorgrid() const;
  void clear_minorgrid() ;
  const ::com::zoho::shapes::Properties& minorgrid() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Properties* release_minorgrid();
  ::com::zoho::shapes::Properties* mutable_minorgrid();
  void set_allocated_minorgrid(::com::zoho::shapes::Properties* value);
  void unsafe_arena_set_allocated_minorgrid(::com::zoho::shapes::Properties* value);
  ::com::zoho::shapes::Properties* unsafe_arena_release_minorgrid();

  private:
  const ::com::zoho::shapes::Properties& _internal_minorgrid() const;
  ::com::zoho::shapes::Properties* _internal_mutable_minorgrid();

  public:
  // optional .com.zoho.shapes.Properties props = 12;
  bool has_props() const;
  void clear_props() ;
  const ::com::zoho::shapes::Properties& props() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::Properties* release_props();
  ::com::zoho::shapes::Properties* mutable_props();
  void set_allocated_props(::com::zoho::shapes::Properties* value);
  void unsafe_arena_set_allocated_props(::com::zoho::shapes::Properties* value);
  ::com::zoho::shapes::Properties* unsafe_arena_release_props();

  private:
  const ::com::zoho::shapes::Properties& _internal_props() const;
  ::com::zoho::shapes::Properties* _internal_mutable_props();

  public:
  // optional .com.zoho.shapes.TextBody textBody = 13;
  bool has_textbody() const;
  void clear_textbody() ;
  const ::com::zoho::shapes::TextBody& textbody() const;
  PROTOBUF_NODISCARD ::com::zoho::shapes::TextBody* release_textbody();
  ::com::zoho::shapes::TextBody* mutable_textbody();
  void set_allocated_textbody(::com::zoho::shapes::TextBody* value);
  void unsafe_arena_set_allocated_textbody(::com::zoho::shapes::TextBody* value);
  ::com::zoho::shapes::TextBody* unsafe_arena_release_textbody();

  private:
  const ::com::zoho::shapes::TextBody& _internal_textbody() const;
  ::com::zoho::shapes::TextBody* _internal_mutable_textbody();

  public:
  // optional .com.zoho.common.NumberFormat numberFormat = 15;
  bool has_numberformat() const;
  void clear_numberformat() ;
  const ::com::zoho::common::NumberFormat& numberformat() const;
  PROTOBUF_NODISCARD ::com::zoho::common::NumberFormat* release_numberformat();
  ::com::zoho::common::NumberFormat* mutable_numberformat();
  void set_allocated_numberformat(::com::zoho::common::NumberFormat* value);
  void unsafe_arena_set_allocated_numberformat(::com::zoho::common::NumberFormat* value);
  ::com::zoho::common::NumberFormat* unsafe_arena_release_numberformat();

  private:
  const ::com::zoho::common::NumberFormat& _internal_numberformat() const;
  ::com::zoho::common::NumberFormat* _internal_mutable_numberformat();

  public:
  // optional .Show.ChartField.PositionElement axPos = 2 [(.com.zoho.common.customOptions) = {
  bool has_axpos() const;
  void clear_axpos() ;
  ::Show::ChartField_PositionElement axpos() const;
  void set_axpos(::Show::ChartField_PositionElement value);

  private:
  ::Show::ChartField_PositionElement _internal_axpos() const;
  void _internal_set_axpos(::Show::ChartField_PositionElement value);

  public:
  // optional .Show.ChartField.TickMarkType majorTickMark = 9;
  bool has_majortickmark() const;
  void clear_majortickmark() ;
  ::Show::ChartField_TickMarkType majortickmark() const;
  void set_majortickmark(::Show::ChartField_TickMarkType value);

  private:
  ::Show::ChartField_TickMarkType _internal_majortickmark() const;
  void _internal_set_majortickmark(::Show::ChartField_TickMarkType value);

  public:
  // optional .Show.ChartField.TickMarkType minorTickMark = 10;
  bool has_minortickmark() const;
  void clear_minortickmark() ;
  ::Show::ChartField_TickMarkType minortickmark() const;
  void set_minortickmark(::Show::ChartField_TickMarkType value);

  private:
  ::Show::ChartField_TickMarkType _internal_minortickmark() const;
  void _internal_set_minortickmark(::Show::ChartField_TickMarkType value);

  public:
  // optional .Show.ChartField.LabelPos labelPos = 11;
  bool has_labelpos() const;
  void clear_labelpos() ;
  ::Show::ChartField_LabelPos labelpos() const;
  void set_labelpos(::Show::ChartField_LabelPos value);

  private:
  ::Show::ChartField_LabelPos _internal_labelpos() const;
  void _internal_set_labelpos(::Show::ChartField_LabelPos value);

  public:
  // optional bool hidden = 14;
  bool has_hidden() const;
  void clear_hidden() ;
  bool hidden() const;
  void set_hidden(bool value);

  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);

  public:
  void temp_setscaling(com::zoho::chart::ChartAxis_AxisDetails_Scaling* scaling) {
    if(&this->scaling() != scaling) {
      set_allocated_scaling(scaling);
    }
  }
  
  com::zoho::chart::ChartAxis_AxisDetails_Scaling* temp_getscaling() const {
    if (has_scaling()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_scaling();
    return nullptr;
  }
  
  void temp_setcross(com::zoho::chart::ChartAxis_AxisDetails_Cross* cross) {
    if(&this->cross() != cross) {
      set_allocated_cross(cross);
    }
  }
  
  com::zoho::chart::ChartAxis_AxisDetails_Cross* temp_getcross() const {
    if (has_cross()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_cross();
    return nullptr;
  }
  
  void temp_settitle(com::zoho::chart::TitleElement* title) {
    if(&this->title() != title) {
      set_allocated_title(title);
    }
  }
  
  com::zoho::chart::TitleElement* temp_gettitle() const {
    if (has_title()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_title();
    return nullptr;
  }
  
  void temp_setmajorGrid(com::zoho::shapes::Properties* majorGrid) {
    if(&this->majorgrid() != majorGrid) {
      set_allocated_majorgrid(majorGrid);
    }
  }
  
  com::zoho::shapes::Properties* temp_getmajorGrid() const {
    if (has_majorgrid()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_majorgrid();
    return nullptr;
  }
  
  void temp_setminorGrid(com::zoho::shapes::Properties* minorGrid) {
    if(&this->minorgrid() != minorGrid) {
      set_allocated_minorgrid(minorGrid);
    }
  }
  
  com::zoho::shapes::Properties* temp_getminorGrid() const {
    if (has_minorgrid()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_minorgrid();
    return nullptr;
  }
  
  void temp_setprops(com::zoho::shapes::Properties* props) {
    if(&this->props() != props) {
      set_allocated_props(props);
    }
  }
  
  com::zoho::shapes::Properties* temp_getprops() const {
    if (has_props()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_props();
    return nullptr;
  }
  
  void temp_settextBody(com::zoho::shapes::TextBody* textBody) {
    if(&this->textbody() != textBody) {
      set_allocated_textbody(textBody);
    }
  }
  
  com::zoho::shapes::TextBody* temp_gettextBody() const {
    if (has_textbody()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_textbody();
    return nullptr;
  }
  
  void temp_setnumberFormat(com::zoho::common::NumberFormat* numberFormat) {
    if(&this->numberformat() != numberFormat) {
      set_allocated_numberformat(numberFormat);
    }
  }
  
  com::zoho::common::NumberFormat* temp_getnumberFormat() const {
    if (has_numberformat()) 
      return (const_cast<com::zoho::chart::ChartAxis_AxisDetails*>(this))->mutable_numberformat();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.AxisDetails)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 8,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr axisid_;
    ::google::protobuf::internal::ArenaStringPtr crossaxisid_;
    ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* scaling_;
    ::com::zoho::chart::ChartAxis_AxisDetails_Cross* cross_;
    ::com::zoho::chart::TitleElement* title_;
    ::com::zoho::shapes::Properties* majorgrid_;
    ::com::zoho::shapes::Properties* minorgrid_;
    ::com::zoho::shapes::Properties* props_;
    ::com::zoho::shapes::TextBody* textbody_;
    ::com::zoho::common::NumberFormat* numberformat_;
    int axpos_;
    int majortickmark_;
    int minortickmark_;
    int labelpos_;
    bool hidden_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis_ValueAxis final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.ValueAxis) */ {
 public:
  inline ChartAxis_ValueAxis() : ChartAxis_ValueAxis(nullptr) {}
  ~ChartAxis_ValueAxis() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_ValueAxis(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_ValueAxis(const ChartAxis_ValueAxis& from)
      : ChartAxis_ValueAxis(nullptr, from) {}
  ChartAxis_ValueAxis(ChartAxis_ValueAxis&& from) noexcept
    : ChartAxis_ValueAxis() {
    *this = ::std::move(from);
  }

  inline ChartAxis_ValueAxis& operator=(const ChartAxis_ValueAxis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_ValueAxis& operator=(ChartAxis_ValueAxis&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_ValueAxis& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_ValueAxis* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_ValueAxis*>(
               &_ChartAxis_ValueAxis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChartAxis_ValueAxis& a, ChartAxis_ValueAxis& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_ValueAxis* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_ValueAxis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_ValueAxis* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_ValueAxis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_ValueAxis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_ValueAxis& from) {
    ChartAxis_ValueAxis::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_ValueAxis* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.ValueAxis";
  }
  protected:
  explicit ChartAxis_ValueAxis(::google::protobuf::Arena* arena);
  ChartAxis_ValueAxis(::google::protobuf::Arena* arena, const ChartAxis_ValueAxis& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DisplayUnit = ChartAxis_ValueAxis_DisplayUnit;

  using CrossBetween = ChartAxis_ValueAxis_CrossBetween;
  static constexpr CrossBetween DEFAULT = ChartAxis_ValueAxis_CrossBetween_DEFAULT;
  static constexpr CrossBetween MIDCAT = ChartAxis_ValueAxis_CrossBetween_MIDCAT;
  static inline bool CrossBetween_IsValid(int value) {
    return ChartAxis_ValueAxis_CrossBetween_IsValid(value);
  }
  static constexpr CrossBetween CrossBetween_MIN = ChartAxis_ValueAxis_CrossBetween_CrossBetween_MIN;
  static constexpr CrossBetween CrossBetween_MAX = ChartAxis_ValueAxis_CrossBetween_CrossBetween_MAX;
  static constexpr int CrossBetween_ARRAYSIZE = ChartAxis_ValueAxis_CrossBetween_CrossBetween_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CrossBetween_descriptor() {
    return ChartAxis_ValueAxis_CrossBetween_descriptor();
  }
  template <typename T>
  static inline const std::string& CrossBetween_Name(T value) {
    return ChartAxis_ValueAxis_CrossBetween_Name(value);
  }
  static inline bool CrossBetween_Parse(absl::string_view name, CrossBetween* value) {
    return ChartAxis_ValueAxis_CrossBetween_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 1,
    kDisplayUnitFieldNumber = 5,
    kCrossBetweenFieldNumber = 2,
    kMajorFieldNumber = 3,
    kMinorFieldNumber = 4,
  };
  // optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
  bool has_details() const;
  void clear_details() ;
  const ::com::zoho::chart::ChartAxis_AxisDetails& details() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_AxisDetails* release_details();
  ::com::zoho::chart::ChartAxis_AxisDetails* mutable_details();
  void set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  void unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  ::com::zoho::chart::ChartAxis_AxisDetails* unsafe_arena_release_details();

  private:
  const ::com::zoho::chart::ChartAxis_AxisDetails& _internal_details() const;
  ::com::zoho::chart::ChartAxis_AxisDetails* _internal_mutable_details();

  public:
  // optional .com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit displayUnit = 5;
  bool has_displayunit() const;
  void clear_displayunit() ;
  const ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit& displayunit() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* release_displayunit();
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* mutable_displayunit();
  void set_allocated_displayunit(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* value);
  void unsafe_arena_set_allocated_displayunit(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* value);
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* unsafe_arena_release_displayunit();

  private:
  const ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit& _internal_displayunit() const;
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* _internal_mutable_displayunit();

  public:
  // optional .com.zoho.chart.ChartAxis.ValueAxis.CrossBetween crossBetween = 2;
  bool has_crossbetween() const;
  void clear_crossbetween() ;
  ::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween crossbetween() const;
  void set_crossbetween(::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween value);

  private:
  ::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween _internal_crossbetween() const;
  void _internal_set_crossbetween(::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween value);

  public:
  // optional float major = 3;
  bool has_major() const;
  void clear_major() ;
  float major() const;
  void set_major(float value);

  private:
  float _internal_major() const;
  void _internal_set_major(float value);

  public:
  // optional float minor = 4;
  bool has_minor() const;
  void clear_minor() ;
  float minor() const;
  void set_minor(float value);

  private:
  float _internal_minor() const;
  void _internal_set_minor(float value);

  public:
  void temp_setdetails(com::zoho::chart::ChartAxis_AxisDetails* details) {
    if(&this->details() != details) {
      set_allocated_details(details);
    }
  }
  
  com::zoho::chart::ChartAxis_AxisDetails* temp_getdetails() const {
    if (has_details()) 
      return (const_cast<com::zoho::chart::ChartAxis_ValueAxis*>(this))->mutable_details();
    return nullptr;
  }
  
  void temp_setdisplayUnit(com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* displayUnit) {
    if(&this->displayunit() != displayUnit) {
      set_allocated_displayunit(displayUnit);
    }
  }
  
  com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* temp_getdisplayUnit() const {
    if (has_displayunit()) 
      return (const_cast<com::zoho::chart::ChartAxis_ValueAxis*>(this))->mutable_displayunit();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.ValueAxis)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::chart::ChartAxis_AxisDetails* details_;
    ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* displayunit_;
    int crossbetween_;
    float major_;
    float minor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis_SeriesAxis final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.SeriesAxis) */ {
 public:
  inline ChartAxis_SeriesAxis() : ChartAxis_SeriesAxis(nullptr) {}
  ~ChartAxis_SeriesAxis() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_SeriesAxis(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_SeriesAxis(const ChartAxis_SeriesAxis& from)
      : ChartAxis_SeriesAxis(nullptr, from) {}
  ChartAxis_SeriesAxis(ChartAxis_SeriesAxis&& from) noexcept
    : ChartAxis_SeriesAxis() {
    *this = ::std::move(from);
  }

  inline ChartAxis_SeriesAxis& operator=(const ChartAxis_SeriesAxis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_SeriesAxis& operator=(ChartAxis_SeriesAxis&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_SeriesAxis& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_SeriesAxis* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_SeriesAxis*>(
               &_ChartAxis_SeriesAxis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChartAxis_SeriesAxis& a, ChartAxis_SeriesAxis& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_SeriesAxis* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_SeriesAxis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_SeriesAxis* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_SeriesAxis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_SeriesAxis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_SeriesAxis& from) {
    ChartAxis_SeriesAxis::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_SeriesAxis* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.SeriesAxis";
  }
  protected:
  explicit ChartAxis_SeriesAxis(::google::protobuf::Arena* arena);
  ChartAxis_SeriesAxis(::google::protobuf::Arena* arena, const ChartAxis_SeriesAxis& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 1,
    kSkipTickLabelFieldNumber = 2,
    kSkipTickMarkFieldNumber = 3,
  };
  // optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
  bool has_details() const;
  void clear_details() ;
  const ::com::zoho::chart::ChartAxis_AxisDetails& details() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_AxisDetails* release_details();
  ::com::zoho::chart::ChartAxis_AxisDetails* mutable_details();
  void set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  void unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  ::com::zoho::chart::ChartAxis_AxisDetails* unsafe_arena_release_details();

  private:
  const ::com::zoho::chart::ChartAxis_AxisDetails& _internal_details() const;
  ::com::zoho::chart::ChartAxis_AxisDetails* _internal_mutable_details();

  public:
  // optional int32 skipTickLabel = 2;
  bool has_skipticklabel() const;
  void clear_skipticklabel() ;
  ::int32_t skipticklabel() const;
  void set_skipticklabel(::int32_t value);

  private:
  ::int32_t _internal_skipticklabel() const;
  void _internal_set_skipticklabel(::int32_t value);

  public:
  // optional int32 skipTickMark = 3;
  bool has_skiptickmark() const;
  void clear_skiptickmark() ;
  ::int32_t skiptickmark() const;
  void set_skiptickmark(::int32_t value);

  private:
  ::int32_t _internal_skiptickmark() const;
  void _internal_set_skiptickmark(::int32_t value);

  public:
  void temp_setdetails(com::zoho::chart::ChartAxis_AxisDetails* details) {
    if(&this->details() != details) {
      set_allocated_details(details);
    }
  }
  
  com::zoho::chart::ChartAxis_AxisDetails* temp_getdetails() const {
    if (has_details()) 
      return (const_cast<com::zoho::chart::ChartAxis_SeriesAxis*>(this))->mutable_details();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.SeriesAxis)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::chart::ChartAxis_AxisDetails* details_;
    ::int32_t skipticklabel_;
    ::int32_t skiptickmark_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis_DateAxis final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.DateAxis) */ {
 public:
  inline ChartAxis_DateAxis() : ChartAxis_DateAxis(nullptr) {}
  ~ChartAxis_DateAxis() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_DateAxis(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_DateAxis(const ChartAxis_DateAxis& from)
      : ChartAxis_DateAxis(nullptr, from) {}
  ChartAxis_DateAxis(ChartAxis_DateAxis&& from) noexcept
    : ChartAxis_DateAxis() {
    *this = ::std::move(from);
  }

  inline ChartAxis_DateAxis& operator=(const ChartAxis_DateAxis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_DateAxis& operator=(ChartAxis_DateAxis&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_DateAxis& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_DateAxis* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_DateAxis*>(
               &_ChartAxis_DateAxis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChartAxis_DateAxis& a, ChartAxis_DateAxis& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_DateAxis* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_DateAxis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_DateAxis* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_DateAxis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_DateAxis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_DateAxis& from) {
    ChartAxis_DateAxis::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_DateAxis* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.DateAxis";
  }
  protected:
  explicit ChartAxis_DateAxis(::google::protobuf::Arena* arena);
  ChartAxis_DateAxis(::google::protobuf::Arena* arena, const ChartAxis_DateAxis& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TimeUnit = ChartAxis_DateAxis_TimeUnit;
  static constexpr TimeUnit DAYS = ChartAxis_DateAxis_TimeUnit_DAYS;
  static constexpr TimeUnit MONTHS = ChartAxis_DateAxis_TimeUnit_MONTHS;
  static constexpr TimeUnit YEARS = ChartAxis_DateAxis_TimeUnit_YEARS;
  static inline bool TimeUnit_IsValid(int value) {
    return ChartAxis_DateAxis_TimeUnit_IsValid(value);
  }
  static constexpr TimeUnit TimeUnit_MIN = ChartAxis_DateAxis_TimeUnit_TimeUnit_MIN;
  static constexpr TimeUnit TimeUnit_MAX = ChartAxis_DateAxis_TimeUnit_TimeUnit_MAX;
  static constexpr int TimeUnit_ARRAYSIZE = ChartAxis_DateAxis_TimeUnit_TimeUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TimeUnit_descriptor() {
    return ChartAxis_DateAxis_TimeUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& TimeUnit_Name(T value) {
    return ChartAxis_DateAxis_TimeUnit_Name(value);
  }
  static inline bool TimeUnit_Parse(absl::string_view name, TimeUnit* value) {
    return ChartAxis_DateAxis_TimeUnit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 1,
    kLblOffsetFieldNumber = 2,
    kMajorFieldNumber = 3,
    kMinorFieldNumber = 4,
    kBaseTimeUnitFieldNumber = 5,
    kMajorTimeUnitFieldNumber = 6,
    kMinorTimeUnitFieldNumber = 7,
  };
  // optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
  bool has_details() const;
  void clear_details() ;
  const ::com::zoho::chart::ChartAxis_AxisDetails& details() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_AxisDetails* release_details();
  ::com::zoho::chart::ChartAxis_AxisDetails* mutable_details();
  void set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  void unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  ::com::zoho::chart::ChartAxis_AxisDetails* unsafe_arena_release_details();

  private:
  const ::com::zoho::chart::ChartAxis_AxisDetails& _internal_details() const;
  ::com::zoho::chart::ChartAxis_AxisDetails* _internal_mutable_details();

  public:
  // optional float lblOffset = 2;
  bool has_lbloffset() const;
  void clear_lbloffset() ;
  float lbloffset() const;
  void set_lbloffset(float value);

  private:
  float _internal_lbloffset() const;
  void _internal_set_lbloffset(float value);

  public:
  // optional float major = 3;
  bool has_major() const;
  void clear_major() ;
  float major() const;
  void set_major(float value);

  private:
  float _internal_major() const;
  void _internal_set_major(float value);

  public:
  // optional float minor = 4;
  bool has_minor() const;
  void clear_minor() ;
  float minor() const;
  void set_minor(float value);

  private:
  float _internal_minor() const;
  void _internal_set_minor(float value);

  public:
  // optional .com.zoho.chart.ChartAxis.DateAxis.TimeUnit baseTimeUnit = 5;
  bool has_basetimeunit() const;
  void clear_basetimeunit() ;
  ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit basetimeunit() const;
  void set_basetimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value);

  private:
  ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit _internal_basetimeunit() const;
  void _internal_set_basetimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value);

  public:
  // optional .com.zoho.chart.ChartAxis.DateAxis.TimeUnit majorTimeUnit = 6;
  bool has_majortimeunit() const;
  void clear_majortimeunit() ;
  ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit majortimeunit() const;
  void set_majortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value);

  private:
  ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit _internal_majortimeunit() const;
  void _internal_set_majortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value);

  public:
  // optional .com.zoho.chart.ChartAxis.DateAxis.TimeUnit minorTimeUnit = 7;
  bool has_minortimeunit() const;
  void clear_minortimeunit() ;
  ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit minortimeunit() const;
  void set_minortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value);

  private:
  ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit _internal_minortimeunit() const;
  void _internal_set_minortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value);

  public:
  void temp_setdetails(com::zoho::chart::ChartAxis_AxisDetails* details) {
    if(&this->details() != details) {
      set_allocated_details(details);
    }
  }
  
  com::zoho::chart::ChartAxis_AxisDetails* temp_getdetails() const {
    if (has_details()) 
      return (const_cast<com::zoho::chart::ChartAxis_DateAxis*>(this))->mutable_details();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.DateAxis)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::chart::ChartAxis_AxisDetails* details_;
    float lbloffset_;
    float major_;
    float minor_;
    int basetimeunit_;
    int majortimeunit_;
    int minortimeunit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis_CategoryAxis final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis.CategoryAxis) */ {
 public:
  inline ChartAxis_CategoryAxis() : ChartAxis_CategoryAxis(nullptr) {}
  ~ChartAxis_CategoryAxis() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis_CategoryAxis(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis_CategoryAxis(const ChartAxis_CategoryAxis& from)
      : ChartAxis_CategoryAxis(nullptr, from) {}
  ChartAxis_CategoryAxis(ChartAxis_CategoryAxis&& from) noexcept
    : ChartAxis_CategoryAxis() {
    *this = ::std::move(from);
  }

  inline ChartAxis_CategoryAxis& operator=(const ChartAxis_CategoryAxis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis_CategoryAxis& operator=(ChartAxis_CategoryAxis&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis_CategoryAxis& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis_CategoryAxis* internal_default_instance() {
    return reinterpret_cast<const ChartAxis_CategoryAxis*>(
               &_ChartAxis_CategoryAxis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ChartAxis_CategoryAxis& a, ChartAxis_CategoryAxis& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis_CategoryAxis* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis_CategoryAxis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis_CategoryAxis* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis_CategoryAxis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis_CategoryAxis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis_CategoryAxis& from) {
    ChartAxis_CategoryAxis::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis_CategoryAxis* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis.CategoryAxis";
  }
  protected:
  explicit ChartAxis_CategoryAxis(::google::protobuf::Arena* arena);
  ChartAxis_CategoryAxis(::google::protobuf::Arena* arena, const ChartAxis_CategoryAxis& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 1,
    kLblAlignFieldNumber = 2,
    kLblOffsetFieldNumber = 3,
    kSkipTickLabelFieldNumber = 4,
    kSkipTickMarkFieldNumber = 5,
  };
  // optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
  bool has_details() const;
  void clear_details() ;
  const ::com::zoho::chart::ChartAxis_AxisDetails& details() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_AxisDetails* release_details();
  ::com::zoho::chart::ChartAxis_AxisDetails* mutable_details();
  void set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  void unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value);
  ::com::zoho::chart::ChartAxis_AxisDetails* unsafe_arena_release_details();

  private:
  const ::com::zoho::chart::ChartAxis_AxisDetails& _internal_details() const;
  ::com::zoho::chart::ChartAxis_AxisDetails* _internal_mutable_details();

  public:
  // optional .com.zoho.common.HorizontalAlignType lblAlign = 2;
  bool has_lblalign() const;
  void clear_lblalign() ;
  ::com::zoho::common::HorizontalAlignType lblalign() const;
  void set_lblalign(::com::zoho::common::HorizontalAlignType value);

  private:
  ::com::zoho::common::HorizontalAlignType _internal_lblalign() const;
  void _internal_set_lblalign(::com::zoho::common::HorizontalAlignType value);

  public:
  // optional float lblOffset = 3;
  bool has_lbloffset() const;
  void clear_lbloffset() ;
  float lbloffset() const;
  void set_lbloffset(float value);

  private:
  float _internal_lbloffset() const;
  void _internal_set_lbloffset(float value);

  public:
  // optional int32 skipTickLabel = 4;
  bool has_skipticklabel() const;
  void clear_skipticklabel() ;
  ::int32_t skipticklabel() const;
  void set_skipticklabel(::int32_t value);

  private:
  ::int32_t _internal_skipticklabel() const;
  void _internal_set_skipticklabel(::int32_t value);

  public:
  // optional int32 skipTickMark = 5;
  bool has_skiptickmark() const;
  void clear_skiptickmark() ;
  ::int32_t skiptickmark() const;
  void set_skiptickmark(::int32_t value);

  private:
  ::int32_t _internal_skiptickmark() const;
  void _internal_set_skiptickmark(::int32_t value);

  public:
  void temp_setdetails(com::zoho::chart::ChartAxis_AxisDetails* details) {
    if(&this->details() != details) {
      set_allocated_details(details);
    }
  }
  
  com::zoho::chart::ChartAxis_AxisDetails* temp_getdetails() const {
    if (has_details()) 
      return (const_cast<com::zoho::chart::ChartAxis_CategoryAxis*>(this))->mutable_details();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis.CategoryAxis)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::chart::ChartAxis_AxisDetails* details_;
    int lblalign_;
    float lbloffset_;
    ::int32_t skipticklabel_;
    ::int32_t skiptickmark_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};// -------------------------------------------------------------------

class ChartAxis final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.zoho.chart.ChartAxis) */ {
 public:
  inline ChartAxis() : ChartAxis(nullptr) {}
  ~ChartAxis() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartAxis(::google::protobuf::internal::ConstantInitialized);

  inline ChartAxis(const ChartAxis& from)
      : ChartAxis(nullptr, from) {}
  ChartAxis(ChartAxis&& from) noexcept
    : ChartAxis() {
    *this = ::std::move(from);
  }

  inline ChartAxis& operator=(const ChartAxis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxis& operator=(ChartAxis&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxis& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxis* internal_default_instance() {
    return reinterpret_cast<const ChartAxis*>(
               &_ChartAxis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChartAxis& a, ChartAxis& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxis* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxis* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChartAxis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChartAxis& from) {
    ChartAxis::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChartAxis* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.zoho.chart.ChartAxis";
  }
  protected:
  explicit ChartAxis(::google::protobuf::Arena* arena);
  ChartAxis(::google::protobuf::Arena* arena, const ChartAxis& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AxisDetails = ChartAxis_AxisDetails;
  using CategoryAxis = ChartAxis_CategoryAxis;
  using ValueAxis = ChartAxis_ValueAxis;
  using DateAxis = ChartAxis_DateAxis;
  using SeriesAxis = ChartAxis_SeriesAxis;

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryFieldNumber = 1,
    kValueFieldNumber = 2,
    kDateFieldNumber = 3,
    kSeriesFieldNumber = 4,
  };
  // optional .com.zoho.chart.ChartAxis.CategoryAxis category = 1;
  bool has_category() const;
  void clear_category() ;
  const ::com::zoho::chart::ChartAxis_CategoryAxis& category() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_CategoryAxis* release_category();
  ::com::zoho::chart::ChartAxis_CategoryAxis* mutable_category();
  void set_allocated_category(::com::zoho::chart::ChartAxis_CategoryAxis* value);
  void unsafe_arena_set_allocated_category(::com::zoho::chart::ChartAxis_CategoryAxis* value);
  ::com::zoho::chart::ChartAxis_CategoryAxis* unsafe_arena_release_category();

  private:
  const ::com::zoho::chart::ChartAxis_CategoryAxis& _internal_category() const;
  ::com::zoho::chart::ChartAxis_CategoryAxis* _internal_mutable_category();

  public:
  // optional .com.zoho.chart.ChartAxis.ValueAxis value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::com::zoho::chart::ChartAxis_ValueAxis& value() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_ValueAxis* release_value();
  ::com::zoho::chart::ChartAxis_ValueAxis* mutable_value();
  void set_allocated_value(::com::zoho::chart::ChartAxis_ValueAxis* value);
  void unsafe_arena_set_allocated_value(::com::zoho::chart::ChartAxis_ValueAxis* value);
  ::com::zoho::chart::ChartAxis_ValueAxis* unsafe_arena_release_value();

  private:
  const ::com::zoho::chart::ChartAxis_ValueAxis& _internal_value() const;
  ::com::zoho::chart::ChartAxis_ValueAxis* _internal_mutable_value();

  public:
  // optional .com.zoho.chart.ChartAxis.DateAxis date = 3;
  bool has_date() const;
  void clear_date() ;
  const ::com::zoho::chart::ChartAxis_DateAxis& date() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_DateAxis* release_date();
  ::com::zoho::chart::ChartAxis_DateAxis* mutable_date();
  void set_allocated_date(::com::zoho::chart::ChartAxis_DateAxis* value);
  void unsafe_arena_set_allocated_date(::com::zoho::chart::ChartAxis_DateAxis* value);
  ::com::zoho::chart::ChartAxis_DateAxis* unsafe_arena_release_date();

  private:
  const ::com::zoho::chart::ChartAxis_DateAxis& _internal_date() const;
  ::com::zoho::chart::ChartAxis_DateAxis* _internal_mutable_date();

  public:
  // optional .com.zoho.chart.ChartAxis.SeriesAxis series = 4;
  bool has_series() const;
  void clear_series() ;
  const ::com::zoho::chart::ChartAxis_SeriesAxis& series() const;
  PROTOBUF_NODISCARD ::com::zoho::chart::ChartAxis_SeriesAxis* release_series();
  ::com::zoho::chart::ChartAxis_SeriesAxis* mutable_series();
  void set_allocated_series(::com::zoho::chart::ChartAxis_SeriesAxis* value);
  void unsafe_arena_set_allocated_series(::com::zoho::chart::ChartAxis_SeriesAxis* value);
  ::com::zoho::chart::ChartAxis_SeriesAxis* unsafe_arena_release_series();

  private:
  const ::com::zoho::chart::ChartAxis_SeriesAxis& _internal_series() const;
  ::com::zoho::chart::ChartAxis_SeriesAxis* _internal_mutable_series();

  public:
  void temp_setcategory(com::zoho::chart::ChartAxis_CategoryAxis* category) {
    if(&this->category() != category) {
      set_allocated_category(category);
    }
  }
  
  com::zoho::chart::ChartAxis_CategoryAxis* temp_getcategory() const {
    if (has_category()) 
      return (const_cast<com::zoho::chart::ChartAxis*>(this))->mutable_category();
    return nullptr;
  }
  
  void temp_setvalue(com::zoho::chart::ChartAxis_ValueAxis* value) {
    if(&this->value() != value) {
      set_allocated_value(value);
    }
  }
  
  com::zoho::chart::ChartAxis_ValueAxis* temp_getvalue() const {
    if (has_value()) 
      return (const_cast<com::zoho::chart::ChartAxis*>(this))->mutable_value();
    return nullptr;
  }
  
  void temp_setdate(com::zoho::chart::ChartAxis_DateAxis* date) {
    if(&this->date() != date) {
      set_allocated_date(date);
    }
  }
  
  com::zoho::chart::ChartAxis_DateAxis* temp_getdate() const {
    if (has_date()) 
      return (const_cast<com::zoho::chart::ChartAxis*>(this))->mutable_date();
    return nullptr;
  }
  
  void temp_setseries(com::zoho::chart::ChartAxis_SeriesAxis* series) {
    if(&this->series() != series) {
      set_allocated_series(series);
    }
  }
  
  com::zoho::chart::ChartAxis_SeriesAxis* temp_getseries() const {
    if (has_series()) 
      return (const_cast<com::zoho::chart::ChartAxis*>(this))->mutable_series();
    return nullptr;
  }
  
  // @@protoc_insertion_point(class_scope:com.zoho.chart.ChartAxis)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::zoho::chart::ChartAxis_CategoryAxis* category_;
    ::com::zoho::chart::ChartAxis_ValueAxis* value_;
    ::com::zoho::chart::ChartAxis_DateAxis* date_;
    ::com::zoho::chart::ChartAxis_SeriesAxis* series_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chartaxis_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ChartAxis_AxisDetails_Scaling

// optional .com.zoho.chart.ChartAxis.AxisDetails.Scaling.Orientation orient = 1;
inline bool ChartAxis_AxisDetails_Scaling::has_orient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails_Scaling::clear_orient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orient_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation ChartAxis_AxisDetails_Scaling::orient() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.Scaling.orient)
  return _internal_orient();
}
inline void ChartAxis_AxisDetails_Scaling::set_orient(::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation value) {
  _internal_set_orient(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.Scaling.orient)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation ChartAxis_AxisDetails_Scaling::_internal_orient() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation>(_impl_.orient_);
}
inline void ChartAxis_AxisDetails_Scaling::_internal_set_orient(::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.orient_ = value;
}

// optional float min = 2;
inline bool ChartAxis_AxisDetails_Scaling::has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails_Scaling::clear_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ChartAxis_AxisDetails_Scaling::min() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.Scaling.min)
  return _internal_min();
}
inline void ChartAxis_AxisDetails_Scaling::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.Scaling.min)
}
inline float ChartAxis_AxisDetails_Scaling::_internal_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_;
}
inline void ChartAxis_AxisDetails_Scaling::_internal_set_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_ = value;
}

// optional float max = 3;
inline bool ChartAxis_AxisDetails_Scaling::has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails_Scaling::clear_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ChartAxis_AxisDetails_Scaling::max() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.Scaling.max)
  return _internal_max();
}
inline void ChartAxis_AxisDetails_Scaling::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.Scaling.max)
}
inline float ChartAxis_AxisDetails_Scaling::_internal_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_;
}
inline void ChartAxis_AxisDetails_Scaling::_internal_set_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_ = value;
}

// -------------------------------------------------------------------

// ChartAxis_AxisDetails_Cross

// optional .com.zoho.chart.ChartAxis.AxisDetails.Cross.CrossType type = 4;
inline bool ChartAxis_AxisDetails_Cross::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails_Cross::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType ChartAxis_AxisDetails_Cross::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.Cross.type)
  return _internal_type();
}
inline void ChartAxis_AxisDetails_Cross::set_type(::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.Cross.type)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType ChartAxis_AxisDetails_Cross::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType>(_impl_.type_);
}
inline void ChartAxis_AxisDetails_Cross::_internal_set_type(::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// optional float value = 5;
inline bool ChartAxis_AxisDetails_Cross::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails_Cross::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ChartAxis_AxisDetails_Cross::value() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.Cross.value)
  return _internal_value();
}
inline void ChartAxis_AxisDetails_Cross::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.Cross.value)
}
inline float ChartAxis_AxisDetails_Cross::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void ChartAxis_AxisDetails_Cross::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ChartAxis_AxisDetails

// optional string axisId = 1 [(.com.zoho.common.customOptions) = {
inline bool ChartAxis_AxisDetails::has_axisid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails::clear_axisid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.axisid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChartAxis_AxisDetails::axisid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.axisId)
  return _internal_axisid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChartAxis_AxisDetails::set_axisid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.axisid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.axisId)
}
inline std::string* ChartAxis_AxisDetails::mutable_axisid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_axisid();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.axisId)
  return _s;
}
inline const std::string& ChartAxis_AxisDetails::_internal_axisid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.axisid_.Get();
}
inline void ChartAxis_AxisDetails::_internal_set_axisid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.axisid_.Set(value, GetArena());
}
inline std::string* ChartAxis_AxisDetails::_internal_mutable_axisid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.axisid_.Mutable( GetArena());
}
inline std::string* ChartAxis_AxisDetails::release_axisid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.axisId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.axisid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.axisid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChartAxis_AxisDetails::set_allocated_axisid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.axisid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.axisid_.IsDefault()) {
          _impl_.axisid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.axisId)
}

// optional .Show.ChartField.PositionElement axPos = 2 [(.com.zoho.common.customOptions) = {
inline bool ChartAxis_AxisDetails::has_axpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails::clear_axpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.axpos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::Show::ChartField_PositionElement ChartAxis_AxisDetails::axpos() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.axPos)
  return _internal_axpos();
}
inline void ChartAxis_AxisDetails::set_axpos(::Show::ChartField_PositionElement value) {
  _internal_set_axpos(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.axPos)
}
inline ::Show::ChartField_PositionElement ChartAxis_AxisDetails::_internal_axpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::ChartField_PositionElement>(_impl_.axpos_);
}
inline void ChartAxis_AxisDetails::_internal_set_axpos(::Show::ChartField_PositionElement value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.axpos_ = value;
}

// optional string crossAxisId = 3 [(.com.zoho.common.customOptions) = {
inline bool ChartAxis_AxisDetails::has_crossaxisid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails::clear_crossaxisid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crossaxisid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChartAxis_AxisDetails::crossaxisid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.crossAxisId)
  return _internal_crossaxisid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChartAxis_AxisDetails::set_crossaxisid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.crossaxisid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.crossAxisId)
}
inline std::string* ChartAxis_AxisDetails::mutable_crossaxisid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_crossaxisid();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.crossAxisId)
  return _s;
}
inline const std::string& ChartAxis_AxisDetails::_internal_crossaxisid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crossaxisid_.Get();
}
inline void ChartAxis_AxisDetails::_internal_set_crossaxisid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.crossaxisid_.Set(value, GetArena());
}
inline std::string* ChartAxis_AxisDetails::_internal_mutable_crossaxisid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.crossaxisid_.Mutable( GetArena());
}
inline std::string* ChartAxis_AxisDetails::release_crossaxisid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.crossAxisId)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.crossaxisid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.crossaxisid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChartAxis_AxisDetails::set_allocated_crossaxisid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.crossaxisid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.crossaxisid_.IsDefault()) {
          _impl_.crossaxisid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.crossAxisId)
}

// optional .com.zoho.chart.ChartAxis.AxisDetails.Scaling scaling = 4;
inline bool ChartAxis_AxisDetails::has_scaling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scaling_ != nullptr);
  return value;
}
inline void ChartAxis_AxisDetails::clear_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.scaling_ != nullptr) _impl_.scaling_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails_Scaling& ChartAxis_AxisDetails::_internal_scaling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* p = _impl_.scaling_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_AxisDetails_Scaling&>(::com::zoho::chart::_ChartAxis_AxisDetails_Scaling_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails_Scaling& ChartAxis_AxisDetails::scaling() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.scaling)
  return _internal_scaling();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_scaling(::com::zoho::chart::ChartAxis_AxisDetails_Scaling* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scaling_);
  }
  _impl_.scaling_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Scaling*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.scaling)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* ChartAxis_AxisDetails::release_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* released = _impl_.scaling_;
  _impl_.scaling_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* ChartAxis_AxisDetails::unsafe_arena_release_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.scaling)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* temp = _impl_.scaling_;
  _impl_.scaling_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* ChartAxis_AxisDetails::_internal_mutable_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.scaling_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_AxisDetails_Scaling>(GetArena());
    _impl_.scaling_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Scaling*>(p);
  }
  return _impl_.scaling_;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* ChartAxis_AxisDetails::mutable_scaling() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_AxisDetails_Scaling* _msg = _internal_mutable_scaling();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.scaling)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_scaling(::com::zoho::chart::ChartAxis_AxisDetails_Scaling* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Scaling*>(_impl_.scaling_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Scaling*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.scaling_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Scaling*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.scaling)
}

// optional .com.zoho.chart.ChartAxis.AxisDetails.Cross cross = 5;
inline bool ChartAxis_AxisDetails::has_cross() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cross_ != nullptr);
  return value;
}
inline void ChartAxis_AxisDetails::clear_cross() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cross_ != nullptr) _impl_.cross_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails_Cross& ChartAxis_AxisDetails::_internal_cross() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_AxisDetails_Cross* p = _impl_.cross_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_AxisDetails_Cross&>(::com::zoho::chart::_ChartAxis_AxisDetails_Cross_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails_Cross& ChartAxis_AxisDetails::cross() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.cross)
  return _internal_cross();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_cross(::com::zoho::chart::ChartAxis_AxisDetails_Cross* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cross_);
  }
  _impl_.cross_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Cross*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.cross)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Cross* ChartAxis_AxisDetails::release_cross() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross* released = _impl_.cross_;
  _impl_.cross_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Cross* ChartAxis_AxisDetails::unsafe_arena_release_cross() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.cross)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross* temp = _impl_.cross_;
  _impl_.cross_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Cross* ChartAxis_AxisDetails::_internal_mutable_cross() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.cross_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_AxisDetails_Cross>(GetArena());
    _impl_.cross_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Cross*>(p);
  }
  return _impl_.cross_;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails_Cross* ChartAxis_AxisDetails::mutable_cross() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_AxisDetails_Cross* _msg = _internal_mutable_cross();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.cross)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_cross(::com::zoho::chart::ChartAxis_AxisDetails_Cross* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Cross*>(_impl_.cross_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Cross*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.cross_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails_Cross*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.cross)
}

// optional .com.zoho.chart.TitleElement title = 6;
inline bool ChartAxis_AxisDetails::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.title_ != nullptr);
  return value;
}
inline const ::com::zoho::chart::TitleElement& ChartAxis_AxisDetails::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::TitleElement* p = _impl_.title_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::TitleElement&>(::com::zoho::chart::_TitleElement_default_instance_);
}
inline const ::com::zoho::chart::TitleElement& ChartAxis_AxisDetails::title() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.title)
  return _internal_title();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_title(::com::zoho::chart::TitleElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.title_);
  }
  _impl_.title_ = reinterpret_cast<::com::zoho::chart::TitleElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.title)
}
inline ::com::zoho::chart::TitleElement* ChartAxis_AxisDetails::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::chart::TitleElement* released = _impl_.title_;
  _impl_.title_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::TitleElement* ChartAxis_AxisDetails::unsafe_arena_release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.title)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::com::zoho::chart::TitleElement* temp = _impl_.title_;
  _impl_.title_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::TitleElement* ChartAxis_AxisDetails::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.title_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::TitleElement>(GetArena());
    _impl_.title_ = reinterpret_cast<::com::zoho::chart::TitleElement*>(p);
  }
  return _impl_.title_;
}
inline ::com::zoho::chart::TitleElement* ChartAxis_AxisDetails::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::TitleElement* _msg = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.title)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_title(::com::zoho::chart::TitleElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.title_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.title_ = reinterpret_cast<::com::zoho::chart::TitleElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.title)
}

// optional .com.zoho.shapes.Properties majorGrid = 7;
inline bool ChartAxis_AxisDetails::has_majorgrid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.majorgrid_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Properties& ChartAxis_AxisDetails::_internal_majorgrid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Properties* p = _impl_.majorgrid_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Properties&>(::com::zoho::shapes::_Properties_default_instance_);
}
inline const ::com::zoho::shapes::Properties& ChartAxis_AxisDetails::majorgrid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.majorGrid)
  return _internal_majorgrid();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_majorgrid(::com::zoho::shapes::Properties* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.majorgrid_);
  }
  _impl_.majorgrid_ = reinterpret_cast<::com::zoho::shapes::Properties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.majorGrid)
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::release_majorgrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::Properties* released = _impl_.majorgrid_;
  _impl_.majorgrid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::unsafe_arena_release_majorgrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.majorGrid)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::com::zoho::shapes::Properties* temp = _impl_.majorgrid_;
  _impl_.majorgrid_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::_internal_mutable_majorgrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.majorgrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Properties>(GetArena());
    _impl_.majorgrid_ = reinterpret_cast<::com::zoho::shapes::Properties*>(p);
  }
  return _impl_.majorgrid_;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::mutable_majorgrid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Properties* _msg = _internal_mutable_majorgrid();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.majorGrid)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_majorgrid(::com::zoho::shapes::Properties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.majorgrid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.majorgrid_ = reinterpret_cast<::com::zoho::shapes::Properties*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.majorGrid)
}

// optional .com.zoho.shapes.Properties minorGrid = 8;
inline bool ChartAxis_AxisDetails::has_minorgrid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minorgrid_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Properties& ChartAxis_AxisDetails::_internal_minorgrid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Properties* p = _impl_.minorgrid_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Properties&>(::com::zoho::shapes::_Properties_default_instance_);
}
inline const ::com::zoho::shapes::Properties& ChartAxis_AxisDetails::minorgrid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.minorGrid)
  return _internal_minorgrid();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_minorgrid(::com::zoho::shapes::Properties* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minorgrid_);
  }
  _impl_.minorgrid_ = reinterpret_cast<::com::zoho::shapes::Properties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.minorGrid)
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::release_minorgrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::shapes::Properties* released = _impl_.minorgrid_;
  _impl_.minorgrid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::unsafe_arena_release_minorgrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.minorGrid)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::com::zoho::shapes::Properties* temp = _impl_.minorgrid_;
  _impl_.minorgrid_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::_internal_mutable_minorgrid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.minorgrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Properties>(GetArena());
    _impl_.minorgrid_ = reinterpret_cast<::com::zoho::shapes::Properties*>(p);
  }
  return _impl_.minorgrid_;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::mutable_minorgrid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Properties* _msg = _internal_mutable_minorgrid();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.minorGrid)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_minorgrid(::com::zoho::shapes::Properties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minorgrid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.minorgrid_ = reinterpret_cast<::com::zoho::shapes::Properties*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.minorGrid)
}

// optional .Show.ChartField.TickMarkType majorTickMark = 9;
inline bool ChartAxis_AxisDetails::has_majortickmark() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails::clear_majortickmark() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.majortickmark_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::Show::ChartField_TickMarkType ChartAxis_AxisDetails::majortickmark() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.majorTickMark)
  return _internal_majortickmark();
}
inline void ChartAxis_AxisDetails::set_majortickmark(::Show::ChartField_TickMarkType value) {
  _internal_set_majortickmark(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.majorTickMark)
}
inline ::Show::ChartField_TickMarkType ChartAxis_AxisDetails::_internal_majortickmark() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::ChartField_TickMarkType>(_impl_.majortickmark_);
}
inline void ChartAxis_AxisDetails::_internal_set_majortickmark(::Show::ChartField_TickMarkType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.majortickmark_ = value;
}

// optional .Show.ChartField.TickMarkType minorTickMark = 10;
inline bool ChartAxis_AxisDetails::has_minortickmark() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails::clear_minortickmark() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minortickmark_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::Show::ChartField_TickMarkType ChartAxis_AxisDetails::minortickmark() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.minorTickMark)
  return _internal_minortickmark();
}
inline void ChartAxis_AxisDetails::set_minortickmark(::Show::ChartField_TickMarkType value) {
  _internal_set_minortickmark(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.minorTickMark)
}
inline ::Show::ChartField_TickMarkType ChartAxis_AxisDetails::_internal_minortickmark() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::ChartField_TickMarkType>(_impl_.minortickmark_);
}
inline void ChartAxis_AxisDetails::_internal_set_minortickmark(::Show::ChartField_TickMarkType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.minortickmark_ = value;
}

// optional .Show.ChartField.LabelPos labelPos = 11;
inline bool ChartAxis_AxisDetails::has_labelpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails::clear_labelpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.labelpos_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::Show::ChartField_LabelPos ChartAxis_AxisDetails::labelpos() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.labelPos)
  return _internal_labelpos();
}
inline void ChartAxis_AxisDetails::set_labelpos(::Show::ChartField_LabelPos value) {
  _internal_set_labelpos(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.labelPos)
}
inline ::Show::ChartField_LabelPos ChartAxis_AxisDetails::_internal_labelpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Show::ChartField_LabelPos>(_impl_.labelpos_);
}
inline void ChartAxis_AxisDetails::_internal_set_labelpos(::Show::ChartField_LabelPos value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.labelpos_ = value;
}

// optional .com.zoho.shapes.Properties props = 12;
inline bool ChartAxis_AxisDetails::has_props() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.props_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::Properties& ChartAxis_AxisDetails::_internal_props() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::Properties* p = _impl_.props_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::Properties&>(::com::zoho::shapes::_Properties_default_instance_);
}
inline const ::com::zoho::shapes::Properties& ChartAxis_AxisDetails::props() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.props)
  return _internal_props();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_props(::com::zoho::shapes::Properties* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.props_);
  }
  _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Properties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.props)
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::release_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::shapes::Properties* released = _impl_.props_;
  _impl_.props_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::unsafe_arena_release_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.props)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::com::zoho::shapes::Properties* temp = _impl_.props_;
  _impl_.props_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::_internal_mutable_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.props_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::Properties>(GetArena());
    _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Properties*>(p);
  }
  return _impl_.props_;
}
inline ::com::zoho::shapes::Properties* ChartAxis_AxisDetails::mutable_props() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::Properties* _msg = _internal_mutable_props();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.props)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_props(::com::zoho::shapes::Properties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.props_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.props_ = reinterpret_cast<::com::zoho::shapes::Properties*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.props)
}

// optional .com.zoho.shapes.TextBody textBody = 13;
inline bool ChartAxis_AxisDetails::has_textbody() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.textbody_ != nullptr);
  return value;
}
inline const ::com::zoho::shapes::TextBody& ChartAxis_AxisDetails::_internal_textbody() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::shapes::TextBody* p = _impl_.textbody_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::shapes::TextBody&>(::com::zoho::shapes::_TextBody_default_instance_);
}
inline const ::com::zoho::shapes::TextBody& ChartAxis_AxisDetails::textbody() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.textBody)
  return _internal_textbody();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_textbody(::com::zoho::shapes::TextBody* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textbody_);
  }
  _impl_.textbody_ = reinterpret_cast<::com::zoho::shapes::TextBody*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.textBody)
}
inline ::com::zoho::shapes::TextBody* ChartAxis_AxisDetails::release_textbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::com::zoho::shapes::TextBody* released = _impl_.textbody_;
  _impl_.textbody_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::shapes::TextBody* ChartAxis_AxisDetails::unsafe_arena_release_textbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.textBody)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::com::zoho::shapes::TextBody* temp = _impl_.textbody_;
  _impl_.textbody_ = nullptr;
  return temp;
}
inline ::com::zoho::shapes::TextBody* ChartAxis_AxisDetails::_internal_mutable_textbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.textbody_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::shapes::TextBody>(GetArena());
    _impl_.textbody_ = reinterpret_cast<::com::zoho::shapes::TextBody*>(p);
  }
  return _impl_.textbody_;
}
inline ::com::zoho::shapes::TextBody* ChartAxis_AxisDetails::mutable_textbody() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::shapes::TextBody* _msg = _internal_mutable_textbody();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.textBody)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_textbody(::com::zoho::shapes::TextBody* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.textbody_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.textbody_ = reinterpret_cast<::com::zoho::shapes::TextBody*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.textBody)
}

// optional bool hidden = 14;
inline bool ChartAxis_AxisDetails::has_hidden() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void ChartAxis_AxisDetails::clear_hidden() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hidden_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool ChartAxis_AxisDetails::hidden() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.hidden)
  return _internal_hidden();
}
inline void ChartAxis_AxisDetails::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.AxisDetails.hidden)
}
inline bool ChartAxis_AxisDetails::_internal_hidden() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hidden_;
}
inline void ChartAxis_AxisDetails::_internal_set_hidden(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.hidden_ = value;
}

// optional .com.zoho.common.NumberFormat numberFormat = 15;
inline bool ChartAxis_AxisDetails::has_numberformat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.numberformat_ != nullptr);
  return value;
}
inline const ::com::zoho::common::NumberFormat& ChartAxis_AxisDetails::_internal_numberformat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::common::NumberFormat* p = _impl_.numberformat_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::common::NumberFormat&>(::com::zoho::common::_NumberFormat_default_instance_);
}
inline const ::com::zoho::common::NumberFormat& ChartAxis_AxisDetails::numberformat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.AxisDetails.numberFormat)
  return _internal_numberformat();
}
inline void ChartAxis_AxisDetails::unsafe_arena_set_allocated_numberformat(::com::zoho::common::NumberFormat* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.numberformat_);
  }
  _impl_.numberformat_ = reinterpret_cast<::com::zoho::common::NumberFormat*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.numberFormat)
}
inline ::com::zoho::common::NumberFormat* ChartAxis_AxisDetails::release_numberformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::com::zoho::common::NumberFormat* released = _impl_.numberformat_;
  _impl_.numberformat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::common::NumberFormat* ChartAxis_AxisDetails::unsafe_arena_release_numberformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.AxisDetails.numberFormat)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::com::zoho::common::NumberFormat* temp = _impl_.numberformat_;
  _impl_.numberformat_ = nullptr;
  return temp;
}
inline ::com::zoho::common::NumberFormat* ChartAxis_AxisDetails::_internal_mutable_numberformat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.numberformat_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::common::NumberFormat>(GetArena());
    _impl_.numberformat_ = reinterpret_cast<::com::zoho::common::NumberFormat*>(p);
  }
  return _impl_.numberformat_;
}
inline ::com::zoho::common::NumberFormat* ChartAxis_AxisDetails::mutable_numberformat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::common::NumberFormat* _msg = _internal_mutable_numberformat();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.AxisDetails.numberFormat)
  return _msg;
}
inline void ChartAxis_AxisDetails::set_allocated_numberformat(::com::zoho::common::NumberFormat* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.numberformat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.numberformat_ = reinterpret_cast<::com::zoho::common::NumberFormat*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.AxisDetails.numberFormat)
}

// -------------------------------------------------------------------

// ChartAxis_CategoryAxis

// optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
inline bool ChartAxis_CategoryAxis::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline void ChartAxis_CategoryAxis::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_CategoryAxis::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_AxisDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_AxisDetails&>(::com::zoho::chart::_ChartAxis_AxisDetails_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_CategoryAxis::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.CategoryAxis.details)
  return _internal_details();
}
inline void ChartAxis_CategoryAxis::unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.CategoryAxis.details)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_CategoryAxis::release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* released = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_CategoryAxis::unsafe_arena_release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.CategoryAxis.details)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_CategoryAxis::_internal_mutable_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_AxisDetails>(GetArena());
    _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(p);
  }
  return _impl_.details_;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_CategoryAxis::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_AxisDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.CategoryAxis.details)
  return _msg;
}
inline void ChartAxis_CategoryAxis::set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(_impl_.details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.CategoryAxis.details)
}

// optional .com.zoho.common.HorizontalAlignType lblAlign = 2;
inline bool ChartAxis_CategoryAxis::has_lblalign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChartAxis_CategoryAxis::clear_lblalign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lblalign_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::common::HorizontalAlignType ChartAxis_CategoryAxis::lblalign() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.CategoryAxis.lblAlign)
  return _internal_lblalign();
}
inline void ChartAxis_CategoryAxis::set_lblalign(::com::zoho::common::HorizontalAlignType value) {
  _internal_set_lblalign(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.CategoryAxis.lblAlign)
}
inline ::com::zoho::common::HorizontalAlignType ChartAxis_CategoryAxis::_internal_lblalign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::common::HorizontalAlignType>(_impl_.lblalign_);
}
inline void ChartAxis_CategoryAxis::_internal_set_lblalign(::com::zoho::common::HorizontalAlignType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lblalign_ = value;
}

// optional float lblOffset = 3;
inline bool ChartAxis_CategoryAxis::has_lbloffset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChartAxis_CategoryAxis::clear_lbloffset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lbloffset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ChartAxis_CategoryAxis::lbloffset() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.CategoryAxis.lblOffset)
  return _internal_lbloffset();
}
inline void ChartAxis_CategoryAxis::set_lbloffset(float value) {
  _internal_set_lbloffset(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.CategoryAxis.lblOffset)
}
inline float ChartAxis_CategoryAxis::_internal_lbloffset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lbloffset_;
}
inline void ChartAxis_CategoryAxis::_internal_set_lbloffset(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.lbloffset_ = value;
}

// optional int32 skipTickLabel = 4;
inline bool ChartAxis_CategoryAxis::has_skipticklabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ChartAxis_CategoryAxis::clear_skipticklabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skipticklabel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ChartAxis_CategoryAxis::skipticklabel() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.CategoryAxis.skipTickLabel)
  return _internal_skipticklabel();
}
inline void ChartAxis_CategoryAxis::set_skipticklabel(::int32_t value) {
  _internal_set_skipticklabel(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.CategoryAxis.skipTickLabel)
}
inline ::int32_t ChartAxis_CategoryAxis::_internal_skipticklabel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skipticklabel_;
}
inline void ChartAxis_CategoryAxis::_internal_set_skipticklabel(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.skipticklabel_ = value;
}

// optional int32 skipTickMark = 5;
inline bool ChartAxis_CategoryAxis::has_skiptickmark() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ChartAxis_CategoryAxis::clear_skiptickmark() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skiptickmark_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t ChartAxis_CategoryAxis::skiptickmark() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.CategoryAxis.skipTickMark)
  return _internal_skiptickmark();
}
inline void ChartAxis_CategoryAxis::set_skiptickmark(::int32_t value) {
  _internal_set_skiptickmark(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.CategoryAxis.skipTickMark)
}
inline ::int32_t ChartAxis_CategoryAxis::_internal_skiptickmark() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skiptickmark_;
}
inline void ChartAxis_CategoryAxis::_internal_set_skiptickmark(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.skiptickmark_ = value;
}

// -------------------------------------------------------------------

// ChartAxis_ValueAxis_DisplayUnit

// optional .com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.DisplayUnitType type = 1;
inline bool ChartAxis_ValueAxis_DisplayUnit::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChartAxis_ValueAxis_DisplayUnit::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType ChartAxis_ValueAxis_DisplayUnit::type() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.type)
  return _internal_type();
}
inline void ChartAxis_ValueAxis_DisplayUnit::set_type(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.type)
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType ChartAxis_ValueAxis_DisplayUnit::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType>(_impl_.type_);
}
inline void ChartAxis_ValueAxis_DisplayUnit::_internal_set_type(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional float custom = 2;
inline bool ChartAxis_ValueAxis_DisplayUnit::has_custom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChartAxis_ValueAxis_DisplayUnit::clear_custom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.custom_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ChartAxis_ValueAxis_DisplayUnit::custom() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.custom)
  return _internal_custom();
}
inline void ChartAxis_ValueAxis_DisplayUnit::set_custom(float value) {
  _internal_set_custom(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.custom)
}
inline float ChartAxis_ValueAxis_DisplayUnit::_internal_custom() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.custom_;
}
inline void ChartAxis_ValueAxis_DisplayUnit::_internal_set_custom(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_ = value;
}

// optional .com.zoho.chart.TitleElement label = 3;
inline bool ChartAxis_ValueAxis_DisplayUnit::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.label_ != nullptr);
  return value;
}
inline const ::com::zoho::chart::TitleElement& ChartAxis_ValueAxis_DisplayUnit::_internal_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::TitleElement* p = _impl_.label_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::TitleElement&>(::com::zoho::chart::_TitleElement_default_instance_);
}
inline const ::com::zoho::chart::TitleElement& ChartAxis_ValueAxis_DisplayUnit::label() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.label)
  return _internal_label();
}
inline void ChartAxis_ValueAxis_DisplayUnit::unsafe_arena_set_allocated_label(::com::zoho::chart::TitleElement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.label_);
  }
  _impl_.label_ = reinterpret_cast<::com::zoho::chart::TitleElement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.label)
}
inline ::com::zoho::chart::TitleElement* ChartAxis_ValueAxis_DisplayUnit::release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::TitleElement* released = _impl_.label_;
  _impl_.label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::TitleElement* ChartAxis_ValueAxis_DisplayUnit::unsafe_arena_release_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.label)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::TitleElement* temp = _impl_.label_;
  _impl_.label_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::TitleElement* ChartAxis_ValueAxis_DisplayUnit::_internal_mutable_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.label_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::TitleElement>(GetArena());
    _impl_.label_ = reinterpret_cast<::com::zoho::chart::TitleElement*>(p);
  }
  return _impl_.label_;
}
inline ::com::zoho::chart::TitleElement* ChartAxis_ValueAxis_DisplayUnit::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::TitleElement* _msg = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.label)
  return _msg;
}
inline void ChartAxis_ValueAxis_DisplayUnit::set_allocated_label(::com::zoho::chart::TitleElement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.label_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.label_ = reinterpret_cast<::com::zoho::chart::TitleElement*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit.label)
}

// -------------------------------------------------------------------

// ChartAxis_ValueAxis

// optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
inline bool ChartAxis_ValueAxis::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline void ChartAxis_ValueAxis::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_ValueAxis::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_AxisDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_AxisDetails&>(::com::zoho::chart::_ChartAxis_AxisDetails_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_ValueAxis::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.details)
  return _internal_details();
}
inline void ChartAxis_ValueAxis::unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.ValueAxis.details)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_ValueAxis::release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* released = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_ValueAxis::unsafe_arena_release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.ValueAxis.details)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_ValueAxis::_internal_mutable_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_AxisDetails>(GetArena());
    _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(p);
  }
  return _impl_.details_;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_ValueAxis::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_AxisDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.ValueAxis.details)
  return _msg;
}
inline void ChartAxis_ValueAxis::set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(_impl_.details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.ValueAxis.details)
}

// optional .com.zoho.chart.ChartAxis.ValueAxis.CrossBetween crossBetween = 2;
inline bool ChartAxis_ValueAxis::has_crossbetween() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChartAxis_ValueAxis::clear_crossbetween() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crossbetween_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween ChartAxis_ValueAxis::crossbetween() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.crossBetween)
  return _internal_crossbetween();
}
inline void ChartAxis_ValueAxis::set_crossbetween(::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween value) {
  _internal_set_crossbetween(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.ValueAxis.crossBetween)
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween ChartAxis_ValueAxis::_internal_crossbetween() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween>(_impl_.crossbetween_);
}
inline void ChartAxis_ValueAxis::_internal_set_crossbetween(::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.crossbetween_ = value;
}

// optional float major = 3;
inline bool ChartAxis_ValueAxis::has_major() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ChartAxis_ValueAxis::clear_major() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.major_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ChartAxis_ValueAxis::major() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.major)
  return _internal_major();
}
inline void ChartAxis_ValueAxis::set_major(float value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.ValueAxis.major)
}
inline float ChartAxis_ValueAxis::_internal_major() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.major_;
}
inline void ChartAxis_ValueAxis::_internal_set_major(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.major_ = value;
}

// optional float minor = 4;
inline bool ChartAxis_ValueAxis::has_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ChartAxis_ValueAxis::clear_minor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float ChartAxis_ValueAxis::minor() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.minor)
  return _internal_minor();
}
inline void ChartAxis_ValueAxis::set_minor(float value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.ValueAxis.minor)
}
inline float ChartAxis_ValueAxis::_internal_minor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minor_;
}
inline void ChartAxis_ValueAxis::_internal_set_minor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.minor_ = value;
}

// optional .com.zoho.chart.ChartAxis.ValueAxis.DisplayUnit displayUnit = 5;
inline bool ChartAxis_ValueAxis::has_displayunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.displayunit_ != nullptr);
  return value;
}
inline void ChartAxis_ValueAxis::clear_displayunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.displayunit_ != nullptr) _impl_.displayunit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit& ChartAxis_ValueAxis::_internal_displayunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* p = _impl_.displayunit_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit&>(::com::zoho::chart::_ChartAxis_ValueAxis_DisplayUnit_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit& ChartAxis_ValueAxis::displayunit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.ValueAxis.displayUnit)
  return _internal_displayunit();
}
inline void ChartAxis_ValueAxis::unsafe_arena_set_allocated_displayunit(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.displayunit_);
  }
  _impl_.displayunit_ = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.ValueAxis.displayUnit)
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* ChartAxis_ValueAxis::release_displayunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* released = _impl_.displayunit_;
  _impl_.displayunit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* ChartAxis_ValueAxis::unsafe_arena_release_displayunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.ValueAxis.displayUnit)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* temp = _impl_.displayunit_;
  _impl_.displayunit_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* ChartAxis_ValueAxis::_internal_mutable_displayunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.displayunit_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit>(GetArena());
    _impl_.displayunit_ = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit*>(p);
  }
  return _impl_.displayunit_;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* ChartAxis_ValueAxis::mutable_displayunit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* _msg = _internal_mutable_displayunit();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.ValueAxis.displayUnit)
  return _msg;
}
inline void ChartAxis_ValueAxis::set_allocated_displayunit(::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit*>(_impl_.displayunit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.displayunit_ = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.ValueAxis.displayUnit)
}

// -------------------------------------------------------------------

// ChartAxis_DateAxis

// optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
inline bool ChartAxis_DateAxis::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline void ChartAxis_DateAxis::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_DateAxis::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_AxisDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_AxisDetails&>(::com::zoho::chart::_ChartAxis_AxisDetails_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_DateAxis::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.DateAxis.details)
  return _internal_details();
}
inline void ChartAxis_DateAxis::unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.DateAxis.details)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_DateAxis::release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* released = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_DateAxis::unsafe_arena_release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.DateAxis.details)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_DateAxis::_internal_mutable_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_AxisDetails>(GetArena());
    _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(p);
  }
  return _impl_.details_;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_DateAxis::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_AxisDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.DateAxis.details)
  return _msg;
}
inline void ChartAxis_DateAxis::set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(_impl_.details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.DateAxis.details)
}

// optional float lblOffset = 2;
inline bool ChartAxis_DateAxis::has_lbloffset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChartAxis_DateAxis::clear_lbloffset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lbloffset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ChartAxis_DateAxis::lbloffset() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.DateAxis.lblOffset)
  return _internal_lbloffset();
}
inline void ChartAxis_DateAxis::set_lbloffset(float value) {
  _internal_set_lbloffset(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.DateAxis.lblOffset)
}
inline float ChartAxis_DateAxis::_internal_lbloffset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lbloffset_;
}
inline void ChartAxis_DateAxis::_internal_set_lbloffset(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lbloffset_ = value;
}

// optional float major = 3;
inline bool ChartAxis_DateAxis::has_major() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChartAxis_DateAxis::clear_major() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.major_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ChartAxis_DateAxis::major() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.DateAxis.major)
  return _internal_major();
}
inline void ChartAxis_DateAxis::set_major(float value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.DateAxis.major)
}
inline float ChartAxis_DateAxis::_internal_major() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.major_;
}
inline void ChartAxis_DateAxis::_internal_set_major(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.major_ = value;
}

// optional float minor = 4;
inline bool ChartAxis_DateAxis::has_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ChartAxis_DateAxis::clear_minor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ChartAxis_DateAxis::minor() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.DateAxis.minor)
  return _internal_minor();
}
inline void ChartAxis_DateAxis::set_minor(float value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.DateAxis.minor)
}
inline float ChartAxis_DateAxis::_internal_minor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minor_;
}
inline void ChartAxis_DateAxis::_internal_set_minor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.minor_ = value;
}

// optional .com.zoho.chart.ChartAxis.DateAxis.TimeUnit baseTimeUnit = 5;
inline bool ChartAxis_DateAxis::has_basetimeunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ChartAxis_DateAxis::clear_basetimeunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.basetimeunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis::basetimeunit() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.DateAxis.baseTimeUnit)
  return _internal_basetimeunit();
}
inline void ChartAxis_DateAxis::set_basetimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value) {
  _internal_set_basetimeunit(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.DateAxis.baseTimeUnit)
}
inline ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis::_internal_basetimeunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::chart::ChartAxis_DateAxis_TimeUnit>(_impl_.basetimeunit_);
}
inline void ChartAxis_DateAxis::_internal_set_basetimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.basetimeunit_ = value;
}

// optional .com.zoho.chart.ChartAxis.DateAxis.TimeUnit majorTimeUnit = 6;
inline bool ChartAxis_DateAxis::has_majortimeunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ChartAxis_DateAxis::clear_majortimeunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.majortimeunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis::majortimeunit() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.DateAxis.majorTimeUnit)
  return _internal_majortimeunit();
}
inline void ChartAxis_DateAxis::set_majortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value) {
  _internal_set_majortimeunit(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.DateAxis.majorTimeUnit)
}
inline ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis::_internal_majortimeunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::chart::ChartAxis_DateAxis_TimeUnit>(_impl_.majortimeunit_);
}
inline void ChartAxis_DateAxis::_internal_set_majortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.majortimeunit_ = value;
}

// optional .com.zoho.chart.ChartAxis.DateAxis.TimeUnit minorTimeUnit = 7;
inline bool ChartAxis_DateAxis::has_minortimeunit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ChartAxis_DateAxis::clear_minortimeunit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minortimeunit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis::minortimeunit() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.DateAxis.minorTimeUnit)
  return _internal_minortimeunit();
}
inline void ChartAxis_DateAxis::set_minortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value) {
  _internal_set_minortimeunit(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.DateAxis.minorTimeUnit)
}
inline ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit ChartAxis_DateAxis::_internal_minortimeunit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::com::zoho::chart::ChartAxis_DateAxis_TimeUnit>(_impl_.minortimeunit_);
}
inline void ChartAxis_DateAxis::_internal_set_minortimeunit(::com::zoho::chart::ChartAxis_DateAxis_TimeUnit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.minortimeunit_ = value;
}

// -------------------------------------------------------------------

// ChartAxis_SeriesAxis

// optional .com.zoho.chart.ChartAxis.AxisDetails details = 1 [(.com.zoho.common.customOptions) = {
inline bool ChartAxis_SeriesAxis::has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline void ChartAxis_SeriesAxis::clear_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_SeriesAxis::_internal_details() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_AxisDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_AxisDetails&>(::com::zoho::chart::_ChartAxis_AxisDetails_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_AxisDetails& ChartAxis_SeriesAxis::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.SeriesAxis.details)
  return _internal_details();
}
inline void ChartAxis_SeriesAxis::unsafe_arena_set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.SeriesAxis.details)
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_SeriesAxis::release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* released = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_SeriesAxis::unsafe_arena_release_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.SeriesAxis.details)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_AxisDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_SeriesAxis::_internal_mutable_details() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_AxisDetails>(GetArena());
    _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(p);
  }
  return _impl_.details_;
}
inline ::com::zoho::chart::ChartAxis_AxisDetails* ChartAxis_SeriesAxis::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_AxisDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.SeriesAxis.details)
  return _msg;
}
inline void ChartAxis_SeriesAxis::set_allocated_details(::com::zoho::chart::ChartAxis_AxisDetails* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(_impl_.details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.details_ = reinterpret_cast<::com::zoho::chart::ChartAxis_AxisDetails*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.SeriesAxis.details)
}

// optional int32 skipTickLabel = 2;
inline bool ChartAxis_SeriesAxis::has_skipticklabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChartAxis_SeriesAxis::clear_skipticklabel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skipticklabel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ChartAxis_SeriesAxis::skipticklabel() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.SeriesAxis.skipTickLabel)
  return _internal_skipticklabel();
}
inline void ChartAxis_SeriesAxis::set_skipticklabel(::int32_t value) {
  _internal_set_skipticklabel(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.SeriesAxis.skipTickLabel)
}
inline ::int32_t ChartAxis_SeriesAxis::_internal_skipticklabel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skipticklabel_;
}
inline void ChartAxis_SeriesAxis::_internal_set_skipticklabel(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.skipticklabel_ = value;
}

// optional int32 skipTickMark = 3;
inline bool ChartAxis_SeriesAxis::has_skiptickmark() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChartAxis_SeriesAxis::clear_skiptickmark() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skiptickmark_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ChartAxis_SeriesAxis::skiptickmark() const {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.SeriesAxis.skipTickMark)
  return _internal_skiptickmark();
}
inline void ChartAxis_SeriesAxis::set_skiptickmark(::int32_t value) {
  _internal_set_skiptickmark(value);
  // @@protoc_insertion_point(field_set:com.zoho.chart.ChartAxis.SeriesAxis.skipTickMark)
}
inline ::int32_t ChartAxis_SeriesAxis::_internal_skiptickmark() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skiptickmark_;
}
inline void ChartAxis_SeriesAxis::_internal_set_skiptickmark(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.skiptickmark_ = value;
}

// -------------------------------------------------------------------

// ChartAxis

// optional .com.zoho.chart.ChartAxis.CategoryAxis category = 1;
inline bool ChartAxis::has_category() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.category_ != nullptr);
  return value;
}
inline void ChartAxis::clear_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.category_ != nullptr) _impl_.category_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::zoho::chart::ChartAxis_CategoryAxis& ChartAxis::_internal_category() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_CategoryAxis* p = _impl_.category_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_CategoryAxis&>(::com::zoho::chart::_ChartAxis_CategoryAxis_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_CategoryAxis& ChartAxis::category() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.category)
  return _internal_category();
}
inline void ChartAxis::unsafe_arena_set_allocated_category(::com::zoho::chart::ChartAxis_CategoryAxis* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.category_);
  }
  _impl_.category_ = reinterpret_cast<::com::zoho::chart::ChartAxis_CategoryAxis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.category)
}
inline ::com::zoho::chart::ChartAxis_CategoryAxis* ChartAxis::release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_CategoryAxis* released = _impl_.category_;
  _impl_.category_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_CategoryAxis* ChartAxis::unsafe_arena_release_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.category)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::zoho::chart::ChartAxis_CategoryAxis* temp = _impl_.category_;
  _impl_.category_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_CategoryAxis* ChartAxis::_internal_mutable_category() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.category_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_CategoryAxis>(GetArena());
    _impl_.category_ = reinterpret_cast<::com::zoho::chart::ChartAxis_CategoryAxis*>(p);
  }
  return _impl_.category_;
}
inline ::com::zoho::chart::ChartAxis_CategoryAxis* ChartAxis::mutable_category() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_CategoryAxis* _msg = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.category)
  return _msg;
}
inline void ChartAxis::set_allocated_category(::com::zoho::chart::ChartAxis_CategoryAxis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_CategoryAxis*>(_impl_.category_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_CategoryAxis*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.category_ = reinterpret_cast<::com::zoho::chart::ChartAxis_CategoryAxis*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.category)
}

// optional .com.zoho.chart.ChartAxis.ValueAxis value = 2;
inline bool ChartAxis::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void ChartAxis::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::zoho::chart::ChartAxis_ValueAxis& ChartAxis::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_ValueAxis* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_ValueAxis&>(::com::zoho::chart::_ChartAxis_ValueAxis_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_ValueAxis& ChartAxis::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.value)
  return _internal_value();
}
inline void ChartAxis::unsafe_arena_set_allocated_value(::com::zoho::chart::ChartAxis_ValueAxis* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.value)
}
inline ::com::zoho::chart::ChartAxis_ValueAxis* ChartAxis::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::chart::ChartAxis_ValueAxis* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis* ChartAxis::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::zoho::chart::ChartAxis_ValueAxis* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis* ChartAxis::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_ValueAxis>(GetArena());
    _impl_.value_ = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis*>(p);
  }
  return _impl_.value_;
}
inline ::com::zoho::chart::ChartAxis_ValueAxis* ChartAxis::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_ValueAxis* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.value)
  return _msg;
}
inline void ChartAxis::set_allocated_value(::com::zoho::chart::ChartAxis_ValueAxis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.value_ = reinterpret_cast<::com::zoho::chart::ChartAxis_ValueAxis*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.value)
}

// optional .com.zoho.chart.ChartAxis.DateAxis date = 3;
inline bool ChartAxis::has_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.date_ != nullptr);
  return value;
}
inline void ChartAxis::clear_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.date_ != nullptr) _impl_.date_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::com::zoho::chart::ChartAxis_DateAxis& ChartAxis::_internal_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_DateAxis* p = _impl_.date_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_DateAxis&>(::com::zoho::chart::_ChartAxis_DateAxis_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_DateAxis& ChartAxis::date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.date)
  return _internal_date();
}
inline void ChartAxis::unsafe_arena_set_allocated_date(::com::zoho::chart::ChartAxis_DateAxis* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.date_);
  }
  _impl_.date_ = reinterpret_cast<::com::zoho::chart::ChartAxis_DateAxis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.date)
}
inline ::com::zoho::chart::ChartAxis_DateAxis* ChartAxis::release_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::chart::ChartAxis_DateAxis* released = _impl_.date_;
  _impl_.date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_DateAxis* ChartAxis::unsafe_arena_release_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.date)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::com::zoho::chart::ChartAxis_DateAxis* temp = _impl_.date_;
  _impl_.date_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_DateAxis* ChartAxis::_internal_mutable_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.date_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_DateAxis>(GetArena());
    _impl_.date_ = reinterpret_cast<::com::zoho::chart::ChartAxis_DateAxis*>(p);
  }
  return _impl_.date_;
}
inline ::com::zoho::chart::ChartAxis_DateAxis* ChartAxis::mutable_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_DateAxis* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.date)
  return _msg;
}
inline void ChartAxis::set_allocated_date(::com::zoho::chart::ChartAxis_DateAxis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_DateAxis*>(_impl_.date_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_DateAxis*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.date_ = reinterpret_cast<::com::zoho::chart::ChartAxis_DateAxis*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.date)
}

// optional .com.zoho.chart.ChartAxis.SeriesAxis series = 4;
inline bool ChartAxis::has_series() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.series_ != nullptr);
  return value;
}
inline void ChartAxis::clear_series() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.series_ != nullptr) _impl_.series_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::com::zoho::chart::ChartAxis_SeriesAxis& ChartAxis::_internal_series() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::zoho::chart::ChartAxis_SeriesAxis* p = _impl_.series_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::zoho::chart::ChartAxis_SeriesAxis&>(::com::zoho::chart::_ChartAxis_SeriesAxis_default_instance_);
}
inline const ::com::zoho::chart::ChartAxis_SeriesAxis& ChartAxis::series() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.zoho.chart.ChartAxis.series)
  return _internal_series();
}
inline void ChartAxis::unsafe_arena_set_allocated_series(::com::zoho::chart::ChartAxis_SeriesAxis* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.series_);
  }
  _impl_.series_ = reinterpret_cast<::com::zoho::chart::ChartAxis_SeriesAxis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.zoho.chart.ChartAxis.series)
}
inline ::com::zoho::chart::ChartAxis_SeriesAxis* ChartAxis::release_series() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::chart::ChartAxis_SeriesAxis* released = _impl_.series_;
  _impl_.series_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::zoho::chart::ChartAxis_SeriesAxis* ChartAxis::unsafe_arena_release_series() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.zoho.chart.ChartAxis.series)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::com::zoho::chart::ChartAxis_SeriesAxis* temp = _impl_.series_;
  _impl_.series_ = nullptr;
  return temp;
}
inline ::com::zoho::chart::ChartAxis_SeriesAxis* ChartAxis::_internal_mutable_series() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.series_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::zoho::chart::ChartAxis_SeriesAxis>(GetArena());
    _impl_.series_ = reinterpret_cast<::com::zoho::chart::ChartAxis_SeriesAxis*>(p);
  }
  return _impl_.series_;
}
inline ::com::zoho::chart::ChartAxis_SeriesAxis* ChartAxis::mutable_series() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::zoho::chart::ChartAxis_SeriesAxis* _msg = _internal_mutable_series();
  // @@protoc_insertion_point(field_mutable:com.zoho.chart.ChartAxis.series)
  return _msg;
}
inline void ChartAxis::set_allocated_series(::com::zoho::chart::ChartAxis_SeriesAxis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::zoho::chart::ChartAxis_SeriesAxis*>(_impl_.series_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::zoho::chart::ChartAxis_SeriesAxis*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.series_ = reinterpret_cast<::com::zoho::chart::ChartAxis_SeriesAxis*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.zoho.chart.ChartAxis.series)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace chart
}  // namespace zoho
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation>() {
  return ::com::zoho::chart::ChartAxis_AxisDetails_Scaling_Orientation_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType>() {
  return ::com::zoho::chart::ChartAxis_AxisDetails_Cross_CrossType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType>() {
  return ::com::zoho::chart::ChartAxis_ValueAxis_DisplayUnit_DisplayUnitType_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween>() {
  return ::com::zoho::chart::ChartAxis_ValueAxis_CrossBetween_descriptor();
}
template <>
struct is_proto_enum<::com::zoho::chart::ChartAxis_DateAxis_TimeUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::zoho::chart::ChartAxis_DateAxis_TimeUnit>() {
  return ::com::zoho::chart::ChartAxis_DateAxis_TimeUnit_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_chartaxis_2eproto_2epb_2eh
