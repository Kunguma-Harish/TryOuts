// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chartstyle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ChartStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var axis: ChartStyle.StyleData {
    get {return _storage._axis ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._axis = newValue}
  }
  /// Returns true if `axis` has been explicitly set.
  public var hasAxis: Bool {return _storage._axis != nil}
  /// Clears the value of `axis`. Subsequent reads from it will return its default value.
  public mutating func clearAxis() {_uniqueStorage()._axis = nil}

  public var axisTitle: ChartStyle.StyleData {
    get {return _storage._axisTitle ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._axisTitle = newValue}
  }
  /// Returns true if `axisTitle` has been explicitly set.
  public var hasAxisTitle: Bool {return _storage._axisTitle != nil}
  /// Clears the value of `axisTitle`. Subsequent reads from it will return its default value.
  public mutating func clearAxisTitle() {_uniqueStorage()._axisTitle = nil}

  public var chartArea: ChartStyle.StyleData {
    get {return _storage._chartArea ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._chartArea = newValue}
  }
  /// Returns true if `chartArea` has been explicitly set.
  public var hasChartArea: Bool {return _storage._chartArea != nil}
  /// Clears the value of `chartArea`. Subsequent reads from it will return its default value.
  public mutating func clearChartArea() {_uniqueStorage()._chartArea = nil}

  public var chartTitle: ChartStyle.StyleData {
    get {return _storage._chartTitle ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._chartTitle = newValue}
  }
  /// Returns true if `chartTitle` has been explicitly set.
  public var hasChartTitle: Bool {return _storage._chartTitle != nil}
  /// Clears the value of `chartTitle`. Subsequent reads from it will return its default value.
  public mutating func clearChartTitle() {_uniqueStorage()._chartTitle = nil}

  public var dataLabels: ChartStyle.StyleData {
    get {return _storage._dataLabels ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._dataLabels = newValue}
  }
  /// Returns true if `dataLabels` has been explicitly set.
  public var hasDataLabels: Bool {return _storage._dataLabels != nil}
  /// Clears the value of `dataLabels`. Subsequent reads from it will return its default value.
  public mutating func clearDataLabels() {_uniqueStorage()._dataLabels = nil}

  public var dataTable: ChartStyle.StyleData {
    get {return _storage._dataTable ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._dataTable = newValue}
  }
  /// Returns true if `dataTable` has been explicitly set.
  public var hasDataTable: Bool {return _storage._dataTable != nil}
  /// Clears the value of `dataTable`. Subsequent reads from it will return its default value.
  public mutating func clearDataTable() {_uniqueStorage()._dataTable = nil}

  public var downBars: ChartStyle.StyleData {
    get {return _storage._downBars ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._downBars = newValue}
  }
  /// Returns true if `downBars` has been explicitly set.
  public var hasDownBars: Bool {return _storage._downBars != nil}
  /// Clears the value of `downBars`. Subsequent reads from it will return its default value.
  public mutating func clearDownBars() {_uniqueStorage()._downBars = nil}

  public var floor: ChartStyle.StyleData {
    get {return _storage._floor ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._floor = newValue}
  }
  /// Returns true if `floor` has been explicitly set.
  public var hasFloor: Bool {return _storage._floor != nil}
  /// Clears the value of `floor`. Subsequent reads from it will return its default value.
  public mutating func clearFloor() {_uniqueStorage()._floor = nil}

  public var legend: ChartStyle.StyleData {
    get {return _storage._legend ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._legend = newValue}
  }
  /// Returns true if `legend` has been explicitly set.
  public var hasLegend: Bool {return _storage._legend != nil}
  /// Clears the value of `legend`. Subsequent reads from it will return its default value.
  public mutating func clearLegend() {_uniqueStorage()._legend = nil}

  public var majorGridlines: ChartStyle.StyleData {
    get {return _storage._majorGridlines ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._majorGridlines = newValue}
  }
  /// Returns true if `majorGridlines` has been explicitly set.
  public var hasMajorGridlines: Bool {return _storage._majorGridlines != nil}
  /// Clears the value of `majorGridlines`. Subsequent reads from it will return its default value.
  public mutating func clearMajorGridlines() {_uniqueStorage()._majorGridlines = nil}

  public var minorGridlines: ChartStyle.StyleData {
    get {return _storage._minorGridlines ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._minorGridlines = newValue}
  }
  /// Returns true if `minorGridlines` has been explicitly set.
  public var hasMinorGridlines: Bool {return _storage._minorGridlines != nil}
  /// Clears the value of `minorGridlines`. Subsequent reads from it will return its default value.
  public mutating func clearMinorGridlines() {_uniqueStorage()._minorGridlines = nil}

  public var otherLines: ChartStyle.StyleData {
    get {return _storage._otherLines ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._otherLines = newValue}
  }
  /// Returns true if `otherLines` has been explicitly set.
  public var hasOtherLines: Bool {return _storage._otherLines != nil}
  /// Clears the value of `otherLines`. Subsequent reads from it will return its default value.
  public mutating func clearOtherLines() {_uniqueStorage()._otherLines = nil}

  public var plotArea: ChartStyle.StyleData {
    get {return _storage._plotArea ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._plotArea = newValue}
  }
  /// Returns true if `plotArea` has been explicitly set.
  public var hasPlotArea: Bool {return _storage._plotArea != nil}
  /// Clears the value of `plotArea`. Subsequent reads from it will return its default value.
  public mutating func clearPlotArea() {_uniqueStorage()._plotArea = nil}

  public var upBars: ChartStyle.StyleData {
    get {return _storage._upBars ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._upBars = newValue}
  }
  /// Returns true if `upBars` has been explicitly set.
  public var hasUpBars: Bool {return _storage._upBars != nil}
  /// Clears the value of `upBars`. Subsequent reads from it will return its default value.
  public mutating func clearUpBars() {_uniqueStorage()._upBars = nil}

  public var walls: ChartStyle.StyleData {
    get {return _storage._walls ?? ChartStyle.StyleData()}
    set {_uniqueStorage()._walls = newValue}
  }
  /// Returns true if `walls` has been explicitly set.
  public var hasWalls: Bool {return _storage._walls != nil}
  /// Clears the value of `walls`. Subsequent reads from it will return its default value.
  public mutating func clearWalls() {_uniqueStorage()._walls = nil}

  /// Fill Data point.
  public var dataPoint: [ChartStyle.StyleData] {
    get {return _storage._dataPoint}
    set {_uniqueStorage()._dataPoint = newValue}
  }

  /// Line Data point
  public var dataPointLine: [ChartStyle.StyleData] {
    get {return _storage._dataPointLine}
    set {_uniqueStorage()._dataPointLine = newValue}
  }

  /// Marker for Data point
  public var dataPointMarker: [ChartStyle.StyleData] {
    get {return _storage._dataPointMarker}
    set {_uniqueStorage()._dataPointMarker = newValue}
  }

  public var categoryAxis: [ChartStyle.StyleData] {
    get {return _storage._categoryAxis}
    set {_uniqueStorage()._categoryAxis = newValue}
  }

  public var valueAxis: [ChartStyle.StyleData] {
    get {return _storage._valueAxis}
    set {_uniqueStorage()._valueAxis = newValue}
  }

  public var seriesAxis: [ChartStyle.StyleData] {
    get {return _storage._seriesAxis}
    set {_uniqueStorage()._seriesAxis = newValue}
  }

  public var dateAxis: [ChartStyle.StyleData] {
    get {return _storage._dateAxis}
    set {_uniqueStorage()._dateAxis = newValue}
  }

  public var dropLines: [ChartStyle.StyleData] {
    get {return _storage._dropLines}
    set {_uniqueStorage()._dropLines = newValue}
  }

  public var hiLowLine: [ChartStyle.StyleData] {
    get {return _storage._hiLowLine}
    set {_uniqueStorage()._hiLowLine = newValue}
  }

  public var leaderLine: [ChartStyle.StyleData] {
    get {return _storage._leaderLine}
    set {_uniqueStorage()._leaderLine = newValue}
  }

  public var defPrProps: PortionProps {
    get {return _storage._defPrProps ?? PortionProps()}
    set {_uniqueStorage()._defPrProps = newValue}
  }
  /// Returns true if `defPrProps` has been explicitly set.
  public var hasDefPrProps: Bool {return _storage._defPrProps != nil}
  /// Clears the value of `defPrProps`. Subsequent reads from it will return its default value.
  public mutating func clearDefPrProps() {_uniqueStorage()._defPrProps = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct StyleData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var themeRef: ThemeReference {
      get {return _storage._themeRef ?? ThemeReference()}
      set {_uniqueStorage()._themeRef = newValue}
    }
    /// Returns true if `themeRef` has been explicitly set.
    public var hasThemeRef: Bool {return _storage._themeRef != nil}
    /// Clears the value of `themeRef`. Subsequent reads from it will return its default value.
    public mutating func clearThemeRef() {_uniqueStorage()._themeRef = nil}

    public var fill: Fill {
      get {return _storage._fill ?? Fill()}
      set {_uniqueStorage()._fill = newValue}
    }
    /// Returns true if `fill` has been explicitly set.
    public var hasFill: Bool {return _storage._fill != nil}
    /// Clears the value of `fill`. Subsequent reads from it will return its default value.
    public mutating func clearFill() {_uniqueStorage()._fill = nil}

    public var stroke: Stroke {
      get {return _storage._stroke ?? Stroke()}
      set {_uniqueStorage()._stroke = newValue}
    }
    /// Returns true if `stroke` has been explicitly set.
    public var hasStroke: Bool {return _storage._stroke != nil}
    /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
    public mutating func clearStroke() {_uniqueStorage()._stroke = nil}

    public var fillPattern: ChartStyle.StyleData.PatternType {
      get {return _storage._fillPattern ?? .none}
      set {_uniqueStorage()._fillPattern = newValue}
    }
    /// Returns true if `fillPattern` has been explicitly set.
    public var hasFillPattern: Bool {return _storage._fillPattern != nil}
    /// Clears the value of `fillPattern`. Subsequent reads from it will return its default value.
    public mutating func clearFillPattern() {_uniqueStorage()._fillPattern = nil}

    public var strokePatern: ChartStyle.StyleData.PatternType {
      get {return _storage._strokePatern ?? .none}
      set {_uniqueStorage()._strokePatern = newValue}
    }
    /// Returns true if `strokePatern` has been explicitly set.
    public var hasStrokePatern: Bool {return _storage._strokePatern != nil}
    /// Clears the value of `strokePatern`. Subsequent reads from it will return its default value.
    public mutating func clearStrokePatern() {_uniqueStorage()._strokePatern = nil}

    public var defPrProps: PortionProps {
      get {return _storage._defPrProps ?? PortionProps()}
      set {_uniqueStorage()._defPrProps = newValue}
    }
    /// Returns true if `defPrProps` has been explicitly set.
    public var hasDefPrProps: Bool {return _storage._defPrProps != nil}
    /// Clears the value of `defPrProps`. Subsequent reads from it will return its default value.
    public mutating func clearDefPrProps() {_uniqueStorage()._defPrProps = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum PatternType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case none // = 0
      case fade // = 1

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .fade
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .fade: return 1
        }
      }

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension ChartStyle.StyleData.PatternType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension ChartStyle: @unchecked Sendable {}
extension ChartStyle.StyleData: @unchecked Sendable {}
extension ChartStyle.StyleData.PatternType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.chart"

extension ChartStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChartStyle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "axis"),
    2: .same(proto: "axisTitle"),
    3: .same(proto: "chartArea"),
    4: .same(proto: "chartTitle"),
    5: .same(proto: "dataLabels"),
    6: .same(proto: "dataTable"),
    7: .same(proto: "downBars"),
    8: .same(proto: "floor"),
    9: .same(proto: "legend"),
    10: .same(proto: "majorGridlines"),
    11: .same(proto: "minorGridlines"),
    12: .same(proto: "otherLines"),
    13: .same(proto: "plotArea"),
    14: .same(proto: "upBars"),
    15: .same(proto: "walls"),
    16: .same(proto: "dataPoint"),
    17: .same(proto: "dataPointLine"),
    18: .same(proto: "dataPointMarker"),
    19: .same(proto: "categoryAxis"),
    20: .same(proto: "valueAxis"),
    21: .same(proto: "seriesAxis"),
    22: .same(proto: "dateAxis"),
    23: .same(proto: "dropLines"),
    24: .same(proto: "hiLowLine"),
    25: .same(proto: "leaderLine"),
    26: .same(proto: "defPrProps"),
  ]

  fileprivate class _StorageClass {
    var _axis: ChartStyle.StyleData? = nil
    var _axisTitle: ChartStyle.StyleData? = nil
    var _chartArea: ChartStyle.StyleData? = nil
    var _chartTitle: ChartStyle.StyleData? = nil
    var _dataLabels: ChartStyle.StyleData? = nil
    var _dataTable: ChartStyle.StyleData? = nil
    var _downBars: ChartStyle.StyleData? = nil
    var _floor: ChartStyle.StyleData? = nil
    var _legend: ChartStyle.StyleData? = nil
    var _majorGridlines: ChartStyle.StyleData? = nil
    var _minorGridlines: ChartStyle.StyleData? = nil
    var _otherLines: ChartStyle.StyleData? = nil
    var _plotArea: ChartStyle.StyleData? = nil
    var _upBars: ChartStyle.StyleData? = nil
    var _walls: ChartStyle.StyleData? = nil
    var _dataPoint: [ChartStyle.StyleData] = []
    var _dataPointLine: [ChartStyle.StyleData] = []
    var _dataPointMarker: [ChartStyle.StyleData] = []
    var _categoryAxis: [ChartStyle.StyleData] = []
    var _valueAxis: [ChartStyle.StyleData] = []
    var _seriesAxis: [ChartStyle.StyleData] = []
    var _dateAxis: [ChartStyle.StyleData] = []
    var _dropLines: [ChartStyle.StyleData] = []
    var _hiLowLine: [ChartStyle.StyleData] = []
    var _leaderLine: [ChartStyle.StyleData] = []
    var _defPrProps: PortionProps? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _axis = source._axis
      _axisTitle = source._axisTitle
      _chartArea = source._chartArea
      _chartTitle = source._chartTitle
      _dataLabels = source._dataLabels
      _dataTable = source._dataTable
      _downBars = source._downBars
      _floor = source._floor
      _legend = source._legend
      _majorGridlines = source._majorGridlines
      _minorGridlines = source._minorGridlines
      _otherLines = source._otherLines
      _plotArea = source._plotArea
      _upBars = source._upBars
      _walls = source._walls
      _dataPoint = source._dataPoint
      _dataPointLine = source._dataPointLine
      _dataPointMarker = source._dataPointMarker
      _categoryAxis = source._categoryAxis
      _valueAxis = source._valueAxis
      _seriesAxis = source._seriesAxis
      _dateAxis = source._dateAxis
      _dropLines = source._dropLines
      _hiLowLine = source._hiLowLine
      _leaderLine = source._leaderLine
      _defPrProps = source._defPrProps
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._axis, !v.isInitialized {return false}
      if let v = _storage._axisTitle, !v.isInitialized {return false}
      if let v = _storage._chartArea, !v.isInitialized {return false}
      if let v = _storage._chartTitle, !v.isInitialized {return false}
      if let v = _storage._dataLabels, !v.isInitialized {return false}
      if let v = _storage._dataTable, !v.isInitialized {return false}
      if let v = _storage._downBars, !v.isInitialized {return false}
      if let v = _storage._floor, !v.isInitialized {return false}
      if let v = _storage._legend, !v.isInitialized {return false}
      if let v = _storage._majorGridlines, !v.isInitialized {return false}
      if let v = _storage._minorGridlines, !v.isInitialized {return false}
      if let v = _storage._otherLines, !v.isInitialized {return false}
      if let v = _storage._plotArea, !v.isInitialized {return false}
      if let v = _storage._upBars, !v.isInitialized {return false}
      if let v = _storage._walls, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._dataPoint) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._dataPointLine) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._dataPointMarker) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._categoryAxis) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._valueAxis) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._seriesAxis) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._dateAxis) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._dropLines) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._hiLowLine) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._leaderLine) {return false}
      if let v = _storage._defPrProps, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._axis) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._axisTitle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chartArea) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._chartTitle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._dataLabels) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._dataTable) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._downBars) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._floor) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._legend) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._majorGridlines) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._minorGridlines) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._otherLines) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._plotArea) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._upBars) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._walls) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._dataPoint) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._dataPointLine) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._dataPointMarker) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._categoryAxis) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._valueAxis) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._seriesAxis) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._dateAxis) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._dropLines) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._hiLowLine) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._leaderLine) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._defPrProps) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._axis {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._axisTitle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chartArea {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._chartTitle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._dataLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._dataTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._downBars {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._floor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._legend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._majorGridlines {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._minorGridlines {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._otherLines {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._plotArea {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._upBars {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._walls {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._dataPoint.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataPoint, fieldNumber: 16)
      }
      if !_storage._dataPointLine.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataPointLine, fieldNumber: 17)
      }
      if !_storage._dataPointMarker.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataPointMarker, fieldNumber: 18)
      }
      if !_storage._categoryAxis.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._categoryAxis, fieldNumber: 19)
      }
      if !_storage._valueAxis.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._valueAxis, fieldNumber: 20)
      }
      if !_storage._seriesAxis.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._seriesAxis, fieldNumber: 21)
      }
      if !_storage._dateAxis.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dateAxis, fieldNumber: 22)
      }
      if !_storage._dropLines.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dropLines, fieldNumber: 23)
      }
      if !_storage._hiLowLine.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hiLowLine, fieldNumber: 24)
      }
      if !_storage._leaderLine.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leaderLine, fieldNumber: 25)
      }
      try { if let v = _storage._defPrProps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartStyle, rhs: ChartStyle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._axis != rhs_storage._axis {return false}
        if _storage._axisTitle != rhs_storage._axisTitle {return false}
        if _storage._chartArea != rhs_storage._chartArea {return false}
        if _storage._chartTitle != rhs_storage._chartTitle {return false}
        if _storage._dataLabels != rhs_storage._dataLabels {return false}
        if _storage._dataTable != rhs_storage._dataTable {return false}
        if _storage._downBars != rhs_storage._downBars {return false}
        if _storage._floor != rhs_storage._floor {return false}
        if _storage._legend != rhs_storage._legend {return false}
        if _storage._majorGridlines != rhs_storage._majorGridlines {return false}
        if _storage._minorGridlines != rhs_storage._minorGridlines {return false}
        if _storage._otherLines != rhs_storage._otherLines {return false}
        if _storage._plotArea != rhs_storage._plotArea {return false}
        if _storage._upBars != rhs_storage._upBars {return false}
        if _storage._walls != rhs_storage._walls {return false}
        if _storage._dataPoint != rhs_storage._dataPoint {return false}
        if _storage._dataPointLine != rhs_storage._dataPointLine {return false}
        if _storage._dataPointMarker != rhs_storage._dataPointMarker {return false}
        if _storage._categoryAxis != rhs_storage._categoryAxis {return false}
        if _storage._valueAxis != rhs_storage._valueAxis {return false}
        if _storage._seriesAxis != rhs_storage._seriesAxis {return false}
        if _storage._dateAxis != rhs_storage._dateAxis {return false}
        if _storage._dropLines != rhs_storage._dropLines {return false}
        if _storage._hiLowLine != rhs_storage._hiLowLine {return false}
        if _storage._leaderLine != rhs_storage._leaderLine {return false}
        if _storage._defPrProps != rhs_storage._defPrProps {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartStyle.StyleData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ChartStyle.protoMessageName + ".StyleData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "themeRef"),
    2: .same(proto: "fill"),
    3: .same(proto: "stroke"),
    4: .same(proto: "fillPattern"),
    5: .same(proto: "strokePatern"),
    6: .same(proto: "defPrProps"),
  ]

  fileprivate class _StorageClass {
    var _themeRef: ThemeReference? = nil
    var _fill: Fill? = nil
    var _stroke: Stroke? = nil
    var _fillPattern: ChartStyle.StyleData.PatternType? = nil
    var _strokePatern: ChartStyle.StyleData.PatternType? = nil
    var _defPrProps: PortionProps? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _themeRef = source._themeRef
      _fill = source._fill
      _stroke = source._stroke
      _fillPattern = source._fillPattern
      _strokePatern = source._strokePatern
      _defPrProps = source._defPrProps
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._themeRef, !v.isInitialized {return false}
      if let v = _storage._fill, !v.isInitialized {return false}
      if let v = _storage._stroke, !v.isInitialized {return false}
      if let v = _storage._defPrProps, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._themeRef) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._fillPattern) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._strokePatern) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._defPrProps) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._themeRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fillPattern {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._strokePatern {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._defPrProps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChartStyle.StyleData, rhs: ChartStyle.StyleData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._themeRef != rhs_storage._themeRef {return false}
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._fillPattern != rhs_storage._fillPattern {return false}
        if _storage._strokePatern != rhs_storage._strokePatern {return false}
        if _storage._defPrProps != rhs_storage._defPrProps {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChartStyle.StyleData.PatternType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "FADE"),
  ]
}
