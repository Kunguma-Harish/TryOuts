// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gradientfill.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct GradientFill {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type of the gradient fill.
  public var type: FillField.GradientFillType {
    get {return _storage._type ?? .linear}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// Angle of the gradient fill , ranges from 0-360.
  public var rotate: Int32 {
    get {return _storage._rotate ?? 0}
    set {_uniqueStorage()._rotate = newValue}
  }
  /// Returns true if `rotate` has been explicitly set.
  public var hasRotate: Bool {return _storage._rotate != nil}
  /// Clears the value of `rotate`. Subsequent reads from it will return its default value.
  public mutating func clearRotate() {_uniqueStorage()._rotate = nil}

  /// Stops for the gradient.
  public var stops: [GradientFill.Stop] {
    get {return _storage._stops}
    set {_uniqueStorage()._stops = newValue}
  }

  public var radial: GradientFill.GradientProperties {
    get {return _storage._radial ?? GradientFill.GradientProperties()}
    set {_uniqueStorage()._radial = newValue}
  }
  /// Returns true if `radial` has been explicitly set.
  public var hasRadial: Bool {return _storage._radial != nil}
  /// Clears the value of `radial`. Subsequent reads from it will return its default value.
  public mutating func clearRadial() {_uniqueStorage()._radial = nil}

  public var rect: GradientFill.GradientProperties {
    get {return _storage._rect ?? GradientFill.GradientProperties()}
    set {_uniqueStorage()._rect = newValue}
  }
  /// Returns true if `rect` has been explicitly set.
  public var hasRect: Bool {return _storage._rect != nil}
  /// Clears the value of `rect`. Subsequent reads from it will return its default value.
  public mutating func clearRect() {_uniqueStorage()._rect = nil}

  public var path: GradientFill.GradientProperties {
    get {return _storage._path ?? GradientFill.GradientProperties()}
    set {_uniqueStorage()._path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return _storage._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {_uniqueStorage()._path = nil}

  public var linear: GradientFill.LinearGradientProperties {
    get {return _storage._linear ?? GradientFill.LinearGradientProperties()}
    set {_uniqueStorage()._linear = newValue}
  }
  /// Returns true if `linear` has been explicitly set.
  public var hasLinear: Bool {return _storage._linear != nil}
  /// Clears the value of `linear`. Subsequent reads from it will return its default value.
  public mutating func clearLinear() {_uniqueStorage()._linear = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Stop {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// color
    public var color: Color {
      get {return _color ?? Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    public var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    public mutating func clearColor() {self._color = nil}

    /// stop offset, ranges from 0-1
    public var position: Float {
      get {return _position ?? 0}
      set {_position = newValue}
    }
    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool {return self._position != nil}
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() {self._position = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _color: Color? = nil
    fileprivate var _position: Float? = nil
  }

  /// This has been used for Radial , Rectangular for now. 
  public struct GradientProperties {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///fillToRect - This rectangle specifies the focus rectangle of the center shape.
    ///tileRect - the rectangular region in which the gradient has to be filled.
    /// Example 1 : Fill a shape with Radial gradient to spread fill from center
    /// fillToRect - L T R B = 0.5 0.5 0.5 0.5
    /// tileRect - L T R B = 0 0 0 0 
    /// Example 2 : Radial gradient to spread fill from Right Bottom.
    /// fillToRect - L T R B = 1 1 0 0 
    /// tileRect - L T R B = 0 0 -1 -1
    /// In both the above examples fillToRect is a single point in the shape.
    /// Example 3 : Rectangular gradient to spread from a basic rectangle and fill the shape.
    /// fillToRect - L T R B = 0.2 0.3 0.2 0.3
    /// tilRect - L T R B = 0 0 0 0
    public var fillToRect: Offset {
      get {return _fillToRect ?? Offset()}
      set {_fillToRect = newValue}
    }
    /// Returns true if `fillToRect` has been explicitly set.
    public var hasFillToRect: Bool {return self._fillToRect != nil}
    /// Clears the value of `fillToRect`. Subsequent reads from it will return its default value.
    public mutating func clearFillToRect() {self._fillToRect = nil}

    public var tileRect: Offset {
      get {return _tileRect ?? Offset()}
      set {_tileRect = newValue}
    }
    /// Returns true if `tileRect` has been explicitly set.
    public var hasTileRect: Bool {return self._tileRect != nil}
    /// Clears the value of `tileRect`. Subsequent reads from it will return its default value.
    public mutating func clearTileRect() {self._tileRect = nil}

    /// true , if flipped in horizontal axis.
    public var fliph: Bool {
      get {return _fliph ?? false}
      set {_fliph = newValue}
    }
    /// Returns true if `fliph` has been explicitly set.
    public var hasFliph: Bool {return self._fliph != nil}
    /// Clears the value of `fliph`. Subsequent reads from it will return its default value.
    public mutating func clearFliph() {self._fliph = nil}

    /// true , if flipped in vertical axis.
    public var flipv: Bool {
      get {return _flipv ?? false}
      set {_flipv = newValue}
    }
    /// Returns true if `flipv` has been explicitly set.
    public var hasFlipv: Bool {return self._flipv != nil}
    /// Clears the value of `flipv`. Subsequent reads from it will return its default value.
    public mutating func clearFlipv() {self._flipv = nil}

    public var cornerOffset: Offset {
      get {return _cornerOffset ?? Offset()}
      set {_cornerOffset = newValue}
    }
    /// Returns true if `cornerOffset` has been explicitly set.
    public var hasCornerOffset: Bool {return self._cornerOffset != nil}
    /// Clears the value of `cornerOffset`. Subsequent reads from it will return its default value.
    public mutating func clearCornerOffset() {self._cornerOffset = nil}

    public var rotate: Int32 {
      get {return _rotate ?? 0}
      set {_rotate = newValue}
    }
    /// Returns true if `rotate` has been explicitly set.
    public var hasRotate: Bool {return self._rotate != nil}
    /// Clears the value of `rotate`. Subsequent reads from it will return its default value.
    public mutating func clearRotate() {self._rotate = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _fillToRect: Offset? = nil
    fileprivate var _tileRect: Offset? = nil
    fileprivate var _fliph: Bool? = nil
    fileprivate var _flipv: Bool? = nil
    fileprivate var _cornerOffset: Offset? = nil
    fileprivate var _rotate: Int32? = nil
  }

  /// The rotate property at the top will be used for linear gradients passing through the center of the shape. For more advanced ones , we shall use this.
  public struct LinearGradientProperties {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var start: Offset {
      get {return _start ?? Offset()}
      set {_start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    public var hasStart: Bool {return self._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    public mutating func clearStart() {self._start = nil}

    public var end: Offset {
      get {return _end ?? Offset()}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    public var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    public mutating func clearEnd() {self._end = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _start: Offset? = nil
    fileprivate var _end: Offset? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension GradientFill: @unchecked Sendable {}
extension GradientFill.Stop: @unchecked Sendable {}
extension GradientFill.GradientProperties: @unchecked Sendable {}
extension GradientFill.LinearGradientProperties: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.shapes"

extension GradientFill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GradientFill"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "rotate"),
    3: .same(proto: "stops"),
    4: .same(proto: "radial"),
    5: .same(proto: "rect"),
    7: .same(proto: "path"),
    6: .same(proto: "linear"),
  ]

  fileprivate class _StorageClass {
    var _type: FillField.GradientFillType? = nil
    var _rotate: Int32? = nil
    var _stops: [GradientFill.Stop] = []
    var _radial: GradientFill.GradientProperties? = nil
    var _rect: GradientFill.GradientProperties? = nil
    var _path: GradientFill.GradientProperties? = nil
    var _linear: GradientFill.LinearGradientProperties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _rotate = source._rotate
      _stops = source._stops
      _radial = source._radial
      _rect = source._rect
      _path = source._path
      _linear = source._linear
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._stops) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._rotate) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._stops) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._radial) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._rect) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._linear) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._path) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._rotate {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      if !_storage._stops.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stops, fieldNumber: 3)
      }
      try { if let v = _storage._radial {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._rect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._linear {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._path {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GradientFill, rhs: GradientFill) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._rotate != rhs_storage._rotate {return false}
        if _storage._stops != rhs_storage._stops {return false}
        if _storage._radial != rhs_storage._radial {return false}
        if _storage._rect != rhs_storage._rect {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._linear != rhs_storage._linear {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GradientFill.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GradientFill.protoMessageName + ".Stop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "position"),
  ]

  public var isInitialized: Bool {
    if self._position == nil {return false}
    if let v = self._color, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GradientFill.Stop, rhs: GradientFill.Stop) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GradientFill.GradientProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GradientFill.protoMessageName + ".GradientProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fillToRect"),
    2: .same(proto: "tileRect"),
    3: .same(proto: "fliph"),
    4: .same(proto: "flipv"),
    5: .same(proto: "cornerOffset"),
    6: .same(proto: "rotate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fillToRect) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tileRect) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._fliph) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._flipv) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cornerOffset) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._rotate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fillToRect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tileRect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fliph {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._flipv {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cornerOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._rotate {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GradientFill.GradientProperties, rhs: GradientFill.GradientProperties) -> Bool {
    if lhs._fillToRect != rhs._fillToRect {return false}
    if lhs._tileRect != rhs._tileRect {return false}
    if lhs._fliph != rhs._fliph {return false}
    if lhs._flipv != rhs._flipv {return false}
    if lhs._cornerOffset != rhs._cornerOffset {return false}
    if lhs._rotate != rhs._rotate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GradientFill.LinearGradientProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = GradientFill.protoMessageName + ".LinearGradientProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GradientFill.LinearGradientProperties, rhs: GradientFill.LinearGradientProperties) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
