// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fields.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_fields_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_fields_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_fields_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_fields_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_fields_2eproto;
namespace Show {
class AnimationField;
struct AnimationFieldDefaultTypeInternal;
extern AnimationFieldDefaultTypeInternal _AnimationField_default_instance_;
class ChartField;
struct ChartFieldDefaultTypeInternal;
extern ChartFieldDefaultTypeInternal _ChartField_default_instance_;
class ChartField_BarChartField;
struct ChartField_BarChartFieldDefaultTypeInternal;
extern ChartField_BarChartFieldDefaultTypeInternal _ChartField_BarChartField_default_instance_;
class CommonField;
struct CommonFieldDefaultTypeInternal;
extern CommonFieldDefaultTypeInternal _CommonField_default_instance_;
class DataSourceField;
struct DataSourceFieldDefaultTypeInternal;
extern DataSourceFieldDefaultTypeInternal _DataSourceField_default_instance_;
class DatabaseField;
struct DatabaseFieldDefaultTypeInternal;
extern DatabaseFieldDefaultTypeInternal _DatabaseField_default_instance_;
class DocumentStatusField;
struct DocumentStatusFieldDefaultTypeInternal;
extern DocumentStatusFieldDefaultTypeInternal _DocumentStatusField_default_instance_;
class EffectsField;
struct EffectsFieldDefaultTypeInternal;
extern EffectsFieldDefaultTypeInternal _EffectsField_default_instance_;
class FileField;
struct FileFieldDefaultTypeInternal;
extern FileFieldDefaultTypeInternal _FileField_default_instance_;
class FillField;
struct FillFieldDefaultTypeInternal;
extern FillFieldDefaultTypeInternal _FillField_default_instance_;
class GeometryField;
struct GeometryFieldDefaultTypeInternal;
extern GeometryFieldDefaultTypeInternal _GeometryField_default_instance_;
class MemberField;
struct MemberFieldDefaultTypeInternal;
extern MemberFieldDefaultTypeInternal _MemberField_default_instance_;
class PortionField;
struct PortionFieldDefaultTypeInternal;
extern PortionFieldDefaultTypeInternal _PortionField_default_instance_;
class PresetSmartDiagram;
struct PresetSmartDiagramDefaultTypeInternal;
extern PresetSmartDiagramDefaultTypeInternal _PresetSmartDiagram_default_instance_;
class ShapeField;
struct ShapeFieldDefaultTypeInternal;
extern ShapeFieldDefaultTypeInternal _ShapeField_default_instance_;
class SlideField;
struct SlideFieldDefaultTypeInternal;
extern SlideFieldDefaultTypeInternal _SlideField_default_instance_;
class StrokeField;
struct StrokeFieldDefaultTypeInternal;
extern StrokeFieldDefaultTypeInternal _StrokeField_default_instance_;
class TableField;
struct TableFieldDefaultTypeInternal;
extern TableFieldDefaultTypeInternal _TableField_default_instance_;
}  // namespace Show
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace Show {
enum CommonField_UseParentProps : int {
  CommonField_UseParentProps_NONE = 0,
  CommonField_UseParentProps_TEXTBOX = 1,
  CommonField_UseParentProps_CommonField_UseParentProps_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommonField_UseParentProps_CommonField_UseParentProps_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommonField_UseParentProps_IsValid(int value);
extern const uint32_t CommonField_UseParentProps_internal_data_[];
constexpr CommonField_UseParentProps CommonField_UseParentProps_UseParentProps_MIN = static_cast<CommonField_UseParentProps>(0);
constexpr CommonField_UseParentProps CommonField_UseParentProps_UseParentProps_MAX = static_cast<CommonField_UseParentProps>(1);
constexpr int CommonField_UseParentProps_UseParentProps_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
CommonField_UseParentProps_descriptor();
template <typename T>
const std::string& CommonField_UseParentProps_Name(T value) {
  static_assert(std::is_same<T, CommonField_UseParentProps>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UseParentProps_Name().");
  return CommonField_UseParentProps_Name(static_cast<CommonField_UseParentProps>(value));
}
template <>
inline const std::string& CommonField_UseParentProps_Name(CommonField_UseParentProps value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommonField_UseParentProps_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool CommonField_UseParentProps_Parse(absl::string_view name, CommonField_UseParentProps* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonField_UseParentProps>(
      CommonField_UseParentProps_descriptor(), name, value);
}
enum CommonField_MeasuringUnit : int {
  CommonField_MeasuringUnit_PIXEL = 0,
  CommonField_MeasuringUnit_INCH = 1,
  CommonField_MeasuringUnit_CM = 2,
  CommonField_MeasuringUnit_CommonField_MeasuringUnit_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommonField_MeasuringUnit_CommonField_MeasuringUnit_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommonField_MeasuringUnit_IsValid(int value);
extern const uint32_t CommonField_MeasuringUnit_internal_data_[];
constexpr CommonField_MeasuringUnit CommonField_MeasuringUnit_MeasuringUnit_MIN = static_cast<CommonField_MeasuringUnit>(0);
constexpr CommonField_MeasuringUnit CommonField_MeasuringUnit_MeasuringUnit_MAX = static_cast<CommonField_MeasuringUnit>(2);
constexpr int CommonField_MeasuringUnit_MeasuringUnit_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CommonField_MeasuringUnit_descriptor();
template <typename T>
const std::string& CommonField_MeasuringUnit_Name(T value) {
  static_assert(std::is_same<T, CommonField_MeasuringUnit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MeasuringUnit_Name().");
  return CommonField_MeasuringUnit_Name(static_cast<CommonField_MeasuringUnit>(value));
}
template <>
inline const std::string& CommonField_MeasuringUnit_Name(CommonField_MeasuringUnit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommonField_MeasuringUnit_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CommonField_MeasuringUnit_Parse(absl::string_view name, CommonField_MeasuringUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonField_MeasuringUnit>(
      CommonField_MeasuringUnit_descriptor(), name, value);
}
enum CommonField_ValueVariant : int {
  CommonField_ValueVariant_UNKNOWN_VARIANT = 0,
  CommonField_ValueVariant_RELATIVE = 1,
  CommonField_ValueVariant_ABSOLUTE = 2,
  CommonField_ValueVariant_CommonField_ValueVariant_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommonField_ValueVariant_CommonField_ValueVariant_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommonField_ValueVariant_IsValid(int value);
extern const uint32_t CommonField_ValueVariant_internal_data_[];
constexpr CommonField_ValueVariant CommonField_ValueVariant_ValueVariant_MIN = static_cast<CommonField_ValueVariant>(0);
constexpr CommonField_ValueVariant CommonField_ValueVariant_ValueVariant_MAX = static_cast<CommonField_ValueVariant>(2);
constexpr int CommonField_ValueVariant_ValueVariant_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CommonField_ValueVariant_descriptor();
template <typename T>
const std::string& CommonField_ValueVariant_Name(T value) {
  static_assert(std::is_same<T, CommonField_ValueVariant>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ValueVariant_Name().");
  return CommonField_ValueVariant_Name(static_cast<CommonField_ValueVariant>(value));
}
template <>
inline const std::string& CommonField_ValueVariant_Name(CommonField_ValueVariant value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommonField_ValueVariant_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CommonField_ValueVariant_Parse(absl::string_view name, CommonField_ValueVariant* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonField_ValueVariant>(
      CommonField_ValueVariant_descriptor(), name, value);
}
enum CommonField_ValueType : int {
  CommonField_ValueType_UNKNOWN = 0,
  CommonField_ValueType_BOOLEAN = 1,
  CommonField_ValueType_STRING = 2,
  CommonField_ValueType_FLOAT = 3,
  CommonField_ValueType_DOUBLE = 4,
  CommonField_ValueType_INTEGER = 5,
  CommonField_ValueType_LONG = 6,
  CommonField_ValueType_PERSON = 7,
  CommonField_ValueType_DATETIME = 8,
  CommonField_ValueType_EMAIL = 9,
  CommonField_ValueType_CONTACT = 10,
  CommonField_ValueType_CUSTOM = 11,
  CommonField_ValueType_CommonField_ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommonField_ValueType_CommonField_ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommonField_ValueType_IsValid(int value);
extern const uint32_t CommonField_ValueType_internal_data_[];
constexpr CommonField_ValueType CommonField_ValueType_ValueType_MIN = static_cast<CommonField_ValueType>(0);
constexpr CommonField_ValueType CommonField_ValueType_ValueType_MAX = static_cast<CommonField_ValueType>(11);
constexpr int CommonField_ValueType_ValueType_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
CommonField_ValueType_descriptor();
template <typename T>
const std::string& CommonField_ValueType_Name(T value) {
  static_assert(std::is_same<T, CommonField_ValueType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ValueType_Name().");
  return CommonField_ValueType_Name(static_cast<CommonField_ValueType>(value));
}
template <>
inline const std::string& CommonField_ValueType_Name(CommonField_ValueType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommonField_ValueType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool CommonField_ValueType_Parse(absl::string_view name, CommonField_ValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonField_ValueType>(
      CommonField_ValueType_descriptor(), name, value);
}
enum CommonField_CompositeValueType : int {
  CommonField_CompositeValueType_DEFAULT_VALUE = 0,
  CommonField_CompositeValueType_BASIC = 1,
  CommonField_CompositeValueType_ARRAY = 2,
  CommonField_CompositeValueType_MATRIX = 3,
  CommonField_CompositeValueType_DATA_MAP = 4,
  CommonField_CompositeValueType_JSON_MAP = 5,
  CommonField_CompositeValueType_CommonField_CompositeValueType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommonField_CompositeValueType_CommonField_CompositeValueType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommonField_CompositeValueType_IsValid(int value);
extern const uint32_t CommonField_CompositeValueType_internal_data_[];
constexpr CommonField_CompositeValueType CommonField_CompositeValueType_CompositeValueType_MIN = static_cast<CommonField_CompositeValueType>(0);
constexpr CommonField_CompositeValueType CommonField_CompositeValueType_CompositeValueType_MAX = static_cast<CommonField_CompositeValueType>(5);
constexpr int CommonField_CompositeValueType_CompositeValueType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
CommonField_CompositeValueType_descriptor();
template <typename T>
const std::string& CommonField_CompositeValueType_Name(T value) {
  static_assert(std::is_same<T, CommonField_CompositeValueType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CompositeValueType_Name().");
  return CommonField_CompositeValueType_Name(static_cast<CommonField_CompositeValueType>(value));
}
template <>
inline const std::string& CommonField_CompositeValueType_Name(CommonField_CompositeValueType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommonField_CompositeValueType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool CommonField_CompositeValueType_Parse(absl::string_view name, CommonField_CompositeValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonField_CompositeValueType>(
      CommonField_CompositeValueType_descriptor(), name, value);
}
enum FileField_FileFormat : int {
  FileField_FileFormat_UNKNOWN_FILE_FORMAT = 0,
  FileField_FileFormat_DOCUMENT = 1,
  FileField_FileFormat_PRESENTATION = 2,
  FileField_FileFormat_SPREADSHEET = 3,
  FileField_FileFormat_LANGUAGE = 4,
  FileField_FileFormat_FileField_FileFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FileField_FileFormat_FileField_FileFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FileField_FileFormat_IsValid(int value);
extern const uint32_t FileField_FileFormat_internal_data_[];
constexpr FileField_FileFormat FileField_FileFormat_FileFormat_MIN = static_cast<FileField_FileFormat>(0);
constexpr FileField_FileFormat FileField_FileFormat_FileFormat_MAX = static_cast<FileField_FileFormat>(4);
constexpr int FileField_FileFormat_FileFormat_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
FileField_FileFormat_descriptor();
template <typename T>
const std::string& FileField_FileFormat_Name(T value) {
  static_assert(std::is_same<T, FileField_FileFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FileFormat_Name().");
  return FileField_FileFormat_Name(static_cast<FileField_FileFormat>(value));
}
template <>
inline const std::string& FileField_FileFormat_Name(FileField_FileFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FileField_FileFormat_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool FileField_FileFormat_Parse(absl::string_view name, FileField_FileFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileField_FileFormat>(
      FileField_FileFormat_descriptor(), name, value);
}
enum FileField_DocumentFileType : int {
  FileField_DocumentFileType_UNKNOWN_DOCUMENT_FILE_TYPE = 0,
  FileField_DocumentFileType_DOC = 1,
  FileField_DocumentFileType_DOCX = 2,
  FileField_DocumentFileType_TXT = 3,
  FileField_DocumentFileType_RTF = 4,
  FileField_DocumentFileType_DOCM = 5,
  FileField_DocumentFileType_DOT = 6,
  FileField_DocumentFileType_DOTM = 7,
  FileField_DocumentFileType_DOTX = 8,
  FileField_DocumentFileType_ODT = 9,
  FileField_DocumentFileType_PDF = 10,
  FileField_DocumentFileType_FileField_DocumentFileType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FileField_DocumentFileType_FileField_DocumentFileType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FileField_DocumentFileType_IsValid(int value);
extern const uint32_t FileField_DocumentFileType_internal_data_[];
constexpr FileField_DocumentFileType FileField_DocumentFileType_DocumentFileType_MIN = static_cast<FileField_DocumentFileType>(0);
constexpr FileField_DocumentFileType FileField_DocumentFileType_DocumentFileType_MAX = static_cast<FileField_DocumentFileType>(10);
constexpr int FileField_DocumentFileType_DocumentFileType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
FileField_DocumentFileType_descriptor();
template <typename T>
const std::string& FileField_DocumentFileType_Name(T value) {
  static_assert(std::is_same<T, FileField_DocumentFileType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DocumentFileType_Name().");
  return FileField_DocumentFileType_Name(static_cast<FileField_DocumentFileType>(value));
}
template <>
inline const std::string& FileField_DocumentFileType_Name(FileField_DocumentFileType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FileField_DocumentFileType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool FileField_DocumentFileType_Parse(absl::string_view name, FileField_DocumentFileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileField_DocumentFileType>(
      FileField_DocumentFileType_descriptor(), name, value);
}
enum FileField_PresentationFileType : int {
  FileField_PresentationFileType_UNKNOWN_PRESENTATION_FILE_TYPE = 0,
  FileField_PresentationFileType_PPT = 1,
  FileField_PresentationFileType_PPTX = 2,
  FileField_PresentationFileType_PPS = 3,
  FileField_PresentationFileType_PPSX = 4,
  FileField_PresentationFileType_ODP = 5,
  FileField_PresentationFileType_SXI = 6,
  FileField_PresentationFileType_KEY = 7,
  FileField_PresentationFileType_FileField_PresentationFileType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FileField_PresentationFileType_FileField_PresentationFileType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FileField_PresentationFileType_IsValid(int value);
extern const uint32_t FileField_PresentationFileType_internal_data_[];
constexpr FileField_PresentationFileType FileField_PresentationFileType_PresentationFileType_MIN = static_cast<FileField_PresentationFileType>(0);
constexpr FileField_PresentationFileType FileField_PresentationFileType_PresentationFileType_MAX = static_cast<FileField_PresentationFileType>(7);
constexpr int FileField_PresentationFileType_PresentationFileType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
FileField_PresentationFileType_descriptor();
template <typename T>
const std::string& FileField_PresentationFileType_Name(T value) {
  static_assert(std::is_same<T, FileField_PresentationFileType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresentationFileType_Name().");
  return FileField_PresentationFileType_Name(static_cast<FileField_PresentationFileType>(value));
}
template <>
inline const std::string& FileField_PresentationFileType_Name(FileField_PresentationFileType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FileField_PresentationFileType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool FileField_PresentationFileType_Parse(absl::string_view name, FileField_PresentationFileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileField_PresentationFileType>(
      FileField_PresentationFileType_descriptor(), name, value);
}
enum FileField_SpreadsheetFileType : int {
  FileField_SpreadsheetFileType_UNKNOWN_SPREADSHEET_FILE_TYPE = 0,
  FileField_SpreadsheetFileType_XLS = 1,
  FileField_SpreadsheetFileType_XLSX = 2,
  FileField_SpreadsheetFileType_XLSM = 3,
  FileField_SpreadsheetFileType_TSV = 4,
  FileField_SpreadsheetFileType_CSV = 5,
  FileField_SpreadsheetFileType_ODS = 6,
  FileField_SpreadsheetFileType_SXC = 7,
  FileField_SpreadsheetFileType_NUMBERS = 8,
  FileField_SpreadsheetFileType_FileField_SpreadsheetFileType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FileField_SpreadsheetFileType_FileField_SpreadsheetFileType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FileField_SpreadsheetFileType_IsValid(int value);
extern const uint32_t FileField_SpreadsheetFileType_internal_data_[];
constexpr FileField_SpreadsheetFileType FileField_SpreadsheetFileType_SpreadsheetFileType_MIN = static_cast<FileField_SpreadsheetFileType>(0);
constexpr FileField_SpreadsheetFileType FileField_SpreadsheetFileType_SpreadsheetFileType_MAX = static_cast<FileField_SpreadsheetFileType>(8);
constexpr int FileField_SpreadsheetFileType_SpreadsheetFileType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
FileField_SpreadsheetFileType_descriptor();
template <typename T>
const std::string& FileField_SpreadsheetFileType_Name(T value) {
  static_assert(std::is_same<T, FileField_SpreadsheetFileType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SpreadsheetFileType_Name().");
  return FileField_SpreadsheetFileType_Name(static_cast<FileField_SpreadsheetFileType>(value));
}
template <>
inline const std::string& FileField_SpreadsheetFileType_Name(FileField_SpreadsheetFileType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FileField_SpreadsheetFileType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool FileField_SpreadsheetFileType_Parse(absl::string_view name, FileField_SpreadsheetFileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileField_SpreadsheetFileType>(
      FileField_SpreadsheetFileType_descriptor(), name, value);
}
enum FileField_LanguageFileType : int {
  FileField_LanguageFileType_UNKNOWN_DEVELOPER_FILE_TYPE = 0,
  FileField_LanguageFileType_HTML = 1,
  FileField_LanguageFileType_CSS = 2,
  FileField_LanguageFileType_JS = 3,
  FileField_LanguageFileType_JAVA = 4,
  FileField_LanguageFileType_CMD = 5,
  FileField_LanguageFileType_LESS = 6,
  FileField_LanguageFileType_JSP = 7,
  FileField_LanguageFileType_JSON = 8,
  FileField_LanguageFileType_PY = 9,
  FileField_LanguageFileType_PROTO = 10,
  FileField_LanguageFileType_XML = 11,
  FileField_LanguageFileType_SQL = 12,
  FileField_LanguageFileType_BAT = 13,
  FileField_LanguageFileType_SWIFT = 14,
  FileField_LanguageFileType_CPP = 15,
  FileField_LanguageFileType_PROPERTIES = 16,
  FileField_LanguageFileType_GO = 17,
  FileField_LanguageFileType_ATOM = 18,
  FileField_LanguageFileType_BASH = 19,
  FileField_LanguageFileType_HPP = 20,
  FileField_LanguageFileType_LOG = 21,
  FileField_LanguageFileType_SH = 22,
  FileField_LanguageFileType_COFFEE = 23,
  FileField_LanguageFileType_DART = 24,
  FileField_LanguageFileType_MD = 25,
  FileField_LanguageFileType_DS = 26,
  FileField_LanguageFileType_MK = 27,
  FileField_LanguageFileType_PALI = 28,
  FileField_LanguageFileType_PL = 29,
  FileField_LanguageFileType_PHP = 30,
  FileField_LanguageFileType_INI = 31,
  FileField_LanguageFileType_RB = 32,
  FileField_LanguageFileType_RS = 33,
  FileField_LanguageFileType_YAML = 34,
  FileField_LanguageFileType_YML = 35,
  FileField_LanguageFileType_TEX = 36,
  FileField_LanguageFileType_ADOC = 37,
  FileField_LanguageFileType_BF = 38,
  FileField_LanguageFileType_CLJ = 39,
  FileField_LanguageFileType_CR = 40,
  FileField_LanguageFileType_CONF = 41,
  FileField_LanguageFileType_CS = 42,
  FileField_LanguageFileType_C = 43,
  FileField_LanguageFileType_ERL = 44,
  FileField_LanguageFileType_GOLO = 45,
  FileField_LanguageFileType_GROOVY = 46,
  FileField_LanguageFileType_GSH = 47,
  FileField_LanguageFileType_HTM = 48,
  FileField_LanguageFileType_HS = 49,
  FileField_LanguageFileType_HX = 50,
  FileField_LanguageFileType_IRB = 51,
  FileField_LanguageFileType_LUA = 52,
  FileField_LanguageFileType_MAK = 53,
  FileField_LanguageFileType_ML = 54,
  FileField_LanguageFileType_SCALA = 55,
  FileField_LanguageFileType_SCM = 56,
  FileField_LanguageFileType_TS = 57,
  FileField_LanguageFileType_VB = 58,
  FileField_LanguageFileType_VIM = 59,
  FileField_LanguageFileType_XHTML = 60,
  FileField_LanguageFileType_XSL = 61,
  FileField_LanguageFileType_ST = 62,
  FileField_LanguageFileType_PERL = 63,
  FileField_LanguageFileType_SS = 64,
  FileField_LanguageFileType_F95 = 65,
  FileField_LanguageFileType_FileField_LanguageFileType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FileField_LanguageFileType_FileField_LanguageFileType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FileField_LanguageFileType_IsValid(int value);
extern const uint32_t FileField_LanguageFileType_internal_data_[];
constexpr FileField_LanguageFileType FileField_LanguageFileType_LanguageFileType_MIN = static_cast<FileField_LanguageFileType>(0);
constexpr FileField_LanguageFileType FileField_LanguageFileType_LanguageFileType_MAX = static_cast<FileField_LanguageFileType>(65);
constexpr int FileField_LanguageFileType_LanguageFileType_ARRAYSIZE = 65 + 1;
const ::google::protobuf::EnumDescriptor*
FileField_LanguageFileType_descriptor();
template <typename T>
const std::string& FileField_LanguageFileType_Name(T value) {
  static_assert(std::is_same<T, FileField_LanguageFileType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LanguageFileType_Name().");
  return FileField_LanguageFileType_Name(static_cast<FileField_LanguageFileType>(value));
}
template <>
inline const std::string& FileField_LanguageFileType_Name(FileField_LanguageFileType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FileField_LanguageFileType_descriptor,
                                                 0, 65>(
      static_cast<int>(value));
}
inline bool FileField_LanguageFileType_Parse(absl::string_view name, FileField_LanguageFileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileField_LanguageFileType>(
      FileField_LanguageFileType_descriptor(), name, value);
}
enum StrokeField_CapType : int {
  StrokeField_CapType_DEF_CAP_TYPE = 0,
  StrokeField_CapType_FLAT = 1,
  StrokeField_CapType_CAPROUND = 2,
  StrokeField_CapType_SQUARE = 3,
  StrokeField_CapType_StrokeField_CapType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StrokeField_CapType_StrokeField_CapType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StrokeField_CapType_IsValid(int value);
extern const uint32_t StrokeField_CapType_internal_data_[];
constexpr StrokeField_CapType StrokeField_CapType_CapType_MIN = static_cast<StrokeField_CapType>(0);
constexpr StrokeField_CapType StrokeField_CapType_CapType_MAX = static_cast<StrokeField_CapType>(3);
constexpr int StrokeField_CapType_CapType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
StrokeField_CapType_descriptor();
template <typename T>
const std::string& StrokeField_CapType_Name(T value) {
  static_assert(std::is_same<T, StrokeField_CapType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CapType_Name().");
  return StrokeField_CapType_Name(static_cast<StrokeField_CapType>(value));
}
template <>
inline const std::string& StrokeField_CapType_Name(StrokeField_CapType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StrokeField_CapType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool StrokeField_CapType_Parse(absl::string_view name, StrokeField_CapType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokeField_CapType>(
      StrokeField_CapType_descriptor(), name, value);
}
enum StrokeField_StrokeType : int {
  StrokeField_StrokeType_SOLID = 0,
  StrokeField_StrokeType_DASH = 1,
  StrokeField_StrokeType_ROUND_DOT = 2,
  StrokeField_StrokeType_SQUARE_DOT = 3,
  StrokeField_StrokeType_LONG_DASH = 4,
  StrokeField_StrokeType_DASHDOT = 5,
  StrokeField_StrokeType_LONG_DASH_DOT = 6,
  StrokeField_StrokeType_LONG_DASH_DOT_DOT = 7,
  StrokeField_StrokeType_DASH_PATTERN = 8,
  StrokeField_StrokeType_StrokeField_StrokeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StrokeField_StrokeType_StrokeField_StrokeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StrokeField_StrokeType_IsValid(int value);
extern const uint32_t StrokeField_StrokeType_internal_data_[];
constexpr StrokeField_StrokeType StrokeField_StrokeType_StrokeType_MIN = static_cast<StrokeField_StrokeType>(0);
constexpr StrokeField_StrokeType StrokeField_StrokeType_StrokeType_MAX = static_cast<StrokeField_StrokeType>(8);
constexpr int StrokeField_StrokeType_StrokeType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
StrokeField_StrokeType_descriptor();
template <typename T>
const std::string& StrokeField_StrokeType_Name(T value) {
  static_assert(std::is_same<T, StrokeField_StrokeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StrokeType_Name().");
  return StrokeField_StrokeType_Name(static_cast<StrokeField_StrokeType>(value));
}
template <>
inline const std::string& StrokeField_StrokeType_Name(StrokeField_StrokeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StrokeField_StrokeType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool StrokeField_StrokeType_Parse(absl::string_view name, StrokeField_StrokeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokeField_StrokeType>(
      StrokeField_StrokeType_descriptor(), name, value);
}
enum StrokeField_JoinType : int {
  StrokeField_JoinType_DEF_JOIN_TYPE = 0,
  StrokeField_JoinType_ROUND = 1,
  StrokeField_JoinType_BEVEL = 2,
  StrokeField_JoinType_MITER = 3,
  StrokeField_JoinType_StrokeField_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StrokeField_JoinType_StrokeField_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StrokeField_JoinType_IsValid(int value);
extern const uint32_t StrokeField_JoinType_internal_data_[];
constexpr StrokeField_JoinType StrokeField_JoinType_JoinType_MIN = static_cast<StrokeField_JoinType>(0);
constexpr StrokeField_JoinType StrokeField_JoinType_JoinType_MAX = static_cast<StrokeField_JoinType>(3);
constexpr int StrokeField_JoinType_JoinType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
StrokeField_JoinType_descriptor();
template <typename T>
const std::string& StrokeField_JoinType_Name(T value) {
  static_assert(std::is_same<T, StrokeField_JoinType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JoinType_Name().");
  return StrokeField_JoinType_Name(static_cast<StrokeField_JoinType>(value));
}
template <>
inline const std::string& StrokeField_JoinType_Name(StrokeField_JoinType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StrokeField_JoinType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool StrokeField_JoinType_Parse(absl::string_view name, StrokeField_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokeField_JoinType>(
      StrokeField_JoinType_descriptor(), name, value);
}
enum StrokeField_MarkerType : int {
  StrokeField_MarkerType_DEF_MARKER_TYPE = 0,
  StrokeField_MarkerType_NONE = 1,
  StrokeField_MarkerType_OPEN = 2,
  StrokeField_MarkerType_BLOCK = 3,
  StrokeField_MarkerType_CLASSIC = 4,
  StrokeField_MarkerType_DIAMOND = 5,
  StrokeField_MarkerType_OVAL = 6,
  StrokeField_MarkerType_HOLLOW_DIAMOND = 7,
  StrokeField_MarkerType_HOLLOW_ARROW_HEAD = 8,
  StrokeField_MarkerType_HOLLOW_CIRCLE = 9,
  StrokeField_MarkerType_AGGREGATION = 10,
  StrokeField_MarkerType_COMPOSITION = 11,
  StrokeField_MarkerType_TERMINATE = 12,
  StrokeField_MarkerType_ZERO_OR_ONE = 13,
  StrokeField_MarkerType_ONE = 14,
  StrokeField_MarkerType_ONE_OPTIONAL = 15,
  StrokeField_MarkerType_MANY = 16,
  StrokeField_MarkerType_ZERO_OR_MANY = 17,
  StrokeField_MarkerType_ONE_MANDATORY = 18,
  StrokeField_MarkerType_ONE_OR_MANY = 19,
  StrokeField_MarkerType_PORT_SYMBOL = 20,
  StrokeField_MarkerType_DIAMOND_START = 21,
  StrokeField_MarkerType_OVAL_START = 22,
  StrokeField_MarkerType_HOLLOW_DIAMOND_START = 23,
  StrokeField_MarkerType_HOLLOW_CIRCLE_START = 24,
  StrokeField_MarkerType_StrokeField_MarkerType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StrokeField_MarkerType_StrokeField_MarkerType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StrokeField_MarkerType_IsValid(int value);
extern const uint32_t StrokeField_MarkerType_internal_data_[];
constexpr StrokeField_MarkerType StrokeField_MarkerType_MarkerType_MIN = static_cast<StrokeField_MarkerType>(0);
constexpr StrokeField_MarkerType StrokeField_MarkerType_MarkerType_MAX = static_cast<StrokeField_MarkerType>(24);
constexpr int StrokeField_MarkerType_MarkerType_ARRAYSIZE = 24 + 1;
const ::google::protobuf::EnumDescriptor*
StrokeField_MarkerType_descriptor();
template <typename T>
const std::string& StrokeField_MarkerType_Name(T value) {
  static_assert(std::is_same<T, StrokeField_MarkerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MarkerType_Name().");
  return StrokeField_MarkerType_Name(static_cast<StrokeField_MarkerType>(value));
}
template <>
inline const std::string& StrokeField_MarkerType_Name(StrokeField_MarkerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StrokeField_MarkerType_descriptor,
                                                 0, 24>(
      static_cast<int>(value));
}
inline bool StrokeField_MarkerType_Parse(absl::string_view name, StrokeField_MarkerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokeField_MarkerType>(
      StrokeField_MarkerType_descriptor(), name, value);
}
enum StrokeField_Size : int {
  StrokeField_Size_DEF_MARKER_SIZE = 0,
  StrokeField_Size_NARROW = 1,
  StrokeField_Size_MEDIUM = 2,
  StrokeField_Size_WIDE = 3,
  StrokeField_Size_EXTRA_WIDE = 4,
  StrokeField_Size_StrokeField_Size_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StrokeField_Size_StrokeField_Size_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StrokeField_Size_IsValid(int value);
extern const uint32_t StrokeField_Size_internal_data_[];
constexpr StrokeField_Size StrokeField_Size_Size_MIN = static_cast<StrokeField_Size>(0);
constexpr StrokeField_Size StrokeField_Size_Size_MAX = static_cast<StrokeField_Size>(4);
constexpr int StrokeField_Size_Size_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
StrokeField_Size_descriptor();
template <typename T>
const std::string& StrokeField_Size_Name(T value) {
  static_assert(std::is_same<T, StrokeField_Size>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Size_Name().");
  return StrokeField_Size_Name(static_cast<StrokeField_Size>(value));
}
template <>
inline const std::string& StrokeField_Size_Name(StrokeField_Size value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StrokeField_Size_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool StrokeField_Size_Parse(absl::string_view name, StrokeField_Size* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokeField_Size>(
      StrokeField_Size_descriptor(), name, value);
}
enum StrokeField_StrokePosition : int {
  StrokeField_StrokePosition_UNKNOWN_POSITION = 0,
  StrokeField_StrokePosition_CENTER = 1,
  StrokeField_StrokePosition_INSIDE = 2,
  StrokeField_StrokePosition_OUTSIDE = 3,
  StrokeField_StrokePosition_StrokeField_StrokePosition_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StrokeField_StrokePosition_StrokeField_StrokePosition_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StrokeField_StrokePosition_IsValid(int value);
extern const uint32_t StrokeField_StrokePosition_internal_data_[];
constexpr StrokeField_StrokePosition StrokeField_StrokePosition_StrokePosition_MIN = static_cast<StrokeField_StrokePosition>(0);
constexpr StrokeField_StrokePosition StrokeField_StrokePosition_StrokePosition_MAX = static_cast<StrokeField_StrokePosition>(3);
constexpr int StrokeField_StrokePosition_StrokePosition_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
StrokeField_StrokePosition_descriptor();
template <typename T>
const std::string& StrokeField_StrokePosition_Name(T value) {
  static_assert(std::is_same<T, StrokeField_StrokePosition>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StrokePosition_Name().");
  return StrokeField_StrokePosition_Name(static_cast<StrokeField_StrokePosition>(value));
}
template <>
inline const std::string& StrokeField_StrokePosition_Name(StrokeField_StrokePosition value) {
  return ::google::protobuf::internal::NameOfDenseEnum<StrokeField_StrokePosition_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool StrokeField_StrokePosition_Parse(absl::string_view name, StrokeField_StrokePosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrokeField_StrokePosition>(
      StrokeField_StrokePosition_descriptor(), name, value);
}
enum GeometryField_ShapeGeometryType : int {
  GeometryField_ShapeGeometryType_PRESET = 0,
  GeometryField_ShapeGeometryType_CUSTOM = 1,
  GeometryField_ShapeGeometryType_PRESET_SMART = 2,
  GeometryField_ShapeGeometryType_GeometryField_ShapeGeometryType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GeometryField_ShapeGeometryType_GeometryField_ShapeGeometryType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GeometryField_ShapeGeometryType_IsValid(int value);
extern const uint32_t GeometryField_ShapeGeometryType_internal_data_[];
constexpr GeometryField_ShapeGeometryType GeometryField_ShapeGeometryType_ShapeGeometryType_MIN = static_cast<GeometryField_ShapeGeometryType>(0);
constexpr GeometryField_ShapeGeometryType GeometryField_ShapeGeometryType_ShapeGeometryType_MAX = static_cast<GeometryField_ShapeGeometryType>(2);
constexpr int GeometryField_ShapeGeometryType_ShapeGeometryType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
GeometryField_ShapeGeometryType_descriptor();
template <typename T>
const std::string& GeometryField_ShapeGeometryType_Name(T value) {
  static_assert(std::is_same<T, GeometryField_ShapeGeometryType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShapeGeometryType_Name().");
  return GeometryField_ShapeGeometryType_Name(static_cast<GeometryField_ShapeGeometryType>(value));
}
template <>
inline const std::string& GeometryField_ShapeGeometryType_Name(GeometryField_ShapeGeometryType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeometryField_ShapeGeometryType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool GeometryField_ShapeGeometryType_Parse(absl::string_view name, GeometryField_ShapeGeometryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeometryField_ShapeGeometryType>(
      GeometryField_ShapeGeometryType_descriptor(), name, value);
}
enum GeometryField_PresetShapeGeometry : int {
  GeometryField_PresetShapeGeometry_DEF_PRESET_SHAPE = 0,
  GeometryField_PresetShapeGeometry_RECT = 1,
  GeometryField_PresetShapeGeometry_ROUND_RECT = 2,
  GeometryField_PresetShapeGeometry_SNIP_SINGLE_RECT = 3,
  GeometryField_PresetShapeGeometry_SNIP_SAMESIDE_RECT = 4,
  GeometryField_PresetShapeGeometry_SNIP_DIAGONAL_RECT = 5,
  GeometryField_PresetShapeGeometry_SNIP_ROUND_SINGLE_RECT = 6,
  GeometryField_PresetShapeGeometry_ROUND_SINGLE_RECT = 7,
  GeometryField_PresetShapeGeometry_ROUND_SAMESIDE_RECT = 8,
  GeometryField_PresetShapeGeometry_ROUND_DIAGONAL_RECT = 9,
  GeometryField_PresetShapeGeometry_OVAL = 10,
  GeometryField_PresetShapeGeometry_ISOSCELES_TRIANGLE = 11,
  GeometryField_PresetShapeGeometry_RIGHT_TRIANGLE = 12,
  GeometryField_PresetShapeGeometry_PARALLELOGRAM = 13,
  GeometryField_PresetShapeGeometry_TRAPEZOID = 14,
  GeometryField_PresetShapeGeometry_DIAMOND = 15,
  GeometryField_PresetShapeGeometry_PENTAGON = 16,
  GeometryField_PresetShapeGeometry_HEXAGON = 17,
  GeometryField_PresetShapeGeometry_HEPTAGON = 18,
  GeometryField_PresetShapeGeometry_OCTAGON = 19,
  GeometryField_PresetShapeGeometry_DECAGON = 20,
  GeometryField_PresetShapeGeometry_DODECAGON = 21,
  GeometryField_PresetShapeGeometry_PIE = 22,
  GeometryField_PresetShapeGeometry_CHORD = 23,
  GeometryField_PresetShapeGeometry_TEARDROP = 24,
  GeometryField_PresetShapeGeometry_FRAME = 25,
  GeometryField_PresetShapeGeometry_HALF_FRAME = 26,
  GeometryField_PresetShapeGeometry_LSHAPE = 27,
  GeometryField_PresetShapeGeometry_DIAGONAL_STRIPE = 28,
  GeometryField_PresetShapeGeometry_CROSS = 29,
  GeometryField_PresetShapeGeometry_PLAQUE = 30,
  GeometryField_PresetShapeGeometry_CAN = 31,
  GeometryField_PresetShapeGeometry_CUBE = 32,
  GeometryField_PresetShapeGeometry_BEVEL = 33,
  GeometryField_PresetShapeGeometry_DONUT = 34,
  GeometryField_PresetShapeGeometry_NO_SYMBOL = 35,
  GeometryField_PresetShapeGeometry_BLOCK_ARC = 36,
  GeometryField_PresetShapeGeometry_FOLDED_CORNER = 37,
  GeometryField_PresetShapeGeometry_SMILEY = 38,
  GeometryField_PresetShapeGeometry_HEART = 39,
  GeometryField_PresetShapeGeometry_LIGHTNING_BOLT = 40,
  GeometryField_PresetShapeGeometry_SUN = 41,
  GeometryField_PresetShapeGeometry_MOON = 42,
  GeometryField_PresetShapeGeometry_CLOUD = 43,
  GeometryField_PresetShapeGeometry_ARC = 44,
  GeometryField_PresetShapeGeometry_DOUBLE_BRACKET = 45,
  GeometryField_PresetShapeGeometry_DOUBLE_BRACE = 46,
  GeometryField_PresetShapeGeometry_LEFT_BRACKET = 47,
  GeometryField_PresetShapeGeometry_RIGHT_BRACKET = 48,
  GeometryField_PresetShapeGeometry_LEFT_BRACE = 49,
  GeometryField_PresetShapeGeometry_RIGHT_BRACE = 50,
  GeometryField_PresetShapeGeometry_CLOCK = 51,
  GeometryField_PresetShapeGeometry_RIGHT_ARROW = 52,
  GeometryField_PresetShapeGeometry_LEFT_ARROW = 53,
  GeometryField_PresetShapeGeometry_UP_ARROW = 54,
  GeometryField_PresetShapeGeometry_DOWN_ARROW = 55,
  GeometryField_PresetShapeGeometry_LEFT_RIGHT_ARROW = 56,
  GeometryField_PresetShapeGeometry_UP_DOWN_ARROW = 57,
  GeometryField_PresetShapeGeometry_QUAD_ARROW = 58,
  GeometryField_PresetShapeGeometry_LEFT_RIGHT_UP_ARROW = 59,
  GeometryField_PresetShapeGeometry_BENT_ARROW = 60,
  GeometryField_PresetShapeGeometry_U_TURN_ARROW = 61,
  GeometryField_PresetShapeGeometry_LEFT_UP_ARROW = 62,
  GeometryField_PresetShapeGeometry_BENT_UP_ARROW = 63,
  GeometryField_PresetShapeGeometry_CURVED_RIGHT_ARROW = 64,
  GeometryField_PresetShapeGeometry_CURVED_LEFT_ARROW = 65,
  GeometryField_PresetShapeGeometry_CURVED_UP_ARROW = 66,
  GeometryField_PresetShapeGeometry_CURVED_DOWN_ARROW = 67,
  GeometryField_PresetShapeGeometry_STRIPED_RIGHT_ARROW = 68,
  GeometryField_PresetShapeGeometry_NOTCHED_RIGHT_ARROW = 69,
  GeometryField_PresetShapeGeometry_PENTAGON_ARROW = 70,
  GeometryField_PresetShapeGeometry_CHEVRON = 71,
  GeometryField_PresetShapeGeometry_RIGHT_ARROW_CALLOUT = 72,
  GeometryField_PresetShapeGeometry_DOWN_ARROW_CALLOUT = 73,
  GeometryField_PresetShapeGeometry_LEFT_ARROW_CALLOUT = 74,
  GeometryField_PresetShapeGeometry_UP_ARROW_CALLOUT = 75,
  GeometryField_PresetShapeGeometry_LEFT_RIGHT_ARROW_CALLOUT = 76,
  GeometryField_PresetShapeGeometry_QUAD_ARROW_CALLOUT = 77,
  GeometryField_PresetShapeGeometry_CIRCULAR_ARROW = 78,
  GeometryField_PresetShapeGeometry_PLUS = 79,
  GeometryField_PresetShapeGeometry_MINUS = 80,
  GeometryField_PresetShapeGeometry_MULTIPLY = 81,
  GeometryField_PresetShapeGeometry_DIVIDE = 82,
  GeometryField_PresetShapeGeometry_EQUAL = 83,
  GeometryField_PresetShapeGeometry_NOT_EQUAL = 84,
  GeometryField_PresetShapeGeometry_PROCESS = 85,
  GeometryField_PresetShapeGeometry_ALTERNATE_PROCESS = 86,
  GeometryField_PresetShapeGeometry_DECISION = 87,
  GeometryField_PresetShapeGeometry_DATA = 88,
  GeometryField_PresetShapeGeometry_PREDEFINED_PROCESS = 89,
  GeometryField_PresetShapeGeometry_INTERNAL_STORAGE = 90,
  GeometryField_PresetShapeGeometry_FLOWCHART_DOCUMENT = 91,
  GeometryField_PresetShapeGeometry_MULTI_DOCUMENT = 92,
  GeometryField_PresetShapeGeometry_TERMINATOR = 93,
  GeometryField_PresetShapeGeometry_PREPARATION = 94,
  GeometryField_PresetShapeGeometry_MANUAL_INPUT = 95,
  GeometryField_PresetShapeGeometry_MANUAL_OPERATION = 96,
  GeometryField_PresetShapeGeometry_FLOWCHART_CONNECTOR = 97,
  GeometryField_PresetShapeGeometry_OFFPAGE_CONNECTOR = 98,
  GeometryField_PresetShapeGeometry_PUNCHED_CARD = 99,
  GeometryField_PresetShapeGeometry_PUNCHED_TAPE = 100,
  GeometryField_PresetShapeGeometry_SUMMING_JUNCTION = 101,
  GeometryField_PresetShapeGeometry_OR = 102,
  GeometryField_PresetShapeGeometry_COLLATE = 103,
  GeometryField_PresetShapeGeometry_SORT = 104,
  GeometryField_PresetShapeGeometry_EXTRACT = 105,
  GeometryField_PresetShapeGeometry_MERGE = 106,
  GeometryField_PresetShapeGeometry_STORED_DATA = 107,
  GeometryField_PresetShapeGeometry_DELAY = 108,
  GeometryField_PresetShapeGeometry_SEQUENTIAL_ACCESS_STORAGE = 109,
  GeometryField_PresetShapeGeometry_MAGNETIC_DISK = 110,
  GeometryField_PresetShapeGeometry_DIRECT_ACCESS_STORAGE = 111,
  GeometryField_PresetShapeGeometry_DISPLAY = 112,
  GeometryField_PresetShapeGeometry_EXPLOSION1 = 113,
  GeometryField_PresetShapeGeometry_EXPLOSION2 = 114,
  GeometryField_PresetShapeGeometry_FOUR_POINT_STAR = 115,
  GeometryField_PresetShapeGeometry_FIVE_POINT_STAR = 116,
  GeometryField_PresetShapeGeometry_SIX_POINT_STAR = 117,
  GeometryField_PresetShapeGeometry_SEVEN_POINT_STAR = 118,
  GeometryField_PresetShapeGeometry_EIGHT_POINT_STAR = 119,
  GeometryField_PresetShapeGeometry_TEN_POINT_STAR = 120,
  GeometryField_PresetShapeGeometry_TWELVE_POINT_STAR = 121,
  GeometryField_PresetShapeGeometry_SIXTEEN_POINT_STAR = 122,
  GeometryField_PresetShapeGeometry_TWENTY_FOUR_POINT_STAR = 123,
  GeometryField_PresetShapeGeometry_THIRTY_TWO_POINT_STAR = 124,
  GeometryField_PresetShapeGeometry_UP_RIBBON = 125,
  GeometryField_PresetShapeGeometry_DOWN_RIBBON = 126,
  GeometryField_PresetShapeGeometry_CURVED_UP_RIBBON = 127,
  GeometryField_PresetShapeGeometry_CURVED_DOWN_RIBBON = 128,
  GeometryField_PresetShapeGeometry_VERTICAL_SCROLL = 129,
  GeometryField_PresetShapeGeometry_HORIZONTAL_SCROLL = 130,
  GeometryField_PresetShapeGeometry_WAVE = 131,
  GeometryField_PresetShapeGeometry_DOUBLE_WAVE = 132,
  GeometryField_PresetShapeGeometry_RECTANGULAR_CALLOUT = 133,
  GeometryField_PresetShapeGeometry_ROUNDED_RECTANGULAR_CALLOUT = 134,
  GeometryField_PresetShapeGeometry_OVAL_CALLOUT = 135,
  GeometryField_PresetShapeGeometry_CLOUD_CALLOUT = 136,
  GeometryField_PresetShapeGeometry_CALLOUT1 = 137,
  GeometryField_PresetShapeGeometry_CALLOUT2 = 138,
  GeometryField_PresetShapeGeometry_CALLOUT3 = 139,
  GeometryField_PresetShapeGeometry_ACCENT_CALLOUT1 = 140,
  GeometryField_PresetShapeGeometry_ACCENT_CALLOUT2 = 141,
  GeometryField_PresetShapeGeometry_ACCENT_CALLOUT3 = 142,
  GeometryField_PresetShapeGeometry_BORDER_CALLOUT1 = 143,
  GeometryField_PresetShapeGeometry_BORDER_CALLOUT2 = 144,
  GeometryField_PresetShapeGeometry_BORDER_CALLOUT3 = 145,
  GeometryField_PresetShapeGeometry_ACCENT_BORDER_CALLOUT1 = 146,
  GeometryField_PresetShapeGeometry_ACCENT_BORDER_CALLOUT2 = 147,
  GeometryField_PresetShapeGeometry_ACCENT_BORDER_CALLOUT3 = 148,
  GeometryField_PresetShapeGeometry_ACTION_PREVIOUS = 149,
  GeometryField_PresetShapeGeometry_ACTION_NEXT = 150,
  GeometryField_PresetShapeGeometry_ACTION_BEGIN = 151,
  GeometryField_PresetShapeGeometry_ACTION_END = 152,
  GeometryField_PresetShapeGeometry_ACTION_HOME = 153,
  GeometryField_PresetShapeGeometry_ACTION_INFORMATION = 154,
  GeometryField_PresetShapeGeometry_ACTION_RETURN = 155,
  GeometryField_PresetShapeGeometry_ACTION_MOVIE = 156,
  GeometryField_PresetShapeGeometry_ACTION_DOCUMENT = 157,
  GeometryField_PresetShapeGeometry_ACTION_SOUND = 158,
  GeometryField_PresetShapeGeometry_ACTION_HELP = 159,
  GeometryField_PresetShapeGeometry_ACTION_CUSTOM = 160,
  GeometryField_PresetShapeGeometry_LINE = 161,
  GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR2 = 162,
  GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR3 = 163,
  GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR4 = 164,
  GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR5 = 165,
  GeometryField_PresetShapeGeometry_CURVED_CONNECTOR2 = 166,
  GeometryField_PresetShapeGeometry_CURVED_CONNECTOR3 = 167,
  GeometryField_PresetShapeGeometry_CURVED_CONNECTOR4 = 168,
  GeometryField_PresetShapeGeometry_CURVED_CONNECTOR5 = 169,
  GeometryField_PresetShapeGeometry_LOCK_SYMBOL = 170,
  GeometryField_PresetShapeGeometry_GRID = 171,
  GeometryField_PresetShapeGeometry_TABLECELL = 172,
  GeometryField_PresetShapeGeometry_CROP_FRAME = 173,
  GeometryField_PresetShapeGeometry_CIRCLE_QUOTE = 174,
  GeometryField_PresetShapeGeometry_RECT_QUOTE = 175,
  GeometryField_PresetShapeGeometry_BORDER_QUOTE = 176,
  GeometryField_PresetShapeGeometry_TWO_EDGED_FRAME = 177,
  GeometryField_PresetShapeGeometry_FOUR_EDGED_FRAME = 178,
  GeometryField_PresetShapeGeometry_TOP_BANNER = 179,
  GeometryField_PresetShapeGeometry_LEFT_BANNER = 180,
  GeometryField_PresetShapeGeometry_SQUARE_ON_CIRCLE_BOARD = 181,
  GeometryField_PresetShapeGeometry_RHOMBUS_ON_BOW_BOARD = 182,
  GeometryField_PresetShapeGeometry_TWIN_COMET = 183,
  GeometryField_PresetShapeGeometry_DOTTED_SIGN = 184,
  GeometryField_PresetShapeGeometry_MAN = 185,
  GeometryField_PresetShapeGeometry_WOMAN = 186,
  GeometryField_PresetShapeGeometry_METER_NEEDLE = 187,
  GeometryField_PresetShapeGeometry_CLOCK_NEEDLE = 188,
  GeometryField_PresetShapeGeometry_TIMER_SCALE = 189,
  GeometryField_PresetShapeGeometry_HORIZONTAL_SLIDER = 190,
  GeometryField_PresetShapeGeometry_VERTICAL_SLIDER = 191,
  GeometryField_PresetShapeGeometry_MOD_RECT = 192,
  GeometryField_PresetShapeGeometry_MOD_CAN = 193,
  GeometryField_PresetShapeGeometry_MOD_PARALLELOGRAM = 194,
  GeometryField_PresetShapeGeometry_MOD_ROUND_RECT = 195,
  GeometryField_PresetShapeGeometry_CIRCLE_FILLER = 196,
  GeometryField_PresetShapeGeometry_ELLIPSE_FILLER = 197,
  GeometryField_PresetShapeGeometry_STAR = 198,
  GeometryField_PresetShapeGeometry_POLYGON = 199,
  GeometryField_PresetShapeGeometry_AUDIO = 200,
  GeometryField_PresetShapeGeometry_ROUND_DIAMOND = 201,
  GeometryField_PresetShapeGeometry_DFD_EXTERNAL_ENTITY_1 = 202,
  GeometryField_PresetShapeGeometry_ERD_ASSOCIATIVE_ENTITY = 203,
  GeometryField_PresetShapeGeometry_GeometryField_PresetShapeGeometry_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GeometryField_PresetShapeGeometry_GeometryField_PresetShapeGeometry_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GeometryField_PresetShapeGeometry_IsValid(int value);
extern const uint32_t GeometryField_PresetShapeGeometry_internal_data_[];
constexpr GeometryField_PresetShapeGeometry GeometryField_PresetShapeGeometry_PresetShapeGeometry_MIN = static_cast<GeometryField_PresetShapeGeometry>(0);
constexpr GeometryField_PresetShapeGeometry GeometryField_PresetShapeGeometry_PresetShapeGeometry_MAX = static_cast<GeometryField_PresetShapeGeometry>(203);
constexpr int GeometryField_PresetShapeGeometry_PresetShapeGeometry_ARRAYSIZE = 203 + 1;
const ::google::protobuf::EnumDescriptor*
GeometryField_PresetShapeGeometry_descriptor();
template <typename T>
const std::string& GeometryField_PresetShapeGeometry_Name(T value) {
  static_assert(std::is_same<T, GeometryField_PresetShapeGeometry>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetShapeGeometry_Name().");
  return GeometryField_PresetShapeGeometry_Name(static_cast<GeometryField_PresetShapeGeometry>(value));
}
template <>
inline const std::string& GeometryField_PresetShapeGeometry_Name(GeometryField_PresetShapeGeometry value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeometryField_PresetShapeGeometry_descriptor,
                                                 0, 203>(
      static_cast<int>(value));
}
inline bool GeometryField_PresetShapeGeometry_Parse(absl::string_view name, GeometryField_PresetShapeGeometry* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeometryField_PresetShapeGeometry>(
      GeometryField_PresetShapeGeometry_descriptor(), name, value);
}
enum GeometryField_PresetSmartShapeGeometry : int {
  GeometryField_PresetSmartShapeGeometry_HORIZONTAL_BLOCK_BATTERY = 0,
  GeometryField_PresetSmartShapeGeometry_VERTICAL_BLOCK_BATTERY = 1,
  GeometryField_PresetSmartShapeGeometry_WALL_CLOCK = 2,
  GeometryField_PresetSmartShapeGeometry_TIMER_CLOCK = 3,
  GeometryField_PresetSmartShapeGeometry_PEOPLE_INDICATOR = 4,
  GeometryField_PresetSmartShapeGeometry_CIRCULAR_PLAIN_INDICATOR = 5,
  GeometryField_PresetSmartShapeGeometry_CIRCULAR_ENCIRCLED_INDICATOR = 6,
  GeometryField_PresetSmartShapeGeometry_CIRCULAR_PLAINFILL_INDICATOR = 7,
  GeometryField_PresetSmartShapeGeometry_CIRCULAR_VERTICALFILL_INDICATOR = 8,
  GeometryField_PresetSmartShapeGeometry_HORIZONTAL_PLAIN_INDICATOR = 9,
  GeometryField_PresetSmartShapeGeometry_HORIZONTAL_CENTERCIRCLE_INDICATOR = 10,
  GeometryField_PresetSmartShapeGeometry_HORIZONTAL_BLOCK_INDICATOR = 11,
  GeometryField_PresetSmartShapeGeometry_VERTICAL_PLAIN_INDICATOR = 12,
  GeometryField_PresetSmartShapeGeometry_VERTICAL_CENTERBUBLE_INDICATOR = 13,
  GeometryField_PresetSmartShapeGeometry_VERTICAL_CENTERPOINT_INDICATOR = 14,
  GeometryField_PresetSmartShapeGeometry_VERTICAL_BLOCK_INDICATOR = 15,
  GeometryField_PresetSmartShapeGeometry_ARC_PLAIN_METER = 16,
  GeometryField_PresetSmartShapeGeometry_ARC_NEEDLE_METER = 17,
  GeometryField_PresetSmartShapeGeometry_ARC_SPEED_METER = 18,
  GeometryField_PresetSmartShapeGeometry_DIGITAL_CLOCK = 19,
  GeometryField_PresetSmartShapeGeometry_GeometryField_PresetSmartShapeGeometry_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GeometryField_PresetSmartShapeGeometry_GeometryField_PresetSmartShapeGeometry_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GeometryField_PresetSmartShapeGeometry_IsValid(int value);
extern const uint32_t GeometryField_PresetSmartShapeGeometry_internal_data_[];
constexpr GeometryField_PresetSmartShapeGeometry GeometryField_PresetSmartShapeGeometry_PresetSmartShapeGeometry_MIN = static_cast<GeometryField_PresetSmartShapeGeometry>(0);
constexpr GeometryField_PresetSmartShapeGeometry GeometryField_PresetSmartShapeGeometry_PresetSmartShapeGeometry_MAX = static_cast<GeometryField_PresetSmartShapeGeometry>(19);
constexpr int GeometryField_PresetSmartShapeGeometry_PresetSmartShapeGeometry_ARRAYSIZE = 19 + 1;
const ::google::protobuf::EnumDescriptor*
GeometryField_PresetSmartShapeGeometry_descriptor();
template <typename T>
const std::string& GeometryField_PresetSmartShapeGeometry_Name(T value) {
  static_assert(std::is_same<T, GeometryField_PresetSmartShapeGeometry>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetSmartShapeGeometry_Name().");
  return GeometryField_PresetSmartShapeGeometry_Name(static_cast<GeometryField_PresetSmartShapeGeometry>(value));
}
template <>
inline const std::string& GeometryField_PresetSmartShapeGeometry_Name(GeometryField_PresetSmartShapeGeometry value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GeometryField_PresetSmartShapeGeometry_descriptor,
                                                 0, 19>(
      static_cast<int>(value));
}
inline bool GeometryField_PresetSmartShapeGeometry_Parse(absl::string_view name, GeometryField_PresetSmartShapeGeometry* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GeometryField_PresetSmartShapeGeometry>(
      GeometryField_PresetSmartShapeGeometry_descriptor(), name, value);
}
enum EffectsField_ShadowType : int {
  EffectsField_ShadowType_INNER = 0,
  EffectsField_ShadowType_OUTER = 1,
  EffectsField_ShadowType_EffectsField_ShadowType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EffectsField_ShadowType_EffectsField_ShadowType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EffectsField_ShadowType_IsValid(int value);
extern const uint32_t EffectsField_ShadowType_internal_data_[];
constexpr EffectsField_ShadowType EffectsField_ShadowType_ShadowType_MIN = static_cast<EffectsField_ShadowType>(0);
constexpr EffectsField_ShadowType EffectsField_ShadowType_ShadowType_MAX = static_cast<EffectsField_ShadowType>(1);
constexpr int EffectsField_ShadowType_ShadowType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
EffectsField_ShadowType_descriptor();
template <typename T>
const std::string& EffectsField_ShadowType_Name(T value) {
  static_assert(std::is_same<T, EffectsField_ShadowType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShadowType_Name().");
  return EffectsField_ShadowType_Name(static_cast<EffectsField_ShadowType>(value));
}
template <>
inline const std::string& EffectsField_ShadowType_Name(EffectsField_ShadowType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EffectsField_ShadowType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool EffectsField_ShadowType_Parse(absl::string_view name, EffectsField_ShadowType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EffectsField_ShadowType>(
      EffectsField_ShadowType_descriptor(), name, value);
}
enum PresetSmartDiagram_PresetSmartDiagramType : int {
  PresetSmartDiagram_PresetSmartDiagramType_UNKNOWN_SMART_DIAGRAM = 0,
  PresetSmartDiagram_PresetSmartDiagramType_PROCESS_DIAGRAM = 1,
  PresetSmartDiagram_PresetSmartDiagramType_PYRAMID_DIAGRAM = 2,
  PresetSmartDiagram_PresetSmartDiagramType_CYCLE_DIAGRAM = 3,
  PresetSmartDiagram_PresetSmartDiagramType_LIST_DIAGRAM = 4,
  PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagram_PresetSmartDiagramType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagram_PresetSmartDiagramType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PresetSmartDiagram_PresetSmartDiagramType_IsValid(int value);
extern const uint32_t PresetSmartDiagram_PresetSmartDiagramType_internal_data_[];
constexpr PresetSmartDiagram_PresetSmartDiagramType PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagramType_MIN = static_cast<PresetSmartDiagram_PresetSmartDiagramType>(0);
constexpr PresetSmartDiagram_PresetSmartDiagramType PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagramType_MAX = static_cast<PresetSmartDiagram_PresetSmartDiagramType>(4);
constexpr int PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagramType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
PresetSmartDiagram_PresetSmartDiagramType_descriptor();
template <typename T>
const std::string& PresetSmartDiagram_PresetSmartDiagramType_Name(T value) {
  static_assert(std::is_same<T, PresetSmartDiagram_PresetSmartDiagramType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetSmartDiagramType_Name().");
  return PresetSmartDiagram_PresetSmartDiagramType_Name(static_cast<PresetSmartDiagram_PresetSmartDiagramType>(value));
}
template <>
inline const std::string& PresetSmartDiagram_PresetSmartDiagramType_Name(PresetSmartDiagram_PresetSmartDiagramType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PresetSmartDiagram_PresetSmartDiagramType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool PresetSmartDiagram_PresetSmartDiagramType_Parse(absl::string_view name, PresetSmartDiagram_PresetSmartDiagramType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PresetSmartDiagram_PresetSmartDiagramType>(
      PresetSmartDiagram_PresetSmartDiagramType_descriptor(), name, value);
}
enum PresetSmartDiagram_PresetProcessSmartDiagramType : int {
  PresetSmartDiagram_PresetProcessSmartDiagramType_UNKNOWN_PROCESS = 0,
  PresetSmartDiagram_PresetProcessSmartDiagramType_HEXAGON_PROCESS = 1,
  PresetSmartDiagram_PresetProcessSmartDiagramType_STEPS_FLOW_PROCESS = 2,
  PresetSmartDiagram_PresetProcessSmartDiagramType_DROPLET_PROCESS = 3,
  PresetSmartDiagram_PresetProcessSmartDiagramType_TEAR_DROP_PROCESS = 4,
  PresetSmartDiagram_PresetProcessSmartDiagramType_OCTAGON_PROCESS = 5,
  PresetSmartDiagram_PresetProcessSmartDiagramType_ROUNDED_RECTANGLE_PROCESS = 6,
  PresetSmartDiagram_PresetProcessSmartDiagramType_PresetSmartDiagram_PresetProcessSmartDiagramType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PresetSmartDiagram_PresetProcessSmartDiagramType_PresetSmartDiagram_PresetProcessSmartDiagramType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PresetSmartDiagram_PresetProcessSmartDiagramType_IsValid(int value);
extern const uint32_t PresetSmartDiagram_PresetProcessSmartDiagramType_internal_data_[];
constexpr PresetSmartDiagram_PresetProcessSmartDiagramType PresetSmartDiagram_PresetProcessSmartDiagramType_PresetProcessSmartDiagramType_MIN = static_cast<PresetSmartDiagram_PresetProcessSmartDiagramType>(0);
constexpr PresetSmartDiagram_PresetProcessSmartDiagramType PresetSmartDiagram_PresetProcessSmartDiagramType_PresetProcessSmartDiagramType_MAX = static_cast<PresetSmartDiagram_PresetProcessSmartDiagramType>(6);
constexpr int PresetSmartDiagram_PresetProcessSmartDiagramType_PresetProcessSmartDiagramType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
PresetSmartDiagram_PresetProcessSmartDiagramType_descriptor();
template <typename T>
const std::string& PresetSmartDiagram_PresetProcessSmartDiagramType_Name(T value) {
  static_assert(std::is_same<T, PresetSmartDiagram_PresetProcessSmartDiagramType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetProcessSmartDiagramType_Name().");
  return PresetSmartDiagram_PresetProcessSmartDiagramType_Name(static_cast<PresetSmartDiagram_PresetProcessSmartDiagramType>(value));
}
template <>
inline const std::string& PresetSmartDiagram_PresetProcessSmartDiagramType_Name(PresetSmartDiagram_PresetProcessSmartDiagramType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PresetSmartDiagram_PresetProcessSmartDiagramType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool PresetSmartDiagram_PresetProcessSmartDiagramType_Parse(absl::string_view name, PresetSmartDiagram_PresetProcessSmartDiagramType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PresetSmartDiagram_PresetProcessSmartDiagramType>(
      PresetSmartDiagram_PresetProcessSmartDiagramType_descriptor(), name, value);
}
enum PresetSmartDiagram_PresetPyramidSmartDiagramType : int {
  PresetSmartDiagram_PresetPyramidSmartDiagramType_UNKNOWN_PYRAMID = 0,
  PresetSmartDiagram_PresetPyramidSmartDiagramType_TRIANGULAR_PYRAMID = 1,
  PresetSmartDiagram_PresetPyramidSmartDiagramType_INSCRIBED_PYRAMID = 2,
  PresetSmartDiagram_PresetPyramidSmartDiagramType_THREE_DIM_PYRAMID = 3,
  PresetSmartDiagram_PresetPyramidSmartDiagramType_SIMPLE_PYRAMID = 4,
  PresetSmartDiagram_PresetPyramidSmartDiagramType_TILTED_PYRAMID = 5,
  PresetSmartDiagram_PresetPyramidSmartDiagramType_FLAGGED_PYRAMID = 6,
  PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetSmartDiagram_PresetPyramidSmartDiagramType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetSmartDiagram_PresetPyramidSmartDiagramType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PresetSmartDiagram_PresetPyramidSmartDiagramType_IsValid(int value);
extern const uint32_t PresetSmartDiagram_PresetPyramidSmartDiagramType_internal_data_[];
constexpr PresetSmartDiagram_PresetPyramidSmartDiagramType PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetPyramidSmartDiagramType_MIN = static_cast<PresetSmartDiagram_PresetPyramidSmartDiagramType>(0);
constexpr PresetSmartDiagram_PresetPyramidSmartDiagramType PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetPyramidSmartDiagramType_MAX = static_cast<PresetSmartDiagram_PresetPyramidSmartDiagramType>(6);
constexpr int PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetPyramidSmartDiagramType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
PresetSmartDiagram_PresetPyramidSmartDiagramType_descriptor();
template <typename T>
const std::string& PresetSmartDiagram_PresetPyramidSmartDiagramType_Name(T value) {
  static_assert(std::is_same<T, PresetSmartDiagram_PresetPyramidSmartDiagramType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetPyramidSmartDiagramType_Name().");
  return PresetSmartDiagram_PresetPyramidSmartDiagramType_Name(static_cast<PresetSmartDiagram_PresetPyramidSmartDiagramType>(value));
}
template <>
inline const std::string& PresetSmartDiagram_PresetPyramidSmartDiagramType_Name(PresetSmartDiagram_PresetPyramidSmartDiagramType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PresetSmartDiagram_PresetPyramidSmartDiagramType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool PresetSmartDiagram_PresetPyramidSmartDiagramType_Parse(absl::string_view name, PresetSmartDiagram_PresetPyramidSmartDiagramType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PresetSmartDiagram_PresetPyramidSmartDiagramType>(
      PresetSmartDiagram_PresetPyramidSmartDiagramType_descriptor(), name, value);
}
enum PresetSmartDiagram_PresetCycleSmartDiagramType : int {
  PresetSmartDiagram_PresetCycleSmartDiagramType_UNKNOWN_CYCLE = 0,
  PresetSmartDiagram_PresetCycleSmartDiagramType_TRAPEZOID_CYCLE = 1,
  PresetSmartDiagram_PresetCycleSmartDiagramType_ARC_CIRCLES_CYCLE = 2,
  PresetSmartDiagram_PresetCycleSmartDiagramType_SQUARE_CYCLE = 3,
  PresetSmartDiagram_PresetCycleSmartDiagramType_LOOP_CYCLE = 4,
  PresetSmartDiagram_PresetCycleSmartDiagramType_DOUGHNUT_CYCLE = 5,
  PresetSmartDiagram_PresetCycleSmartDiagramType_CONNECTOR_CYCLE = 6,
  PresetSmartDiagram_PresetCycleSmartDiagramType_PresetSmartDiagram_PresetCycleSmartDiagramType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PresetSmartDiagram_PresetCycleSmartDiagramType_PresetSmartDiagram_PresetCycleSmartDiagramType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PresetSmartDiagram_PresetCycleSmartDiagramType_IsValid(int value);
extern const uint32_t PresetSmartDiagram_PresetCycleSmartDiagramType_internal_data_[];
constexpr PresetSmartDiagram_PresetCycleSmartDiagramType PresetSmartDiagram_PresetCycleSmartDiagramType_PresetCycleSmartDiagramType_MIN = static_cast<PresetSmartDiagram_PresetCycleSmartDiagramType>(0);
constexpr PresetSmartDiagram_PresetCycleSmartDiagramType PresetSmartDiagram_PresetCycleSmartDiagramType_PresetCycleSmartDiagramType_MAX = static_cast<PresetSmartDiagram_PresetCycleSmartDiagramType>(6);
constexpr int PresetSmartDiagram_PresetCycleSmartDiagramType_PresetCycleSmartDiagramType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
PresetSmartDiagram_PresetCycleSmartDiagramType_descriptor();
template <typename T>
const std::string& PresetSmartDiagram_PresetCycleSmartDiagramType_Name(T value) {
  static_assert(std::is_same<T, PresetSmartDiagram_PresetCycleSmartDiagramType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetCycleSmartDiagramType_Name().");
  return PresetSmartDiagram_PresetCycleSmartDiagramType_Name(static_cast<PresetSmartDiagram_PresetCycleSmartDiagramType>(value));
}
template <>
inline const std::string& PresetSmartDiagram_PresetCycleSmartDiagramType_Name(PresetSmartDiagram_PresetCycleSmartDiagramType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PresetSmartDiagram_PresetCycleSmartDiagramType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool PresetSmartDiagram_PresetCycleSmartDiagramType_Parse(absl::string_view name, PresetSmartDiagram_PresetCycleSmartDiagramType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PresetSmartDiagram_PresetCycleSmartDiagramType>(
      PresetSmartDiagram_PresetCycleSmartDiagramType_descriptor(), name, value);
}
enum PresetSmartDiagram_PresetListSmartDiagramType : int {
  PresetSmartDiagram_PresetListSmartDiagramType_UNKNOWN_LIST = 0,
  PresetSmartDiagram_PresetListSmartDiagramType_FLAG_LIST = 1,
  PresetSmartDiagram_PresetListSmartDiagramType_DROP_LIST = 2,
  PresetSmartDiagram_PresetListSmartDiagramType_RIBBON_LIST = 3,
  PresetSmartDiagram_PresetListSmartDiagramType_STRIP_LIST = 4,
  PresetSmartDiagram_PresetListSmartDiagramType_SHAFT_LIST = 5,
  PresetSmartDiagram_PresetListSmartDiagramType_STACK_CARD_LIST = 6,
  PresetSmartDiagram_PresetListSmartDiagramType_TIER_LIST = 7,
  PresetSmartDiagram_PresetListSmartDiagramType_PETAL_LIST = 8,
  PresetSmartDiagram_PresetListSmartDiagramType_ALTER_LIST = 9,
  PresetSmartDiagram_PresetListSmartDiagramType_DECK_LIST = 10,
  PresetSmartDiagram_PresetListSmartDiagramType_PresetSmartDiagram_PresetListSmartDiagramType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PresetSmartDiagram_PresetListSmartDiagramType_PresetSmartDiagram_PresetListSmartDiagramType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PresetSmartDiagram_PresetListSmartDiagramType_IsValid(int value);
extern const uint32_t PresetSmartDiagram_PresetListSmartDiagramType_internal_data_[];
constexpr PresetSmartDiagram_PresetListSmartDiagramType PresetSmartDiagram_PresetListSmartDiagramType_PresetListSmartDiagramType_MIN = static_cast<PresetSmartDiagram_PresetListSmartDiagramType>(0);
constexpr PresetSmartDiagram_PresetListSmartDiagramType PresetSmartDiagram_PresetListSmartDiagramType_PresetListSmartDiagramType_MAX = static_cast<PresetSmartDiagram_PresetListSmartDiagramType>(10);
constexpr int PresetSmartDiagram_PresetListSmartDiagramType_PresetListSmartDiagramType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
PresetSmartDiagram_PresetListSmartDiagramType_descriptor();
template <typename T>
const std::string& PresetSmartDiagram_PresetListSmartDiagramType_Name(T value) {
  static_assert(std::is_same<T, PresetSmartDiagram_PresetListSmartDiagramType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PresetListSmartDiagramType_Name().");
  return PresetSmartDiagram_PresetListSmartDiagramType_Name(static_cast<PresetSmartDiagram_PresetListSmartDiagramType>(value));
}
template <>
inline const std::string& PresetSmartDiagram_PresetListSmartDiagramType_Name(PresetSmartDiagram_PresetListSmartDiagramType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PresetSmartDiagram_PresetListSmartDiagramType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool PresetSmartDiagram_PresetListSmartDiagramType_Parse(absl::string_view name, PresetSmartDiagram_PresetListSmartDiagramType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PresetSmartDiagram_PresetListSmartDiagramType>(
      PresetSmartDiagram_PresetListSmartDiagramType_descriptor(), name, value);
}
enum ShapeField_PlaceHolderType : int {
  ShapeField_PlaceHolderType_TITLE = 0,
  ShapeField_PlaceHolderType_TXTBODY = 1,
  ShapeField_PlaceHolderType_DATETIME = 2,
  ShapeField_PlaceHolderType_FOOTER = 3,
  ShapeField_PlaceHolderType_SLIDENUM = 4,
  ShapeField_PlaceHolderType_CONTENT = 5,
  ShapeField_PlaceHolderType_TXT = 6,
  ShapeField_PlaceHolderType_SUBTITLE = 7,
  ShapeField_PlaceHolderType_PICT = 8,
  ShapeField_PlaceHolderType_CLIPART = 9,
  ShapeField_PlaceHolderType_CHART = 10,
  ShapeField_PlaceHolderType_TABLE = 11,
  ShapeField_PlaceHolderType_SMARTART = 12,
  ShapeField_PlaceHolderType_MEDIA = 13,
  ShapeField_PlaceHolderType_BODY = 14,
  ShapeField_PlaceHolderType_FILE = 15,
  ShapeField_PlaceHolderType_ShapeField_PlaceHolderType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ShapeField_PlaceHolderType_ShapeField_PlaceHolderType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ShapeField_PlaceHolderType_IsValid(int value);
extern const uint32_t ShapeField_PlaceHolderType_internal_data_[];
constexpr ShapeField_PlaceHolderType ShapeField_PlaceHolderType_PlaceHolderType_MIN = static_cast<ShapeField_PlaceHolderType>(0);
constexpr ShapeField_PlaceHolderType ShapeField_PlaceHolderType_PlaceHolderType_MAX = static_cast<ShapeField_PlaceHolderType>(15);
constexpr int ShapeField_PlaceHolderType_PlaceHolderType_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor*
ShapeField_PlaceHolderType_descriptor();
template <typename T>
const std::string& ShapeField_PlaceHolderType_Name(T value) {
  static_assert(std::is_same<T, ShapeField_PlaceHolderType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PlaceHolderType_Name().");
  return ShapeField_PlaceHolderType_Name(static_cast<ShapeField_PlaceHolderType>(value));
}
template <>
inline const std::string& ShapeField_PlaceHolderType_Name(ShapeField_PlaceHolderType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ShapeField_PlaceHolderType_descriptor,
                                                 0, 15>(
      static_cast<int>(value));
}
inline bool ShapeField_PlaceHolderType_Parse(absl::string_view name, ShapeField_PlaceHolderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeField_PlaceHolderType>(
      ShapeField_PlaceHolderType_descriptor(), name, value);
}
enum ShapeField_BlendMode : int {
  ShapeField_BlendMode_NORMAL = 0,
  ShapeField_BlendMode_MULTIPLY = 1,
  ShapeField_BlendMode_SCREEN = 2,
  ShapeField_BlendMode_OVERLAY = 3,
  ShapeField_BlendMode_DARKEN = 4,
  ShapeField_BlendMode_LIGHTEN = 5,
  ShapeField_BlendMode_COLOR_DODGE = 6,
  ShapeField_BlendMode_COLOR_BURN = 7,
  ShapeField_BlendMode_SOFT_LIGHT = 8,
  ShapeField_BlendMode_HARD_LIGHT = 9,
  ShapeField_BlendMode_DIFFERENCE = 10,
  ShapeField_BlendMode_EXCLUSION = 11,
  ShapeField_BlendMode_HUE = 12,
  ShapeField_BlendMode_SATURATION = 13,
  ShapeField_BlendMode_COLOR = 14,
  ShapeField_BlendMode_LUMINOSITY = 15,
  ShapeField_BlendMode_ShapeField_BlendMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ShapeField_BlendMode_ShapeField_BlendMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ShapeField_BlendMode_IsValid(int value);
extern const uint32_t ShapeField_BlendMode_internal_data_[];
constexpr ShapeField_BlendMode ShapeField_BlendMode_BlendMode_MIN = static_cast<ShapeField_BlendMode>(0);
constexpr ShapeField_BlendMode ShapeField_BlendMode_BlendMode_MAX = static_cast<ShapeField_BlendMode>(15);
constexpr int ShapeField_BlendMode_BlendMode_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor*
ShapeField_BlendMode_descriptor();
template <typename T>
const std::string& ShapeField_BlendMode_Name(T value) {
  static_assert(std::is_same<T, ShapeField_BlendMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BlendMode_Name().");
  return ShapeField_BlendMode_Name(static_cast<ShapeField_BlendMode>(value));
}
template <>
inline const std::string& ShapeField_BlendMode_Name(ShapeField_BlendMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ShapeField_BlendMode_descriptor,
                                                 0, 15>(
      static_cast<int>(value));
}
inline bool ShapeField_BlendMode_Parse(absl::string_view name, ShapeField_BlendMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeField_BlendMode>(
      ShapeField_BlendMode_descriptor(), name, value);
}
enum ShapeField_CombineRule : int {
  ShapeField_CombineRule_NO_RULE = 0,
  ShapeField_CombineRule_UNION = 1,
  ShapeField_CombineRule_INTERSECT = 2,
  ShapeField_CombineRule_COMBINE = 3,
  ShapeField_CombineRule_SUBTRACT = 4,
  ShapeField_CombineRule_INVERSE_INTERSECT = 5,
  ShapeField_CombineRule_ShapeField_CombineRule_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ShapeField_CombineRule_ShapeField_CombineRule_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ShapeField_CombineRule_IsValid(int value);
extern const uint32_t ShapeField_CombineRule_internal_data_[];
constexpr ShapeField_CombineRule ShapeField_CombineRule_CombineRule_MIN = static_cast<ShapeField_CombineRule>(0);
constexpr ShapeField_CombineRule ShapeField_CombineRule_CombineRule_MAX = static_cast<ShapeField_CombineRule>(5);
constexpr int ShapeField_CombineRule_CombineRule_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ShapeField_CombineRule_descriptor();
template <typename T>
const std::string& ShapeField_CombineRule_Name(T value) {
  static_assert(std::is_same<T, ShapeField_CombineRule>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CombineRule_Name().");
  return ShapeField_CombineRule_Name(static_cast<ShapeField_CombineRule>(value));
}
template <>
inline const std::string& ShapeField_CombineRule_Name(ShapeField_CombineRule value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ShapeField_CombineRule_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ShapeField_CombineRule_Parse(absl::string_view name, ShapeField_CombineRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeField_CombineRule>(
      ShapeField_CombineRule_descriptor(), name, value);
}
enum SlideField_LayoutType : int {
  SlideField_LayoutType_BLANK = 0,
  SlideField_LayoutType_TITLE = 1,
  SlideField_LayoutType_OBJ = 2,
  SlideField_LayoutType_SEC_HEADER = 3,
  SlideField_LayoutType_TWO_OBJ = 4,
  SlideField_LayoutType_TXT = 5,
  SlideField_LayoutType_TWO_TXT = 6,
  SlideField_LayoutType_TWO_OBJ_TWO_TXT = 7,
  SlideField_LayoutType_TITLE_ONLY = 8,
  SlideField_LayoutType_OBJ_AND_TXT = 9,
  SlideField_LayoutType_TXT_OBJ = 10,
  SlideField_LayoutType_OBJ_TXT = 11,
  SlideField_LayoutType_PIC_TXT = 12,
  SlideField_LayoutType_OBJ_ONLY = 13,
  SlideField_LayoutType_TWO_OBJ_TXT = 14,
  SlideField_LayoutType_TXT_TWO_OBJ = 15,
  SlideField_LayoutType_OBJ_TWO_OBJ = 16,
  SlideField_LayoutType_TWO_OBJ_OBJ = 17,
  SlideField_LayoutType_FOUR_OBJ = 18,
  SlideField_LayoutType_TXT_OVER_OBJ = 19,
  SlideField_LayoutType_OBJ_OVER_TXT = 20,
  SlideField_LayoutType_TXT_CLIPART = 21,
  SlideField_LayoutType_CLIPART_TXT = 22,
  SlideField_LayoutType_TXT_CHART = 23,
  SlideField_LayoutType_CHART_TXT = 24,
  SlideField_LayoutType_TXT_MEDIA = 25,
  SlideField_LayoutType_MEDIA_TXT = 26,
  SlideField_LayoutType_TABLE = 27,
  SlideField_LayoutType_SMARTART = 28,
  SlideField_LayoutType_CHART = 29,
  SlideField_LayoutType_VERT_TXT = 30,
  SlideField_LayoutType_VERT_TITLE_TXT = 31,
  SlideField_LayoutType_TITLE_THREE_PICT_TXT = 33,
  SlideField_LayoutType_TITLE_FOUR_PICT = 34,
  SlideField_LayoutType_TITLE_TXT_TWO_PICT = 35,
  SlideField_LayoutType_TWO_OBJ_OVER_TXT = 36,
  SlideField_LayoutType_CLIPART_VERT_TXT = 37,
  SlideField_LayoutType_VERT_TITLE_TX_OVER_CHART = 38,
  SlideField_LayoutType_PIC_TITLE_RGT = 39,
  SlideField_LayoutType_PIC_TITLE_LFT = 40,
  SlideField_LayoutType_PIC_TITLE_CENTER = 41,
  SlideField_LayoutType_PIC_TITLE_TXT_LFT = 42,
  SlideField_LayoutType_PIC_TITLE_TXT_RGT = 43,
  SlideField_LayoutType_THREE_PICT_TXT = 44,
  SlideField_LayoutType_CUSTOM = 32,
  SlideField_LayoutType_SlideField_LayoutType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SlideField_LayoutType_SlideField_LayoutType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SlideField_LayoutType_IsValid(int value);
extern const uint32_t SlideField_LayoutType_internal_data_[];
constexpr SlideField_LayoutType SlideField_LayoutType_LayoutType_MIN = static_cast<SlideField_LayoutType>(0);
constexpr SlideField_LayoutType SlideField_LayoutType_LayoutType_MAX = static_cast<SlideField_LayoutType>(44);
constexpr int SlideField_LayoutType_LayoutType_ARRAYSIZE = 44 + 1;
const ::google::protobuf::EnumDescriptor*
SlideField_LayoutType_descriptor();
template <typename T>
const std::string& SlideField_LayoutType_Name(T value) {
  static_assert(std::is_same<T, SlideField_LayoutType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LayoutType_Name().");
  return SlideField_LayoutType_Name(static_cast<SlideField_LayoutType>(value));
}
template <>
inline const std::string& SlideField_LayoutType_Name(SlideField_LayoutType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SlideField_LayoutType_descriptor,
                                                 0, 44>(
      static_cast<int>(value));
}
inline bool SlideField_LayoutType_Parse(absl::string_view name, SlideField_LayoutType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlideField_LayoutType>(
      SlideField_LayoutType_descriptor(), name, value);
}
enum PortionField_SlideNumberField : int {
  PortionField_SlideNumberField_NUM1 = 0,
  PortionField_SlideNumberField_NUM2 = 1,
  PortionField_SlideNumberField_PortionField_SlideNumberField_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PortionField_SlideNumberField_PortionField_SlideNumberField_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PortionField_SlideNumberField_IsValid(int value);
extern const uint32_t PortionField_SlideNumberField_internal_data_[];
constexpr PortionField_SlideNumberField PortionField_SlideNumberField_SlideNumberField_MIN = static_cast<PortionField_SlideNumberField>(0);
constexpr PortionField_SlideNumberField PortionField_SlideNumberField_SlideNumberField_MAX = static_cast<PortionField_SlideNumberField>(1);
constexpr int PortionField_SlideNumberField_SlideNumberField_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
PortionField_SlideNumberField_descriptor();
template <typename T>
const std::string& PortionField_SlideNumberField_Name(T value) {
  static_assert(std::is_same<T, PortionField_SlideNumberField>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SlideNumberField_Name().");
  return PortionField_SlideNumberField_Name(static_cast<PortionField_SlideNumberField>(value));
}
template <>
inline const std::string& PortionField_SlideNumberField_Name(PortionField_SlideNumberField value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PortionField_SlideNumberField_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PortionField_SlideNumberField_Parse(absl::string_view name, PortionField_SlideNumberField* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortionField_SlideNumberField>(
      PortionField_SlideNumberField_descriptor(), name, value);
}
enum PortionField_DateTimeField : int {
  PortionField_DateTimeField_DEF_DATE_TIME_FIELD_FORMAT = 0,
  PortionField_DateTimeField_FORMAT1 = 1,
  PortionField_DateTimeField_FORMAT2 = 2,
  PortionField_DateTimeField_FORMAT3 = 3,
  PortionField_DateTimeField_FORMAT4 = 4,
  PortionField_DateTimeField_FORMAT5 = 5,
  PortionField_DateTimeField_FORMAT6 = 6,
  PortionField_DateTimeField_FORMAT7 = 7,
  PortionField_DateTimeField_FORMAT8 = 8,
  PortionField_DateTimeField_FORMAT9 = 9,
  PortionField_DateTimeField_FORMAT10 = 10,
  PortionField_DateTimeField_FORMAT11 = 11,
  PortionField_DateTimeField_FORMAT12 = 12,
  PortionField_DateTimeField_FORMAT13 = 13,
  PortionField_DateTimeField_FORMAT14 = 14,
  PortionField_DateTimeField_FORMAT15 = 15,
  PortionField_DateTimeField_PortionField_DateTimeField_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PortionField_DateTimeField_PortionField_DateTimeField_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PortionField_DateTimeField_IsValid(int value);
extern const uint32_t PortionField_DateTimeField_internal_data_[];
constexpr PortionField_DateTimeField PortionField_DateTimeField_DateTimeField_MIN = static_cast<PortionField_DateTimeField>(0);
constexpr PortionField_DateTimeField PortionField_DateTimeField_DateTimeField_MAX = static_cast<PortionField_DateTimeField>(15);
constexpr int PortionField_DateTimeField_DateTimeField_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor*
PortionField_DateTimeField_descriptor();
template <typename T>
const std::string& PortionField_DateTimeField_Name(T value) {
  static_assert(std::is_same<T, PortionField_DateTimeField>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DateTimeField_Name().");
  return PortionField_DateTimeField_Name(static_cast<PortionField_DateTimeField>(value));
}
template <>
inline const std::string& PortionField_DateTimeField_Name(PortionField_DateTimeField value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PortionField_DateTimeField_descriptor,
                                                 0, 15>(
      static_cast<int>(value));
}
inline bool PortionField_DateTimeField_Parse(absl::string_view name, PortionField_DateTimeField* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortionField_DateTimeField>(
      PortionField_DateTimeField_descriptor(), name, value);
}
enum PortionField_FontVariant : int {
  PortionField_FontVariant_SMALLCAPS = 0,
  PortionField_FontVariant_ALLCAPS = 1,
  PortionField_FontVariant_NONE = 2,
  PortionField_FontVariant_CAPITALIZE = 3,
  PortionField_FontVariant_PortionField_FontVariant_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PortionField_FontVariant_PortionField_FontVariant_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PortionField_FontVariant_IsValid(int value);
extern const uint32_t PortionField_FontVariant_internal_data_[];
constexpr PortionField_FontVariant PortionField_FontVariant_FontVariant_MIN = static_cast<PortionField_FontVariant>(0);
constexpr PortionField_FontVariant PortionField_FontVariant_FontVariant_MAX = static_cast<PortionField_FontVariant>(3);
constexpr int PortionField_FontVariant_FontVariant_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PortionField_FontVariant_descriptor();
template <typename T>
const std::string& PortionField_FontVariant_Name(T value) {
  static_assert(std::is_same<T, PortionField_FontVariant>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FontVariant_Name().");
  return PortionField_FontVariant_Name(static_cast<PortionField_FontVariant>(value));
}
template <>
inline const std::string& PortionField_FontVariant_Name(PortionField_FontVariant value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PortionField_FontVariant_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PortionField_FontVariant_Parse(absl::string_view name, PortionField_FontVariant* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortionField_FontVariant>(
      PortionField_FontVariant_descriptor(), name, value);
}
enum PortionField_FontWeight : int {
  PortionField_FontWeight_THIN = 0,
  PortionField_FontWeight_EXTRA_LIGHT = 1,
  PortionField_FontWeight_LIGHT = 2,
  PortionField_FontWeight_NORMAL = 4,
  PortionField_FontWeight_MEDIUM = 5,
  PortionField_FontWeight_DEMI_BOLD = 6,
  PortionField_FontWeight_BOLD = 7,
  PortionField_FontWeight_HEAVY = 8,
  PortionField_FontWeight_BLACK = 9,
  PortionField_FontWeight_PortionField_FontWeight_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PortionField_FontWeight_PortionField_FontWeight_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PortionField_FontWeight_IsValid(int value);
extern const uint32_t PortionField_FontWeight_internal_data_[];
constexpr PortionField_FontWeight PortionField_FontWeight_FontWeight_MIN = static_cast<PortionField_FontWeight>(0);
constexpr PortionField_FontWeight PortionField_FontWeight_FontWeight_MAX = static_cast<PortionField_FontWeight>(9);
constexpr int PortionField_FontWeight_FontWeight_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
PortionField_FontWeight_descriptor();
template <typename T>
const std::string& PortionField_FontWeight_Name(T value) {
  static_assert(std::is_same<T, PortionField_FontWeight>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FontWeight_Name().");
  return PortionField_FontWeight_Name(static_cast<PortionField_FontWeight>(value));
}
template <>
inline const std::string& PortionField_FontWeight_Name(PortionField_FontWeight value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PortionField_FontWeight_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool PortionField_FontWeight_Parse(absl::string_view name, PortionField_FontWeight* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortionField_FontWeight>(
      PortionField_FontWeight_descriptor(), name, value);
}
enum FillField_FillType : int {
  FillField_FillType_DEF_FILL = 0,
  FillField_FillType_NONE = 1,
  FillField_FillType_SOLID = 2,
  FillField_FillType_GRADIENT = 3,
  FillField_FillType_PICT = 4,
  FillField_FillType_GRP = 5,
  FillField_FillType_PATTERN = 6,
  FillField_FillType_TEXTBOX = 7,
  FillField_FillType_FillField_FillType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FillField_FillType_FillField_FillType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FillField_FillType_IsValid(int value);
extern const uint32_t FillField_FillType_internal_data_[];
constexpr FillField_FillType FillField_FillType_FillType_MIN = static_cast<FillField_FillType>(0);
constexpr FillField_FillType FillField_FillType_FillType_MAX = static_cast<FillField_FillType>(7);
constexpr int FillField_FillType_FillType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
FillField_FillType_descriptor();
template <typename T>
const std::string& FillField_FillType_Name(T value) {
  static_assert(std::is_same<T, FillField_FillType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FillType_Name().");
  return FillField_FillType_Name(static_cast<FillField_FillType>(value));
}
template <>
inline const std::string& FillField_FillType_Name(FillField_FillType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FillField_FillType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool FillField_FillType_Parse(absl::string_view name, FillField_FillType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FillField_FillType>(
      FillField_FillType_descriptor(), name, value);
}
enum FillField_GradientFillType : int {
  FillField_GradientFillType_LINEAR = 0,
  FillField_GradientFillType_RADIAL = 1,
  FillField_GradientFillType_RECTANGULAR = 2,
  FillField_GradientFillType_PATH = 3,
  FillField_GradientFillType_ANGULAR = 4,
  FillField_GradientFillType_FillField_GradientFillType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FillField_GradientFillType_FillField_GradientFillType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FillField_GradientFillType_IsValid(int value);
extern const uint32_t FillField_GradientFillType_internal_data_[];
constexpr FillField_GradientFillType FillField_GradientFillType_GradientFillType_MIN = static_cast<FillField_GradientFillType>(0);
constexpr FillField_GradientFillType FillField_GradientFillType_GradientFillType_MAX = static_cast<FillField_GradientFillType>(4);
constexpr int FillField_GradientFillType_GradientFillType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
FillField_GradientFillType_descriptor();
template <typename T>
const std::string& FillField_GradientFillType_Name(T value) {
  static_assert(std::is_same<T, FillField_GradientFillType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GradientFillType_Name().");
  return FillField_GradientFillType_Name(static_cast<FillField_GradientFillType>(value));
}
template <>
inline const std::string& FillField_GradientFillType_Name(FillField_GradientFillType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FillField_GradientFillType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool FillField_GradientFillType_Parse(absl::string_view name, FillField_GradientFillType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FillField_GradientFillType>(
      FillField_GradientFillType_descriptor(), name, value);
}
enum FillField_FillRule : int {
  FillField_FillRule_NO_RULE = 0,
  FillField_FillRule_NON_ZERO = 1,
  FillField_FillRule_EVEN_ODD = 2,
  FillField_FillRule_FillField_FillRule_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FillField_FillRule_FillField_FillRule_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FillField_FillRule_IsValid(int value);
extern const uint32_t FillField_FillRule_internal_data_[];
constexpr FillField_FillRule FillField_FillRule_FillRule_MIN = static_cast<FillField_FillRule>(0);
constexpr FillField_FillRule FillField_FillRule_FillRule_MAX = static_cast<FillField_FillRule>(2);
constexpr int FillField_FillRule_FillRule_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
FillField_FillRule_descriptor();
template <typename T>
const std::string& FillField_FillRule_Name(T value) {
  static_assert(std::is_same<T, FillField_FillRule>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FillRule_Name().");
  return FillField_FillRule_Name(static_cast<FillField_FillRule>(value));
}
template <>
inline const std::string& FillField_FillRule_Name(FillField_FillRule value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FillField_FillRule_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool FillField_FillRule_Parse(absl::string_view name, FillField_FillRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FillField_FillRule>(
      FillField_FillRule_descriptor(), name, value);
}
enum ChartField_BarChartField_BarType : int {
  ChartField_BarChartField_BarType_BAR = 0,
  ChartField_BarChartField_BarType_COL = 1,
  ChartField_BarChartField_BarType_ChartField_BarChartField_BarType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartField_BarChartField_BarType_ChartField_BarChartField_BarType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartField_BarChartField_BarType_IsValid(int value);
extern const uint32_t ChartField_BarChartField_BarType_internal_data_[];
constexpr ChartField_BarChartField_BarType ChartField_BarChartField_BarType_BarType_MIN = static_cast<ChartField_BarChartField_BarType>(0);
constexpr ChartField_BarChartField_BarType ChartField_BarChartField_BarType_BarType_MAX = static_cast<ChartField_BarChartField_BarType>(1);
constexpr int ChartField_BarChartField_BarType_BarType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ChartField_BarChartField_BarType_descriptor();
template <typename T>
const std::string& ChartField_BarChartField_BarType_Name(T value) {
  static_assert(std::is_same<T, ChartField_BarChartField_BarType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BarType_Name().");
  return ChartField_BarChartField_BarType_Name(static_cast<ChartField_BarChartField_BarType>(value));
}
template <>
inline const std::string& ChartField_BarChartField_BarType_Name(ChartField_BarChartField_BarType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartField_BarChartField_BarType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ChartField_BarChartField_BarType_Parse(absl::string_view name, ChartField_BarChartField_BarType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartField_BarChartField_BarType>(
      ChartField_BarChartField_BarType_descriptor(), name, value);
}
enum ChartField_ChartType : int {
  ChartField_ChartType_BAR = 0,
  ChartField_ChartType_BAR3D = 1,
  ChartField_ChartType_LINE = 2,
  ChartField_ChartType_LINE3D = 3,
  ChartField_ChartType_AREA = 4,
  ChartField_ChartType_AREA3D = 5,
  ChartField_ChartType_PIE = 6,
  ChartField_ChartType_PIE3D = 7,
  ChartField_ChartType_REPPIE = 8,
  ChartField_ChartType_DOUGHNUT = 9,
  ChartField_ChartType_SCATTER = 10,
  ChartField_ChartType_BUBBLE = 11,
  ChartField_ChartType_ChartField_ChartType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartField_ChartType_ChartField_ChartType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartField_ChartType_IsValid(int value);
extern const uint32_t ChartField_ChartType_internal_data_[];
constexpr ChartField_ChartType ChartField_ChartType_ChartType_MIN = static_cast<ChartField_ChartType>(0);
constexpr ChartField_ChartType ChartField_ChartType_ChartType_MAX = static_cast<ChartField_ChartType>(11);
constexpr int ChartField_ChartType_ChartType_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
ChartField_ChartType_descriptor();
template <typename T>
const std::string& ChartField_ChartType_Name(T value) {
  static_assert(std::is_same<T, ChartField_ChartType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChartType_Name().");
  return ChartField_ChartType_Name(static_cast<ChartField_ChartType>(value));
}
template <>
inline const std::string& ChartField_ChartType_Name(ChartField_ChartType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartField_ChartType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool ChartField_ChartType_Parse(absl::string_view name, ChartField_ChartType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartField_ChartType>(
      ChartField_ChartType_descriptor(), name, value);
}
enum ChartField_Grouping : int {
  ChartField_Grouping_STANDARD = 0,
  ChartField_Grouping_CLUSTERED = 1,
  ChartField_Grouping_STACKED = 2,
  ChartField_Grouping_PERCENTSTACKED = 3,
  ChartField_Grouping_ChartField_Grouping_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartField_Grouping_ChartField_Grouping_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartField_Grouping_IsValid(int value);
extern const uint32_t ChartField_Grouping_internal_data_[];
constexpr ChartField_Grouping ChartField_Grouping_Grouping_MIN = static_cast<ChartField_Grouping>(0);
constexpr ChartField_Grouping ChartField_Grouping_Grouping_MAX = static_cast<ChartField_Grouping>(3);
constexpr int ChartField_Grouping_Grouping_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChartField_Grouping_descriptor();
template <typename T>
const std::string& ChartField_Grouping_Name(T value) {
  static_assert(std::is_same<T, ChartField_Grouping>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Grouping_Name().");
  return ChartField_Grouping_Name(static_cast<ChartField_Grouping>(value));
}
template <>
inline const std::string& ChartField_Grouping_Name(ChartField_Grouping value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartField_Grouping_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ChartField_Grouping_Parse(absl::string_view name, ChartField_Grouping* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartField_Grouping>(
      ChartField_Grouping_descriptor(), name, value);
}
enum ChartField_DataLabelPosition : int {
  ChartField_DataLabelPosition_BESTFIT = 0,
  ChartField_DataLabelPosition_BOTTOM = 1,
  ChartField_DataLabelPosition_CENTER = 2,
  ChartField_DataLabelPosition_INBASE = 3,
  ChartField_DataLabelPosition_INEND = 4,
  ChartField_DataLabelPosition_LEFT = 5,
  ChartField_DataLabelPosition_OUTEND = 6,
  ChartField_DataLabelPosition_RIGHT = 7,
  ChartField_DataLabelPosition_TOP = 8,
  ChartField_DataLabelPosition_ChartField_DataLabelPosition_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartField_DataLabelPosition_ChartField_DataLabelPosition_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartField_DataLabelPosition_IsValid(int value);
extern const uint32_t ChartField_DataLabelPosition_internal_data_[];
constexpr ChartField_DataLabelPosition ChartField_DataLabelPosition_DataLabelPosition_MIN = static_cast<ChartField_DataLabelPosition>(0);
constexpr ChartField_DataLabelPosition ChartField_DataLabelPosition_DataLabelPosition_MAX = static_cast<ChartField_DataLabelPosition>(8);
constexpr int ChartField_DataLabelPosition_DataLabelPosition_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ChartField_DataLabelPosition_descriptor();
template <typename T>
const std::string& ChartField_DataLabelPosition_Name(T value) {
  static_assert(std::is_same<T, ChartField_DataLabelPosition>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataLabelPosition_Name().");
  return ChartField_DataLabelPosition_Name(static_cast<ChartField_DataLabelPosition>(value));
}
template <>
inline const std::string& ChartField_DataLabelPosition_Name(ChartField_DataLabelPosition value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartField_DataLabelPosition_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ChartField_DataLabelPosition_Parse(absl::string_view name, ChartField_DataLabelPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartField_DataLabelPosition>(
      ChartField_DataLabelPosition_descriptor(), name, value);
}
enum ChartField_PositionElement : int {
  ChartField_PositionElement_T = 0,
  ChartField_PositionElement_L = 1,
  ChartField_PositionElement_B = 2,
  ChartField_PositionElement_R = 3,
  ChartField_PositionElement_TR = 4,
  ChartField_PositionElement_MANUAL = 5,
  ChartField_PositionElement_C = 6,
  ChartField_PositionElement_ChartField_PositionElement_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartField_PositionElement_ChartField_PositionElement_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartField_PositionElement_IsValid(int value);
extern const uint32_t ChartField_PositionElement_internal_data_[];
constexpr ChartField_PositionElement ChartField_PositionElement_PositionElement_MIN = static_cast<ChartField_PositionElement>(0);
constexpr ChartField_PositionElement ChartField_PositionElement_PositionElement_MAX = static_cast<ChartField_PositionElement>(6);
constexpr int ChartField_PositionElement_PositionElement_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ChartField_PositionElement_descriptor();
template <typename T>
const std::string& ChartField_PositionElement_Name(T value) {
  static_assert(std::is_same<T, ChartField_PositionElement>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PositionElement_Name().");
  return ChartField_PositionElement_Name(static_cast<ChartField_PositionElement>(value));
}
template <>
inline const std::string& ChartField_PositionElement_Name(ChartField_PositionElement value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartField_PositionElement_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ChartField_PositionElement_Parse(absl::string_view name, ChartField_PositionElement* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartField_PositionElement>(
      ChartField_PositionElement_descriptor(), name, value);
}
enum ChartField_TickMarkType : int {
  ChartField_TickMarkType_NONE = 0,
  ChartField_TickMarkType_IN = 1,
  ChartField_TickMarkType_OUT = 2,
  ChartField_TickMarkType_CROSS = 3,
  ChartField_TickMarkType_ChartField_TickMarkType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartField_TickMarkType_ChartField_TickMarkType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartField_TickMarkType_IsValid(int value);
extern const uint32_t ChartField_TickMarkType_internal_data_[];
constexpr ChartField_TickMarkType ChartField_TickMarkType_TickMarkType_MIN = static_cast<ChartField_TickMarkType>(0);
constexpr ChartField_TickMarkType ChartField_TickMarkType_TickMarkType_MAX = static_cast<ChartField_TickMarkType>(3);
constexpr int ChartField_TickMarkType_TickMarkType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChartField_TickMarkType_descriptor();
template <typename T>
const std::string& ChartField_TickMarkType_Name(T value) {
  static_assert(std::is_same<T, ChartField_TickMarkType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TickMarkType_Name().");
  return ChartField_TickMarkType_Name(static_cast<ChartField_TickMarkType>(value));
}
template <>
inline const std::string& ChartField_TickMarkType_Name(ChartField_TickMarkType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartField_TickMarkType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ChartField_TickMarkType_Parse(absl::string_view name, ChartField_TickMarkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartField_TickMarkType>(
      ChartField_TickMarkType_descriptor(), name, value);
}
enum ChartField_LabelPos : int {
  ChartField_LabelPos_NIL = 0,
  ChartField_LabelPos_HIGH = 1,
  ChartField_LabelPos_LOW = 2,
  ChartField_LabelPos_NEXTTO = 3,
  ChartField_LabelPos_ChartField_LabelPos_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChartField_LabelPos_ChartField_LabelPos_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChartField_LabelPos_IsValid(int value);
extern const uint32_t ChartField_LabelPos_internal_data_[];
constexpr ChartField_LabelPos ChartField_LabelPos_LabelPos_MIN = static_cast<ChartField_LabelPos>(0);
constexpr ChartField_LabelPos ChartField_LabelPos_LabelPos_MAX = static_cast<ChartField_LabelPos>(3);
constexpr int ChartField_LabelPos_LabelPos_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChartField_LabelPos_descriptor();
template <typename T>
const std::string& ChartField_LabelPos_Name(T value) {
  static_assert(std::is_same<T, ChartField_LabelPos>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LabelPos_Name().");
  return ChartField_LabelPos_Name(static_cast<ChartField_LabelPos>(value));
}
template <>
inline const std::string& ChartField_LabelPos_Name(ChartField_LabelPos value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChartField_LabelPos_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ChartField_LabelPos_Parse(absl::string_view name, ChartField_LabelPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartField_LabelPos>(
      ChartField_LabelPos_descriptor(), name, value);
}
enum TableField_TextDirection : int {
  TableField_TextDirection_HORIZONTAL = 0,
  TableField_TextDirection_VERTICAL = 1,
  TableField_TextDirection_VERTICAL270 = 2,
  TableField_TextDirection_WORDARTVERTICAL = 3,
  TableField_TextDirection_TableField_TextDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TableField_TextDirection_TableField_TextDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TableField_TextDirection_IsValid(int value);
extern const uint32_t TableField_TextDirection_internal_data_[];
constexpr TableField_TextDirection TableField_TextDirection_TextDirection_MIN = static_cast<TableField_TextDirection>(0);
constexpr TableField_TextDirection TableField_TextDirection_TextDirection_MAX = static_cast<TableField_TextDirection>(3);
constexpr int TableField_TextDirection_TextDirection_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TableField_TextDirection_descriptor();
template <typename T>
const std::string& TableField_TextDirection_Name(T value) {
  static_assert(std::is_same<T, TableField_TextDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TextDirection_Name().");
  return TableField_TextDirection_Name(static_cast<TableField_TextDirection>(value));
}
template <>
inline const std::string& TableField_TextDirection_Name(TableField_TextDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TableField_TextDirection_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TableField_TextDirection_Parse(absl::string_view name, TableField_TextDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableField_TextDirection>(
      TableField_TextDirection_descriptor(), name, value);
}
enum AnimationField_TransitionType : int {
  AnimationField_TransitionType_NONE = 0,
  AnimationField_TransitionType_BLINDS = 1,
  AnimationField_TransitionType_CHECKERS = 2,
  AnimationField_TransitionType_CIRCLE = 3,
  AnimationField_TransitionType_COMB = 4,
  AnimationField_TransitionType_COVER = 5,
  AnimationField_TransitionType_CUT = 6,
  AnimationField_TransitionType_DIAMOND = 7,
  AnimationField_TransitionType_DISSOLVE = 8,
  AnimationField_TransitionType_FADE = 9,
  AnimationField_TransitionType_NEWSFLASH = 10,
  AnimationField_TransitionType_PLUS = 11,
  AnimationField_TransitionType_PULL = 12,
  AnimationField_TransitionType_PUSH = 13,
  AnimationField_TransitionType_RANDOM = 14,
  AnimationField_TransitionType_RANDOMBAR = 15,
  AnimationField_TransitionType_SPLIT = 16,
  AnimationField_TransitionType_STRIPS = 17,
  AnimationField_TransitionType_WEDGE = 18,
  AnimationField_TransitionType_WHEEL = 19,
  AnimationField_TransitionType_WIPE = 20,
  AnimationField_TransitionType_ZOOM = 21,
  AnimationField_TransitionType_FLY = 22,
  AnimationField_TransitionType_FLOAT = 23,
  AnimationField_TransitionType_APPEAR = 24,
  AnimationField_TransitionType_REVOLVINGDOOR = 25,
  AnimationField_TransitionType_PIVOT = 26,
  AnimationField_TransitionType_TWIRL = 27,
  AnimationField_TransitionType_SWAP = 28,
  AnimationField_TransitionType_FLIP = 29,
  AnimationField_TransitionType_CUBE = 30,
  AnimationField_TransitionType_GALLERY = 31,
  AnimationField_TransitionType_FALL = 32,
  AnimationField_TransitionType_REVEAL = 33,
  AnimationField_TransitionType_GEOMETRIC = 34,
  AnimationField_TransitionType_FLASH = 35,
  AnimationField_TransitionType_RIPPLE = 36,
  AnimationField_TransitionType_HONEYCOMB = 37,
  AnimationField_TransitionType_GLITTER = 38,
  AnimationField_TransitionType_VORTEX = 39,
  AnimationField_TransitionType_PEEK = 40,
  AnimationField_TransitionType_EXPAND_OR_CONTRACT = 41,
  AnimationField_TransitionType_FADED_SWIVEL = 42,
  AnimationField_TransitionType_FADED_ZOOM = 43,
  AnimationField_TransitionType_CENTER_REVOLVE = 44,
  AnimationField_TransitionType_GROW_OR_SHRINK_AND_TURN = 45,
  AnimationField_TransitionType_RISEUP_SINKDOWN = 46,
  AnimationField_TransitionType_SPINNER = 47,
  AnimationField_TransitionType_BOOMER = 48,
  AnimationField_TransitionType_BOUNCE = 49,
  AnimationField_TransitionType_CREDITS = 50,
  AnimationField_TransitionType_CURVE_UP_OR_DOWN = 51,
  AnimationField_TransitionType_PIN_WHEEL = 52,
  AnimationField_TransitionType_SPIRAL = 53,
  AnimationField_TransitionType_SWIVEL = 54,
  AnimationField_TransitionType_WHIP = 55,
  AnimationField_TransitionType_CURVY_FLOAT = 56,
  AnimationField_TransitionType_DROP = 57,
  AnimationField_TransitionType_PAN = 58,
  AnimationField_TransitionType_FERRISWHEEL = 59,
  AnimationField_TransitionType_CONVEYOR = 60,
  AnimationField_TransitionType_ROTATE = 61,
  AnimationField_TransitionType_WINDOW = 62,
  AnimationField_TransitionType_ORBIT = 63,
  AnimationField_TransitionType_FLYTHRU = 64,
  AnimationField_TransitionType_BOX = 65,
  AnimationField_TransitionType_DOOR = 66,
  AnimationField_TransitionType_SHRED = 67,
  AnimationField_TransitionType_WHEEL_WIPE = 68,
  AnimationField_TransitionType_METEOR = 69,
  AnimationField_TransitionType_PATH = 70,
  AnimationField_TransitionType_DRAW = 71,
  AnimationField_TransitionType_MORPH = 72,
  AnimationField_TransitionType_AnimationField_TransitionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_TransitionType_AnimationField_TransitionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_TransitionType_IsValid(int value);
extern const uint32_t AnimationField_TransitionType_internal_data_[];
constexpr AnimationField_TransitionType AnimationField_TransitionType_TransitionType_MIN = static_cast<AnimationField_TransitionType>(0);
constexpr AnimationField_TransitionType AnimationField_TransitionType_TransitionType_MAX = static_cast<AnimationField_TransitionType>(72);
constexpr int AnimationField_TransitionType_TransitionType_ARRAYSIZE = 72 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_TransitionType_descriptor();
template <typename T>
const std::string& AnimationField_TransitionType_Name(T value) {
  static_assert(std::is_same<T, AnimationField_TransitionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TransitionType_Name().");
  return AnimationField_TransitionType_Name(static_cast<AnimationField_TransitionType>(value));
}
template <>
inline const std::string& AnimationField_TransitionType_Name(AnimationField_TransitionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_TransitionType_descriptor,
                                                 0, 72>(
      static_cast<int>(value));
}
inline bool AnimationField_TransitionType_Parse(absl::string_view name, AnimationField_TransitionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_TransitionType>(
      AnimationField_TransitionType_descriptor(), name, value);
}
enum AnimationField_Axis : int {
  AnimationField_Axis_HOR = 0,
  AnimationField_Axis_VER = 1,
  AnimationField_Axis_AnimationField_Axis_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_Axis_AnimationField_Axis_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_Axis_IsValid(int value);
extern const uint32_t AnimationField_Axis_internal_data_[];
constexpr AnimationField_Axis AnimationField_Axis_Axis_MIN = static_cast<AnimationField_Axis>(0);
constexpr AnimationField_Axis AnimationField_Axis_Axis_MAX = static_cast<AnimationField_Axis>(1);
constexpr int AnimationField_Axis_Axis_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_Axis_descriptor();
template <typename T>
const std::string& AnimationField_Axis_Name(T value) {
  static_assert(std::is_same<T, AnimationField_Axis>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Axis_Name().");
  return AnimationField_Axis_Name(static_cast<AnimationField_Axis>(value));
}
template <>
inline const std::string& AnimationField_Axis_Name(AnimationField_Axis value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_Axis_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AnimationField_Axis_Parse(absl::string_view name, AnimationField_Axis* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_Axis>(
      AnimationField_Axis_descriptor(), name, value);
}
enum AnimationField_Direction : int {
  AnimationField_Direction_LEFT = 0,
  AnimationField_Direction_DOWN = 1,
  AnimationField_Direction_RIGHT = 2,
  AnimationField_Direction_UP = 3,
  AnimationField_Direction_LEFT_DOWN = 4,
  AnimationField_Direction_LEFT_UP = 5,
  AnimationField_Direction_RIGHT_DOWN = 6,
  AnimationField_Direction_RIGHT_UP = 7,
  AnimationField_Direction_CENTER = 8,
  AnimationField_Direction_AnimationField_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_Direction_AnimationField_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_Direction_IsValid(int value);
extern const uint32_t AnimationField_Direction_internal_data_[];
constexpr AnimationField_Direction AnimationField_Direction_Direction_MIN = static_cast<AnimationField_Direction>(0);
constexpr AnimationField_Direction AnimationField_Direction_Direction_MAX = static_cast<AnimationField_Direction>(8);
constexpr int AnimationField_Direction_Direction_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_Direction_descriptor();
template <typename T>
const std::string& AnimationField_Direction_Name(T value) {
  static_assert(std::is_same<T, AnimationField_Direction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Direction_Name().");
  return AnimationField_Direction_Name(static_cast<AnimationField_Direction>(value));
}
template <>
inline const std::string& AnimationField_Direction_Name(AnimationField_Direction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_Direction_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool AnimationField_Direction_Parse(absl::string_view name, AnimationField_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_Direction>(
      AnimationField_Direction_descriptor(), name, value);
}
enum AnimationField_TransitionDirection : int {
  AnimationField_TransitionDirection_IN = 0,
  AnimationField_TransitionDirection_OUT = 1,
  AnimationField_TransitionDirection_IN_SLIGHTLY = 2,
  AnimationField_TransitionDirection_OUT_SLIGHTLY = 3,
  AnimationField_TransitionDirection_IN_FROM_CENTER = 4,
  AnimationField_TransitionDirection_OUT_FROM_BOTTOM = 5,
  AnimationField_TransitionDirection_OUT_TO_CENTER = 6,
  AnimationField_TransitionDirection_IN_TO_BOTTOM = 7,
  AnimationField_TransitionDirection_AnimationField_TransitionDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_TransitionDirection_AnimationField_TransitionDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_TransitionDirection_IsValid(int value);
extern const uint32_t AnimationField_TransitionDirection_internal_data_[];
constexpr AnimationField_TransitionDirection AnimationField_TransitionDirection_TransitionDirection_MIN = static_cast<AnimationField_TransitionDirection>(0);
constexpr AnimationField_TransitionDirection AnimationField_TransitionDirection_TransitionDirection_MAX = static_cast<AnimationField_TransitionDirection>(7);
constexpr int AnimationField_TransitionDirection_TransitionDirection_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_TransitionDirection_descriptor();
template <typename T>
const std::string& AnimationField_TransitionDirection_Name(T value) {
  static_assert(std::is_same<T, AnimationField_TransitionDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TransitionDirection_Name().");
  return AnimationField_TransitionDirection_Name(static_cast<AnimationField_TransitionDirection>(value));
}
template <>
inline const std::string& AnimationField_TransitionDirection_Name(AnimationField_TransitionDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_TransitionDirection_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool AnimationField_TransitionDirection_Parse(absl::string_view name, AnimationField_TransitionDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_TransitionDirection>(
      AnimationField_TransitionDirection_descriptor(), name, value);
}
enum AnimationField_RotateDirection : int {
  AnimationField_RotateDirection_CLOCKWISE = 0,
  AnimationField_RotateDirection_ANTI_CLOCKWISE = 1,
  AnimationField_RotateDirection_AnimationField_RotateDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_RotateDirection_AnimationField_RotateDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_RotateDirection_IsValid(int value);
extern const uint32_t AnimationField_RotateDirection_internal_data_[];
constexpr AnimationField_RotateDirection AnimationField_RotateDirection_RotateDirection_MIN = static_cast<AnimationField_RotateDirection>(0);
constexpr AnimationField_RotateDirection AnimationField_RotateDirection_RotateDirection_MAX = static_cast<AnimationField_RotateDirection>(1);
constexpr int AnimationField_RotateDirection_RotateDirection_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_RotateDirection_descriptor();
template <typename T>
const std::string& AnimationField_RotateDirection_Name(T value) {
  static_assert(std::is_same<T, AnimationField_RotateDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RotateDirection_Name().");
  return AnimationField_RotateDirection_Name(static_cast<AnimationField_RotateDirection>(value));
}
template <>
inline const std::string& AnimationField_RotateDirection_Name(AnimationField_RotateDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_RotateDirection_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AnimationField_RotateDirection_Parse(absl::string_view name, AnimationField_RotateDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_RotateDirection>(
      AnimationField_RotateDirection_descriptor(), name, value);
}
enum AnimationField_ObjectType : int {
  AnimationField_ObjectType_STRIP = 0,
  AnimationField_ObjectType_PARTICLE = 1,
  AnimationField_ObjectType_AnimationField_ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_ObjectType_AnimationField_ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_ObjectType_IsValid(int value);
extern const uint32_t AnimationField_ObjectType_internal_data_[];
constexpr AnimationField_ObjectType AnimationField_ObjectType_ObjectType_MIN = static_cast<AnimationField_ObjectType>(0);
constexpr AnimationField_ObjectType AnimationField_ObjectType_ObjectType_MAX = static_cast<AnimationField_ObjectType>(1);
constexpr int AnimationField_ObjectType_ObjectType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_ObjectType_descriptor();
template <typename T>
const std::string& AnimationField_ObjectType_Name(T value) {
  static_assert(std::is_same<T, AnimationField_ObjectType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ObjectType_Name().");
  return AnimationField_ObjectType_Name(static_cast<AnimationField_ObjectType>(value));
}
template <>
inline const std::string& AnimationField_ObjectType_Name(AnimationField_ObjectType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_ObjectType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AnimationField_ObjectType_Parse(absl::string_view name, AnimationField_ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_ObjectType>(
      AnimationField_ObjectType_descriptor(), name, value);
}
enum AnimationField_AnimationStart : int {
  AnimationField_AnimationStart_CLICK = 0,
  AnimationField_AnimationStart_WITHEFFECT = 1,
  AnimationField_AnimationStart_AFTEREFFECT = 2,
  AnimationField_AnimationStart_AnimationField_AnimationStart_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_AnimationStart_AnimationField_AnimationStart_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_AnimationStart_IsValid(int value);
extern const uint32_t AnimationField_AnimationStart_internal_data_[];
constexpr AnimationField_AnimationStart AnimationField_AnimationStart_AnimationStart_MIN = static_cast<AnimationField_AnimationStart>(0);
constexpr AnimationField_AnimationStart AnimationField_AnimationStart_AnimationStart_MAX = static_cast<AnimationField_AnimationStart>(2);
constexpr int AnimationField_AnimationStart_AnimationStart_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_AnimationStart_descriptor();
template <typename T>
const std::string& AnimationField_AnimationStart_Name(T value) {
  static_assert(std::is_same<T, AnimationField_AnimationStart>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AnimationStart_Name().");
  return AnimationField_AnimationStart_Name(static_cast<AnimationField_AnimationStart>(value));
}
template <>
inline const std::string& AnimationField_AnimationStart_Name(AnimationField_AnimationStart value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_AnimationStart_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AnimationField_AnimationStart_Parse(absl::string_view name, AnimationField_AnimationStart* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_AnimationStart>(
      AnimationField_AnimationStart_descriptor(), name, value);
}
enum AnimationField_AnimationMatchType : int {
  AnimationField_AnimationMatchType_UNKNOWN_MATCH_TYPE = 0,
  AnimationField_AnimationMatchType_OBJECT = 1,
  AnimationField_AnimationMatchType_WORD = 2,
  AnimationField_AnimationMatchType_CHAR = 3,
  AnimationField_AnimationMatchType_AnimationField_AnimationMatchType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_AnimationMatchType_AnimationField_AnimationMatchType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_AnimationMatchType_IsValid(int value);
extern const uint32_t AnimationField_AnimationMatchType_internal_data_[];
constexpr AnimationField_AnimationMatchType AnimationField_AnimationMatchType_AnimationMatchType_MIN = static_cast<AnimationField_AnimationMatchType>(0);
constexpr AnimationField_AnimationMatchType AnimationField_AnimationMatchType_AnimationMatchType_MAX = static_cast<AnimationField_AnimationMatchType>(3);
constexpr int AnimationField_AnimationMatchType_AnimationMatchType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_AnimationMatchType_descriptor();
template <typename T>
const std::string& AnimationField_AnimationMatchType_Name(T value) {
  static_assert(std::is_same<T, AnimationField_AnimationMatchType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AnimationMatchType_Name().");
  return AnimationField_AnimationMatchType_Name(static_cast<AnimationField_AnimationMatchType>(value));
}
template <>
inline const std::string& AnimationField_AnimationMatchType_Name(AnimationField_AnimationMatchType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_AnimationMatchType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AnimationField_AnimationMatchType_Parse(absl::string_view name, AnimationField_AnimationMatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_AnimationMatchType>(
      AnimationField_AnimationMatchType_descriptor(), name, value);
}
enum AnimationField_AnimationMatchBasis : int {
  AnimationField_AnimationMatchBasis_UNKNOWN_MATCH_BASIS = 0,
  AnimationField_AnimationMatchBasis_OBJECT_NAME = 1,
  AnimationField_AnimationMatchBasis_AnimationField_AnimationMatchBasis_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AnimationField_AnimationMatchBasis_AnimationField_AnimationMatchBasis_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AnimationField_AnimationMatchBasis_IsValid(int value);
extern const uint32_t AnimationField_AnimationMatchBasis_internal_data_[];
constexpr AnimationField_AnimationMatchBasis AnimationField_AnimationMatchBasis_AnimationMatchBasis_MIN = static_cast<AnimationField_AnimationMatchBasis>(0);
constexpr AnimationField_AnimationMatchBasis AnimationField_AnimationMatchBasis_AnimationMatchBasis_MAX = static_cast<AnimationField_AnimationMatchBasis>(1);
constexpr int AnimationField_AnimationMatchBasis_AnimationMatchBasis_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
AnimationField_AnimationMatchBasis_descriptor();
template <typename T>
const std::string& AnimationField_AnimationMatchBasis_Name(T value) {
  static_assert(std::is_same<T, AnimationField_AnimationMatchBasis>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AnimationMatchBasis_Name().");
  return AnimationField_AnimationMatchBasis_Name(static_cast<AnimationField_AnimationMatchBasis>(value));
}
template <>
inline const std::string& AnimationField_AnimationMatchBasis_Name(AnimationField_AnimationMatchBasis value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AnimationField_AnimationMatchBasis_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool AnimationField_AnimationMatchBasis_Parse(absl::string_view name, AnimationField_AnimationMatchBasis* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnimationField_AnimationMatchBasis>(
      AnimationField_AnimationMatchBasis_descriptor(), name, value);
}
enum MemberField_MemberRoleType : int {
  MemberField_MemberRoleType_UNKNOWN_MEMBER_ROLE_TYPE = 0,
  MemberField_MemberRoleType_ADMIN = 1,
  MemberField_MemberRoleType_EDITOR = 2,
  MemberField_MemberRoleType_VIEWER = 3,
  MemberField_MemberRoleType_GUEST_EDITOR = 4,
  MemberField_MemberRoleType_GUEST_COMMENTER = 5,
  MemberField_MemberRoleType_GUEST_VIEWER = 6,
  MemberField_MemberRoleType_MemberField_MemberRoleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MemberField_MemberRoleType_MemberField_MemberRoleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MemberField_MemberRoleType_IsValid(int value);
extern const uint32_t MemberField_MemberRoleType_internal_data_[];
constexpr MemberField_MemberRoleType MemberField_MemberRoleType_MemberRoleType_MIN = static_cast<MemberField_MemberRoleType>(0);
constexpr MemberField_MemberRoleType MemberField_MemberRoleType_MemberRoleType_MAX = static_cast<MemberField_MemberRoleType>(6);
constexpr int MemberField_MemberRoleType_MemberRoleType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
MemberField_MemberRoleType_descriptor();
template <typename T>
const std::string& MemberField_MemberRoleType_Name(T value) {
  static_assert(std::is_same<T, MemberField_MemberRoleType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MemberRoleType_Name().");
  return MemberField_MemberRoleType_Name(static_cast<MemberField_MemberRoleType>(value));
}
template <>
inline const std::string& MemberField_MemberRoleType_Name(MemberField_MemberRoleType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MemberField_MemberRoleType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool MemberField_MemberRoleType_Parse(absl::string_view name, MemberField_MemberRoleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemberField_MemberRoleType>(
      MemberField_MemberRoleType_descriptor(), name, value);
}
enum DocumentStatusField_DocumentStatusType : int {
  DocumentStatusField_DocumentStatusType_UNKNOWN_STATUS = 0,
  DocumentStatusField_DocumentStatusType_DESIGN_IN_PROGRESS = 1,
  DocumentStatusField_DocumentStatusType_UNDER_DISCUSSION = 2,
  DocumentStatusField_DocumentStatusType_READY_FOR_DEVELOPMENT = 3,
  DocumentStatusField_DocumentStatusType_CUSTOM = 4,
  DocumentStatusField_DocumentStatusType_UNDER_DEVELOPMENT = 5,
  DocumentStatusField_DocumentStatusType_DEVELOPED = 6,
  DocumentStatusField_DocumentStatusType_REQUEST_FOR_MODIFICATION = 7,
  DocumentStatusField_DocumentStatusType_MODIFICATION_IN_PROGRESS = 8,
  DocumentStatusField_DocumentStatusType_DISCREPANCY_NOTED = 9,
  DocumentStatusField_DocumentStatusType_RELEASED = 10,
  DocumentStatusField_DocumentStatusType_DocumentStatusField_DocumentStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DocumentStatusField_DocumentStatusType_DocumentStatusField_DocumentStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DocumentStatusField_DocumentStatusType_IsValid(int value);
extern const uint32_t DocumentStatusField_DocumentStatusType_internal_data_[];
constexpr DocumentStatusField_DocumentStatusType DocumentStatusField_DocumentStatusType_DocumentStatusType_MIN = static_cast<DocumentStatusField_DocumentStatusType>(0);
constexpr DocumentStatusField_DocumentStatusType DocumentStatusField_DocumentStatusType_DocumentStatusType_MAX = static_cast<DocumentStatusField_DocumentStatusType>(10);
constexpr int DocumentStatusField_DocumentStatusType_DocumentStatusType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
DocumentStatusField_DocumentStatusType_descriptor();
template <typename T>
const std::string& DocumentStatusField_DocumentStatusType_Name(T value) {
  static_assert(std::is_same<T, DocumentStatusField_DocumentStatusType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DocumentStatusType_Name().");
  return DocumentStatusField_DocumentStatusType_Name(static_cast<DocumentStatusField_DocumentStatusType>(value));
}
template <>
inline const std::string& DocumentStatusField_DocumentStatusType_Name(DocumentStatusField_DocumentStatusType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DocumentStatusField_DocumentStatusType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool DocumentStatusField_DocumentStatusType_Parse(absl::string_view name, DocumentStatusField_DocumentStatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DocumentStatusField_DocumentStatusType>(
      DocumentStatusField_DocumentStatusType_descriptor(), name, value);
}
enum DataSourceField_DataSourceServiceType : int {
  DataSourceField_DataSourceServiceType_UNKNOWN_SERVICE = 0,
  DataSourceField_DataSourceServiceType_ZOHO_SHEET = 1,
  DataSourceField_DataSourceServiceType_ZOHO_CRM = 2,
  DataSourceField_DataSourceServiceType_ZOHO_SURVEY = 3,
  DataSourceField_DataSourceServiceType_DataSourceField_DataSourceServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataSourceField_DataSourceServiceType_DataSourceField_DataSourceServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataSourceField_DataSourceServiceType_IsValid(int value);
extern const uint32_t DataSourceField_DataSourceServiceType_internal_data_[];
constexpr DataSourceField_DataSourceServiceType DataSourceField_DataSourceServiceType_DataSourceServiceType_MIN = static_cast<DataSourceField_DataSourceServiceType>(0);
constexpr DataSourceField_DataSourceServiceType DataSourceField_DataSourceServiceType_DataSourceServiceType_MAX = static_cast<DataSourceField_DataSourceServiceType>(3);
constexpr int DataSourceField_DataSourceServiceType_DataSourceServiceType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DataSourceField_DataSourceServiceType_descriptor();
template <typename T>
const std::string& DataSourceField_DataSourceServiceType_Name(T value) {
  static_assert(std::is_same<T, DataSourceField_DataSourceServiceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataSourceServiceType_Name().");
  return DataSourceField_DataSourceServiceType_Name(static_cast<DataSourceField_DataSourceServiceType>(value));
}
template <>
inline const std::string& DataSourceField_DataSourceServiceType_Name(DataSourceField_DataSourceServiceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DataSourceField_DataSourceServiceType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DataSourceField_DataSourceServiceType_Parse(absl::string_view name, DataSourceField_DataSourceServiceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataSourceField_DataSourceServiceType>(
      DataSourceField_DataSourceServiceType_descriptor(), name, value);
}
enum DatabaseField_TableOrColumnCategory : int {
  DatabaseField_TableOrColumnCategory_DEFAULT_TABLE_COLUMN = 0,
  DatabaseField_TableOrColumnCategory_PARENT = 1,
  DatabaseField_TableOrColumnCategory_CHILD = 2,
  DatabaseField_TableOrColumnCategory_DatabaseField_TableOrColumnCategory_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_TableOrColumnCategory_DatabaseField_TableOrColumnCategory_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_TableOrColumnCategory_IsValid(int value);
extern const uint32_t DatabaseField_TableOrColumnCategory_internal_data_[];
constexpr DatabaseField_TableOrColumnCategory DatabaseField_TableOrColumnCategory_TableOrColumnCategory_MIN = static_cast<DatabaseField_TableOrColumnCategory>(0);
constexpr DatabaseField_TableOrColumnCategory DatabaseField_TableOrColumnCategory_TableOrColumnCategory_MAX = static_cast<DatabaseField_TableOrColumnCategory>(2);
constexpr int DatabaseField_TableOrColumnCategory_TableOrColumnCategory_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_TableOrColumnCategory_descriptor();
template <typename T>
const std::string& DatabaseField_TableOrColumnCategory_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_TableOrColumnCategory>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TableOrColumnCategory_Name().");
  return DatabaseField_TableOrColumnCategory_Name(static_cast<DatabaseField_TableOrColumnCategory>(value));
}
template <>
inline const std::string& DatabaseField_TableOrColumnCategory_Name(DatabaseField_TableOrColumnCategory value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_TableOrColumnCategory_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DatabaseField_TableOrColumnCategory_Parse(absl::string_view name, DatabaseField_TableOrColumnCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_TableOrColumnCategory>(
      DatabaseField_TableOrColumnCategory_descriptor(), name, value);
}
enum DatabaseField_WhereOperator : int {
  DatabaseField_WhereOperator_DEFAULT_WHERE_OPERATOR = 0,
  DatabaseField_WhereOperator_COMPARISON = 1,
  DatabaseField_WhereOperator_PATTERN = 2,
  DatabaseField_WhereOperator_DatabaseField_WhereOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_WhereOperator_DatabaseField_WhereOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_WhereOperator_IsValid(int value);
extern const uint32_t DatabaseField_WhereOperator_internal_data_[];
constexpr DatabaseField_WhereOperator DatabaseField_WhereOperator_WhereOperator_MIN = static_cast<DatabaseField_WhereOperator>(0);
constexpr DatabaseField_WhereOperator DatabaseField_WhereOperator_WhereOperator_MAX = static_cast<DatabaseField_WhereOperator>(2);
constexpr int DatabaseField_WhereOperator_WhereOperator_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_WhereOperator_descriptor();
template <typename T>
const std::string& DatabaseField_WhereOperator_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_WhereOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WhereOperator_Name().");
  return DatabaseField_WhereOperator_Name(static_cast<DatabaseField_WhereOperator>(value));
}
template <>
inline const std::string& DatabaseField_WhereOperator_Name(DatabaseField_WhereOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_WhereOperator_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DatabaseField_WhereOperator_Parse(absl::string_view name, DatabaseField_WhereOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_WhereOperator>(
      DatabaseField_WhereOperator_descriptor(), name, value);
}
enum DatabaseField_ComparisonOperator : int {
  DatabaseField_ComparisonOperator_DEFAULT_COMPARISON_OPERATOR = 0,
  DatabaseField_ComparisonOperator_EQUALS = 1,
  DatabaseField_ComparisonOperator_NOT_EQUALS = 2,
  DatabaseField_ComparisonOperator_GREATER_THAN = 3,
  DatabaseField_ComparisonOperator_LESSER_THAN = 4,
  DatabaseField_ComparisonOperator_GREATER_THAN_OR_EQUALS = 5,
  DatabaseField_ComparisonOperator_LESSER_THAN_OR_EQUALS = 6,
  DatabaseField_ComparisonOperator_DatabaseField_ComparisonOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_ComparisonOperator_DatabaseField_ComparisonOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_ComparisonOperator_IsValid(int value);
extern const uint32_t DatabaseField_ComparisonOperator_internal_data_[];
constexpr DatabaseField_ComparisonOperator DatabaseField_ComparisonOperator_ComparisonOperator_MIN = static_cast<DatabaseField_ComparisonOperator>(0);
constexpr DatabaseField_ComparisonOperator DatabaseField_ComparisonOperator_ComparisonOperator_MAX = static_cast<DatabaseField_ComparisonOperator>(6);
constexpr int DatabaseField_ComparisonOperator_ComparisonOperator_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_ComparisonOperator_descriptor();
template <typename T>
const std::string& DatabaseField_ComparisonOperator_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_ComparisonOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ComparisonOperator_Name().");
  return DatabaseField_ComparisonOperator_Name(static_cast<DatabaseField_ComparisonOperator>(value));
}
template <>
inline const std::string& DatabaseField_ComparisonOperator_Name(DatabaseField_ComparisonOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_ComparisonOperator_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool DatabaseField_ComparisonOperator_Parse(absl::string_view name, DatabaseField_ComparisonOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_ComparisonOperator>(
      DatabaseField_ComparisonOperator_descriptor(), name, value);
}
enum DatabaseField_LogicalOperator : int {
  DatabaseField_LogicalOperator_DEFAULT_LOGICAL_OPERATOR = 0,
  DatabaseField_LogicalOperator_AND = 1,
  DatabaseField_LogicalOperator_OR = 2,
  DatabaseField_LogicalOperator_NOT = 3,
  DatabaseField_LogicalOperator_DatabaseField_LogicalOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_LogicalOperator_DatabaseField_LogicalOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_LogicalOperator_IsValid(int value);
extern const uint32_t DatabaseField_LogicalOperator_internal_data_[];
constexpr DatabaseField_LogicalOperator DatabaseField_LogicalOperator_LogicalOperator_MIN = static_cast<DatabaseField_LogicalOperator>(0);
constexpr DatabaseField_LogicalOperator DatabaseField_LogicalOperator_LogicalOperator_MAX = static_cast<DatabaseField_LogicalOperator>(3);
constexpr int DatabaseField_LogicalOperator_LogicalOperator_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_LogicalOperator_descriptor();
template <typename T>
const std::string& DatabaseField_LogicalOperator_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_LogicalOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LogicalOperator_Name().");
  return DatabaseField_LogicalOperator_Name(static_cast<DatabaseField_LogicalOperator>(value));
}
template <>
inline const std::string& DatabaseField_LogicalOperator_Name(DatabaseField_LogicalOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_LogicalOperator_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DatabaseField_LogicalOperator_Parse(absl::string_view name, DatabaseField_LogicalOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_LogicalOperator>(
      DatabaseField_LogicalOperator_descriptor(), name, value);
}
enum DatabaseField_SubQueryOperator : int {
  DatabaseField_SubQueryOperator_DEFAULT_SUB_QUERY_OPERATOR = 0,
  DatabaseField_SubQueryOperator_START_SUB_QUERY = 1,
  DatabaseField_SubQueryOperator_END_SUB_QUERY = 2,
  DatabaseField_SubQueryOperator_DatabaseField_SubQueryOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_SubQueryOperator_DatabaseField_SubQueryOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_SubQueryOperator_IsValid(int value);
extern const uint32_t DatabaseField_SubQueryOperator_internal_data_[];
constexpr DatabaseField_SubQueryOperator DatabaseField_SubQueryOperator_SubQueryOperator_MIN = static_cast<DatabaseField_SubQueryOperator>(0);
constexpr DatabaseField_SubQueryOperator DatabaseField_SubQueryOperator_SubQueryOperator_MAX = static_cast<DatabaseField_SubQueryOperator>(2);
constexpr int DatabaseField_SubQueryOperator_SubQueryOperator_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_SubQueryOperator_descriptor();
template <typename T>
const std::string& DatabaseField_SubQueryOperator_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_SubQueryOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SubQueryOperator_Name().");
  return DatabaseField_SubQueryOperator_Name(static_cast<DatabaseField_SubQueryOperator>(value));
}
template <>
inline const std::string& DatabaseField_SubQueryOperator_Name(DatabaseField_SubQueryOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_SubQueryOperator_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DatabaseField_SubQueryOperator_Parse(absl::string_view name, DatabaseField_SubQueryOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_SubQueryOperator>(
      DatabaseField_SubQueryOperator_descriptor(), name, value);
}
enum DatabaseField_PatternOperator : int {
  DatabaseField_PatternOperator_DEFAULT_PATTERN_OPERATOR = 0,
  DatabaseField_PatternOperator_IN = 1,
  DatabaseField_PatternOperator_BETWEEN = 2,
  DatabaseField_PatternOperator_LIKE = 3,
  DatabaseField_PatternOperator_STARTS_WITH = 4,
  DatabaseField_PatternOperator_ENDS_WITH = 5,
  DatabaseField_PatternOperator_EXISTS = 6,
  DatabaseField_PatternOperator_SOME = 7,
  DatabaseField_PatternOperator_ANY = 8,
  DatabaseField_PatternOperator_ALL = 9,
  DatabaseField_PatternOperator_DatabaseField_PatternOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_PatternOperator_DatabaseField_PatternOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_PatternOperator_IsValid(int value);
extern const uint32_t DatabaseField_PatternOperator_internal_data_[];
constexpr DatabaseField_PatternOperator DatabaseField_PatternOperator_PatternOperator_MIN = static_cast<DatabaseField_PatternOperator>(0);
constexpr DatabaseField_PatternOperator DatabaseField_PatternOperator_PatternOperator_MAX = static_cast<DatabaseField_PatternOperator>(9);
constexpr int DatabaseField_PatternOperator_PatternOperator_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_PatternOperator_descriptor();
template <typename T>
const std::string& DatabaseField_PatternOperator_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_PatternOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PatternOperator_Name().");
  return DatabaseField_PatternOperator_Name(static_cast<DatabaseField_PatternOperator>(value));
}
template <>
inline const std::string& DatabaseField_PatternOperator_Name(DatabaseField_PatternOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_PatternOperator_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool DatabaseField_PatternOperator_Parse(absl::string_view name, DatabaseField_PatternOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_PatternOperator>(
      DatabaseField_PatternOperator_descriptor(), name, value);
}
enum DatabaseField_SortOrder : int {
  DatabaseField_SortOrder_DEFAULT_SORT_ORDER = 0,
  DatabaseField_SortOrder_ASCENDING = 1,
  DatabaseField_SortOrder_DESCENDING = 2,
  DatabaseField_SortOrder_DatabaseField_SortOrder_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_SortOrder_DatabaseField_SortOrder_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_SortOrder_IsValid(int value);
extern const uint32_t DatabaseField_SortOrder_internal_data_[];
constexpr DatabaseField_SortOrder DatabaseField_SortOrder_SortOrder_MIN = static_cast<DatabaseField_SortOrder>(0);
constexpr DatabaseField_SortOrder DatabaseField_SortOrder_SortOrder_MAX = static_cast<DatabaseField_SortOrder>(2);
constexpr int DatabaseField_SortOrder_SortOrder_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_SortOrder_descriptor();
template <typename T>
const std::string& DatabaseField_SortOrder_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_SortOrder>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SortOrder_Name().");
  return DatabaseField_SortOrder_Name(static_cast<DatabaseField_SortOrder>(value));
}
template <>
inline const std::string& DatabaseField_SortOrder_Name(DatabaseField_SortOrder value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_SortOrder_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DatabaseField_SortOrder_Parse(absl::string_view name, DatabaseField_SortOrder* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_SortOrder>(
      DatabaseField_SortOrder_descriptor(), name, value);
}
enum DatabaseField_DataOperator : int {
  DatabaseField_DataOperator_DEFAULT_DATA_OPERATOR = 0,
  DatabaseField_DataOperator_INSERT = 1,
  DatabaseField_DataOperator_MODIFY = 2,
  DatabaseField_DataOperator_DELETE = 3,
  DatabaseField_DataOperator_SELECT = 4,
  DatabaseField_DataOperator_DatabaseField_DataOperator_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_DataOperator_DatabaseField_DataOperator_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_DataOperator_IsValid(int value);
extern const uint32_t DatabaseField_DataOperator_internal_data_[];
constexpr DatabaseField_DataOperator DatabaseField_DataOperator_DataOperator_MIN = static_cast<DatabaseField_DataOperator>(0);
constexpr DatabaseField_DataOperator DatabaseField_DataOperator_DataOperator_MAX = static_cast<DatabaseField_DataOperator>(4);
constexpr int DatabaseField_DataOperator_DataOperator_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_DataOperator_descriptor();
template <typename T>
const std::string& DatabaseField_DataOperator_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_DataOperator>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataOperator_Name().");
  return DatabaseField_DataOperator_Name(static_cast<DatabaseField_DataOperator>(value));
}
template <>
inline const std::string& DatabaseField_DataOperator_Name(DatabaseField_DataOperator value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_DataOperator_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool DatabaseField_DataOperator_Parse(absl::string_view name, DatabaseField_DataOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_DataOperator>(
      DatabaseField_DataOperator_descriptor(), name, value);
}
enum DatabaseField_DataOperatedOn : int {
  DatabaseField_DataOperatedOn_DEFAULT_DATA_OPERATED_ON = 0,
  DatabaseField_DataOperatedOn_TABLE = 1,
  DatabaseField_DataOperatedOn_COLUMN = 2,
  DatabaseField_DataOperatedOn_ROW = 3,
  DatabaseField_DataOperatedOn_DatabaseField_DataOperatedOn_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DatabaseField_DataOperatedOn_DatabaseField_DataOperatedOn_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DatabaseField_DataOperatedOn_IsValid(int value);
extern const uint32_t DatabaseField_DataOperatedOn_internal_data_[];
constexpr DatabaseField_DataOperatedOn DatabaseField_DataOperatedOn_DataOperatedOn_MIN = static_cast<DatabaseField_DataOperatedOn>(0);
constexpr DatabaseField_DataOperatedOn DatabaseField_DataOperatedOn_DataOperatedOn_MAX = static_cast<DatabaseField_DataOperatedOn>(3);
constexpr int DatabaseField_DataOperatedOn_DataOperatedOn_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DatabaseField_DataOperatedOn_descriptor();
template <typename T>
const std::string& DatabaseField_DataOperatedOn_Name(T value) {
  static_assert(std::is_same<T, DatabaseField_DataOperatedOn>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataOperatedOn_Name().");
  return DatabaseField_DataOperatedOn_Name(static_cast<DatabaseField_DataOperatedOn>(value));
}
template <>
inline const std::string& DatabaseField_DataOperatedOn_Name(DatabaseField_DataOperatedOn value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DatabaseField_DataOperatedOn_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DatabaseField_DataOperatedOn_Parse(absl::string_view name, DatabaseField_DataOperatedOn* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseField_DataOperatedOn>(
      DatabaseField_DataOperatedOn_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TableField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.TableField) */ {
 public:
  inline TableField() : TableField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TableField(::google::protobuf::internal::ConstantInitialized);

  inline TableField(const TableField& from)
      : TableField(nullptr, from) {}
  TableField(TableField&& from) noexcept
    : TableField() {
    *this = ::std::move(from);
  }

  inline TableField& operator=(const TableField& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableField& operator=(TableField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableField& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableField* internal_default_instance() {
    return reinterpret_cast<const TableField*>(
               &_TableField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TableField& a, TableField& b) {
    a.Swap(&b);
  }
  inline void Swap(TableField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TableField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TableField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.TableField";
  }
  protected:
  explicit TableField(::google::protobuf::Arena* arena);
  TableField(::google::protobuf::Arena* arena, const TableField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TextDirection = TableField_TextDirection;
  static constexpr TextDirection HORIZONTAL = TableField_TextDirection_HORIZONTAL;
  static constexpr TextDirection VERTICAL = TableField_TextDirection_VERTICAL;
  static constexpr TextDirection VERTICAL270 = TableField_TextDirection_VERTICAL270;
  static constexpr TextDirection WORDARTVERTICAL = TableField_TextDirection_WORDARTVERTICAL;
  static inline bool TextDirection_IsValid(int value) {
    return TableField_TextDirection_IsValid(value);
  }
  static constexpr TextDirection TextDirection_MIN = TableField_TextDirection_TextDirection_MIN;
  static constexpr TextDirection TextDirection_MAX = TableField_TextDirection_TextDirection_MAX;
  static constexpr int TextDirection_ARRAYSIZE = TableField_TextDirection_TextDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TextDirection_descriptor() {
    return TableField_TextDirection_descriptor();
  }
  template <typename T>
  static inline const std::string& TextDirection_Name(T value) {
    return TableField_TextDirection_Name(value);
  }
  static inline bool TextDirection_Parse(absl::string_view name, TextDirection* value) {
    return TableField_TextDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.TableField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class StrokeField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.StrokeField) */ {
 public:
  inline StrokeField() : StrokeField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StrokeField(::google::protobuf::internal::ConstantInitialized);

  inline StrokeField(const StrokeField& from)
      : StrokeField(nullptr, from) {}
  StrokeField(StrokeField&& from) noexcept
    : StrokeField() {
    *this = ::std::move(from);
  }

  inline StrokeField& operator=(const StrokeField& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrokeField& operator=(StrokeField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrokeField& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrokeField* internal_default_instance() {
    return reinterpret_cast<const StrokeField*>(
               &_StrokeField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StrokeField& a, StrokeField& b) {
    a.Swap(&b);
  }
  inline void Swap(StrokeField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrokeField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrokeField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrokeField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StrokeField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StrokeField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.StrokeField";
  }
  protected:
  explicit StrokeField(::google::protobuf::Arena* arena);
  StrokeField(::google::protobuf::Arena* arena, const StrokeField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CapType = StrokeField_CapType;
  static constexpr CapType DEF_CAP_TYPE = StrokeField_CapType_DEF_CAP_TYPE;
  static constexpr CapType FLAT = StrokeField_CapType_FLAT;
  static constexpr CapType CAPROUND = StrokeField_CapType_CAPROUND;
  static constexpr CapType SQUARE = StrokeField_CapType_SQUARE;
  static inline bool CapType_IsValid(int value) {
    return StrokeField_CapType_IsValid(value);
  }
  static constexpr CapType CapType_MIN = StrokeField_CapType_CapType_MIN;
  static constexpr CapType CapType_MAX = StrokeField_CapType_CapType_MAX;
  static constexpr int CapType_ARRAYSIZE = StrokeField_CapType_CapType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CapType_descriptor() {
    return StrokeField_CapType_descriptor();
  }
  template <typename T>
  static inline const std::string& CapType_Name(T value) {
    return StrokeField_CapType_Name(value);
  }
  static inline bool CapType_Parse(absl::string_view name, CapType* value) {
    return StrokeField_CapType_Parse(name, value);
  }

  using StrokeType = StrokeField_StrokeType;
  static constexpr StrokeType SOLID = StrokeField_StrokeType_SOLID;
  static constexpr StrokeType DASH = StrokeField_StrokeType_DASH;
  static constexpr StrokeType ROUND_DOT = StrokeField_StrokeType_ROUND_DOT;
  static constexpr StrokeType SQUARE_DOT = StrokeField_StrokeType_SQUARE_DOT;
  static constexpr StrokeType LONG_DASH = StrokeField_StrokeType_LONG_DASH;
  static constexpr StrokeType DASHDOT = StrokeField_StrokeType_DASHDOT;
  static constexpr StrokeType LONG_DASH_DOT = StrokeField_StrokeType_LONG_DASH_DOT;
  static constexpr StrokeType LONG_DASH_DOT_DOT = StrokeField_StrokeType_LONG_DASH_DOT_DOT;
  static constexpr StrokeType DASH_PATTERN = StrokeField_StrokeType_DASH_PATTERN;
  static inline bool StrokeType_IsValid(int value) {
    return StrokeField_StrokeType_IsValid(value);
  }
  static constexpr StrokeType StrokeType_MIN = StrokeField_StrokeType_StrokeType_MIN;
  static constexpr StrokeType StrokeType_MAX = StrokeField_StrokeType_StrokeType_MAX;
  static constexpr int StrokeType_ARRAYSIZE = StrokeField_StrokeType_StrokeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StrokeType_descriptor() {
    return StrokeField_StrokeType_descriptor();
  }
  template <typename T>
  static inline const std::string& StrokeType_Name(T value) {
    return StrokeField_StrokeType_Name(value);
  }
  static inline bool StrokeType_Parse(absl::string_view name, StrokeType* value) {
    return StrokeField_StrokeType_Parse(name, value);
  }

  using JoinType = StrokeField_JoinType;
  static constexpr JoinType DEF_JOIN_TYPE = StrokeField_JoinType_DEF_JOIN_TYPE;
  static constexpr JoinType ROUND = StrokeField_JoinType_ROUND;
  static constexpr JoinType BEVEL = StrokeField_JoinType_BEVEL;
  static constexpr JoinType MITER = StrokeField_JoinType_MITER;
  static inline bool JoinType_IsValid(int value) {
    return StrokeField_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN = StrokeField_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX = StrokeField_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE = StrokeField_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JoinType_descriptor() {
    return StrokeField_JoinType_descriptor();
  }
  template <typename T>
  static inline const std::string& JoinType_Name(T value) {
    return StrokeField_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(absl::string_view name, JoinType* value) {
    return StrokeField_JoinType_Parse(name, value);
  }

  using MarkerType = StrokeField_MarkerType;
  static constexpr MarkerType DEF_MARKER_TYPE = StrokeField_MarkerType_DEF_MARKER_TYPE;
  static constexpr MarkerType NONE = StrokeField_MarkerType_NONE;
  static constexpr MarkerType OPEN = StrokeField_MarkerType_OPEN;
  static constexpr MarkerType BLOCK = StrokeField_MarkerType_BLOCK;
  static constexpr MarkerType CLASSIC = StrokeField_MarkerType_CLASSIC;
  static constexpr MarkerType DIAMOND = StrokeField_MarkerType_DIAMOND;
  static constexpr MarkerType OVAL = StrokeField_MarkerType_OVAL;
  static constexpr MarkerType HOLLOW_DIAMOND = StrokeField_MarkerType_HOLLOW_DIAMOND;
  static constexpr MarkerType HOLLOW_ARROW_HEAD = StrokeField_MarkerType_HOLLOW_ARROW_HEAD;
  static constexpr MarkerType HOLLOW_CIRCLE = StrokeField_MarkerType_HOLLOW_CIRCLE;
  static constexpr MarkerType AGGREGATION = StrokeField_MarkerType_AGGREGATION;
  static constexpr MarkerType COMPOSITION = StrokeField_MarkerType_COMPOSITION;
  static constexpr MarkerType TERMINATE = StrokeField_MarkerType_TERMINATE;
  static constexpr MarkerType ZERO_OR_ONE = StrokeField_MarkerType_ZERO_OR_ONE;
  static constexpr MarkerType ONE = StrokeField_MarkerType_ONE;
  static constexpr MarkerType ONE_OPTIONAL = StrokeField_MarkerType_ONE_OPTIONAL;
  static constexpr MarkerType MANY = StrokeField_MarkerType_MANY;
  static constexpr MarkerType ZERO_OR_MANY = StrokeField_MarkerType_ZERO_OR_MANY;
  static constexpr MarkerType ONE_MANDATORY = StrokeField_MarkerType_ONE_MANDATORY;
  static constexpr MarkerType ONE_OR_MANY = StrokeField_MarkerType_ONE_OR_MANY;
  static constexpr MarkerType PORT_SYMBOL = StrokeField_MarkerType_PORT_SYMBOL;
  static constexpr MarkerType DIAMOND_START = StrokeField_MarkerType_DIAMOND_START;
  static constexpr MarkerType OVAL_START = StrokeField_MarkerType_OVAL_START;
  static constexpr MarkerType HOLLOW_DIAMOND_START = StrokeField_MarkerType_HOLLOW_DIAMOND_START;
  static constexpr MarkerType HOLLOW_CIRCLE_START = StrokeField_MarkerType_HOLLOW_CIRCLE_START;
  static inline bool MarkerType_IsValid(int value) {
    return StrokeField_MarkerType_IsValid(value);
  }
  static constexpr MarkerType MarkerType_MIN = StrokeField_MarkerType_MarkerType_MIN;
  static constexpr MarkerType MarkerType_MAX = StrokeField_MarkerType_MarkerType_MAX;
  static constexpr int MarkerType_ARRAYSIZE = StrokeField_MarkerType_MarkerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MarkerType_descriptor() {
    return StrokeField_MarkerType_descriptor();
  }
  template <typename T>
  static inline const std::string& MarkerType_Name(T value) {
    return StrokeField_MarkerType_Name(value);
  }
  static inline bool MarkerType_Parse(absl::string_view name, MarkerType* value) {
    return StrokeField_MarkerType_Parse(name, value);
  }

  using Size = StrokeField_Size;
  static constexpr Size DEF_MARKER_SIZE = StrokeField_Size_DEF_MARKER_SIZE;
  static constexpr Size NARROW = StrokeField_Size_NARROW;
  static constexpr Size MEDIUM = StrokeField_Size_MEDIUM;
  static constexpr Size WIDE = StrokeField_Size_WIDE;
  static constexpr Size EXTRA_WIDE = StrokeField_Size_EXTRA_WIDE;
  static inline bool Size_IsValid(int value) {
    return StrokeField_Size_IsValid(value);
  }
  static constexpr Size Size_MIN = StrokeField_Size_Size_MIN;
  static constexpr Size Size_MAX = StrokeField_Size_Size_MAX;
  static constexpr int Size_ARRAYSIZE = StrokeField_Size_Size_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Size_descriptor() {
    return StrokeField_Size_descriptor();
  }
  template <typename T>
  static inline const std::string& Size_Name(T value) {
    return StrokeField_Size_Name(value);
  }
  static inline bool Size_Parse(absl::string_view name, Size* value) {
    return StrokeField_Size_Parse(name, value);
  }

  using StrokePosition = StrokeField_StrokePosition;
  static constexpr StrokePosition UNKNOWN_POSITION = StrokeField_StrokePosition_UNKNOWN_POSITION;
  static constexpr StrokePosition CENTER = StrokeField_StrokePosition_CENTER;
  static constexpr StrokePosition INSIDE = StrokeField_StrokePosition_INSIDE;
  static constexpr StrokePosition OUTSIDE = StrokeField_StrokePosition_OUTSIDE;
  static inline bool StrokePosition_IsValid(int value) {
    return StrokeField_StrokePosition_IsValid(value);
  }
  static constexpr StrokePosition StrokePosition_MIN = StrokeField_StrokePosition_StrokePosition_MIN;
  static constexpr StrokePosition StrokePosition_MAX = StrokeField_StrokePosition_StrokePosition_MAX;
  static constexpr int StrokePosition_ARRAYSIZE = StrokeField_StrokePosition_StrokePosition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* StrokePosition_descriptor() {
    return StrokeField_StrokePosition_descriptor();
  }
  template <typename T>
  static inline const std::string& StrokePosition_Name(T value) {
    return StrokeField_StrokePosition_Name(value);
  }
  static inline bool StrokePosition_Parse(absl::string_view name, StrokePosition* value) {
    return StrokeField_StrokePosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.StrokeField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class SlideField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.SlideField) */ {
 public:
  inline SlideField() : SlideField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SlideField(::google::protobuf::internal::ConstantInitialized);

  inline SlideField(const SlideField& from)
      : SlideField(nullptr, from) {}
  SlideField(SlideField&& from) noexcept
    : SlideField() {
    *this = ::std::move(from);
  }

  inline SlideField& operator=(const SlideField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlideField& operator=(SlideField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SlideField& default_instance() {
    return *internal_default_instance();
  }
  static inline const SlideField* internal_default_instance() {
    return reinterpret_cast<const SlideField*>(
               &_SlideField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SlideField& a, SlideField& b) {
    a.Swap(&b);
  }
  inline void Swap(SlideField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlideField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SlideField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SlideField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SlideField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SlideField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.SlideField";
  }
  protected:
  explicit SlideField(::google::protobuf::Arena* arena);
  SlideField(::google::protobuf::Arena* arena, const SlideField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LayoutType = SlideField_LayoutType;
  static constexpr LayoutType BLANK = SlideField_LayoutType_BLANK;
  static constexpr LayoutType TITLE = SlideField_LayoutType_TITLE;
  static constexpr LayoutType OBJ = SlideField_LayoutType_OBJ;
  static constexpr LayoutType SEC_HEADER = SlideField_LayoutType_SEC_HEADER;
  static constexpr LayoutType TWO_OBJ = SlideField_LayoutType_TWO_OBJ;
  static constexpr LayoutType TXT = SlideField_LayoutType_TXT;
  static constexpr LayoutType TWO_TXT = SlideField_LayoutType_TWO_TXT;
  static constexpr LayoutType TWO_OBJ_TWO_TXT = SlideField_LayoutType_TWO_OBJ_TWO_TXT;
  static constexpr LayoutType TITLE_ONLY = SlideField_LayoutType_TITLE_ONLY;
  static constexpr LayoutType OBJ_AND_TXT = SlideField_LayoutType_OBJ_AND_TXT;
  static constexpr LayoutType TXT_OBJ = SlideField_LayoutType_TXT_OBJ;
  static constexpr LayoutType OBJ_TXT = SlideField_LayoutType_OBJ_TXT;
  static constexpr LayoutType PIC_TXT = SlideField_LayoutType_PIC_TXT;
  static constexpr LayoutType OBJ_ONLY = SlideField_LayoutType_OBJ_ONLY;
  static constexpr LayoutType TWO_OBJ_TXT = SlideField_LayoutType_TWO_OBJ_TXT;
  static constexpr LayoutType TXT_TWO_OBJ = SlideField_LayoutType_TXT_TWO_OBJ;
  static constexpr LayoutType OBJ_TWO_OBJ = SlideField_LayoutType_OBJ_TWO_OBJ;
  static constexpr LayoutType TWO_OBJ_OBJ = SlideField_LayoutType_TWO_OBJ_OBJ;
  static constexpr LayoutType FOUR_OBJ = SlideField_LayoutType_FOUR_OBJ;
  static constexpr LayoutType TXT_OVER_OBJ = SlideField_LayoutType_TXT_OVER_OBJ;
  static constexpr LayoutType OBJ_OVER_TXT = SlideField_LayoutType_OBJ_OVER_TXT;
  static constexpr LayoutType TXT_CLIPART = SlideField_LayoutType_TXT_CLIPART;
  static constexpr LayoutType CLIPART_TXT = SlideField_LayoutType_CLIPART_TXT;
  static constexpr LayoutType TXT_CHART = SlideField_LayoutType_TXT_CHART;
  static constexpr LayoutType CHART_TXT = SlideField_LayoutType_CHART_TXT;
  static constexpr LayoutType TXT_MEDIA = SlideField_LayoutType_TXT_MEDIA;
  static constexpr LayoutType MEDIA_TXT = SlideField_LayoutType_MEDIA_TXT;
  static constexpr LayoutType TABLE = SlideField_LayoutType_TABLE;
  static constexpr LayoutType SMARTART = SlideField_LayoutType_SMARTART;
  static constexpr LayoutType CHART = SlideField_LayoutType_CHART;
  static constexpr LayoutType VERT_TXT = SlideField_LayoutType_VERT_TXT;
  static constexpr LayoutType VERT_TITLE_TXT = SlideField_LayoutType_VERT_TITLE_TXT;
  static constexpr LayoutType TITLE_THREE_PICT_TXT = SlideField_LayoutType_TITLE_THREE_PICT_TXT;
  static constexpr LayoutType TITLE_FOUR_PICT = SlideField_LayoutType_TITLE_FOUR_PICT;
  static constexpr LayoutType TITLE_TXT_TWO_PICT = SlideField_LayoutType_TITLE_TXT_TWO_PICT;
  static constexpr LayoutType TWO_OBJ_OVER_TXT = SlideField_LayoutType_TWO_OBJ_OVER_TXT;
  static constexpr LayoutType CLIPART_VERT_TXT = SlideField_LayoutType_CLIPART_VERT_TXT;
  static constexpr LayoutType VERT_TITLE_TX_OVER_CHART = SlideField_LayoutType_VERT_TITLE_TX_OVER_CHART;
  static constexpr LayoutType PIC_TITLE_RGT = SlideField_LayoutType_PIC_TITLE_RGT;
  static constexpr LayoutType PIC_TITLE_LFT = SlideField_LayoutType_PIC_TITLE_LFT;
  static constexpr LayoutType PIC_TITLE_CENTER = SlideField_LayoutType_PIC_TITLE_CENTER;
  static constexpr LayoutType PIC_TITLE_TXT_LFT = SlideField_LayoutType_PIC_TITLE_TXT_LFT;
  static constexpr LayoutType PIC_TITLE_TXT_RGT = SlideField_LayoutType_PIC_TITLE_TXT_RGT;
  static constexpr LayoutType THREE_PICT_TXT = SlideField_LayoutType_THREE_PICT_TXT;
  static constexpr LayoutType CUSTOM = SlideField_LayoutType_CUSTOM;
  static inline bool LayoutType_IsValid(int value) {
    return SlideField_LayoutType_IsValid(value);
  }
  static constexpr LayoutType LayoutType_MIN = SlideField_LayoutType_LayoutType_MIN;
  static constexpr LayoutType LayoutType_MAX = SlideField_LayoutType_LayoutType_MAX;
  static constexpr int LayoutType_ARRAYSIZE = SlideField_LayoutType_LayoutType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LayoutType_descriptor() {
    return SlideField_LayoutType_descriptor();
  }
  template <typename T>
  static inline const std::string& LayoutType_Name(T value) {
    return SlideField_LayoutType_Name(value);
  }
  static inline bool LayoutType_Parse(absl::string_view name, LayoutType* value) {
    return SlideField_LayoutType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.SlideField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class ShapeField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.ShapeField) */ {
 public:
  inline ShapeField() : ShapeField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShapeField(::google::protobuf::internal::ConstantInitialized);

  inline ShapeField(const ShapeField& from)
      : ShapeField(nullptr, from) {}
  ShapeField(ShapeField&& from) noexcept
    : ShapeField() {
    *this = ::std::move(from);
  }

  inline ShapeField& operator=(const ShapeField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeField& operator=(ShapeField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeField* internal_default_instance() {
    return reinterpret_cast<const ShapeField*>(
               &_ShapeField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ShapeField& a, ShapeField& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShapeField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShapeField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.ShapeField";
  }
  protected:
  explicit ShapeField(::google::protobuf::Arena* arena);
  ShapeField(::google::protobuf::Arena* arena, const ShapeField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using PlaceHolderType = ShapeField_PlaceHolderType;
  static constexpr PlaceHolderType TITLE = ShapeField_PlaceHolderType_TITLE;
  static constexpr PlaceHolderType TXTBODY = ShapeField_PlaceHolderType_TXTBODY;
  static constexpr PlaceHolderType DATETIME = ShapeField_PlaceHolderType_DATETIME;
  static constexpr PlaceHolderType FOOTER = ShapeField_PlaceHolderType_FOOTER;
  static constexpr PlaceHolderType SLIDENUM = ShapeField_PlaceHolderType_SLIDENUM;
  static constexpr PlaceHolderType CONTENT = ShapeField_PlaceHolderType_CONTENT;
  static constexpr PlaceHolderType TXT = ShapeField_PlaceHolderType_TXT;
  static constexpr PlaceHolderType SUBTITLE = ShapeField_PlaceHolderType_SUBTITLE;
  static constexpr PlaceHolderType PICT = ShapeField_PlaceHolderType_PICT;
  static constexpr PlaceHolderType CLIPART = ShapeField_PlaceHolderType_CLIPART;
  static constexpr PlaceHolderType CHART = ShapeField_PlaceHolderType_CHART;
  static constexpr PlaceHolderType TABLE = ShapeField_PlaceHolderType_TABLE;
  static constexpr PlaceHolderType SMARTART = ShapeField_PlaceHolderType_SMARTART;
  static constexpr PlaceHolderType MEDIA = ShapeField_PlaceHolderType_MEDIA;
  static constexpr PlaceHolderType BODY = ShapeField_PlaceHolderType_BODY;
  static constexpr PlaceHolderType FILE = ShapeField_PlaceHolderType_FILE;
  static inline bool PlaceHolderType_IsValid(int value) {
    return ShapeField_PlaceHolderType_IsValid(value);
  }
  static constexpr PlaceHolderType PlaceHolderType_MIN = ShapeField_PlaceHolderType_PlaceHolderType_MIN;
  static constexpr PlaceHolderType PlaceHolderType_MAX = ShapeField_PlaceHolderType_PlaceHolderType_MAX;
  static constexpr int PlaceHolderType_ARRAYSIZE = ShapeField_PlaceHolderType_PlaceHolderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PlaceHolderType_descriptor() {
    return ShapeField_PlaceHolderType_descriptor();
  }
  template <typename T>
  static inline const std::string& PlaceHolderType_Name(T value) {
    return ShapeField_PlaceHolderType_Name(value);
  }
  static inline bool PlaceHolderType_Parse(absl::string_view name, PlaceHolderType* value) {
    return ShapeField_PlaceHolderType_Parse(name, value);
  }

  using BlendMode = ShapeField_BlendMode;
  static constexpr BlendMode NORMAL = ShapeField_BlendMode_NORMAL;
  static constexpr BlendMode MULTIPLY = ShapeField_BlendMode_MULTIPLY;
  static constexpr BlendMode SCREEN = ShapeField_BlendMode_SCREEN;
  static constexpr BlendMode OVERLAY = ShapeField_BlendMode_OVERLAY;
  static constexpr BlendMode DARKEN = ShapeField_BlendMode_DARKEN;
  static constexpr BlendMode LIGHTEN = ShapeField_BlendMode_LIGHTEN;
  static constexpr BlendMode COLOR_DODGE = ShapeField_BlendMode_COLOR_DODGE;
  static constexpr BlendMode COLOR_BURN = ShapeField_BlendMode_COLOR_BURN;
  static constexpr BlendMode SOFT_LIGHT = ShapeField_BlendMode_SOFT_LIGHT;
  static constexpr BlendMode HARD_LIGHT = ShapeField_BlendMode_HARD_LIGHT;
  static constexpr BlendMode DIFFERENCE = ShapeField_BlendMode_DIFFERENCE;
  static constexpr BlendMode EXCLUSION = ShapeField_BlendMode_EXCLUSION;
  static constexpr BlendMode HUE = ShapeField_BlendMode_HUE;
  static constexpr BlendMode SATURATION = ShapeField_BlendMode_SATURATION;
  static constexpr BlendMode COLOR = ShapeField_BlendMode_COLOR;
  static constexpr BlendMode LUMINOSITY = ShapeField_BlendMode_LUMINOSITY;
  static inline bool BlendMode_IsValid(int value) {
    return ShapeField_BlendMode_IsValid(value);
  }
  static constexpr BlendMode BlendMode_MIN = ShapeField_BlendMode_BlendMode_MIN;
  static constexpr BlendMode BlendMode_MAX = ShapeField_BlendMode_BlendMode_MAX;
  static constexpr int BlendMode_ARRAYSIZE = ShapeField_BlendMode_BlendMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BlendMode_descriptor() {
    return ShapeField_BlendMode_descriptor();
  }
  template <typename T>
  static inline const std::string& BlendMode_Name(T value) {
    return ShapeField_BlendMode_Name(value);
  }
  static inline bool BlendMode_Parse(absl::string_view name, BlendMode* value) {
    return ShapeField_BlendMode_Parse(name, value);
  }

  using CombineRule = ShapeField_CombineRule;
  static constexpr CombineRule NO_RULE = ShapeField_CombineRule_NO_RULE;
  static constexpr CombineRule UNION = ShapeField_CombineRule_UNION;
  static constexpr CombineRule INTERSECT = ShapeField_CombineRule_INTERSECT;
  static constexpr CombineRule COMBINE = ShapeField_CombineRule_COMBINE;
  static constexpr CombineRule SUBTRACT = ShapeField_CombineRule_SUBTRACT;
  static constexpr CombineRule INVERSE_INTERSECT = ShapeField_CombineRule_INVERSE_INTERSECT;
  static inline bool CombineRule_IsValid(int value) {
    return ShapeField_CombineRule_IsValid(value);
  }
  static constexpr CombineRule CombineRule_MIN = ShapeField_CombineRule_CombineRule_MIN;
  static constexpr CombineRule CombineRule_MAX = ShapeField_CombineRule_CombineRule_MAX;
  static constexpr int CombineRule_ARRAYSIZE = ShapeField_CombineRule_CombineRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CombineRule_descriptor() {
    return ShapeField_CombineRule_descriptor();
  }
  template <typename T>
  static inline const std::string& CombineRule_Name(T value) {
    return ShapeField_CombineRule_Name(value);
  }
  static inline bool CombineRule_Parse(absl::string_view name, CombineRule* value) {
    return ShapeField_CombineRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.ShapeField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class PresetSmartDiagram final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.PresetSmartDiagram) */ {
 public:
  inline PresetSmartDiagram() : PresetSmartDiagram(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PresetSmartDiagram(::google::protobuf::internal::ConstantInitialized);

  inline PresetSmartDiagram(const PresetSmartDiagram& from)
      : PresetSmartDiagram(nullptr, from) {}
  PresetSmartDiagram(PresetSmartDiagram&& from) noexcept
    : PresetSmartDiagram() {
    *this = ::std::move(from);
  }

  inline PresetSmartDiagram& operator=(const PresetSmartDiagram& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresetSmartDiagram& operator=(PresetSmartDiagram&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PresetSmartDiagram& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresetSmartDiagram* internal_default_instance() {
    return reinterpret_cast<const PresetSmartDiagram*>(
               &_PresetSmartDiagram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PresetSmartDiagram& a, PresetSmartDiagram& b) {
    a.Swap(&b);
  }
  inline void Swap(PresetSmartDiagram* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresetSmartDiagram* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PresetSmartDiagram* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PresetSmartDiagram>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PresetSmartDiagram& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PresetSmartDiagram& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.PresetSmartDiagram";
  }
  protected:
  explicit PresetSmartDiagram(::google::protobuf::Arena* arena);
  PresetSmartDiagram(::google::protobuf::Arena* arena, const PresetSmartDiagram& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using PresetSmartDiagramType = PresetSmartDiagram_PresetSmartDiagramType;
  static constexpr PresetSmartDiagramType UNKNOWN_SMART_DIAGRAM = PresetSmartDiagram_PresetSmartDiagramType_UNKNOWN_SMART_DIAGRAM;
  static constexpr PresetSmartDiagramType PROCESS_DIAGRAM = PresetSmartDiagram_PresetSmartDiagramType_PROCESS_DIAGRAM;
  static constexpr PresetSmartDiagramType PYRAMID_DIAGRAM = PresetSmartDiagram_PresetSmartDiagramType_PYRAMID_DIAGRAM;
  static constexpr PresetSmartDiagramType CYCLE_DIAGRAM = PresetSmartDiagram_PresetSmartDiagramType_CYCLE_DIAGRAM;
  static constexpr PresetSmartDiagramType LIST_DIAGRAM = PresetSmartDiagram_PresetSmartDiagramType_LIST_DIAGRAM;
  static inline bool PresetSmartDiagramType_IsValid(int value) {
    return PresetSmartDiagram_PresetSmartDiagramType_IsValid(value);
  }
  static constexpr PresetSmartDiagramType PresetSmartDiagramType_MIN = PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagramType_MIN;
  static constexpr PresetSmartDiagramType PresetSmartDiagramType_MAX = PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagramType_MAX;
  static constexpr int PresetSmartDiagramType_ARRAYSIZE = PresetSmartDiagram_PresetSmartDiagramType_PresetSmartDiagramType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetSmartDiagramType_descriptor() {
    return PresetSmartDiagram_PresetSmartDiagramType_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetSmartDiagramType_Name(T value) {
    return PresetSmartDiagram_PresetSmartDiagramType_Name(value);
  }
  static inline bool PresetSmartDiagramType_Parse(absl::string_view name, PresetSmartDiagramType* value) {
    return PresetSmartDiagram_PresetSmartDiagramType_Parse(name, value);
  }

  using PresetProcessSmartDiagramType = PresetSmartDiagram_PresetProcessSmartDiagramType;
  static constexpr PresetProcessSmartDiagramType UNKNOWN_PROCESS = PresetSmartDiagram_PresetProcessSmartDiagramType_UNKNOWN_PROCESS;
  static constexpr PresetProcessSmartDiagramType HEXAGON_PROCESS = PresetSmartDiagram_PresetProcessSmartDiagramType_HEXAGON_PROCESS;
  static constexpr PresetProcessSmartDiagramType STEPS_FLOW_PROCESS = PresetSmartDiagram_PresetProcessSmartDiagramType_STEPS_FLOW_PROCESS;
  static constexpr PresetProcessSmartDiagramType DROPLET_PROCESS = PresetSmartDiagram_PresetProcessSmartDiagramType_DROPLET_PROCESS;
  static constexpr PresetProcessSmartDiagramType TEAR_DROP_PROCESS = PresetSmartDiagram_PresetProcessSmartDiagramType_TEAR_DROP_PROCESS;
  static constexpr PresetProcessSmartDiagramType OCTAGON_PROCESS = PresetSmartDiagram_PresetProcessSmartDiagramType_OCTAGON_PROCESS;
  static constexpr PresetProcessSmartDiagramType ROUNDED_RECTANGLE_PROCESS = PresetSmartDiagram_PresetProcessSmartDiagramType_ROUNDED_RECTANGLE_PROCESS;
  static inline bool PresetProcessSmartDiagramType_IsValid(int value) {
    return PresetSmartDiagram_PresetProcessSmartDiagramType_IsValid(value);
  }
  static constexpr PresetProcessSmartDiagramType PresetProcessSmartDiagramType_MIN = PresetSmartDiagram_PresetProcessSmartDiagramType_PresetProcessSmartDiagramType_MIN;
  static constexpr PresetProcessSmartDiagramType PresetProcessSmartDiagramType_MAX = PresetSmartDiagram_PresetProcessSmartDiagramType_PresetProcessSmartDiagramType_MAX;
  static constexpr int PresetProcessSmartDiagramType_ARRAYSIZE = PresetSmartDiagram_PresetProcessSmartDiagramType_PresetProcessSmartDiagramType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetProcessSmartDiagramType_descriptor() {
    return PresetSmartDiagram_PresetProcessSmartDiagramType_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetProcessSmartDiagramType_Name(T value) {
    return PresetSmartDiagram_PresetProcessSmartDiagramType_Name(value);
  }
  static inline bool PresetProcessSmartDiagramType_Parse(absl::string_view name, PresetProcessSmartDiagramType* value) {
    return PresetSmartDiagram_PresetProcessSmartDiagramType_Parse(name, value);
  }

  using PresetPyramidSmartDiagramType = PresetSmartDiagram_PresetPyramidSmartDiagramType;
  static constexpr PresetPyramidSmartDiagramType UNKNOWN_PYRAMID = PresetSmartDiagram_PresetPyramidSmartDiagramType_UNKNOWN_PYRAMID;
  static constexpr PresetPyramidSmartDiagramType TRIANGULAR_PYRAMID = PresetSmartDiagram_PresetPyramidSmartDiagramType_TRIANGULAR_PYRAMID;
  static constexpr PresetPyramidSmartDiagramType INSCRIBED_PYRAMID = PresetSmartDiagram_PresetPyramidSmartDiagramType_INSCRIBED_PYRAMID;
  static constexpr PresetPyramidSmartDiagramType THREE_DIM_PYRAMID = PresetSmartDiagram_PresetPyramidSmartDiagramType_THREE_DIM_PYRAMID;
  static constexpr PresetPyramidSmartDiagramType SIMPLE_PYRAMID = PresetSmartDiagram_PresetPyramidSmartDiagramType_SIMPLE_PYRAMID;
  static constexpr PresetPyramidSmartDiagramType TILTED_PYRAMID = PresetSmartDiagram_PresetPyramidSmartDiagramType_TILTED_PYRAMID;
  static constexpr PresetPyramidSmartDiagramType FLAGGED_PYRAMID = PresetSmartDiagram_PresetPyramidSmartDiagramType_FLAGGED_PYRAMID;
  static inline bool PresetPyramidSmartDiagramType_IsValid(int value) {
    return PresetSmartDiagram_PresetPyramidSmartDiagramType_IsValid(value);
  }
  static constexpr PresetPyramidSmartDiagramType PresetPyramidSmartDiagramType_MIN = PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetPyramidSmartDiagramType_MIN;
  static constexpr PresetPyramidSmartDiagramType PresetPyramidSmartDiagramType_MAX = PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetPyramidSmartDiagramType_MAX;
  static constexpr int PresetPyramidSmartDiagramType_ARRAYSIZE = PresetSmartDiagram_PresetPyramidSmartDiagramType_PresetPyramidSmartDiagramType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetPyramidSmartDiagramType_descriptor() {
    return PresetSmartDiagram_PresetPyramidSmartDiagramType_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetPyramidSmartDiagramType_Name(T value) {
    return PresetSmartDiagram_PresetPyramidSmartDiagramType_Name(value);
  }
  static inline bool PresetPyramidSmartDiagramType_Parse(absl::string_view name, PresetPyramidSmartDiagramType* value) {
    return PresetSmartDiagram_PresetPyramidSmartDiagramType_Parse(name, value);
  }

  using PresetCycleSmartDiagramType = PresetSmartDiagram_PresetCycleSmartDiagramType;
  static constexpr PresetCycleSmartDiagramType UNKNOWN_CYCLE = PresetSmartDiagram_PresetCycleSmartDiagramType_UNKNOWN_CYCLE;
  static constexpr PresetCycleSmartDiagramType TRAPEZOID_CYCLE = PresetSmartDiagram_PresetCycleSmartDiagramType_TRAPEZOID_CYCLE;
  static constexpr PresetCycleSmartDiagramType ARC_CIRCLES_CYCLE = PresetSmartDiagram_PresetCycleSmartDiagramType_ARC_CIRCLES_CYCLE;
  static constexpr PresetCycleSmartDiagramType SQUARE_CYCLE = PresetSmartDiagram_PresetCycleSmartDiagramType_SQUARE_CYCLE;
  static constexpr PresetCycleSmartDiagramType LOOP_CYCLE = PresetSmartDiagram_PresetCycleSmartDiagramType_LOOP_CYCLE;
  static constexpr PresetCycleSmartDiagramType DOUGHNUT_CYCLE = PresetSmartDiagram_PresetCycleSmartDiagramType_DOUGHNUT_CYCLE;
  static constexpr PresetCycleSmartDiagramType CONNECTOR_CYCLE = PresetSmartDiagram_PresetCycleSmartDiagramType_CONNECTOR_CYCLE;
  static inline bool PresetCycleSmartDiagramType_IsValid(int value) {
    return PresetSmartDiagram_PresetCycleSmartDiagramType_IsValid(value);
  }
  static constexpr PresetCycleSmartDiagramType PresetCycleSmartDiagramType_MIN = PresetSmartDiagram_PresetCycleSmartDiagramType_PresetCycleSmartDiagramType_MIN;
  static constexpr PresetCycleSmartDiagramType PresetCycleSmartDiagramType_MAX = PresetSmartDiagram_PresetCycleSmartDiagramType_PresetCycleSmartDiagramType_MAX;
  static constexpr int PresetCycleSmartDiagramType_ARRAYSIZE = PresetSmartDiagram_PresetCycleSmartDiagramType_PresetCycleSmartDiagramType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetCycleSmartDiagramType_descriptor() {
    return PresetSmartDiagram_PresetCycleSmartDiagramType_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetCycleSmartDiagramType_Name(T value) {
    return PresetSmartDiagram_PresetCycleSmartDiagramType_Name(value);
  }
  static inline bool PresetCycleSmartDiagramType_Parse(absl::string_view name, PresetCycleSmartDiagramType* value) {
    return PresetSmartDiagram_PresetCycleSmartDiagramType_Parse(name, value);
  }

  using PresetListSmartDiagramType = PresetSmartDiagram_PresetListSmartDiagramType;
  static constexpr PresetListSmartDiagramType UNKNOWN_LIST = PresetSmartDiagram_PresetListSmartDiagramType_UNKNOWN_LIST;
  static constexpr PresetListSmartDiagramType FLAG_LIST = PresetSmartDiagram_PresetListSmartDiagramType_FLAG_LIST;
  static constexpr PresetListSmartDiagramType DROP_LIST = PresetSmartDiagram_PresetListSmartDiagramType_DROP_LIST;
  static constexpr PresetListSmartDiagramType RIBBON_LIST = PresetSmartDiagram_PresetListSmartDiagramType_RIBBON_LIST;
  static constexpr PresetListSmartDiagramType STRIP_LIST = PresetSmartDiagram_PresetListSmartDiagramType_STRIP_LIST;
  static constexpr PresetListSmartDiagramType SHAFT_LIST = PresetSmartDiagram_PresetListSmartDiagramType_SHAFT_LIST;
  static constexpr PresetListSmartDiagramType STACK_CARD_LIST = PresetSmartDiagram_PresetListSmartDiagramType_STACK_CARD_LIST;
  static constexpr PresetListSmartDiagramType TIER_LIST = PresetSmartDiagram_PresetListSmartDiagramType_TIER_LIST;
  static constexpr PresetListSmartDiagramType PETAL_LIST = PresetSmartDiagram_PresetListSmartDiagramType_PETAL_LIST;
  static constexpr PresetListSmartDiagramType ALTER_LIST = PresetSmartDiagram_PresetListSmartDiagramType_ALTER_LIST;
  static constexpr PresetListSmartDiagramType DECK_LIST = PresetSmartDiagram_PresetListSmartDiagramType_DECK_LIST;
  static inline bool PresetListSmartDiagramType_IsValid(int value) {
    return PresetSmartDiagram_PresetListSmartDiagramType_IsValid(value);
  }
  static constexpr PresetListSmartDiagramType PresetListSmartDiagramType_MIN = PresetSmartDiagram_PresetListSmartDiagramType_PresetListSmartDiagramType_MIN;
  static constexpr PresetListSmartDiagramType PresetListSmartDiagramType_MAX = PresetSmartDiagram_PresetListSmartDiagramType_PresetListSmartDiagramType_MAX;
  static constexpr int PresetListSmartDiagramType_ARRAYSIZE = PresetSmartDiagram_PresetListSmartDiagramType_PresetListSmartDiagramType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetListSmartDiagramType_descriptor() {
    return PresetSmartDiagram_PresetListSmartDiagramType_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetListSmartDiagramType_Name(T value) {
    return PresetSmartDiagram_PresetListSmartDiagramType_Name(value);
  }
  static inline bool PresetListSmartDiagramType_Parse(absl::string_view name, PresetListSmartDiagramType* value) {
    return PresetSmartDiagram_PresetListSmartDiagramType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.PresetSmartDiagram)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class PortionField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.PortionField) */ {
 public:
  inline PortionField() : PortionField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PortionField(::google::protobuf::internal::ConstantInitialized);

  inline PortionField(const PortionField& from)
      : PortionField(nullptr, from) {}
  PortionField(PortionField&& from) noexcept
    : PortionField() {
    *this = ::std::move(from);
  }

  inline PortionField& operator=(const PortionField& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortionField& operator=(PortionField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortionField& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortionField* internal_default_instance() {
    return reinterpret_cast<const PortionField*>(
               &_PortionField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PortionField& a, PortionField& b) {
    a.Swap(&b);
  }
  inline void Swap(PortionField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortionField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortionField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortionField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PortionField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PortionField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.PortionField";
  }
  protected:
  explicit PortionField(::google::protobuf::Arena* arena);
  PortionField(::google::protobuf::Arena* arena, const PortionField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SlideNumberField = PortionField_SlideNumberField;
  static constexpr SlideNumberField NUM1 = PortionField_SlideNumberField_NUM1;
  static constexpr SlideNumberField NUM2 = PortionField_SlideNumberField_NUM2;
  static inline bool SlideNumberField_IsValid(int value) {
    return PortionField_SlideNumberField_IsValid(value);
  }
  static constexpr SlideNumberField SlideNumberField_MIN = PortionField_SlideNumberField_SlideNumberField_MIN;
  static constexpr SlideNumberField SlideNumberField_MAX = PortionField_SlideNumberField_SlideNumberField_MAX;
  static constexpr int SlideNumberField_ARRAYSIZE = PortionField_SlideNumberField_SlideNumberField_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SlideNumberField_descriptor() {
    return PortionField_SlideNumberField_descriptor();
  }
  template <typename T>
  static inline const std::string& SlideNumberField_Name(T value) {
    return PortionField_SlideNumberField_Name(value);
  }
  static inline bool SlideNumberField_Parse(absl::string_view name, SlideNumberField* value) {
    return PortionField_SlideNumberField_Parse(name, value);
  }

  using DateTimeField = PortionField_DateTimeField;
  static constexpr DateTimeField DEF_DATE_TIME_FIELD_FORMAT = PortionField_DateTimeField_DEF_DATE_TIME_FIELD_FORMAT;
  static constexpr DateTimeField FORMAT1 = PortionField_DateTimeField_FORMAT1;
  static constexpr DateTimeField FORMAT2 = PortionField_DateTimeField_FORMAT2;
  static constexpr DateTimeField FORMAT3 = PortionField_DateTimeField_FORMAT3;
  static constexpr DateTimeField FORMAT4 = PortionField_DateTimeField_FORMAT4;
  static constexpr DateTimeField FORMAT5 = PortionField_DateTimeField_FORMAT5;
  static constexpr DateTimeField FORMAT6 = PortionField_DateTimeField_FORMAT6;
  static constexpr DateTimeField FORMAT7 = PortionField_DateTimeField_FORMAT7;
  static constexpr DateTimeField FORMAT8 = PortionField_DateTimeField_FORMAT8;
  static constexpr DateTimeField FORMAT9 = PortionField_DateTimeField_FORMAT9;
  static constexpr DateTimeField FORMAT10 = PortionField_DateTimeField_FORMAT10;
  static constexpr DateTimeField FORMAT11 = PortionField_DateTimeField_FORMAT11;
  static constexpr DateTimeField FORMAT12 = PortionField_DateTimeField_FORMAT12;
  static constexpr DateTimeField FORMAT13 = PortionField_DateTimeField_FORMAT13;
  static constexpr DateTimeField FORMAT14 = PortionField_DateTimeField_FORMAT14;
  static constexpr DateTimeField FORMAT15 = PortionField_DateTimeField_FORMAT15;
  static inline bool DateTimeField_IsValid(int value) {
    return PortionField_DateTimeField_IsValid(value);
  }
  static constexpr DateTimeField DateTimeField_MIN = PortionField_DateTimeField_DateTimeField_MIN;
  static constexpr DateTimeField DateTimeField_MAX = PortionField_DateTimeField_DateTimeField_MAX;
  static constexpr int DateTimeField_ARRAYSIZE = PortionField_DateTimeField_DateTimeField_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DateTimeField_descriptor() {
    return PortionField_DateTimeField_descriptor();
  }
  template <typename T>
  static inline const std::string& DateTimeField_Name(T value) {
    return PortionField_DateTimeField_Name(value);
  }
  static inline bool DateTimeField_Parse(absl::string_view name, DateTimeField* value) {
    return PortionField_DateTimeField_Parse(name, value);
  }

  using FontVariant = PortionField_FontVariant;
  static constexpr FontVariant SMALLCAPS = PortionField_FontVariant_SMALLCAPS;
  static constexpr FontVariant ALLCAPS = PortionField_FontVariant_ALLCAPS;
  static constexpr FontVariant NONE = PortionField_FontVariant_NONE;
  static constexpr FontVariant CAPITALIZE = PortionField_FontVariant_CAPITALIZE;
  static inline bool FontVariant_IsValid(int value) {
    return PortionField_FontVariant_IsValid(value);
  }
  static constexpr FontVariant FontVariant_MIN = PortionField_FontVariant_FontVariant_MIN;
  static constexpr FontVariant FontVariant_MAX = PortionField_FontVariant_FontVariant_MAX;
  static constexpr int FontVariant_ARRAYSIZE = PortionField_FontVariant_FontVariant_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FontVariant_descriptor() {
    return PortionField_FontVariant_descriptor();
  }
  template <typename T>
  static inline const std::string& FontVariant_Name(T value) {
    return PortionField_FontVariant_Name(value);
  }
  static inline bool FontVariant_Parse(absl::string_view name, FontVariant* value) {
    return PortionField_FontVariant_Parse(name, value);
  }

  using FontWeight = PortionField_FontWeight;
  static constexpr FontWeight THIN = PortionField_FontWeight_THIN;
  static constexpr FontWeight EXTRA_LIGHT = PortionField_FontWeight_EXTRA_LIGHT;
  static constexpr FontWeight LIGHT = PortionField_FontWeight_LIGHT;
  static constexpr FontWeight NORMAL = PortionField_FontWeight_NORMAL;
  static constexpr FontWeight MEDIUM = PortionField_FontWeight_MEDIUM;
  static constexpr FontWeight DEMI_BOLD = PortionField_FontWeight_DEMI_BOLD;
  static constexpr FontWeight BOLD = PortionField_FontWeight_BOLD;
  static constexpr FontWeight HEAVY = PortionField_FontWeight_HEAVY;
  static constexpr FontWeight BLACK = PortionField_FontWeight_BLACK;
  static inline bool FontWeight_IsValid(int value) {
    return PortionField_FontWeight_IsValid(value);
  }
  static constexpr FontWeight FontWeight_MIN = PortionField_FontWeight_FontWeight_MIN;
  static constexpr FontWeight FontWeight_MAX = PortionField_FontWeight_FontWeight_MAX;
  static constexpr int FontWeight_ARRAYSIZE = PortionField_FontWeight_FontWeight_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FontWeight_descriptor() {
    return PortionField_FontWeight_descriptor();
  }
  template <typename T>
  static inline const std::string& FontWeight_Name(T value) {
    return PortionField_FontWeight_Name(value);
  }
  static inline bool FontWeight_Parse(absl::string_view name, FontWeight* value) {
    return PortionField_FontWeight_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.PortionField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class MemberField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.MemberField) */ {
 public:
  inline MemberField() : MemberField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MemberField(::google::protobuf::internal::ConstantInitialized);

  inline MemberField(const MemberField& from)
      : MemberField(nullptr, from) {}
  MemberField(MemberField&& from) noexcept
    : MemberField() {
    *this = ::std::move(from);
  }

  inline MemberField& operator=(const MemberField& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemberField& operator=(MemberField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemberField& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemberField* internal_default_instance() {
    return reinterpret_cast<const MemberField*>(
               &_MemberField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MemberField& a, MemberField& b) {
    a.Swap(&b);
  }
  inline void Swap(MemberField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemberField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemberField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemberField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MemberField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MemberField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.MemberField";
  }
  protected:
  explicit MemberField(::google::protobuf::Arena* arena);
  MemberField(::google::protobuf::Arena* arena, const MemberField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MemberRoleType = MemberField_MemberRoleType;
  static constexpr MemberRoleType UNKNOWN_MEMBER_ROLE_TYPE = MemberField_MemberRoleType_UNKNOWN_MEMBER_ROLE_TYPE;
  static constexpr MemberRoleType ADMIN = MemberField_MemberRoleType_ADMIN;
  static constexpr MemberRoleType EDITOR = MemberField_MemberRoleType_EDITOR;
  static constexpr MemberRoleType VIEWER = MemberField_MemberRoleType_VIEWER;
  static constexpr MemberRoleType GUEST_EDITOR = MemberField_MemberRoleType_GUEST_EDITOR;
  static constexpr MemberRoleType GUEST_COMMENTER = MemberField_MemberRoleType_GUEST_COMMENTER;
  static constexpr MemberRoleType GUEST_VIEWER = MemberField_MemberRoleType_GUEST_VIEWER;
  static inline bool MemberRoleType_IsValid(int value) {
    return MemberField_MemberRoleType_IsValid(value);
  }
  static constexpr MemberRoleType MemberRoleType_MIN = MemberField_MemberRoleType_MemberRoleType_MIN;
  static constexpr MemberRoleType MemberRoleType_MAX = MemberField_MemberRoleType_MemberRoleType_MAX;
  static constexpr int MemberRoleType_ARRAYSIZE = MemberField_MemberRoleType_MemberRoleType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MemberRoleType_descriptor() {
    return MemberField_MemberRoleType_descriptor();
  }
  template <typename T>
  static inline const std::string& MemberRoleType_Name(T value) {
    return MemberField_MemberRoleType_Name(value);
  }
  static inline bool MemberRoleType_Parse(absl::string_view name, MemberRoleType* value) {
    return MemberField_MemberRoleType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.MemberField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class GeometryField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.GeometryField) */ {
 public:
  inline GeometryField() : GeometryField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GeometryField(::google::protobuf::internal::ConstantInitialized);

  inline GeometryField(const GeometryField& from)
      : GeometryField(nullptr, from) {}
  GeometryField(GeometryField&& from) noexcept
    : GeometryField() {
    *this = ::std::move(from);
  }

  inline GeometryField& operator=(const GeometryField& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeometryField& operator=(GeometryField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeometryField& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeometryField* internal_default_instance() {
    return reinterpret_cast<const GeometryField*>(
               &_GeometryField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GeometryField& a, GeometryField& b) {
    a.Swap(&b);
  }
  inline void Swap(GeometryField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeometryField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeometryField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeometryField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GeometryField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GeometryField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.GeometryField";
  }
  protected:
  explicit GeometryField(::google::protobuf::Arena* arena);
  GeometryField(::google::protobuf::Arena* arena, const GeometryField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ShapeGeometryType = GeometryField_ShapeGeometryType;
  static constexpr ShapeGeometryType PRESET = GeometryField_ShapeGeometryType_PRESET;
  static constexpr ShapeGeometryType CUSTOM = GeometryField_ShapeGeometryType_CUSTOM;
  static constexpr ShapeGeometryType PRESET_SMART = GeometryField_ShapeGeometryType_PRESET_SMART;
  static inline bool ShapeGeometryType_IsValid(int value) {
    return GeometryField_ShapeGeometryType_IsValid(value);
  }
  static constexpr ShapeGeometryType ShapeGeometryType_MIN = GeometryField_ShapeGeometryType_ShapeGeometryType_MIN;
  static constexpr ShapeGeometryType ShapeGeometryType_MAX = GeometryField_ShapeGeometryType_ShapeGeometryType_MAX;
  static constexpr int ShapeGeometryType_ARRAYSIZE = GeometryField_ShapeGeometryType_ShapeGeometryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ShapeGeometryType_descriptor() {
    return GeometryField_ShapeGeometryType_descriptor();
  }
  template <typename T>
  static inline const std::string& ShapeGeometryType_Name(T value) {
    return GeometryField_ShapeGeometryType_Name(value);
  }
  static inline bool ShapeGeometryType_Parse(absl::string_view name, ShapeGeometryType* value) {
    return GeometryField_ShapeGeometryType_Parse(name, value);
  }

  using PresetShapeGeometry = GeometryField_PresetShapeGeometry;
  static constexpr PresetShapeGeometry DEF_PRESET_SHAPE = GeometryField_PresetShapeGeometry_DEF_PRESET_SHAPE;
  static constexpr PresetShapeGeometry RECT = GeometryField_PresetShapeGeometry_RECT;
  static constexpr PresetShapeGeometry ROUND_RECT = GeometryField_PresetShapeGeometry_ROUND_RECT;
  static constexpr PresetShapeGeometry SNIP_SINGLE_RECT = GeometryField_PresetShapeGeometry_SNIP_SINGLE_RECT;
  static constexpr PresetShapeGeometry SNIP_SAMESIDE_RECT = GeometryField_PresetShapeGeometry_SNIP_SAMESIDE_RECT;
  static constexpr PresetShapeGeometry SNIP_DIAGONAL_RECT = GeometryField_PresetShapeGeometry_SNIP_DIAGONAL_RECT;
  static constexpr PresetShapeGeometry SNIP_ROUND_SINGLE_RECT = GeometryField_PresetShapeGeometry_SNIP_ROUND_SINGLE_RECT;
  static constexpr PresetShapeGeometry ROUND_SINGLE_RECT = GeometryField_PresetShapeGeometry_ROUND_SINGLE_RECT;
  static constexpr PresetShapeGeometry ROUND_SAMESIDE_RECT = GeometryField_PresetShapeGeometry_ROUND_SAMESIDE_RECT;
  static constexpr PresetShapeGeometry ROUND_DIAGONAL_RECT = GeometryField_PresetShapeGeometry_ROUND_DIAGONAL_RECT;
  static constexpr PresetShapeGeometry OVAL = GeometryField_PresetShapeGeometry_OVAL;
  static constexpr PresetShapeGeometry ISOSCELES_TRIANGLE = GeometryField_PresetShapeGeometry_ISOSCELES_TRIANGLE;
  static constexpr PresetShapeGeometry RIGHT_TRIANGLE = GeometryField_PresetShapeGeometry_RIGHT_TRIANGLE;
  static constexpr PresetShapeGeometry PARALLELOGRAM = GeometryField_PresetShapeGeometry_PARALLELOGRAM;
  static constexpr PresetShapeGeometry TRAPEZOID = GeometryField_PresetShapeGeometry_TRAPEZOID;
  static constexpr PresetShapeGeometry DIAMOND = GeometryField_PresetShapeGeometry_DIAMOND;
  static constexpr PresetShapeGeometry PENTAGON = GeometryField_PresetShapeGeometry_PENTAGON;
  static constexpr PresetShapeGeometry HEXAGON = GeometryField_PresetShapeGeometry_HEXAGON;
  static constexpr PresetShapeGeometry HEPTAGON = GeometryField_PresetShapeGeometry_HEPTAGON;
  static constexpr PresetShapeGeometry OCTAGON = GeometryField_PresetShapeGeometry_OCTAGON;
  static constexpr PresetShapeGeometry DECAGON = GeometryField_PresetShapeGeometry_DECAGON;
  static constexpr PresetShapeGeometry DODECAGON = GeometryField_PresetShapeGeometry_DODECAGON;
  static constexpr PresetShapeGeometry PIE = GeometryField_PresetShapeGeometry_PIE;
  static constexpr PresetShapeGeometry CHORD = GeometryField_PresetShapeGeometry_CHORD;
  static constexpr PresetShapeGeometry TEARDROP = GeometryField_PresetShapeGeometry_TEARDROP;
  static constexpr PresetShapeGeometry FRAME = GeometryField_PresetShapeGeometry_FRAME;
  static constexpr PresetShapeGeometry HALF_FRAME = GeometryField_PresetShapeGeometry_HALF_FRAME;
  static constexpr PresetShapeGeometry LSHAPE = GeometryField_PresetShapeGeometry_LSHAPE;
  static constexpr PresetShapeGeometry DIAGONAL_STRIPE = GeometryField_PresetShapeGeometry_DIAGONAL_STRIPE;
  static constexpr PresetShapeGeometry CROSS = GeometryField_PresetShapeGeometry_CROSS;
  static constexpr PresetShapeGeometry PLAQUE = GeometryField_PresetShapeGeometry_PLAQUE;
  static constexpr PresetShapeGeometry CAN = GeometryField_PresetShapeGeometry_CAN;
  static constexpr PresetShapeGeometry CUBE = GeometryField_PresetShapeGeometry_CUBE;
  static constexpr PresetShapeGeometry BEVEL = GeometryField_PresetShapeGeometry_BEVEL;
  static constexpr PresetShapeGeometry DONUT = GeometryField_PresetShapeGeometry_DONUT;
  static constexpr PresetShapeGeometry NO_SYMBOL = GeometryField_PresetShapeGeometry_NO_SYMBOL;
  static constexpr PresetShapeGeometry BLOCK_ARC = GeometryField_PresetShapeGeometry_BLOCK_ARC;
  static constexpr PresetShapeGeometry FOLDED_CORNER = GeometryField_PresetShapeGeometry_FOLDED_CORNER;
  static constexpr PresetShapeGeometry SMILEY = GeometryField_PresetShapeGeometry_SMILEY;
  static constexpr PresetShapeGeometry HEART = GeometryField_PresetShapeGeometry_HEART;
  static constexpr PresetShapeGeometry LIGHTNING_BOLT = GeometryField_PresetShapeGeometry_LIGHTNING_BOLT;
  static constexpr PresetShapeGeometry SUN = GeometryField_PresetShapeGeometry_SUN;
  static constexpr PresetShapeGeometry MOON = GeometryField_PresetShapeGeometry_MOON;
  static constexpr PresetShapeGeometry CLOUD = GeometryField_PresetShapeGeometry_CLOUD;
  static constexpr PresetShapeGeometry ARC = GeometryField_PresetShapeGeometry_ARC;
  static constexpr PresetShapeGeometry DOUBLE_BRACKET = GeometryField_PresetShapeGeometry_DOUBLE_BRACKET;
  static constexpr PresetShapeGeometry DOUBLE_BRACE = GeometryField_PresetShapeGeometry_DOUBLE_BRACE;
  static constexpr PresetShapeGeometry LEFT_BRACKET = GeometryField_PresetShapeGeometry_LEFT_BRACKET;
  static constexpr PresetShapeGeometry RIGHT_BRACKET = GeometryField_PresetShapeGeometry_RIGHT_BRACKET;
  static constexpr PresetShapeGeometry LEFT_BRACE = GeometryField_PresetShapeGeometry_LEFT_BRACE;
  static constexpr PresetShapeGeometry RIGHT_BRACE = GeometryField_PresetShapeGeometry_RIGHT_BRACE;
  static constexpr PresetShapeGeometry CLOCK = GeometryField_PresetShapeGeometry_CLOCK;
  static constexpr PresetShapeGeometry RIGHT_ARROW = GeometryField_PresetShapeGeometry_RIGHT_ARROW;
  static constexpr PresetShapeGeometry LEFT_ARROW = GeometryField_PresetShapeGeometry_LEFT_ARROW;
  static constexpr PresetShapeGeometry UP_ARROW = GeometryField_PresetShapeGeometry_UP_ARROW;
  static constexpr PresetShapeGeometry DOWN_ARROW = GeometryField_PresetShapeGeometry_DOWN_ARROW;
  static constexpr PresetShapeGeometry LEFT_RIGHT_ARROW = GeometryField_PresetShapeGeometry_LEFT_RIGHT_ARROW;
  static constexpr PresetShapeGeometry UP_DOWN_ARROW = GeometryField_PresetShapeGeometry_UP_DOWN_ARROW;
  static constexpr PresetShapeGeometry QUAD_ARROW = GeometryField_PresetShapeGeometry_QUAD_ARROW;
  static constexpr PresetShapeGeometry LEFT_RIGHT_UP_ARROW = GeometryField_PresetShapeGeometry_LEFT_RIGHT_UP_ARROW;
  static constexpr PresetShapeGeometry BENT_ARROW = GeometryField_PresetShapeGeometry_BENT_ARROW;
  static constexpr PresetShapeGeometry U_TURN_ARROW = GeometryField_PresetShapeGeometry_U_TURN_ARROW;
  static constexpr PresetShapeGeometry LEFT_UP_ARROW = GeometryField_PresetShapeGeometry_LEFT_UP_ARROW;
  static constexpr PresetShapeGeometry BENT_UP_ARROW = GeometryField_PresetShapeGeometry_BENT_UP_ARROW;
  static constexpr PresetShapeGeometry CURVED_RIGHT_ARROW = GeometryField_PresetShapeGeometry_CURVED_RIGHT_ARROW;
  static constexpr PresetShapeGeometry CURVED_LEFT_ARROW = GeometryField_PresetShapeGeometry_CURVED_LEFT_ARROW;
  static constexpr PresetShapeGeometry CURVED_UP_ARROW = GeometryField_PresetShapeGeometry_CURVED_UP_ARROW;
  static constexpr PresetShapeGeometry CURVED_DOWN_ARROW = GeometryField_PresetShapeGeometry_CURVED_DOWN_ARROW;
  static constexpr PresetShapeGeometry STRIPED_RIGHT_ARROW = GeometryField_PresetShapeGeometry_STRIPED_RIGHT_ARROW;
  static constexpr PresetShapeGeometry NOTCHED_RIGHT_ARROW = GeometryField_PresetShapeGeometry_NOTCHED_RIGHT_ARROW;
  static constexpr PresetShapeGeometry PENTAGON_ARROW = GeometryField_PresetShapeGeometry_PENTAGON_ARROW;
  static constexpr PresetShapeGeometry CHEVRON = GeometryField_PresetShapeGeometry_CHEVRON;
  static constexpr PresetShapeGeometry RIGHT_ARROW_CALLOUT = GeometryField_PresetShapeGeometry_RIGHT_ARROW_CALLOUT;
  static constexpr PresetShapeGeometry DOWN_ARROW_CALLOUT = GeometryField_PresetShapeGeometry_DOWN_ARROW_CALLOUT;
  static constexpr PresetShapeGeometry LEFT_ARROW_CALLOUT = GeometryField_PresetShapeGeometry_LEFT_ARROW_CALLOUT;
  static constexpr PresetShapeGeometry UP_ARROW_CALLOUT = GeometryField_PresetShapeGeometry_UP_ARROW_CALLOUT;
  static constexpr PresetShapeGeometry LEFT_RIGHT_ARROW_CALLOUT = GeometryField_PresetShapeGeometry_LEFT_RIGHT_ARROW_CALLOUT;
  static constexpr PresetShapeGeometry QUAD_ARROW_CALLOUT = GeometryField_PresetShapeGeometry_QUAD_ARROW_CALLOUT;
  static constexpr PresetShapeGeometry CIRCULAR_ARROW = GeometryField_PresetShapeGeometry_CIRCULAR_ARROW;
  static constexpr PresetShapeGeometry PLUS = GeometryField_PresetShapeGeometry_PLUS;
  static constexpr PresetShapeGeometry MINUS = GeometryField_PresetShapeGeometry_MINUS;
  static constexpr PresetShapeGeometry MULTIPLY = GeometryField_PresetShapeGeometry_MULTIPLY;
  static constexpr PresetShapeGeometry DIVIDE = GeometryField_PresetShapeGeometry_DIVIDE;
  static constexpr PresetShapeGeometry EQUAL = GeometryField_PresetShapeGeometry_EQUAL;
  static constexpr PresetShapeGeometry NOT_EQUAL = GeometryField_PresetShapeGeometry_NOT_EQUAL;
  static constexpr PresetShapeGeometry PROCESS = GeometryField_PresetShapeGeometry_PROCESS;
  static constexpr PresetShapeGeometry ALTERNATE_PROCESS = GeometryField_PresetShapeGeometry_ALTERNATE_PROCESS;
  static constexpr PresetShapeGeometry DECISION = GeometryField_PresetShapeGeometry_DECISION;
  static constexpr PresetShapeGeometry DATA = GeometryField_PresetShapeGeometry_DATA;
  static constexpr PresetShapeGeometry PREDEFINED_PROCESS = GeometryField_PresetShapeGeometry_PREDEFINED_PROCESS;
  static constexpr PresetShapeGeometry INTERNAL_STORAGE = GeometryField_PresetShapeGeometry_INTERNAL_STORAGE;
  static constexpr PresetShapeGeometry FLOWCHART_DOCUMENT = GeometryField_PresetShapeGeometry_FLOWCHART_DOCUMENT;
  static constexpr PresetShapeGeometry MULTI_DOCUMENT = GeometryField_PresetShapeGeometry_MULTI_DOCUMENT;
  static constexpr PresetShapeGeometry TERMINATOR = GeometryField_PresetShapeGeometry_TERMINATOR;
  static constexpr PresetShapeGeometry PREPARATION = GeometryField_PresetShapeGeometry_PREPARATION;
  static constexpr PresetShapeGeometry MANUAL_INPUT = GeometryField_PresetShapeGeometry_MANUAL_INPUT;
  static constexpr PresetShapeGeometry MANUAL_OPERATION = GeometryField_PresetShapeGeometry_MANUAL_OPERATION;
  static constexpr PresetShapeGeometry FLOWCHART_CONNECTOR = GeometryField_PresetShapeGeometry_FLOWCHART_CONNECTOR;
  static constexpr PresetShapeGeometry OFFPAGE_CONNECTOR = GeometryField_PresetShapeGeometry_OFFPAGE_CONNECTOR;
  static constexpr PresetShapeGeometry PUNCHED_CARD = GeometryField_PresetShapeGeometry_PUNCHED_CARD;
  static constexpr PresetShapeGeometry PUNCHED_TAPE = GeometryField_PresetShapeGeometry_PUNCHED_TAPE;
  static constexpr PresetShapeGeometry SUMMING_JUNCTION = GeometryField_PresetShapeGeometry_SUMMING_JUNCTION;
  static constexpr PresetShapeGeometry OR = GeometryField_PresetShapeGeometry_OR;
  static constexpr PresetShapeGeometry COLLATE = GeometryField_PresetShapeGeometry_COLLATE;
  static constexpr PresetShapeGeometry SORT = GeometryField_PresetShapeGeometry_SORT;
  static constexpr PresetShapeGeometry EXTRACT = GeometryField_PresetShapeGeometry_EXTRACT;
  static constexpr PresetShapeGeometry MERGE = GeometryField_PresetShapeGeometry_MERGE;
  static constexpr PresetShapeGeometry STORED_DATA = GeometryField_PresetShapeGeometry_STORED_DATA;
  static constexpr PresetShapeGeometry DELAY = GeometryField_PresetShapeGeometry_DELAY;
  static constexpr PresetShapeGeometry SEQUENTIAL_ACCESS_STORAGE = GeometryField_PresetShapeGeometry_SEQUENTIAL_ACCESS_STORAGE;
  static constexpr PresetShapeGeometry MAGNETIC_DISK = GeometryField_PresetShapeGeometry_MAGNETIC_DISK;
  static constexpr PresetShapeGeometry DIRECT_ACCESS_STORAGE = GeometryField_PresetShapeGeometry_DIRECT_ACCESS_STORAGE;
  static constexpr PresetShapeGeometry DISPLAY = GeometryField_PresetShapeGeometry_DISPLAY;
  static constexpr PresetShapeGeometry EXPLOSION1 = GeometryField_PresetShapeGeometry_EXPLOSION1;
  static constexpr PresetShapeGeometry EXPLOSION2 = GeometryField_PresetShapeGeometry_EXPLOSION2;
  static constexpr PresetShapeGeometry FOUR_POINT_STAR = GeometryField_PresetShapeGeometry_FOUR_POINT_STAR;
  static constexpr PresetShapeGeometry FIVE_POINT_STAR = GeometryField_PresetShapeGeometry_FIVE_POINT_STAR;
  static constexpr PresetShapeGeometry SIX_POINT_STAR = GeometryField_PresetShapeGeometry_SIX_POINT_STAR;
  static constexpr PresetShapeGeometry SEVEN_POINT_STAR = GeometryField_PresetShapeGeometry_SEVEN_POINT_STAR;
  static constexpr PresetShapeGeometry EIGHT_POINT_STAR = GeometryField_PresetShapeGeometry_EIGHT_POINT_STAR;
  static constexpr PresetShapeGeometry TEN_POINT_STAR = GeometryField_PresetShapeGeometry_TEN_POINT_STAR;
  static constexpr PresetShapeGeometry TWELVE_POINT_STAR = GeometryField_PresetShapeGeometry_TWELVE_POINT_STAR;
  static constexpr PresetShapeGeometry SIXTEEN_POINT_STAR = GeometryField_PresetShapeGeometry_SIXTEEN_POINT_STAR;
  static constexpr PresetShapeGeometry TWENTY_FOUR_POINT_STAR = GeometryField_PresetShapeGeometry_TWENTY_FOUR_POINT_STAR;
  static constexpr PresetShapeGeometry THIRTY_TWO_POINT_STAR = GeometryField_PresetShapeGeometry_THIRTY_TWO_POINT_STAR;
  static constexpr PresetShapeGeometry UP_RIBBON = GeometryField_PresetShapeGeometry_UP_RIBBON;
  static constexpr PresetShapeGeometry DOWN_RIBBON = GeometryField_PresetShapeGeometry_DOWN_RIBBON;
  static constexpr PresetShapeGeometry CURVED_UP_RIBBON = GeometryField_PresetShapeGeometry_CURVED_UP_RIBBON;
  static constexpr PresetShapeGeometry CURVED_DOWN_RIBBON = GeometryField_PresetShapeGeometry_CURVED_DOWN_RIBBON;
  static constexpr PresetShapeGeometry VERTICAL_SCROLL = GeometryField_PresetShapeGeometry_VERTICAL_SCROLL;
  static constexpr PresetShapeGeometry HORIZONTAL_SCROLL = GeometryField_PresetShapeGeometry_HORIZONTAL_SCROLL;
  static constexpr PresetShapeGeometry WAVE = GeometryField_PresetShapeGeometry_WAVE;
  static constexpr PresetShapeGeometry DOUBLE_WAVE = GeometryField_PresetShapeGeometry_DOUBLE_WAVE;
  static constexpr PresetShapeGeometry RECTANGULAR_CALLOUT = GeometryField_PresetShapeGeometry_RECTANGULAR_CALLOUT;
  static constexpr PresetShapeGeometry ROUNDED_RECTANGULAR_CALLOUT = GeometryField_PresetShapeGeometry_ROUNDED_RECTANGULAR_CALLOUT;
  static constexpr PresetShapeGeometry OVAL_CALLOUT = GeometryField_PresetShapeGeometry_OVAL_CALLOUT;
  static constexpr PresetShapeGeometry CLOUD_CALLOUT = GeometryField_PresetShapeGeometry_CLOUD_CALLOUT;
  static constexpr PresetShapeGeometry CALLOUT1 = GeometryField_PresetShapeGeometry_CALLOUT1;
  static constexpr PresetShapeGeometry CALLOUT2 = GeometryField_PresetShapeGeometry_CALLOUT2;
  static constexpr PresetShapeGeometry CALLOUT3 = GeometryField_PresetShapeGeometry_CALLOUT3;
  static constexpr PresetShapeGeometry ACCENT_CALLOUT1 = GeometryField_PresetShapeGeometry_ACCENT_CALLOUT1;
  static constexpr PresetShapeGeometry ACCENT_CALLOUT2 = GeometryField_PresetShapeGeometry_ACCENT_CALLOUT2;
  static constexpr PresetShapeGeometry ACCENT_CALLOUT3 = GeometryField_PresetShapeGeometry_ACCENT_CALLOUT3;
  static constexpr PresetShapeGeometry BORDER_CALLOUT1 = GeometryField_PresetShapeGeometry_BORDER_CALLOUT1;
  static constexpr PresetShapeGeometry BORDER_CALLOUT2 = GeometryField_PresetShapeGeometry_BORDER_CALLOUT2;
  static constexpr PresetShapeGeometry BORDER_CALLOUT3 = GeometryField_PresetShapeGeometry_BORDER_CALLOUT3;
  static constexpr PresetShapeGeometry ACCENT_BORDER_CALLOUT1 = GeometryField_PresetShapeGeometry_ACCENT_BORDER_CALLOUT1;
  static constexpr PresetShapeGeometry ACCENT_BORDER_CALLOUT2 = GeometryField_PresetShapeGeometry_ACCENT_BORDER_CALLOUT2;
  static constexpr PresetShapeGeometry ACCENT_BORDER_CALLOUT3 = GeometryField_PresetShapeGeometry_ACCENT_BORDER_CALLOUT3;
  static constexpr PresetShapeGeometry ACTION_PREVIOUS = GeometryField_PresetShapeGeometry_ACTION_PREVIOUS;
  static constexpr PresetShapeGeometry ACTION_NEXT = GeometryField_PresetShapeGeometry_ACTION_NEXT;
  static constexpr PresetShapeGeometry ACTION_BEGIN = GeometryField_PresetShapeGeometry_ACTION_BEGIN;
  static constexpr PresetShapeGeometry ACTION_END = GeometryField_PresetShapeGeometry_ACTION_END;
  static constexpr PresetShapeGeometry ACTION_HOME = GeometryField_PresetShapeGeometry_ACTION_HOME;
  static constexpr PresetShapeGeometry ACTION_INFORMATION = GeometryField_PresetShapeGeometry_ACTION_INFORMATION;
  static constexpr PresetShapeGeometry ACTION_RETURN = GeometryField_PresetShapeGeometry_ACTION_RETURN;
  static constexpr PresetShapeGeometry ACTION_MOVIE = GeometryField_PresetShapeGeometry_ACTION_MOVIE;
  static constexpr PresetShapeGeometry ACTION_DOCUMENT = GeometryField_PresetShapeGeometry_ACTION_DOCUMENT;
  static constexpr PresetShapeGeometry ACTION_SOUND = GeometryField_PresetShapeGeometry_ACTION_SOUND;
  static constexpr PresetShapeGeometry ACTION_HELP = GeometryField_PresetShapeGeometry_ACTION_HELP;
  static constexpr PresetShapeGeometry ACTION_CUSTOM = GeometryField_PresetShapeGeometry_ACTION_CUSTOM;
  static constexpr PresetShapeGeometry LINE = GeometryField_PresetShapeGeometry_LINE;
  static constexpr PresetShapeGeometry ELBOW_CONNECTOR2 = GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR2;
  static constexpr PresetShapeGeometry ELBOW_CONNECTOR3 = GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR3;
  static constexpr PresetShapeGeometry ELBOW_CONNECTOR4 = GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR4;
  static constexpr PresetShapeGeometry ELBOW_CONNECTOR5 = GeometryField_PresetShapeGeometry_ELBOW_CONNECTOR5;
  static constexpr PresetShapeGeometry CURVED_CONNECTOR2 = GeometryField_PresetShapeGeometry_CURVED_CONNECTOR2;
  static constexpr PresetShapeGeometry CURVED_CONNECTOR3 = GeometryField_PresetShapeGeometry_CURVED_CONNECTOR3;
  static constexpr PresetShapeGeometry CURVED_CONNECTOR4 = GeometryField_PresetShapeGeometry_CURVED_CONNECTOR4;
  static constexpr PresetShapeGeometry CURVED_CONNECTOR5 = GeometryField_PresetShapeGeometry_CURVED_CONNECTOR5;
  static constexpr PresetShapeGeometry LOCK_SYMBOL = GeometryField_PresetShapeGeometry_LOCK_SYMBOL;
  static constexpr PresetShapeGeometry GRID = GeometryField_PresetShapeGeometry_GRID;
  static constexpr PresetShapeGeometry TABLECELL = GeometryField_PresetShapeGeometry_TABLECELL;
  static constexpr PresetShapeGeometry CROP_FRAME = GeometryField_PresetShapeGeometry_CROP_FRAME;
  static constexpr PresetShapeGeometry CIRCLE_QUOTE = GeometryField_PresetShapeGeometry_CIRCLE_QUOTE;
  static constexpr PresetShapeGeometry RECT_QUOTE = GeometryField_PresetShapeGeometry_RECT_QUOTE;
  static constexpr PresetShapeGeometry BORDER_QUOTE = GeometryField_PresetShapeGeometry_BORDER_QUOTE;
  static constexpr PresetShapeGeometry TWO_EDGED_FRAME = GeometryField_PresetShapeGeometry_TWO_EDGED_FRAME;
  static constexpr PresetShapeGeometry FOUR_EDGED_FRAME = GeometryField_PresetShapeGeometry_FOUR_EDGED_FRAME;
  static constexpr PresetShapeGeometry TOP_BANNER = GeometryField_PresetShapeGeometry_TOP_BANNER;
  static constexpr PresetShapeGeometry LEFT_BANNER = GeometryField_PresetShapeGeometry_LEFT_BANNER;
  static constexpr PresetShapeGeometry SQUARE_ON_CIRCLE_BOARD = GeometryField_PresetShapeGeometry_SQUARE_ON_CIRCLE_BOARD;
  static constexpr PresetShapeGeometry RHOMBUS_ON_BOW_BOARD = GeometryField_PresetShapeGeometry_RHOMBUS_ON_BOW_BOARD;
  static constexpr PresetShapeGeometry TWIN_COMET = GeometryField_PresetShapeGeometry_TWIN_COMET;
  static constexpr PresetShapeGeometry DOTTED_SIGN = GeometryField_PresetShapeGeometry_DOTTED_SIGN;
  static constexpr PresetShapeGeometry MAN = GeometryField_PresetShapeGeometry_MAN;
  static constexpr PresetShapeGeometry WOMAN = GeometryField_PresetShapeGeometry_WOMAN;
  static constexpr PresetShapeGeometry METER_NEEDLE = GeometryField_PresetShapeGeometry_METER_NEEDLE;
  static constexpr PresetShapeGeometry CLOCK_NEEDLE = GeometryField_PresetShapeGeometry_CLOCK_NEEDLE;
  static constexpr PresetShapeGeometry TIMER_SCALE = GeometryField_PresetShapeGeometry_TIMER_SCALE;
  static constexpr PresetShapeGeometry HORIZONTAL_SLIDER = GeometryField_PresetShapeGeometry_HORIZONTAL_SLIDER;
  static constexpr PresetShapeGeometry VERTICAL_SLIDER = GeometryField_PresetShapeGeometry_VERTICAL_SLIDER;
  static constexpr PresetShapeGeometry MOD_RECT = GeometryField_PresetShapeGeometry_MOD_RECT;
  static constexpr PresetShapeGeometry MOD_CAN = GeometryField_PresetShapeGeometry_MOD_CAN;
  static constexpr PresetShapeGeometry MOD_PARALLELOGRAM = GeometryField_PresetShapeGeometry_MOD_PARALLELOGRAM;
  static constexpr PresetShapeGeometry MOD_ROUND_RECT = GeometryField_PresetShapeGeometry_MOD_ROUND_RECT;
  static constexpr PresetShapeGeometry CIRCLE_FILLER = GeometryField_PresetShapeGeometry_CIRCLE_FILLER;
  static constexpr PresetShapeGeometry ELLIPSE_FILLER = GeometryField_PresetShapeGeometry_ELLIPSE_FILLER;
  static constexpr PresetShapeGeometry STAR = GeometryField_PresetShapeGeometry_STAR;
  static constexpr PresetShapeGeometry POLYGON = GeometryField_PresetShapeGeometry_POLYGON;
  static constexpr PresetShapeGeometry AUDIO = GeometryField_PresetShapeGeometry_AUDIO;
  static constexpr PresetShapeGeometry ROUND_DIAMOND = GeometryField_PresetShapeGeometry_ROUND_DIAMOND;
  static constexpr PresetShapeGeometry DFD_EXTERNAL_ENTITY_1 = GeometryField_PresetShapeGeometry_DFD_EXTERNAL_ENTITY_1;
  static constexpr PresetShapeGeometry ERD_ASSOCIATIVE_ENTITY = GeometryField_PresetShapeGeometry_ERD_ASSOCIATIVE_ENTITY;
  static inline bool PresetShapeGeometry_IsValid(int value) {
    return GeometryField_PresetShapeGeometry_IsValid(value);
  }
  static constexpr PresetShapeGeometry PresetShapeGeometry_MIN = GeometryField_PresetShapeGeometry_PresetShapeGeometry_MIN;
  static constexpr PresetShapeGeometry PresetShapeGeometry_MAX = GeometryField_PresetShapeGeometry_PresetShapeGeometry_MAX;
  static constexpr int PresetShapeGeometry_ARRAYSIZE = GeometryField_PresetShapeGeometry_PresetShapeGeometry_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetShapeGeometry_descriptor() {
    return GeometryField_PresetShapeGeometry_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetShapeGeometry_Name(T value) {
    return GeometryField_PresetShapeGeometry_Name(value);
  }
  static inline bool PresetShapeGeometry_Parse(absl::string_view name, PresetShapeGeometry* value) {
    return GeometryField_PresetShapeGeometry_Parse(name, value);
  }

  using PresetSmartShapeGeometry = GeometryField_PresetSmartShapeGeometry;
  static constexpr PresetSmartShapeGeometry HORIZONTAL_BLOCK_BATTERY = GeometryField_PresetSmartShapeGeometry_HORIZONTAL_BLOCK_BATTERY;
  static constexpr PresetSmartShapeGeometry VERTICAL_BLOCK_BATTERY = GeometryField_PresetSmartShapeGeometry_VERTICAL_BLOCK_BATTERY;
  static constexpr PresetSmartShapeGeometry WALL_CLOCK = GeometryField_PresetSmartShapeGeometry_WALL_CLOCK;
  static constexpr PresetSmartShapeGeometry TIMER_CLOCK = GeometryField_PresetSmartShapeGeometry_TIMER_CLOCK;
  static constexpr PresetSmartShapeGeometry PEOPLE_INDICATOR = GeometryField_PresetSmartShapeGeometry_PEOPLE_INDICATOR;
  static constexpr PresetSmartShapeGeometry CIRCULAR_PLAIN_INDICATOR = GeometryField_PresetSmartShapeGeometry_CIRCULAR_PLAIN_INDICATOR;
  static constexpr PresetSmartShapeGeometry CIRCULAR_ENCIRCLED_INDICATOR = GeometryField_PresetSmartShapeGeometry_CIRCULAR_ENCIRCLED_INDICATOR;
  static constexpr PresetSmartShapeGeometry CIRCULAR_PLAINFILL_INDICATOR = GeometryField_PresetSmartShapeGeometry_CIRCULAR_PLAINFILL_INDICATOR;
  static constexpr PresetSmartShapeGeometry CIRCULAR_VERTICALFILL_INDICATOR = GeometryField_PresetSmartShapeGeometry_CIRCULAR_VERTICALFILL_INDICATOR;
  static constexpr PresetSmartShapeGeometry HORIZONTAL_PLAIN_INDICATOR = GeometryField_PresetSmartShapeGeometry_HORIZONTAL_PLAIN_INDICATOR;
  static constexpr PresetSmartShapeGeometry HORIZONTAL_CENTERCIRCLE_INDICATOR = GeometryField_PresetSmartShapeGeometry_HORIZONTAL_CENTERCIRCLE_INDICATOR;
  static constexpr PresetSmartShapeGeometry HORIZONTAL_BLOCK_INDICATOR = GeometryField_PresetSmartShapeGeometry_HORIZONTAL_BLOCK_INDICATOR;
  static constexpr PresetSmartShapeGeometry VERTICAL_PLAIN_INDICATOR = GeometryField_PresetSmartShapeGeometry_VERTICAL_PLAIN_INDICATOR;
  static constexpr PresetSmartShapeGeometry VERTICAL_CENTERBUBLE_INDICATOR = GeometryField_PresetSmartShapeGeometry_VERTICAL_CENTERBUBLE_INDICATOR;
  static constexpr PresetSmartShapeGeometry VERTICAL_CENTERPOINT_INDICATOR = GeometryField_PresetSmartShapeGeometry_VERTICAL_CENTERPOINT_INDICATOR;
  static constexpr PresetSmartShapeGeometry VERTICAL_BLOCK_INDICATOR = GeometryField_PresetSmartShapeGeometry_VERTICAL_BLOCK_INDICATOR;
  static constexpr PresetSmartShapeGeometry ARC_PLAIN_METER = GeometryField_PresetSmartShapeGeometry_ARC_PLAIN_METER;
  static constexpr PresetSmartShapeGeometry ARC_NEEDLE_METER = GeometryField_PresetSmartShapeGeometry_ARC_NEEDLE_METER;
  static constexpr PresetSmartShapeGeometry ARC_SPEED_METER = GeometryField_PresetSmartShapeGeometry_ARC_SPEED_METER;
  static constexpr PresetSmartShapeGeometry DIGITAL_CLOCK = GeometryField_PresetSmartShapeGeometry_DIGITAL_CLOCK;
  static inline bool PresetSmartShapeGeometry_IsValid(int value) {
    return GeometryField_PresetSmartShapeGeometry_IsValid(value);
  }
  static constexpr PresetSmartShapeGeometry PresetSmartShapeGeometry_MIN = GeometryField_PresetSmartShapeGeometry_PresetSmartShapeGeometry_MIN;
  static constexpr PresetSmartShapeGeometry PresetSmartShapeGeometry_MAX = GeometryField_PresetSmartShapeGeometry_PresetSmartShapeGeometry_MAX;
  static constexpr int PresetSmartShapeGeometry_ARRAYSIZE = GeometryField_PresetSmartShapeGeometry_PresetSmartShapeGeometry_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresetSmartShapeGeometry_descriptor() {
    return GeometryField_PresetSmartShapeGeometry_descriptor();
  }
  template <typename T>
  static inline const std::string& PresetSmartShapeGeometry_Name(T value) {
    return GeometryField_PresetSmartShapeGeometry_Name(value);
  }
  static inline bool PresetSmartShapeGeometry_Parse(absl::string_view name, PresetSmartShapeGeometry* value) {
    return GeometryField_PresetSmartShapeGeometry_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.GeometryField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class FillField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.FillField) */ {
 public:
  inline FillField() : FillField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FillField(::google::protobuf::internal::ConstantInitialized);

  inline FillField(const FillField& from)
      : FillField(nullptr, from) {}
  FillField(FillField&& from) noexcept
    : FillField() {
    *this = ::std::move(from);
  }

  inline FillField& operator=(const FillField& from) {
    CopyFrom(from);
    return *this;
  }
  inline FillField& operator=(FillField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FillField& default_instance() {
    return *internal_default_instance();
  }
  static inline const FillField* internal_default_instance() {
    return reinterpret_cast<const FillField*>(
               &_FillField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FillField& a, FillField& b) {
    a.Swap(&b);
  }
  inline void Swap(FillField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FillField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FillField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FillField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FillField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FillField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.FillField";
  }
  protected:
  explicit FillField(::google::protobuf::Arena* arena);
  FillField(::google::protobuf::Arena* arena, const FillField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using FillType = FillField_FillType;
  static constexpr FillType DEF_FILL = FillField_FillType_DEF_FILL;
  static constexpr FillType NONE = FillField_FillType_NONE;
  static constexpr FillType SOLID = FillField_FillType_SOLID;
  static constexpr FillType GRADIENT = FillField_FillType_GRADIENT;
  static constexpr FillType PICT = FillField_FillType_PICT;
  static constexpr FillType GRP = FillField_FillType_GRP;
  static constexpr FillType PATTERN = FillField_FillType_PATTERN;
  static constexpr FillType TEXTBOX = FillField_FillType_TEXTBOX;
  static inline bool FillType_IsValid(int value) {
    return FillField_FillType_IsValid(value);
  }
  static constexpr FillType FillType_MIN = FillField_FillType_FillType_MIN;
  static constexpr FillType FillType_MAX = FillField_FillType_FillType_MAX;
  static constexpr int FillType_ARRAYSIZE = FillField_FillType_FillType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FillType_descriptor() {
    return FillField_FillType_descriptor();
  }
  template <typename T>
  static inline const std::string& FillType_Name(T value) {
    return FillField_FillType_Name(value);
  }
  static inline bool FillType_Parse(absl::string_view name, FillType* value) {
    return FillField_FillType_Parse(name, value);
  }

  using GradientFillType = FillField_GradientFillType;
  static constexpr GradientFillType LINEAR = FillField_GradientFillType_LINEAR;
  static constexpr GradientFillType RADIAL = FillField_GradientFillType_RADIAL;
  static constexpr GradientFillType RECTANGULAR = FillField_GradientFillType_RECTANGULAR;
  static constexpr GradientFillType PATH = FillField_GradientFillType_PATH;
  static constexpr GradientFillType ANGULAR = FillField_GradientFillType_ANGULAR;
  static inline bool GradientFillType_IsValid(int value) {
    return FillField_GradientFillType_IsValid(value);
  }
  static constexpr GradientFillType GradientFillType_MIN = FillField_GradientFillType_GradientFillType_MIN;
  static constexpr GradientFillType GradientFillType_MAX = FillField_GradientFillType_GradientFillType_MAX;
  static constexpr int GradientFillType_ARRAYSIZE = FillField_GradientFillType_GradientFillType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GradientFillType_descriptor() {
    return FillField_GradientFillType_descriptor();
  }
  template <typename T>
  static inline const std::string& GradientFillType_Name(T value) {
    return FillField_GradientFillType_Name(value);
  }
  static inline bool GradientFillType_Parse(absl::string_view name, GradientFillType* value) {
    return FillField_GradientFillType_Parse(name, value);
  }

  using FillRule = FillField_FillRule;
  static constexpr FillRule NO_RULE = FillField_FillRule_NO_RULE;
  static constexpr FillRule NON_ZERO = FillField_FillRule_NON_ZERO;
  static constexpr FillRule EVEN_ODD = FillField_FillRule_EVEN_ODD;
  static inline bool FillRule_IsValid(int value) {
    return FillField_FillRule_IsValid(value);
  }
  static constexpr FillRule FillRule_MIN = FillField_FillRule_FillRule_MIN;
  static constexpr FillRule FillRule_MAX = FillField_FillRule_FillRule_MAX;
  static constexpr int FillRule_ARRAYSIZE = FillField_FillRule_FillRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FillRule_descriptor() {
    return FillField_FillRule_descriptor();
  }
  template <typename T>
  static inline const std::string& FillRule_Name(T value) {
    return FillField_FillRule_Name(value);
  }
  static inline bool FillRule_Parse(absl::string_view name, FillRule* value) {
    return FillField_FillRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.FillField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class FileField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.FileField) */ {
 public:
  inline FileField() : FileField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FileField(::google::protobuf::internal::ConstantInitialized);

  inline FileField(const FileField& from)
      : FileField(nullptr, from) {}
  FileField(FileField&& from) noexcept
    : FileField() {
    *this = ::std::move(from);
  }

  inline FileField& operator=(const FileField& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileField& operator=(FileField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileField& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileField* internal_default_instance() {
    return reinterpret_cast<const FileField*>(
               &_FileField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FileField& a, FileField& b) {
    a.Swap(&b);
  }
  inline void Swap(FileField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FileField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FileField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.FileField";
  }
  protected:
  explicit FileField(::google::protobuf::Arena* arena);
  FileField(::google::protobuf::Arena* arena, const FileField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using FileFormat = FileField_FileFormat;
  static constexpr FileFormat UNKNOWN_FILE_FORMAT = FileField_FileFormat_UNKNOWN_FILE_FORMAT;
  static constexpr FileFormat DOCUMENT = FileField_FileFormat_DOCUMENT;
  static constexpr FileFormat PRESENTATION = FileField_FileFormat_PRESENTATION;
  static constexpr FileFormat SPREADSHEET = FileField_FileFormat_SPREADSHEET;
  static constexpr FileFormat LANGUAGE = FileField_FileFormat_LANGUAGE;
  static inline bool FileFormat_IsValid(int value) {
    return FileField_FileFormat_IsValid(value);
  }
  static constexpr FileFormat FileFormat_MIN = FileField_FileFormat_FileFormat_MIN;
  static constexpr FileFormat FileFormat_MAX = FileField_FileFormat_FileFormat_MAX;
  static constexpr int FileFormat_ARRAYSIZE = FileField_FileFormat_FileFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FileFormat_descriptor() {
    return FileField_FileFormat_descriptor();
  }
  template <typename T>
  static inline const std::string& FileFormat_Name(T value) {
    return FileField_FileFormat_Name(value);
  }
  static inline bool FileFormat_Parse(absl::string_view name, FileFormat* value) {
    return FileField_FileFormat_Parse(name, value);
  }

  using DocumentFileType = FileField_DocumentFileType;
  static constexpr DocumentFileType UNKNOWN_DOCUMENT_FILE_TYPE = FileField_DocumentFileType_UNKNOWN_DOCUMENT_FILE_TYPE;
  static constexpr DocumentFileType DOC = FileField_DocumentFileType_DOC;
  static constexpr DocumentFileType DOCX = FileField_DocumentFileType_DOCX;
  static constexpr DocumentFileType TXT = FileField_DocumentFileType_TXT;
  static constexpr DocumentFileType RTF = FileField_DocumentFileType_RTF;
  static constexpr DocumentFileType DOCM = FileField_DocumentFileType_DOCM;
  static constexpr DocumentFileType DOT = FileField_DocumentFileType_DOT;
  static constexpr DocumentFileType DOTM = FileField_DocumentFileType_DOTM;
  static constexpr DocumentFileType DOTX = FileField_DocumentFileType_DOTX;
  static constexpr DocumentFileType ODT = FileField_DocumentFileType_ODT;
  static constexpr DocumentFileType PDF = FileField_DocumentFileType_PDF;
  static inline bool DocumentFileType_IsValid(int value) {
    return FileField_DocumentFileType_IsValid(value);
  }
  static constexpr DocumentFileType DocumentFileType_MIN = FileField_DocumentFileType_DocumentFileType_MIN;
  static constexpr DocumentFileType DocumentFileType_MAX = FileField_DocumentFileType_DocumentFileType_MAX;
  static constexpr int DocumentFileType_ARRAYSIZE = FileField_DocumentFileType_DocumentFileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DocumentFileType_descriptor() {
    return FileField_DocumentFileType_descriptor();
  }
  template <typename T>
  static inline const std::string& DocumentFileType_Name(T value) {
    return FileField_DocumentFileType_Name(value);
  }
  static inline bool DocumentFileType_Parse(absl::string_view name, DocumentFileType* value) {
    return FileField_DocumentFileType_Parse(name, value);
  }

  using PresentationFileType = FileField_PresentationFileType;
  static constexpr PresentationFileType UNKNOWN_PRESENTATION_FILE_TYPE = FileField_PresentationFileType_UNKNOWN_PRESENTATION_FILE_TYPE;
  static constexpr PresentationFileType PPT = FileField_PresentationFileType_PPT;
  static constexpr PresentationFileType PPTX = FileField_PresentationFileType_PPTX;
  static constexpr PresentationFileType PPS = FileField_PresentationFileType_PPS;
  static constexpr PresentationFileType PPSX = FileField_PresentationFileType_PPSX;
  static constexpr PresentationFileType ODP = FileField_PresentationFileType_ODP;
  static constexpr PresentationFileType SXI = FileField_PresentationFileType_SXI;
  static constexpr PresentationFileType KEY = FileField_PresentationFileType_KEY;
  static inline bool PresentationFileType_IsValid(int value) {
    return FileField_PresentationFileType_IsValid(value);
  }
  static constexpr PresentationFileType PresentationFileType_MIN = FileField_PresentationFileType_PresentationFileType_MIN;
  static constexpr PresentationFileType PresentationFileType_MAX = FileField_PresentationFileType_PresentationFileType_MAX;
  static constexpr int PresentationFileType_ARRAYSIZE = FileField_PresentationFileType_PresentationFileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PresentationFileType_descriptor() {
    return FileField_PresentationFileType_descriptor();
  }
  template <typename T>
  static inline const std::string& PresentationFileType_Name(T value) {
    return FileField_PresentationFileType_Name(value);
  }
  static inline bool PresentationFileType_Parse(absl::string_view name, PresentationFileType* value) {
    return FileField_PresentationFileType_Parse(name, value);
  }

  using SpreadsheetFileType = FileField_SpreadsheetFileType;
  static constexpr SpreadsheetFileType UNKNOWN_SPREADSHEET_FILE_TYPE = FileField_SpreadsheetFileType_UNKNOWN_SPREADSHEET_FILE_TYPE;
  static constexpr SpreadsheetFileType XLS = FileField_SpreadsheetFileType_XLS;
  static constexpr SpreadsheetFileType XLSX = FileField_SpreadsheetFileType_XLSX;
  static constexpr SpreadsheetFileType XLSM = FileField_SpreadsheetFileType_XLSM;
  static constexpr SpreadsheetFileType TSV = FileField_SpreadsheetFileType_TSV;
  static constexpr SpreadsheetFileType CSV = FileField_SpreadsheetFileType_CSV;
  static constexpr SpreadsheetFileType ODS = FileField_SpreadsheetFileType_ODS;
  static constexpr SpreadsheetFileType SXC = FileField_SpreadsheetFileType_SXC;
  static constexpr SpreadsheetFileType NUMBERS = FileField_SpreadsheetFileType_NUMBERS;
  static inline bool SpreadsheetFileType_IsValid(int value) {
    return FileField_SpreadsheetFileType_IsValid(value);
  }
  static constexpr SpreadsheetFileType SpreadsheetFileType_MIN = FileField_SpreadsheetFileType_SpreadsheetFileType_MIN;
  static constexpr SpreadsheetFileType SpreadsheetFileType_MAX = FileField_SpreadsheetFileType_SpreadsheetFileType_MAX;
  static constexpr int SpreadsheetFileType_ARRAYSIZE = FileField_SpreadsheetFileType_SpreadsheetFileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SpreadsheetFileType_descriptor() {
    return FileField_SpreadsheetFileType_descriptor();
  }
  template <typename T>
  static inline const std::string& SpreadsheetFileType_Name(T value) {
    return FileField_SpreadsheetFileType_Name(value);
  }
  static inline bool SpreadsheetFileType_Parse(absl::string_view name, SpreadsheetFileType* value) {
    return FileField_SpreadsheetFileType_Parse(name, value);
  }

  using LanguageFileType = FileField_LanguageFileType;
  static constexpr LanguageFileType UNKNOWN_DEVELOPER_FILE_TYPE = FileField_LanguageFileType_UNKNOWN_DEVELOPER_FILE_TYPE;
  static constexpr LanguageFileType HTML = FileField_LanguageFileType_HTML;
  static constexpr LanguageFileType CSS = FileField_LanguageFileType_CSS;
  static constexpr LanguageFileType JS = FileField_LanguageFileType_JS;
  static constexpr LanguageFileType JAVA = FileField_LanguageFileType_JAVA;
  static constexpr LanguageFileType CMD = FileField_LanguageFileType_CMD;
  static constexpr LanguageFileType LESS = FileField_LanguageFileType_LESS;
  static constexpr LanguageFileType JSP = FileField_LanguageFileType_JSP;
  static constexpr LanguageFileType JSON = FileField_LanguageFileType_JSON;
  static constexpr LanguageFileType PY = FileField_LanguageFileType_PY;
  static constexpr LanguageFileType PROTO = FileField_LanguageFileType_PROTO;
  static constexpr LanguageFileType XML = FileField_LanguageFileType_XML;
  static constexpr LanguageFileType SQL = FileField_LanguageFileType_SQL;
  static constexpr LanguageFileType BAT = FileField_LanguageFileType_BAT;
  static constexpr LanguageFileType SWIFT = FileField_LanguageFileType_SWIFT;
  static constexpr LanguageFileType CPP = FileField_LanguageFileType_CPP;
  static constexpr LanguageFileType PROPERTIES = FileField_LanguageFileType_PROPERTIES;
  static constexpr LanguageFileType GO = FileField_LanguageFileType_GO;
  static constexpr LanguageFileType ATOM = FileField_LanguageFileType_ATOM;
  static constexpr LanguageFileType BASH = FileField_LanguageFileType_BASH;
  static constexpr LanguageFileType HPP = FileField_LanguageFileType_HPP;
  static constexpr LanguageFileType LOG = FileField_LanguageFileType_LOG;
  static constexpr LanguageFileType SH = FileField_LanguageFileType_SH;
  static constexpr LanguageFileType COFFEE = FileField_LanguageFileType_COFFEE;
  static constexpr LanguageFileType DART = FileField_LanguageFileType_DART;
  static constexpr LanguageFileType MD = FileField_LanguageFileType_MD;
  static constexpr LanguageFileType DS = FileField_LanguageFileType_DS;
  static constexpr LanguageFileType MK = FileField_LanguageFileType_MK;
  static constexpr LanguageFileType PALI = FileField_LanguageFileType_PALI;
  static constexpr LanguageFileType PL = FileField_LanguageFileType_PL;
  static constexpr LanguageFileType PHP = FileField_LanguageFileType_PHP;
  static constexpr LanguageFileType INI = FileField_LanguageFileType_INI;
  static constexpr LanguageFileType RB = FileField_LanguageFileType_RB;
  static constexpr LanguageFileType RS = FileField_LanguageFileType_RS;
  static constexpr LanguageFileType YAML = FileField_LanguageFileType_YAML;
  static constexpr LanguageFileType YML = FileField_LanguageFileType_YML;
  static constexpr LanguageFileType TEX = FileField_LanguageFileType_TEX;
  static constexpr LanguageFileType ADOC = FileField_LanguageFileType_ADOC;
  static constexpr LanguageFileType BF = FileField_LanguageFileType_BF;
  static constexpr LanguageFileType CLJ = FileField_LanguageFileType_CLJ;
  static constexpr LanguageFileType CR = FileField_LanguageFileType_CR;
  static constexpr LanguageFileType CONF = FileField_LanguageFileType_CONF;
  static constexpr LanguageFileType CS = FileField_LanguageFileType_CS;
  static constexpr LanguageFileType C = FileField_LanguageFileType_C;
  static constexpr LanguageFileType ERL = FileField_LanguageFileType_ERL;
  static constexpr LanguageFileType GOLO = FileField_LanguageFileType_GOLO;
  static constexpr LanguageFileType GROOVY = FileField_LanguageFileType_GROOVY;
  static constexpr LanguageFileType GSH = FileField_LanguageFileType_GSH;
  static constexpr LanguageFileType HTM = FileField_LanguageFileType_HTM;
  static constexpr LanguageFileType HS = FileField_LanguageFileType_HS;
  static constexpr LanguageFileType HX = FileField_LanguageFileType_HX;
  static constexpr LanguageFileType IRB = FileField_LanguageFileType_IRB;
  static constexpr LanguageFileType LUA = FileField_LanguageFileType_LUA;
  static constexpr LanguageFileType MAK = FileField_LanguageFileType_MAK;
  static constexpr LanguageFileType ML = FileField_LanguageFileType_ML;
  static constexpr LanguageFileType SCALA = FileField_LanguageFileType_SCALA;
  static constexpr LanguageFileType SCM = FileField_LanguageFileType_SCM;
  static constexpr LanguageFileType TS = FileField_LanguageFileType_TS;
  static constexpr LanguageFileType VB = FileField_LanguageFileType_VB;
  static constexpr LanguageFileType VIM = FileField_LanguageFileType_VIM;
  static constexpr LanguageFileType XHTML = FileField_LanguageFileType_XHTML;
  static constexpr LanguageFileType XSL = FileField_LanguageFileType_XSL;
  static constexpr LanguageFileType ST = FileField_LanguageFileType_ST;
  static constexpr LanguageFileType PERL = FileField_LanguageFileType_PERL;
  static constexpr LanguageFileType SS = FileField_LanguageFileType_SS;
  static constexpr LanguageFileType F95 = FileField_LanguageFileType_F95;
  static inline bool LanguageFileType_IsValid(int value) {
    return FileField_LanguageFileType_IsValid(value);
  }
  static constexpr LanguageFileType LanguageFileType_MIN = FileField_LanguageFileType_LanguageFileType_MIN;
  static constexpr LanguageFileType LanguageFileType_MAX = FileField_LanguageFileType_LanguageFileType_MAX;
  static constexpr int LanguageFileType_ARRAYSIZE = FileField_LanguageFileType_LanguageFileType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LanguageFileType_descriptor() {
    return FileField_LanguageFileType_descriptor();
  }
  template <typename T>
  static inline const std::string& LanguageFileType_Name(T value) {
    return FileField_LanguageFileType_Name(value);
  }
  static inline bool LanguageFileType_Parse(absl::string_view name, LanguageFileType* value) {
    return FileField_LanguageFileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.FileField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class EffectsField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.EffectsField) */ {
 public:
  inline EffectsField() : EffectsField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EffectsField(::google::protobuf::internal::ConstantInitialized);

  inline EffectsField(const EffectsField& from)
      : EffectsField(nullptr, from) {}
  EffectsField(EffectsField&& from) noexcept
    : EffectsField() {
    *this = ::std::move(from);
  }

  inline EffectsField& operator=(const EffectsField& from) {
    CopyFrom(from);
    return *this;
  }
  inline EffectsField& operator=(EffectsField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EffectsField& default_instance() {
    return *internal_default_instance();
  }
  static inline const EffectsField* internal_default_instance() {
    return reinterpret_cast<const EffectsField*>(
               &_EffectsField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EffectsField& a, EffectsField& b) {
    a.Swap(&b);
  }
  inline void Swap(EffectsField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EffectsField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EffectsField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EffectsField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EffectsField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EffectsField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.EffectsField";
  }
  protected:
  explicit EffectsField(::google::protobuf::Arena* arena);
  EffectsField(::google::protobuf::Arena* arena, const EffectsField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ShadowType = EffectsField_ShadowType;
  static constexpr ShadowType INNER = EffectsField_ShadowType_INNER;
  static constexpr ShadowType OUTER = EffectsField_ShadowType_OUTER;
  static inline bool ShadowType_IsValid(int value) {
    return EffectsField_ShadowType_IsValid(value);
  }
  static constexpr ShadowType ShadowType_MIN = EffectsField_ShadowType_ShadowType_MIN;
  static constexpr ShadowType ShadowType_MAX = EffectsField_ShadowType_ShadowType_MAX;
  static constexpr int ShadowType_ARRAYSIZE = EffectsField_ShadowType_ShadowType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ShadowType_descriptor() {
    return EffectsField_ShadowType_descriptor();
  }
  template <typename T>
  static inline const std::string& ShadowType_Name(T value) {
    return EffectsField_ShadowType_Name(value);
  }
  static inline bool ShadowType_Parse(absl::string_view name, ShadowType* value) {
    return EffectsField_ShadowType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.EffectsField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class DocumentStatusField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.DocumentStatusField) */ {
 public:
  inline DocumentStatusField() : DocumentStatusField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DocumentStatusField(::google::protobuf::internal::ConstantInitialized);

  inline DocumentStatusField(const DocumentStatusField& from)
      : DocumentStatusField(nullptr, from) {}
  DocumentStatusField(DocumentStatusField&& from) noexcept
    : DocumentStatusField() {
    *this = ::std::move(from);
  }

  inline DocumentStatusField& operator=(const DocumentStatusField& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentStatusField& operator=(DocumentStatusField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentStatusField& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentStatusField* internal_default_instance() {
    return reinterpret_cast<const DocumentStatusField*>(
               &_DocumentStatusField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DocumentStatusField& a, DocumentStatusField& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentStatusField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentStatusField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentStatusField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentStatusField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DocumentStatusField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DocumentStatusField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.DocumentStatusField";
  }
  protected:
  explicit DocumentStatusField(::google::protobuf::Arena* arena);
  DocumentStatusField(::google::protobuf::Arena* arena, const DocumentStatusField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DocumentStatusType = DocumentStatusField_DocumentStatusType;
  static constexpr DocumentStatusType UNKNOWN_STATUS = DocumentStatusField_DocumentStatusType_UNKNOWN_STATUS;
  static constexpr DocumentStatusType DESIGN_IN_PROGRESS = DocumentStatusField_DocumentStatusType_DESIGN_IN_PROGRESS;
  static constexpr DocumentStatusType UNDER_DISCUSSION = DocumentStatusField_DocumentStatusType_UNDER_DISCUSSION;
  static constexpr DocumentStatusType READY_FOR_DEVELOPMENT = DocumentStatusField_DocumentStatusType_READY_FOR_DEVELOPMENT;
  static constexpr DocumentStatusType CUSTOM = DocumentStatusField_DocumentStatusType_CUSTOM;
  static constexpr DocumentStatusType UNDER_DEVELOPMENT = DocumentStatusField_DocumentStatusType_UNDER_DEVELOPMENT;
  static constexpr DocumentStatusType DEVELOPED = DocumentStatusField_DocumentStatusType_DEVELOPED;
  static constexpr DocumentStatusType REQUEST_FOR_MODIFICATION = DocumentStatusField_DocumentStatusType_REQUEST_FOR_MODIFICATION;
  static constexpr DocumentStatusType MODIFICATION_IN_PROGRESS = DocumentStatusField_DocumentStatusType_MODIFICATION_IN_PROGRESS;
  static constexpr DocumentStatusType DISCREPANCY_NOTED = DocumentStatusField_DocumentStatusType_DISCREPANCY_NOTED;
  static constexpr DocumentStatusType RELEASED = DocumentStatusField_DocumentStatusType_RELEASED;
  static inline bool DocumentStatusType_IsValid(int value) {
    return DocumentStatusField_DocumentStatusType_IsValid(value);
  }
  static constexpr DocumentStatusType DocumentStatusType_MIN = DocumentStatusField_DocumentStatusType_DocumentStatusType_MIN;
  static constexpr DocumentStatusType DocumentStatusType_MAX = DocumentStatusField_DocumentStatusType_DocumentStatusType_MAX;
  static constexpr int DocumentStatusType_ARRAYSIZE = DocumentStatusField_DocumentStatusType_DocumentStatusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DocumentStatusType_descriptor() {
    return DocumentStatusField_DocumentStatusType_descriptor();
  }
  template <typename T>
  static inline const std::string& DocumentStatusType_Name(T value) {
    return DocumentStatusField_DocumentStatusType_Name(value);
  }
  static inline bool DocumentStatusType_Parse(absl::string_view name, DocumentStatusType* value) {
    return DocumentStatusField_DocumentStatusType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.DocumentStatusField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class DatabaseField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.DatabaseField) */ {
 public:
  inline DatabaseField() : DatabaseField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DatabaseField(::google::protobuf::internal::ConstantInitialized);

  inline DatabaseField(const DatabaseField& from)
      : DatabaseField(nullptr, from) {}
  DatabaseField(DatabaseField&& from) noexcept
    : DatabaseField() {
    *this = ::std::move(from);
  }

  inline DatabaseField& operator=(const DatabaseField& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseField& operator=(DatabaseField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseField& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseField* internal_default_instance() {
    return reinterpret_cast<const DatabaseField*>(
               &_DatabaseField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DatabaseField& a, DatabaseField& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DatabaseField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DatabaseField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.DatabaseField";
  }
  protected:
  explicit DatabaseField(::google::protobuf::Arena* arena);
  DatabaseField(::google::protobuf::Arena* arena, const DatabaseField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TableOrColumnCategory = DatabaseField_TableOrColumnCategory;
  static constexpr TableOrColumnCategory DEFAULT_TABLE_COLUMN = DatabaseField_TableOrColumnCategory_DEFAULT_TABLE_COLUMN;
  static constexpr TableOrColumnCategory PARENT = DatabaseField_TableOrColumnCategory_PARENT;
  static constexpr TableOrColumnCategory CHILD = DatabaseField_TableOrColumnCategory_CHILD;
  static inline bool TableOrColumnCategory_IsValid(int value) {
    return DatabaseField_TableOrColumnCategory_IsValid(value);
  }
  static constexpr TableOrColumnCategory TableOrColumnCategory_MIN = DatabaseField_TableOrColumnCategory_TableOrColumnCategory_MIN;
  static constexpr TableOrColumnCategory TableOrColumnCategory_MAX = DatabaseField_TableOrColumnCategory_TableOrColumnCategory_MAX;
  static constexpr int TableOrColumnCategory_ARRAYSIZE = DatabaseField_TableOrColumnCategory_TableOrColumnCategory_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TableOrColumnCategory_descriptor() {
    return DatabaseField_TableOrColumnCategory_descriptor();
  }
  template <typename T>
  static inline const std::string& TableOrColumnCategory_Name(T value) {
    return DatabaseField_TableOrColumnCategory_Name(value);
  }
  static inline bool TableOrColumnCategory_Parse(absl::string_view name, TableOrColumnCategory* value) {
    return DatabaseField_TableOrColumnCategory_Parse(name, value);
  }

  using WhereOperator = DatabaseField_WhereOperator;
  static constexpr WhereOperator DEFAULT_WHERE_OPERATOR = DatabaseField_WhereOperator_DEFAULT_WHERE_OPERATOR;
  static constexpr WhereOperator COMPARISON = DatabaseField_WhereOperator_COMPARISON;
  static constexpr WhereOperator PATTERN = DatabaseField_WhereOperator_PATTERN;
  static inline bool WhereOperator_IsValid(int value) {
    return DatabaseField_WhereOperator_IsValid(value);
  }
  static constexpr WhereOperator WhereOperator_MIN = DatabaseField_WhereOperator_WhereOperator_MIN;
  static constexpr WhereOperator WhereOperator_MAX = DatabaseField_WhereOperator_WhereOperator_MAX;
  static constexpr int WhereOperator_ARRAYSIZE = DatabaseField_WhereOperator_WhereOperator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* WhereOperator_descriptor() {
    return DatabaseField_WhereOperator_descriptor();
  }
  template <typename T>
  static inline const std::string& WhereOperator_Name(T value) {
    return DatabaseField_WhereOperator_Name(value);
  }
  static inline bool WhereOperator_Parse(absl::string_view name, WhereOperator* value) {
    return DatabaseField_WhereOperator_Parse(name, value);
  }

  using ComparisonOperator = DatabaseField_ComparisonOperator;
  static constexpr ComparisonOperator DEFAULT_COMPARISON_OPERATOR = DatabaseField_ComparisonOperator_DEFAULT_COMPARISON_OPERATOR;
  static constexpr ComparisonOperator EQUALS = DatabaseField_ComparisonOperator_EQUALS;
  static constexpr ComparisonOperator NOT_EQUALS = DatabaseField_ComparisonOperator_NOT_EQUALS;
  static constexpr ComparisonOperator GREATER_THAN = DatabaseField_ComparisonOperator_GREATER_THAN;
  static constexpr ComparisonOperator LESSER_THAN = DatabaseField_ComparisonOperator_LESSER_THAN;
  static constexpr ComparisonOperator GREATER_THAN_OR_EQUALS = DatabaseField_ComparisonOperator_GREATER_THAN_OR_EQUALS;
  static constexpr ComparisonOperator LESSER_THAN_OR_EQUALS = DatabaseField_ComparisonOperator_LESSER_THAN_OR_EQUALS;
  static inline bool ComparisonOperator_IsValid(int value) {
    return DatabaseField_ComparisonOperator_IsValid(value);
  }
  static constexpr ComparisonOperator ComparisonOperator_MIN = DatabaseField_ComparisonOperator_ComparisonOperator_MIN;
  static constexpr ComparisonOperator ComparisonOperator_MAX = DatabaseField_ComparisonOperator_ComparisonOperator_MAX;
  static constexpr int ComparisonOperator_ARRAYSIZE = DatabaseField_ComparisonOperator_ComparisonOperator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ComparisonOperator_descriptor() {
    return DatabaseField_ComparisonOperator_descriptor();
  }
  template <typename T>
  static inline const std::string& ComparisonOperator_Name(T value) {
    return DatabaseField_ComparisonOperator_Name(value);
  }
  static inline bool ComparisonOperator_Parse(absl::string_view name, ComparisonOperator* value) {
    return DatabaseField_ComparisonOperator_Parse(name, value);
  }

  using LogicalOperator = DatabaseField_LogicalOperator;
  static constexpr LogicalOperator DEFAULT_LOGICAL_OPERATOR = DatabaseField_LogicalOperator_DEFAULT_LOGICAL_OPERATOR;
  static constexpr LogicalOperator AND = DatabaseField_LogicalOperator_AND;
  static constexpr LogicalOperator OR = DatabaseField_LogicalOperator_OR;
  static constexpr LogicalOperator NOT = DatabaseField_LogicalOperator_NOT;
  static inline bool LogicalOperator_IsValid(int value) {
    return DatabaseField_LogicalOperator_IsValid(value);
  }
  static constexpr LogicalOperator LogicalOperator_MIN = DatabaseField_LogicalOperator_LogicalOperator_MIN;
  static constexpr LogicalOperator LogicalOperator_MAX = DatabaseField_LogicalOperator_LogicalOperator_MAX;
  static constexpr int LogicalOperator_ARRAYSIZE = DatabaseField_LogicalOperator_LogicalOperator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LogicalOperator_descriptor() {
    return DatabaseField_LogicalOperator_descriptor();
  }
  template <typename T>
  static inline const std::string& LogicalOperator_Name(T value) {
    return DatabaseField_LogicalOperator_Name(value);
  }
  static inline bool LogicalOperator_Parse(absl::string_view name, LogicalOperator* value) {
    return DatabaseField_LogicalOperator_Parse(name, value);
  }

  using SubQueryOperator = DatabaseField_SubQueryOperator;
  static constexpr SubQueryOperator DEFAULT_SUB_QUERY_OPERATOR = DatabaseField_SubQueryOperator_DEFAULT_SUB_QUERY_OPERATOR;
  static constexpr SubQueryOperator START_SUB_QUERY = DatabaseField_SubQueryOperator_START_SUB_QUERY;
  static constexpr SubQueryOperator END_SUB_QUERY = DatabaseField_SubQueryOperator_END_SUB_QUERY;
  static inline bool SubQueryOperator_IsValid(int value) {
    return DatabaseField_SubQueryOperator_IsValid(value);
  }
  static constexpr SubQueryOperator SubQueryOperator_MIN = DatabaseField_SubQueryOperator_SubQueryOperator_MIN;
  static constexpr SubQueryOperator SubQueryOperator_MAX = DatabaseField_SubQueryOperator_SubQueryOperator_MAX;
  static constexpr int SubQueryOperator_ARRAYSIZE = DatabaseField_SubQueryOperator_SubQueryOperator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SubQueryOperator_descriptor() {
    return DatabaseField_SubQueryOperator_descriptor();
  }
  template <typename T>
  static inline const std::string& SubQueryOperator_Name(T value) {
    return DatabaseField_SubQueryOperator_Name(value);
  }
  static inline bool SubQueryOperator_Parse(absl::string_view name, SubQueryOperator* value) {
    return DatabaseField_SubQueryOperator_Parse(name, value);
  }

  using PatternOperator = DatabaseField_PatternOperator;
  static constexpr PatternOperator DEFAULT_PATTERN_OPERATOR = DatabaseField_PatternOperator_DEFAULT_PATTERN_OPERATOR;
  static constexpr PatternOperator IN = DatabaseField_PatternOperator_IN;
  static constexpr PatternOperator BETWEEN = DatabaseField_PatternOperator_BETWEEN;
  static constexpr PatternOperator LIKE = DatabaseField_PatternOperator_LIKE;
  static constexpr PatternOperator STARTS_WITH = DatabaseField_PatternOperator_STARTS_WITH;
  static constexpr PatternOperator ENDS_WITH = DatabaseField_PatternOperator_ENDS_WITH;
  static constexpr PatternOperator EXISTS = DatabaseField_PatternOperator_EXISTS;
  static constexpr PatternOperator SOME = DatabaseField_PatternOperator_SOME;
  static constexpr PatternOperator ANY = DatabaseField_PatternOperator_ANY;
  static constexpr PatternOperator ALL = DatabaseField_PatternOperator_ALL;
  static inline bool PatternOperator_IsValid(int value) {
    return DatabaseField_PatternOperator_IsValid(value);
  }
  static constexpr PatternOperator PatternOperator_MIN = DatabaseField_PatternOperator_PatternOperator_MIN;
  static constexpr PatternOperator PatternOperator_MAX = DatabaseField_PatternOperator_PatternOperator_MAX;
  static constexpr int PatternOperator_ARRAYSIZE = DatabaseField_PatternOperator_PatternOperator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PatternOperator_descriptor() {
    return DatabaseField_PatternOperator_descriptor();
  }
  template <typename T>
  static inline const std::string& PatternOperator_Name(T value) {
    return DatabaseField_PatternOperator_Name(value);
  }
  static inline bool PatternOperator_Parse(absl::string_view name, PatternOperator* value) {
    return DatabaseField_PatternOperator_Parse(name, value);
  }

  using SortOrder = DatabaseField_SortOrder;
  static constexpr SortOrder DEFAULT_SORT_ORDER = DatabaseField_SortOrder_DEFAULT_SORT_ORDER;
  static constexpr SortOrder ASCENDING = DatabaseField_SortOrder_ASCENDING;
  static constexpr SortOrder DESCENDING = DatabaseField_SortOrder_DESCENDING;
  static inline bool SortOrder_IsValid(int value) {
    return DatabaseField_SortOrder_IsValid(value);
  }
  static constexpr SortOrder SortOrder_MIN = DatabaseField_SortOrder_SortOrder_MIN;
  static constexpr SortOrder SortOrder_MAX = DatabaseField_SortOrder_SortOrder_MAX;
  static constexpr int SortOrder_ARRAYSIZE = DatabaseField_SortOrder_SortOrder_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SortOrder_descriptor() {
    return DatabaseField_SortOrder_descriptor();
  }
  template <typename T>
  static inline const std::string& SortOrder_Name(T value) {
    return DatabaseField_SortOrder_Name(value);
  }
  static inline bool SortOrder_Parse(absl::string_view name, SortOrder* value) {
    return DatabaseField_SortOrder_Parse(name, value);
  }

  using DataOperator = DatabaseField_DataOperator;
  static constexpr DataOperator DEFAULT_DATA_OPERATOR = DatabaseField_DataOperator_DEFAULT_DATA_OPERATOR;
  static constexpr DataOperator INSERT = DatabaseField_DataOperator_INSERT;
  static constexpr DataOperator MODIFY = DatabaseField_DataOperator_MODIFY;
  static constexpr DataOperator DELETE = DatabaseField_DataOperator_DELETE;
  static constexpr DataOperator SELECT = DatabaseField_DataOperator_SELECT;
  static inline bool DataOperator_IsValid(int value) {
    return DatabaseField_DataOperator_IsValid(value);
  }
  static constexpr DataOperator DataOperator_MIN = DatabaseField_DataOperator_DataOperator_MIN;
  static constexpr DataOperator DataOperator_MAX = DatabaseField_DataOperator_DataOperator_MAX;
  static constexpr int DataOperator_ARRAYSIZE = DatabaseField_DataOperator_DataOperator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DataOperator_descriptor() {
    return DatabaseField_DataOperator_descriptor();
  }
  template <typename T>
  static inline const std::string& DataOperator_Name(T value) {
    return DatabaseField_DataOperator_Name(value);
  }
  static inline bool DataOperator_Parse(absl::string_view name, DataOperator* value) {
    return DatabaseField_DataOperator_Parse(name, value);
  }

  using DataOperatedOn = DatabaseField_DataOperatedOn;
  static constexpr DataOperatedOn DEFAULT_DATA_OPERATED_ON = DatabaseField_DataOperatedOn_DEFAULT_DATA_OPERATED_ON;
  static constexpr DataOperatedOn TABLE = DatabaseField_DataOperatedOn_TABLE;
  static constexpr DataOperatedOn COLUMN = DatabaseField_DataOperatedOn_COLUMN;
  static constexpr DataOperatedOn ROW = DatabaseField_DataOperatedOn_ROW;
  static inline bool DataOperatedOn_IsValid(int value) {
    return DatabaseField_DataOperatedOn_IsValid(value);
  }
  static constexpr DataOperatedOn DataOperatedOn_MIN = DatabaseField_DataOperatedOn_DataOperatedOn_MIN;
  static constexpr DataOperatedOn DataOperatedOn_MAX = DatabaseField_DataOperatedOn_DataOperatedOn_MAX;
  static constexpr int DataOperatedOn_ARRAYSIZE = DatabaseField_DataOperatedOn_DataOperatedOn_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DataOperatedOn_descriptor() {
    return DatabaseField_DataOperatedOn_descriptor();
  }
  template <typename T>
  static inline const std::string& DataOperatedOn_Name(T value) {
    return DatabaseField_DataOperatedOn_Name(value);
  }
  static inline bool DataOperatedOn_Parse(absl::string_view name, DataOperatedOn* value) {
    return DatabaseField_DataOperatedOn_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.DatabaseField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class DataSourceField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.DataSourceField) */ {
 public:
  inline DataSourceField() : DataSourceField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataSourceField(::google::protobuf::internal::ConstantInitialized);

  inline DataSourceField(const DataSourceField& from)
      : DataSourceField(nullptr, from) {}
  DataSourceField(DataSourceField&& from) noexcept
    : DataSourceField() {
    *this = ::std::move(from);
  }

  inline DataSourceField& operator=(const DataSourceField& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataSourceField& operator=(DataSourceField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataSourceField& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataSourceField* internal_default_instance() {
    return reinterpret_cast<const DataSourceField*>(
               &_DataSourceField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DataSourceField& a, DataSourceField& b) {
    a.Swap(&b);
  }
  inline void Swap(DataSourceField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataSourceField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataSourceField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataSourceField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataSourceField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataSourceField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.DataSourceField";
  }
  protected:
  explicit DataSourceField(::google::protobuf::Arena* arena);
  DataSourceField(::google::protobuf::Arena* arena, const DataSourceField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using DataSourceServiceType = DataSourceField_DataSourceServiceType;
  static constexpr DataSourceServiceType UNKNOWN_SERVICE = DataSourceField_DataSourceServiceType_UNKNOWN_SERVICE;
  static constexpr DataSourceServiceType ZOHO_SHEET = DataSourceField_DataSourceServiceType_ZOHO_SHEET;
  static constexpr DataSourceServiceType ZOHO_CRM = DataSourceField_DataSourceServiceType_ZOHO_CRM;
  static constexpr DataSourceServiceType ZOHO_SURVEY = DataSourceField_DataSourceServiceType_ZOHO_SURVEY;
  static inline bool DataSourceServiceType_IsValid(int value) {
    return DataSourceField_DataSourceServiceType_IsValid(value);
  }
  static constexpr DataSourceServiceType DataSourceServiceType_MIN = DataSourceField_DataSourceServiceType_DataSourceServiceType_MIN;
  static constexpr DataSourceServiceType DataSourceServiceType_MAX = DataSourceField_DataSourceServiceType_DataSourceServiceType_MAX;
  static constexpr int DataSourceServiceType_ARRAYSIZE = DataSourceField_DataSourceServiceType_DataSourceServiceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DataSourceServiceType_descriptor() {
    return DataSourceField_DataSourceServiceType_descriptor();
  }
  template <typename T>
  static inline const std::string& DataSourceServiceType_Name(T value) {
    return DataSourceField_DataSourceServiceType_Name(value);
  }
  static inline bool DataSourceServiceType_Parse(absl::string_view name, DataSourceServiceType* value) {
    return DataSourceField_DataSourceServiceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.DataSourceField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class CommonField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.CommonField) */ {
 public:
  inline CommonField() : CommonField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonField(::google::protobuf::internal::ConstantInitialized);

  inline CommonField(const CommonField& from)
      : CommonField(nullptr, from) {}
  CommonField(CommonField&& from) noexcept
    : CommonField() {
    *this = ::std::move(from);
  }

  inline CommonField& operator=(const CommonField& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonField& operator=(CommonField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonField& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonField* internal_default_instance() {
    return reinterpret_cast<const CommonField*>(
               &_CommonField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommonField& a, CommonField& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommonField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommonField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.CommonField";
  }
  protected:
  explicit CommonField(::google::protobuf::Arena* arena);
  CommonField(::google::protobuf::Arena* arena, const CommonField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UseParentProps = CommonField_UseParentProps;
  static constexpr UseParentProps NONE = CommonField_UseParentProps_NONE;
  static constexpr UseParentProps TEXTBOX = CommonField_UseParentProps_TEXTBOX;
  static inline bool UseParentProps_IsValid(int value) {
    return CommonField_UseParentProps_IsValid(value);
  }
  static constexpr UseParentProps UseParentProps_MIN = CommonField_UseParentProps_UseParentProps_MIN;
  static constexpr UseParentProps UseParentProps_MAX = CommonField_UseParentProps_UseParentProps_MAX;
  static constexpr int UseParentProps_ARRAYSIZE = CommonField_UseParentProps_UseParentProps_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UseParentProps_descriptor() {
    return CommonField_UseParentProps_descriptor();
  }
  template <typename T>
  static inline const std::string& UseParentProps_Name(T value) {
    return CommonField_UseParentProps_Name(value);
  }
  static inline bool UseParentProps_Parse(absl::string_view name, UseParentProps* value) {
    return CommonField_UseParentProps_Parse(name, value);
  }

  using MeasuringUnit = CommonField_MeasuringUnit;
  static constexpr MeasuringUnit PIXEL = CommonField_MeasuringUnit_PIXEL;
  static constexpr MeasuringUnit INCH = CommonField_MeasuringUnit_INCH;
  static constexpr MeasuringUnit CM = CommonField_MeasuringUnit_CM;
  static inline bool MeasuringUnit_IsValid(int value) {
    return CommonField_MeasuringUnit_IsValid(value);
  }
  static constexpr MeasuringUnit MeasuringUnit_MIN = CommonField_MeasuringUnit_MeasuringUnit_MIN;
  static constexpr MeasuringUnit MeasuringUnit_MAX = CommonField_MeasuringUnit_MeasuringUnit_MAX;
  static constexpr int MeasuringUnit_ARRAYSIZE = CommonField_MeasuringUnit_MeasuringUnit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MeasuringUnit_descriptor() {
    return CommonField_MeasuringUnit_descriptor();
  }
  template <typename T>
  static inline const std::string& MeasuringUnit_Name(T value) {
    return CommonField_MeasuringUnit_Name(value);
  }
  static inline bool MeasuringUnit_Parse(absl::string_view name, MeasuringUnit* value) {
    return CommonField_MeasuringUnit_Parse(name, value);
  }

  using ValueVariant = CommonField_ValueVariant;
  static constexpr ValueVariant UNKNOWN_VARIANT = CommonField_ValueVariant_UNKNOWN_VARIANT;
  static constexpr ValueVariant RELATIVE = CommonField_ValueVariant_RELATIVE;
  static constexpr ValueVariant ABSOLUTE = CommonField_ValueVariant_ABSOLUTE;
  static inline bool ValueVariant_IsValid(int value) {
    return CommonField_ValueVariant_IsValid(value);
  }
  static constexpr ValueVariant ValueVariant_MIN = CommonField_ValueVariant_ValueVariant_MIN;
  static constexpr ValueVariant ValueVariant_MAX = CommonField_ValueVariant_ValueVariant_MAX;
  static constexpr int ValueVariant_ARRAYSIZE = CommonField_ValueVariant_ValueVariant_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ValueVariant_descriptor() {
    return CommonField_ValueVariant_descriptor();
  }
  template <typename T>
  static inline const std::string& ValueVariant_Name(T value) {
    return CommonField_ValueVariant_Name(value);
  }
  static inline bool ValueVariant_Parse(absl::string_view name, ValueVariant* value) {
    return CommonField_ValueVariant_Parse(name, value);
  }

  using ValueType = CommonField_ValueType;
  static constexpr ValueType UNKNOWN = CommonField_ValueType_UNKNOWN;
  static constexpr ValueType BOOLEAN = CommonField_ValueType_BOOLEAN;
  static constexpr ValueType STRING = CommonField_ValueType_STRING;
  static constexpr ValueType FLOAT = CommonField_ValueType_FLOAT;
  static constexpr ValueType DOUBLE = CommonField_ValueType_DOUBLE;
  static constexpr ValueType INTEGER = CommonField_ValueType_INTEGER;
  static constexpr ValueType LONG = CommonField_ValueType_LONG;
  static constexpr ValueType PERSON = CommonField_ValueType_PERSON;
  static constexpr ValueType DATETIME = CommonField_ValueType_DATETIME;
  static constexpr ValueType EMAIL = CommonField_ValueType_EMAIL;
  static constexpr ValueType CONTACT = CommonField_ValueType_CONTACT;
  static constexpr ValueType CUSTOM = CommonField_ValueType_CUSTOM;
  static inline bool ValueType_IsValid(int value) {
    return CommonField_ValueType_IsValid(value);
  }
  static constexpr ValueType ValueType_MIN = CommonField_ValueType_ValueType_MIN;
  static constexpr ValueType ValueType_MAX = CommonField_ValueType_ValueType_MAX;
  static constexpr int ValueType_ARRAYSIZE = CommonField_ValueType_ValueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ValueType_descriptor() {
    return CommonField_ValueType_descriptor();
  }
  template <typename T>
  static inline const std::string& ValueType_Name(T value) {
    return CommonField_ValueType_Name(value);
  }
  static inline bool ValueType_Parse(absl::string_view name, ValueType* value) {
    return CommonField_ValueType_Parse(name, value);
  }

  using CompositeValueType = CommonField_CompositeValueType;
  static constexpr CompositeValueType DEFAULT_VALUE = CommonField_CompositeValueType_DEFAULT_VALUE;
  static constexpr CompositeValueType BASIC = CommonField_CompositeValueType_BASIC;
  static constexpr CompositeValueType ARRAY = CommonField_CompositeValueType_ARRAY;
  static constexpr CompositeValueType MATRIX = CommonField_CompositeValueType_MATRIX;
  static constexpr CompositeValueType DATA_MAP = CommonField_CompositeValueType_DATA_MAP;
  static constexpr CompositeValueType JSON_MAP = CommonField_CompositeValueType_JSON_MAP;
  static inline bool CompositeValueType_IsValid(int value) {
    return CommonField_CompositeValueType_IsValid(value);
  }
  static constexpr CompositeValueType CompositeValueType_MIN = CommonField_CompositeValueType_CompositeValueType_MIN;
  static constexpr CompositeValueType CompositeValueType_MAX = CommonField_CompositeValueType_CompositeValueType_MAX;
  static constexpr int CompositeValueType_ARRAYSIZE = CommonField_CompositeValueType_CompositeValueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CompositeValueType_descriptor() {
    return CommonField_CompositeValueType_descriptor();
  }
  template <typename T>
  static inline const std::string& CompositeValueType_Name(T value) {
    return CommonField_CompositeValueType_Name(value);
  }
  static inline bool CompositeValueType_Parse(absl::string_view name, CompositeValueType* value) {
    return CommonField_CompositeValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.CommonField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class ChartField_BarChartField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.ChartField.BarChartField) */ {
 public:
  inline ChartField_BarChartField() : ChartField_BarChartField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartField_BarChartField(::google::protobuf::internal::ConstantInitialized);

  inline ChartField_BarChartField(const ChartField_BarChartField& from)
      : ChartField_BarChartField(nullptr, from) {}
  ChartField_BarChartField(ChartField_BarChartField&& from) noexcept
    : ChartField_BarChartField() {
    *this = ::std::move(from);
  }

  inline ChartField_BarChartField& operator=(const ChartField_BarChartField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartField_BarChartField& operator=(ChartField_BarChartField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartField_BarChartField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartField_BarChartField* internal_default_instance() {
    return reinterpret_cast<const ChartField_BarChartField*>(
               &_ChartField_BarChartField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ChartField_BarChartField& a, ChartField_BarChartField& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartField_BarChartField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartField_BarChartField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartField_BarChartField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartField_BarChartField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChartField_BarChartField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChartField_BarChartField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.ChartField.BarChartField";
  }
  protected:
  explicit ChartField_BarChartField(::google::protobuf::Arena* arena);
  ChartField_BarChartField(::google::protobuf::Arena* arena, const ChartField_BarChartField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using BarType = ChartField_BarChartField_BarType;
  static constexpr BarType BAR = ChartField_BarChartField_BarType_BAR;
  static constexpr BarType COL = ChartField_BarChartField_BarType_COL;
  static inline bool BarType_IsValid(int value) {
    return ChartField_BarChartField_BarType_IsValid(value);
  }
  static constexpr BarType BarType_MIN = ChartField_BarChartField_BarType_BarType_MIN;
  static constexpr BarType BarType_MAX = ChartField_BarChartField_BarType_BarType_MAX;
  static constexpr int BarType_ARRAYSIZE = ChartField_BarChartField_BarType_BarType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BarType_descriptor() {
    return ChartField_BarChartField_BarType_descriptor();
  }
  template <typename T>
  static inline const std::string& BarType_Name(T value) {
    return ChartField_BarChartField_BarType_Name(value);
  }
  static inline bool BarType_Parse(absl::string_view name, BarType* value) {
    return ChartField_BarChartField_BarType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.ChartField.BarChartField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class ChartField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.ChartField) */ {
 public:
  inline ChartField() : ChartField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChartField(::google::protobuf::internal::ConstantInitialized);

  inline ChartField(const ChartField& from)
      : ChartField(nullptr, from) {}
  ChartField(ChartField&& from) noexcept
    : ChartField() {
    *this = ::std::move(from);
  }

  inline ChartField& operator=(const ChartField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartField& operator=(ChartField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartField* internal_default_instance() {
    return reinterpret_cast<const ChartField*>(
               &_ChartField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChartField& a, ChartField& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChartField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChartField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.ChartField";
  }
  protected:
  explicit ChartField(::google::protobuf::Arena* arena);
  ChartField(::google::protobuf::Arena* arena, const ChartField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using BarChartField = ChartField_BarChartField;

  using ChartType = ChartField_ChartType;
  static constexpr ChartType BAR = ChartField_ChartType_BAR;
  static constexpr ChartType BAR3D = ChartField_ChartType_BAR3D;
  static constexpr ChartType LINE = ChartField_ChartType_LINE;
  static constexpr ChartType LINE3D = ChartField_ChartType_LINE3D;
  static constexpr ChartType AREA = ChartField_ChartType_AREA;
  static constexpr ChartType AREA3D = ChartField_ChartType_AREA3D;
  static constexpr ChartType PIE = ChartField_ChartType_PIE;
  static constexpr ChartType PIE3D = ChartField_ChartType_PIE3D;
  static constexpr ChartType REPPIE = ChartField_ChartType_REPPIE;
  static constexpr ChartType DOUGHNUT = ChartField_ChartType_DOUGHNUT;
  static constexpr ChartType SCATTER = ChartField_ChartType_SCATTER;
  static constexpr ChartType BUBBLE = ChartField_ChartType_BUBBLE;
  static inline bool ChartType_IsValid(int value) {
    return ChartField_ChartType_IsValid(value);
  }
  static constexpr ChartType ChartType_MIN = ChartField_ChartType_ChartType_MIN;
  static constexpr ChartType ChartType_MAX = ChartField_ChartType_ChartType_MAX;
  static constexpr int ChartType_ARRAYSIZE = ChartField_ChartType_ChartType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ChartType_descriptor() {
    return ChartField_ChartType_descriptor();
  }
  template <typename T>
  static inline const std::string& ChartType_Name(T value) {
    return ChartField_ChartType_Name(value);
  }
  static inline bool ChartType_Parse(absl::string_view name, ChartType* value) {
    return ChartField_ChartType_Parse(name, value);
  }

  using Grouping = ChartField_Grouping;
  static constexpr Grouping STANDARD = ChartField_Grouping_STANDARD;
  static constexpr Grouping CLUSTERED = ChartField_Grouping_CLUSTERED;
  static constexpr Grouping STACKED = ChartField_Grouping_STACKED;
  static constexpr Grouping PERCENTSTACKED = ChartField_Grouping_PERCENTSTACKED;
  static inline bool Grouping_IsValid(int value) {
    return ChartField_Grouping_IsValid(value);
  }
  static constexpr Grouping Grouping_MIN = ChartField_Grouping_Grouping_MIN;
  static constexpr Grouping Grouping_MAX = ChartField_Grouping_Grouping_MAX;
  static constexpr int Grouping_ARRAYSIZE = ChartField_Grouping_Grouping_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Grouping_descriptor() {
    return ChartField_Grouping_descriptor();
  }
  template <typename T>
  static inline const std::string& Grouping_Name(T value) {
    return ChartField_Grouping_Name(value);
  }
  static inline bool Grouping_Parse(absl::string_view name, Grouping* value) {
    return ChartField_Grouping_Parse(name, value);
  }

  using DataLabelPosition = ChartField_DataLabelPosition;
  static constexpr DataLabelPosition BESTFIT = ChartField_DataLabelPosition_BESTFIT;
  static constexpr DataLabelPosition BOTTOM = ChartField_DataLabelPosition_BOTTOM;
  static constexpr DataLabelPosition CENTER = ChartField_DataLabelPosition_CENTER;
  static constexpr DataLabelPosition INBASE = ChartField_DataLabelPosition_INBASE;
  static constexpr DataLabelPosition INEND = ChartField_DataLabelPosition_INEND;
  static constexpr DataLabelPosition LEFT = ChartField_DataLabelPosition_LEFT;
  static constexpr DataLabelPosition OUTEND = ChartField_DataLabelPosition_OUTEND;
  static constexpr DataLabelPosition RIGHT = ChartField_DataLabelPosition_RIGHT;
  static constexpr DataLabelPosition TOP = ChartField_DataLabelPosition_TOP;
  static inline bool DataLabelPosition_IsValid(int value) {
    return ChartField_DataLabelPosition_IsValid(value);
  }
  static constexpr DataLabelPosition DataLabelPosition_MIN = ChartField_DataLabelPosition_DataLabelPosition_MIN;
  static constexpr DataLabelPosition DataLabelPosition_MAX = ChartField_DataLabelPosition_DataLabelPosition_MAX;
  static constexpr int DataLabelPosition_ARRAYSIZE = ChartField_DataLabelPosition_DataLabelPosition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DataLabelPosition_descriptor() {
    return ChartField_DataLabelPosition_descriptor();
  }
  template <typename T>
  static inline const std::string& DataLabelPosition_Name(T value) {
    return ChartField_DataLabelPosition_Name(value);
  }
  static inline bool DataLabelPosition_Parse(absl::string_view name, DataLabelPosition* value) {
    return ChartField_DataLabelPosition_Parse(name, value);
  }

  using PositionElement = ChartField_PositionElement;
  static constexpr PositionElement T = ChartField_PositionElement_T;
  static constexpr PositionElement L = ChartField_PositionElement_L;
  static constexpr PositionElement B = ChartField_PositionElement_B;
  static constexpr PositionElement R = ChartField_PositionElement_R;
  static constexpr PositionElement TR = ChartField_PositionElement_TR;
  static constexpr PositionElement MANUAL = ChartField_PositionElement_MANUAL;
  static constexpr PositionElement C = ChartField_PositionElement_C;
  static inline bool PositionElement_IsValid(int value) {
    return ChartField_PositionElement_IsValid(value);
  }
  static constexpr PositionElement PositionElement_MIN = ChartField_PositionElement_PositionElement_MIN;
  static constexpr PositionElement PositionElement_MAX = ChartField_PositionElement_PositionElement_MAX;
  static constexpr int PositionElement_ARRAYSIZE = ChartField_PositionElement_PositionElement_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PositionElement_descriptor() {
    return ChartField_PositionElement_descriptor();
  }
  template <typename T>
  static inline const std::string& PositionElement_Name(T value) {
    return ChartField_PositionElement_Name(value);
  }
  static inline bool PositionElement_Parse(absl::string_view name, PositionElement* value) {
    return ChartField_PositionElement_Parse(name, value);
  }

  using TickMarkType = ChartField_TickMarkType;
  static constexpr TickMarkType NONE = ChartField_TickMarkType_NONE;
  static constexpr TickMarkType IN = ChartField_TickMarkType_IN;
  static constexpr TickMarkType OUT = ChartField_TickMarkType_OUT;
  static constexpr TickMarkType CROSS = ChartField_TickMarkType_CROSS;
  static inline bool TickMarkType_IsValid(int value) {
    return ChartField_TickMarkType_IsValid(value);
  }
  static constexpr TickMarkType TickMarkType_MIN = ChartField_TickMarkType_TickMarkType_MIN;
  static constexpr TickMarkType TickMarkType_MAX = ChartField_TickMarkType_TickMarkType_MAX;
  static constexpr int TickMarkType_ARRAYSIZE = ChartField_TickMarkType_TickMarkType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TickMarkType_descriptor() {
    return ChartField_TickMarkType_descriptor();
  }
  template <typename T>
  static inline const std::string& TickMarkType_Name(T value) {
    return ChartField_TickMarkType_Name(value);
  }
  static inline bool TickMarkType_Parse(absl::string_view name, TickMarkType* value) {
    return ChartField_TickMarkType_Parse(name, value);
  }

  using LabelPos = ChartField_LabelPos;
  static constexpr LabelPos NIL = ChartField_LabelPos_NIL;
  static constexpr LabelPos HIGH = ChartField_LabelPos_HIGH;
  static constexpr LabelPos LOW = ChartField_LabelPos_LOW;
  static constexpr LabelPos NEXTTO = ChartField_LabelPos_NEXTTO;
  static inline bool LabelPos_IsValid(int value) {
    return ChartField_LabelPos_IsValid(value);
  }
  static constexpr LabelPos LabelPos_MIN = ChartField_LabelPos_LabelPos_MIN;
  static constexpr LabelPos LabelPos_MAX = ChartField_LabelPos_LabelPos_MAX;
  static constexpr int LabelPos_ARRAYSIZE = ChartField_LabelPos_LabelPos_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LabelPos_descriptor() {
    return ChartField_LabelPos_descriptor();
  }
  template <typename T>
  static inline const std::string& LabelPos_Name(T value) {
    return ChartField_LabelPos_Name(value);
  }
  static inline bool LabelPos_Parse(absl::string_view name, LabelPos* value) {
    return ChartField_LabelPos_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.ChartField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};// -------------------------------------------------------------------

class AnimationField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Show.AnimationField) */ {
 public:
  inline AnimationField() : AnimationField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnimationField(::google::protobuf::internal::ConstantInitialized);

  inline AnimationField(const AnimationField& from)
      : AnimationField(nullptr, from) {}
  AnimationField(AnimationField&& from) noexcept
    : AnimationField() {
    *this = ::std::move(from);
  }

  inline AnimationField& operator=(const AnimationField& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimationField& operator=(AnimationField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimationField& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimationField* internal_default_instance() {
    return reinterpret_cast<const AnimationField*>(
               &_AnimationField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AnimationField& a, AnimationField& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimationField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimationField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimationField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimationField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AnimationField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AnimationField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Show.AnimationField";
  }
  protected:
  explicit AnimationField(::google::protobuf::Arena* arena);
  AnimationField(::google::protobuf::Arena* arena, const AnimationField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TransitionType = AnimationField_TransitionType;
  static constexpr TransitionType NONE = AnimationField_TransitionType_NONE;
  static constexpr TransitionType BLINDS = AnimationField_TransitionType_BLINDS;
  static constexpr TransitionType CHECKERS = AnimationField_TransitionType_CHECKERS;
  static constexpr TransitionType CIRCLE = AnimationField_TransitionType_CIRCLE;
  static constexpr TransitionType COMB = AnimationField_TransitionType_COMB;
  static constexpr TransitionType COVER = AnimationField_TransitionType_COVER;
  static constexpr TransitionType CUT = AnimationField_TransitionType_CUT;
  static constexpr TransitionType DIAMOND = AnimationField_TransitionType_DIAMOND;
  static constexpr TransitionType DISSOLVE = AnimationField_TransitionType_DISSOLVE;
  static constexpr TransitionType FADE = AnimationField_TransitionType_FADE;
  static constexpr TransitionType NEWSFLASH = AnimationField_TransitionType_NEWSFLASH;
  static constexpr TransitionType PLUS = AnimationField_TransitionType_PLUS;
  static constexpr TransitionType PULL = AnimationField_TransitionType_PULL;
  static constexpr TransitionType PUSH = AnimationField_TransitionType_PUSH;
  static constexpr TransitionType RANDOM = AnimationField_TransitionType_RANDOM;
  static constexpr TransitionType RANDOMBAR = AnimationField_TransitionType_RANDOMBAR;
  static constexpr TransitionType SPLIT = AnimationField_TransitionType_SPLIT;
  static constexpr TransitionType STRIPS = AnimationField_TransitionType_STRIPS;
  static constexpr TransitionType WEDGE = AnimationField_TransitionType_WEDGE;
  static constexpr TransitionType WHEEL = AnimationField_TransitionType_WHEEL;
  static constexpr TransitionType WIPE = AnimationField_TransitionType_WIPE;
  static constexpr TransitionType ZOOM = AnimationField_TransitionType_ZOOM;
  static constexpr TransitionType FLY = AnimationField_TransitionType_FLY;
  static constexpr TransitionType FLOAT = AnimationField_TransitionType_FLOAT;
  static constexpr TransitionType APPEAR = AnimationField_TransitionType_APPEAR;
  static constexpr TransitionType REVOLVINGDOOR = AnimationField_TransitionType_REVOLVINGDOOR;
  static constexpr TransitionType PIVOT = AnimationField_TransitionType_PIVOT;
  static constexpr TransitionType TWIRL = AnimationField_TransitionType_TWIRL;
  static constexpr TransitionType SWAP = AnimationField_TransitionType_SWAP;
  static constexpr TransitionType FLIP = AnimationField_TransitionType_FLIP;
  static constexpr TransitionType CUBE = AnimationField_TransitionType_CUBE;
  static constexpr TransitionType GALLERY = AnimationField_TransitionType_GALLERY;
  static constexpr TransitionType FALL = AnimationField_TransitionType_FALL;
  static constexpr TransitionType REVEAL = AnimationField_TransitionType_REVEAL;
  static constexpr TransitionType GEOMETRIC = AnimationField_TransitionType_GEOMETRIC;
  static constexpr TransitionType FLASH = AnimationField_TransitionType_FLASH;
  static constexpr TransitionType RIPPLE = AnimationField_TransitionType_RIPPLE;
  static constexpr TransitionType HONEYCOMB = AnimationField_TransitionType_HONEYCOMB;
  static constexpr TransitionType GLITTER = AnimationField_TransitionType_GLITTER;
  static constexpr TransitionType VORTEX = AnimationField_TransitionType_VORTEX;
  static constexpr TransitionType PEEK = AnimationField_TransitionType_PEEK;
  static constexpr TransitionType EXPAND_OR_CONTRACT = AnimationField_TransitionType_EXPAND_OR_CONTRACT;
  static constexpr TransitionType FADED_SWIVEL = AnimationField_TransitionType_FADED_SWIVEL;
  static constexpr TransitionType FADED_ZOOM = AnimationField_TransitionType_FADED_ZOOM;
  static constexpr TransitionType CENTER_REVOLVE = AnimationField_TransitionType_CENTER_REVOLVE;
  static constexpr TransitionType GROW_OR_SHRINK_AND_TURN = AnimationField_TransitionType_GROW_OR_SHRINK_AND_TURN;
  static constexpr TransitionType RISEUP_SINKDOWN = AnimationField_TransitionType_RISEUP_SINKDOWN;
  static constexpr TransitionType SPINNER = AnimationField_TransitionType_SPINNER;
  static constexpr TransitionType BOOMER = AnimationField_TransitionType_BOOMER;
  static constexpr TransitionType BOUNCE = AnimationField_TransitionType_BOUNCE;
  static constexpr TransitionType CREDITS = AnimationField_TransitionType_CREDITS;
  static constexpr TransitionType CURVE_UP_OR_DOWN = AnimationField_TransitionType_CURVE_UP_OR_DOWN;
  static constexpr TransitionType PIN_WHEEL = AnimationField_TransitionType_PIN_WHEEL;
  static constexpr TransitionType SPIRAL = AnimationField_TransitionType_SPIRAL;
  static constexpr TransitionType SWIVEL = AnimationField_TransitionType_SWIVEL;
  static constexpr TransitionType WHIP = AnimationField_TransitionType_WHIP;
  static constexpr TransitionType CURVY_FLOAT = AnimationField_TransitionType_CURVY_FLOAT;
  static constexpr TransitionType DROP = AnimationField_TransitionType_DROP;
  static constexpr TransitionType PAN = AnimationField_TransitionType_PAN;
  static constexpr TransitionType FERRISWHEEL = AnimationField_TransitionType_FERRISWHEEL;
  static constexpr TransitionType CONVEYOR = AnimationField_TransitionType_CONVEYOR;
  static constexpr TransitionType ROTATE = AnimationField_TransitionType_ROTATE;
  static constexpr TransitionType WINDOW = AnimationField_TransitionType_WINDOW;
  static constexpr TransitionType ORBIT = AnimationField_TransitionType_ORBIT;
  static constexpr TransitionType FLYTHRU = AnimationField_TransitionType_FLYTHRU;
  static constexpr TransitionType BOX = AnimationField_TransitionType_BOX;
  static constexpr TransitionType DOOR = AnimationField_TransitionType_DOOR;
  static constexpr TransitionType SHRED = AnimationField_TransitionType_SHRED;
  static constexpr TransitionType WHEEL_WIPE = AnimationField_TransitionType_WHEEL_WIPE;
  static constexpr TransitionType METEOR = AnimationField_TransitionType_METEOR;
  static constexpr TransitionType PATH = AnimationField_TransitionType_PATH;
  static constexpr TransitionType DRAW = AnimationField_TransitionType_DRAW;
  static constexpr TransitionType MORPH = AnimationField_TransitionType_MORPH;
  static inline bool TransitionType_IsValid(int value) {
    return AnimationField_TransitionType_IsValid(value);
  }
  static constexpr TransitionType TransitionType_MIN = AnimationField_TransitionType_TransitionType_MIN;
  static constexpr TransitionType TransitionType_MAX = AnimationField_TransitionType_TransitionType_MAX;
  static constexpr int TransitionType_ARRAYSIZE = AnimationField_TransitionType_TransitionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TransitionType_descriptor() {
    return AnimationField_TransitionType_descriptor();
  }
  template <typename T>
  static inline const std::string& TransitionType_Name(T value) {
    return AnimationField_TransitionType_Name(value);
  }
  static inline bool TransitionType_Parse(absl::string_view name, TransitionType* value) {
    return AnimationField_TransitionType_Parse(name, value);
  }

  using Axis = AnimationField_Axis;
  static constexpr Axis HOR = AnimationField_Axis_HOR;
  static constexpr Axis VER = AnimationField_Axis_VER;
  static inline bool Axis_IsValid(int value) {
    return AnimationField_Axis_IsValid(value);
  }
  static constexpr Axis Axis_MIN = AnimationField_Axis_Axis_MIN;
  static constexpr Axis Axis_MAX = AnimationField_Axis_Axis_MAX;
  static constexpr int Axis_ARRAYSIZE = AnimationField_Axis_Axis_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Axis_descriptor() {
    return AnimationField_Axis_descriptor();
  }
  template <typename T>
  static inline const std::string& Axis_Name(T value) {
    return AnimationField_Axis_Name(value);
  }
  static inline bool Axis_Parse(absl::string_view name, Axis* value) {
    return AnimationField_Axis_Parse(name, value);
  }

  using Direction = AnimationField_Direction;
  static constexpr Direction LEFT = AnimationField_Direction_LEFT;
  static constexpr Direction DOWN = AnimationField_Direction_DOWN;
  static constexpr Direction RIGHT = AnimationField_Direction_RIGHT;
  static constexpr Direction UP = AnimationField_Direction_UP;
  static constexpr Direction LEFT_DOWN = AnimationField_Direction_LEFT_DOWN;
  static constexpr Direction LEFT_UP = AnimationField_Direction_LEFT_UP;
  static constexpr Direction RIGHT_DOWN = AnimationField_Direction_RIGHT_DOWN;
  static constexpr Direction RIGHT_UP = AnimationField_Direction_RIGHT_UP;
  static constexpr Direction CENTER = AnimationField_Direction_CENTER;
  static inline bool Direction_IsValid(int value) {
    return AnimationField_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN = AnimationField_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX = AnimationField_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE = AnimationField_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Direction_descriptor() {
    return AnimationField_Direction_descriptor();
  }
  template <typename T>
  static inline const std::string& Direction_Name(T value) {
    return AnimationField_Direction_Name(value);
  }
  static inline bool Direction_Parse(absl::string_view name, Direction* value) {
    return AnimationField_Direction_Parse(name, value);
  }

  using TransitionDirection = AnimationField_TransitionDirection;
  static constexpr TransitionDirection IN = AnimationField_TransitionDirection_IN;
  static constexpr TransitionDirection OUT = AnimationField_TransitionDirection_OUT;
  static constexpr TransitionDirection IN_SLIGHTLY = AnimationField_TransitionDirection_IN_SLIGHTLY;
  static constexpr TransitionDirection OUT_SLIGHTLY = AnimationField_TransitionDirection_OUT_SLIGHTLY;
  static constexpr TransitionDirection IN_FROM_CENTER = AnimationField_TransitionDirection_IN_FROM_CENTER;
  static constexpr TransitionDirection OUT_FROM_BOTTOM = AnimationField_TransitionDirection_OUT_FROM_BOTTOM;
  static constexpr TransitionDirection OUT_TO_CENTER = AnimationField_TransitionDirection_OUT_TO_CENTER;
  static constexpr TransitionDirection IN_TO_BOTTOM = AnimationField_TransitionDirection_IN_TO_BOTTOM;
  static inline bool TransitionDirection_IsValid(int value) {
    return AnimationField_TransitionDirection_IsValid(value);
  }
  static constexpr TransitionDirection TransitionDirection_MIN = AnimationField_TransitionDirection_TransitionDirection_MIN;
  static constexpr TransitionDirection TransitionDirection_MAX = AnimationField_TransitionDirection_TransitionDirection_MAX;
  static constexpr int TransitionDirection_ARRAYSIZE = AnimationField_TransitionDirection_TransitionDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TransitionDirection_descriptor() {
    return AnimationField_TransitionDirection_descriptor();
  }
  template <typename T>
  static inline const std::string& TransitionDirection_Name(T value) {
    return AnimationField_TransitionDirection_Name(value);
  }
  static inline bool TransitionDirection_Parse(absl::string_view name, TransitionDirection* value) {
    return AnimationField_TransitionDirection_Parse(name, value);
  }

  using RotateDirection = AnimationField_RotateDirection;
  static constexpr RotateDirection CLOCKWISE = AnimationField_RotateDirection_CLOCKWISE;
  static constexpr RotateDirection ANTI_CLOCKWISE = AnimationField_RotateDirection_ANTI_CLOCKWISE;
  static inline bool RotateDirection_IsValid(int value) {
    return AnimationField_RotateDirection_IsValid(value);
  }
  static constexpr RotateDirection RotateDirection_MIN = AnimationField_RotateDirection_RotateDirection_MIN;
  static constexpr RotateDirection RotateDirection_MAX = AnimationField_RotateDirection_RotateDirection_MAX;
  static constexpr int RotateDirection_ARRAYSIZE = AnimationField_RotateDirection_RotateDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RotateDirection_descriptor() {
    return AnimationField_RotateDirection_descriptor();
  }
  template <typename T>
  static inline const std::string& RotateDirection_Name(T value) {
    return AnimationField_RotateDirection_Name(value);
  }
  static inline bool RotateDirection_Parse(absl::string_view name, RotateDirection* value) {
    return AnimationField_RotateDirection_Parse(name, value);
  }

  using ObjectType = AnimationField_ObjectType;
  static constexpr ObjectType STRIP = AnimationField_ObjectType_STRIP;
  static constexpr ObjectType PARTICLE = AnimationField_ObjectType_PARTICLE;
  static inline bool ObjectType_IsValid(int value) {
    return AnimationField_ObjectType_IsValid(value);
  }
  static constexpr ObjectType ObjectType_MIN = AnimationField_ObjectType_ObjectType_MIN;
  static constexpr ObjectType ObjectType_MAX = AnimationField_ObjectType_ObjectType_MAX;
  static constexpr int ObjectType_ARRAYSIZE = AnimationField_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ObjectType_descriptor() {
    return AnimationField_ObjectType_descriptor();
  }
  template <typename T>
  static inline const std::string& ObjectType_Name(T value) {
    return AnimationField_ObjectType_Name(value);
  }
  static inline bool ObjectType_Parse(absl::string_view name, ObjectType* value) {
    return AnimationField_ObjectType_Parse(name, value);
  }

  using AnimationStart = AnimationField_AnimationStart;
  static constexpr AnimationStart CLICK = AnimationField_AnimationStart_CLICK;
  static constexpr AnimationStart WITHEFFECT = AnimationField_AnimationStart_WITHEFFECT;
  static constexpr AnimationStart AFTEREFFECT = AnimationField_AnimationStart_AFTEREFFECT;
  static inline bool AnimationStart_IsValid(int value) {
    return AnimationField_AnimationStart_IsValid(value);
  }
  static constexpr AnimationStart AnimationStart_MIN = AnimationField_AnimationStart_AnimationStart_MIN;
  static constexpr AnimationStart AnimationStart_MAX = AnimationField_AnimationStart_AnimationStart_MAX;
  static constexpr int AnimationStart_ARRAYSIZE = AnimationField_AnimationStart_AnimationStart_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AnimationStart_descriptor() {
    return AnimationField_AnimationStart_descriptor();
  }
  template <typename T>
  static inline const std::string& AnimationStart_Name(T value) {
    return AnimationField_AnimationStart_Name(value);
  }
  static inline bool AnimationStart_Parse(absl::string_view name, AnimationStart* value) {
    return AnimationField_AnimationStart_Parse(name, value);
  }

  using AnimationMatchType = AnimationField_AnimationMatchType;
  static constexpr AnimationMatchType UNKNOWN_MATCH_TYPE = AnimationField_AnimationMatchType_UNKNOWN_MATCH_TYPE;
  static constexpr AnimationMatchType OBJECT = AnimationField_AnimationMatchType_OBJECT;
  static constexpr AnimationMatchType WORD = AnimationField_AnimationMatchType_WORD;
  static constexpr AnimationMatchType CHAR = AnimationField_AnimationMatchType_CHAR;
  static inline bool AnimationMatchType_IsValid(int value) {
    return AnimationField_AnimationMatchType_IsValid(value);
  }
  static constexpr AnimationMatchType AnimationMatchType_MIN = AnimationField_AnimationMatchType_AnimationMatchType_MIN;
  static constexpr AnimationMatchType AnimationMatchType_MAX = AnimationField_AnimationMatchType_AnimationMatchType_MAX;
  static constexpr int AnimationMatchType_ARRAYSIZE = AnimationField_AnimationMatchType_AnimationMatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AnimationMatchType_descriptor() {
    return AnimationField_AnimationMatchType_descriptor();
  }
  template <typename T>
  static inline const std::string& AnimationMatchType_Name(T value) {
    return AnimationField_AnimationMatchType_Name(value);
  }
  static inline bool AnimationMatchType_Parse(absl::string_view name, AnimationMatchType* value) {
    return AnimationField_AnimationMatchType_Parse(name, value);
  }

  using AnimationMatchBasis = AnimationField_AnimationMatchBasis;
  static constexpr AnimationMatchBasis UNKNOWN_MATCH_BASIS = AnimationField_AnimationMatchBasis_UNKNOWN_MATCH_BASIS;
  static constexpr AnimationMatchBasis OBJECT_NAME = AnimationField_AnimationMatchBasis_OBJECT_NAME;
  static inline bool AnimationMatchBasis_IsValid(int value) {
    return AnimationField_AnimationMatchBasis_IsValid(value);
  }
  static constexpr AnimationMatchBasis AnimationMatchBasis_MIN = AnimationField_AnimationMatchBasis_AnimationMatchBasis_MIN;
  static constexpr AnimationMatchBasis AnimationMatchBasis_MAX = AnimationField_AnimationMatchBasis_AnimationMatchBasis_MAX;
  static constexpr int AnimationMatchBasis_ARRAYSIZE = AnimationField_AnimationMatchBasis_AnimationMatchBasis_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AnimationMatchBasis_descriptor() {
    return AnimationField_AnimationMatchBasis_descriptor();
  }
  template <typename T>
  static inline const std::string& AnimationMatchBasis_Name(T value) {
    return AnimationField_AnimationMatchBasis_Name(value);
  }
  static inline bool AnimationMatchBasis_Parse(absl::string_view name, AnimationMatchBasis* value) {
    return AnimationField_AnimationMatchBasis_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Show.AnimationField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_fields_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CommonField

// -------------------------------------------------------------------

// FileField

// -------------------------------------------------------------------

// StrokeField

// -------------------------------------------------------------------

// GeometryField

// -------------------------------------------------------------------

// EffectsField

// -------------------------------------------------------------------

// PresetSmartDiagram

// -------------------------------------------------------------------

// ShapeField

// -------------------------------------------------------------------

// SlideField

// -------------------------------------------------------------------

// PortionField

// -------------------------------------------------------------------

// FillField

// -------------------------------------------------------------------

// ChartField_BarChartField

// -------------------------------------------------------------------

// ChartField

// -------------------------------------------------------------------

// TableField

// -------------------------------------------------------------------

// AnimationField

// -------------------------------------------------------------------

// MemberField

// -------------------------------------------------------------------

// DocumentStatusField

// -------------------------------------------------------------------

// DataSourceField

// -------------------------------------------------------------------

// DatabaseField

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Show


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::Show::CommonField_UseParentProps> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::CommonField_UseParentProps>() {
  return ::Show::CommonField_UseParentProps_descriptor();
}
template <>
struct is_proto_enum<::Show::CommonField_MeasuringUnit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::CommonField_MeasuringUnit>() {
  return ::Show::CommonField_MeasuringUnit_descriptor();
}
template <>
struct is_proto_enum<::Show::CommonField_ValueVariant> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::CommonField_ValueVariant>() {
  return ::Show::CommonField_ValueVariant_descriptor();
}
template <>
struct is_proto_enum<::Show::CommonField_ValueType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::CommonField_ValueType>() {
  return ::Show::CommonField_ValueType_descriptor();
}
template <>
struct is_proto_enum<::Show::CommonField_CompositeValueType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::CommonField_CompositeValueType>() {
  return ::Show::CommonField_CompositeValueType_descriptor();
}
template <>
struct is_proto_enum<::Show::FileField_FileFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FileField_FileFormat>() {
  return ::Show::FileField_FileFormat_descriptor();
}
template <>
struct is_proto_enum<::Show::FileField_DocumentFileType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FileField_DocumentFileType>() {
  return ::Show::FileField_DocumentFileType_descriptor();
}
template <>
struct is_proto_enum<::Show::FileField_PresentationFileType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FileField_PresentationFileType>() {
  return ::Show::FileField_PresentationFileType_descriptor();
}
template <>
struct is_proto_enum<::Show::FileField_SpreadsheetFileType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FileField_SpreadsheetFileType>() {
  return ::Show::FileField_SpreadsheetFileType_descriptor();
}
template <>
struct is_proto_enum<::Show::FileField_LanguageFileType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FileField_LanguageFileType>() {
  return ::Show::FileField_LanguageFileType_descriptor();
}
template <>
struct is_proto_enum<::Show::StrokeField_CapType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::StrokeField_CapType>() {
  return ::Show::StrokeField_CapType_descriptor();
}
template <>
struct is_proto_enum<::Show::StrokeField_StrokeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::StrokeField_StrokeType>() {
  return ::Show::StrokeField_StrokeType_descriptor();
}
template <>
struct is_proto_enum<::Show::StrokeField_JoinType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::StrokeField_JoinType>() {
  return ::Show::StrokeField_JoinType_descriptor();
}
template <>
struct is_proto_enum<::Show::StrokeField_MarkerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::StrokeField_MarkerType>() {
  return ::Show::StrokeField_MarkerType_descriptor();
}
template <>
struct is_proto_enum<::Show::StrokeField_Size> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::StrokeField_Size>() {
  return ::Show::StrokeField_Size_descriptor();
}
template <>
struct is_proto_enum<::Show::StrokeField_StrokePosition> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::StrokeField_StrokePosition>() {
  return ::Show::StrokeField_StrokePosition_descriptor();
}
template <>
struct is_proto_enum<::Show::GeometryField_ShapeGeometryType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::GeometryField_ShapeGeometryType>() {
  return ::Show::GeometryField_ShapeGeometryType_descriptor();
}
template <>
struct is_proto_enum<::Show::GeometryField_PresetShapeGeometry> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::GeometryField_PresetShapeGeometry>() {
  return ::Show::GeometryField_PresetShapeGeometry_descriptor();
}
template <>
struct is_proto_enum<::Show::GeometryField_PresetSmartShapeGeometry> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::GeometryField_PresetSmartShapeGeometry>() {
  return ::Show::GeometryField_PresetSmartShapeGeometry_descriptor();
}
template <>
struct is_proto_enum<::Show::EffectsField_ShadowType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::EffectsField_ShadowType>() {
  return ::Show::EffectsField_ShadowType_descriptor();
}
template <>
struct is_proto_enum<::Show::PresetSmartDiagram_PresetSmartDiagramType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PresetSmartDiagram_PresetSmartDiagramType>() {
  return ::Show::PresetSmartDiagram_PresetSmartDiagramType_descriptor();
}
template <>
struct is_proto_enum<::Show::PresetSmartDiagram_PresetProcessSmartDiagramType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PresetSmartDiagram_PresetProcessSmartDiagramType>() {
  return ::Show::PresetSmartDiagram_PresetProcessSmartDiagramType_descriptor();
}
template <>
struct is_proto_enum<::Show::PresetSmartDiagram_PresetPyramidSmartDiagramType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PresetSmartDiagram_PresetPyramidSmartDiagramType>() {
  return ::Show::PresetSmartDiagram_PresetPyramidSmartDiagramType_descriptor();
}
template <>
struct is_proto_enum<::Show::PresetSmartDiagram_PresetCycleSmartDiagramType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PresetSmartDiagram_PresetCycleSmartDiagramType>() {
  return ::Show::PresetSmartDiagram_PresetCycleSmartDiagramType_descriptor();
}
template <>
struct is_proto_enum<::Show::PresetSmartDiagram_PresetListSmartDiagramType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PresetSmartDiagram_PresetListSmartDiagramType>() {
  return ::Show::PresetSmartDiagram_PresetListSmartDiagramType_descriptor();
}
template <>
struct is_proto_enum<::Show::ShapeField_PlaceHolderType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ShapeField_PlaceHolderType>() {
  return ::Show::ShapeField_PlaceHolderType_descriptor();
}
template <>
struct is_proto_enum<::Show::ShapeField_BlendMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ShapeField_BlendMode>() {
  return ::Show::ShapeField_BlendMode_descriptor();
}
template <>
struct is_proto_enum<::Show::ShapeField_CombineRule> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ShapeField_CombineRule>() {
  return ::Show::ShapeField_CombineRule_descriptor();
}
template <>
struct is_proto_enum<::Show::SlideField_LayoutType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::SlideField_LayoutType>() {
  return ::Show::SlideField_LayoutType_descriptor();
}
template <>
struct is_proto_enum<::Show::PortionField_SlideNumberField> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PortionField_SlideNumberField>() {
  return ::Show::PortionField_SlideNumberField_descriptor();
}
template <>
struct is_proto_enum<::Show::PortionField_DateTimeField> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PortionField_DateTimeField>() {
  return ::Show::PortionField_DateTimeField_descriptor();
}
template <>
struct is_proto_enum<::Show::PortionField_FontVariant> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PortionField_FontVariant>() {
  return ::Show::PortionField_FontVariant_descriptor();
}
template <>
struct is_proto_enum<::Show::PortionField_FontWeight> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::PortionField_FontWeight>() {
  return ::Show::PortionField_FontWeight_descriptor();
}
template <>
struct is_proto_enum<::Show::FillField_FillType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FillField_FillType>() {
  return ::Show::FillField_FillType_descriptor();
}
template <>
struct is_proto_enum<::Show::FillField_GradientFillType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FillField_GradientFillType>() {
  return ::Show::FillField_GradientFillType_descriptor();
}
template <>
struct is_proto_enum<::Show::FillField_FillRule> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::FillField_FillRule>() {
  return ::Show::FillField_FillRule_descriptor();
}
template <>
struct is_proto_enum<::Show::ChartField_BarChartField_BarType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ChartField_BarChartField_BarType>() {
  return ::Show::ChartField_BarChartField_BarType_descriptor();
}
template <>
struct is_proto_enum<::Show::ChartField_ChartType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ChartField_ChartType>() {
  return ::Show::ChartField_ChartType_descriptor();
}
template <>
struct is_proto_enum<::Show::ChartField_Grouping> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ChartField_Grouping>() {
  return ::Show::ChartField_Grouping_descriptor();
}
template <>
struct is_proto_enum<::Show::ChartField_DataLabelPosition> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ChartField_DataLabelPosition>() {
  return ::Show::ChartField_DataLabelPosition_descriptor();
}
template <>
struct is_proto_enum<::Show::ChartField_PositionElement> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ChartField_PositionElement>() {
  return ::Show::ChartField_PositionElement_descriptor();
}
template <>
struct is_proto_enum<::Show::ChartField_TickMarkType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ChartField_TickMarkType>() {
  return ::Show::ChartField_TickMarkType_descriptor();
}
template <>
struct is_proto_enum<::Show::ChartField_LabelPos> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::ChartField_LabelPos>() {
  return ::Show::ChartField_LabelPos_descriptor();
}
template <>
struct is_proto_enum<::Show::TableField_TextDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::TableField_TextDirection>() {
  return ::Show::TableField_TextDirection_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_TransitionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_TransitionType>() {
  return ::Show::AnimationField_TransitionType_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_Axis> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_Axis>() {
  return ::Show::AnimationField_Axis_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_Direction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_Direction>() {
  return ::Show::AnimationField_Direction_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_TransitionDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_TransitionDirection>() {
  return ::Show::AnimationField_TransitionDirection_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_RotateDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_RotateDirection>() {
  return ::Show::AnimationField_RotateDirection_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_ObjectType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_ObjectType>() {
  return ::Show::AnimationField_ObjectType_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_AnimationStart> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_AnimationStart>() {
  return ::Show::AnimationField_AnimationStart_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_AnimationMatchType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_AnimationMatchType>() {
  return ::Show::AnimationField_AnimationMatchType_descriptor();
}
template <>
struct is_proto_enum<::Show::AnimationField_AnimationMatchBasis> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::AnimationField_AnimationMatchBasis>() {
  return ::Show::AnimationField_AnimationMatchBasis_descriptor();
}
template <>
struct is_proto_enum<::Show::MemberField_MemberRoleType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::MemberField_MemberRoleType>() {
  return ::Show::MemberField_MemberRoleType_descriptor();
}
template <>
struct is_proto_enum<::Show::DocumentStatusField_DocumentStatusType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DocumentStatusField_DocumentStatusType>() {
  return ::Show::DocumentStatusField_DocumentStatusType_descriptor();
}
template <>
struct is_proto_enum<::Show::DataSourceField_DataSourceServiceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DataSourceField_DataSourceServiceType>() {
  return ::Show::DataSourceField_DataSourceServiceType_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_TableOrColumnCategory> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_TableOrColumnCategory>() {
  return ::Show::DatabaseField_TableOrColumnCategory_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_WhereOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_WhereOperator>() {
  return ::Show::DatabaseField_WhereOperator_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_ComparisonOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_ComparisonOperator>() {
  return ::Show::DatabaseField_ComparisonOperator_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_LogicalOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_LogicalOperator>() {
  return ::Show::DatabaseField_LogicalOperator_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_SubQueryOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_SubQueryOperator>() {
  return ::Show::DatabaseField_SubQueryOperator_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_PatternOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_PatternOperator>() {
  return ::Show::DatabaseField_PatternOperator_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_SortOrder> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_SortOrder>() {
  return ::Show::DatabaseField_SortOrder_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_DataOperator> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_DataOperator>() {
  return ::Show::DatabaseField_DataOperator_descriptor();
}
template <>
struct is_proto_enum<::Show::DatabaseField_DataOperatedOn> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Show::DatabaseField_DataOperatedOn>() {
  return ::Show::DatabaseField_DataOperatedOn_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_fields_2eproto_2epb_2eh
