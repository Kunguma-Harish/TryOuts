// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: notifications.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Notifications {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notificationDetails: [Notifications.NotificationDetails] = []

  /// Last read notification id
  public var lastConsumedID: String {
    get {return _lastConsumedID ?? String()}
    set {_lastConsumedID = newValue}
  }
  /// Returns true if `lastConsumedID` has been explicitly set.
  public var hasLastConsumedID: Bool {return self._lastConsumedID != nil}
  /// Clears the value of `lastConsumedID`. Subsequent reads from it will return its default value.
  public mutating func clearLastConsumedID() {self._lastConsumedID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NotificationDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var project: ProjectLevelNotification {
      get {return _storage._project ?? ProjectLevelNotification()}
      set {_uniqueStorage()._project = newValue}
    }
    /// Returns true if `project` has been explicitly set.
    public var hasProject: Bool {return _storage._project != nil}
    /// Clears the value of `project`. Subsequent reads from it will return its default value.
    public mutating func clearProject() {_uniqueStorage()._project = nil}

    public var status: NotificationStatus {
      get {return _storage._status ?? NotificationStatus()}
      set {_uniqueStorage()._status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return _storage._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {_uniqueStorage()._status = nil}

    public var type: Notifications.NotificationDetails.NotificationType {
      get {return _storage._type ?? .unknownNotificationType}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    public var organisation: OrgLevelNotification {
      get {return _storage._organisation ?? OrgLevelNotification()}
      set {_uniqueStorage()._organisation = newValue}
    }
    /// Returns true if `organisation` has been explicitly set.
    public var hasOrganisation: Bool {return _storage._organisation != nil}
    /// Clears the value of `organisation`. Subsequent reads from it will return its default value.
    public mutating func clearOrganisation() {_uniqueStorage()._organisation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum NotificationType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownNotificationType // = 0
      case organisation // = 1
      case project // = 2

      public init() {
        self = .unknownNotificationType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownNotificationType
        case 1: self = .organisation
        case 2: self = .project
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownNotificationType: return 0
        case .organisation: return 1
        case .project: return 2
        }
      }

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _lastConsumedID: String? = nil
}

#if swift(>=4.2)

extension Notifications.NotificationDetails.NotificationType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct NotificationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: NotificationStatus.Status {
    get {return _status ?? .unknown}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var consumer: NotificationStatus.Consumer {
    get {return _consumer ?? NotificationStatus.Consumer()}
    set {_consumer = newValue}
  }
  /// Returns true if `consumer` has been explicitly set.
  public var hasConsumer: Bool {return self._consumer != nil}
  /// Clears the value of `consumer`. Subsequent reads from it will return its default value.
  public mutating func clearConsumer() {self._consumer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case unread // = 1
    case read // = 2

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .unread
      case 2: self = .read
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .unread: return 1
      case .read: return 2
      }
    }

  }

  public struct Consumer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var time: Time {
      get {return _time ?? Time()}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    public var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    public mutating func clearTime() {self._time = nil}

    public var device: NotificationStatus.Consumer.DeviceDetails {
      get {return _device ?? NotificationStatus.Consumer.DeviceDetails()}
      set {_device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    public var hasDevice: Bool {return self._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    public mutating func clearDevice() {self._device = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DeviceDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: NotificationStatus.Consumer.DeviceDetails.DeviceType {
        get {return _type ?? .unknownDevice}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var browser: NotificationStatus.Consumer.DeviceDetails.BrowserDetails {
        get {return _browser ?? NotificationStatus.Consumer.DeviceDetails.BrowserDetails()}
        set {_browser = newValue}
      }
      /// Returns true if `browser` has been explicitly set.
      public var hasBrowser: Bool {return self._browser != nil}
      /// Clears the value of `browser`. Subsequent reads from it will return its default value.
      public mutating func clearBrowser() {self._browser = nil}

      public var os: NotificationStatus.Consumer.DeviceDetails.OSDetails {
        get {return _os ?? NotificationStatus.Consumer.DeviceDetails.OSDetails()}
        set {_os = newValue}
      }
      /// Returns true if `os` has been explicitly set.
      public var hasOs: Bool {return self._os != nil}
      /// Clears the value of `os`. Subsequent reads from it will return its default value.
      public mutating func clearOs() {self._os = nil}

      /// To store model of the device - IPhone 7 etc..
      public var model: String {
        get {return _model ?? String()}
        set {_model = newValue}
      }
      /// Returns true if `model` has been explicitly set.
      public var hasModel: Bool {return self._model != nil}
      /// Clears the value of `model`. Subsequent reads from it will return its default value.
      public mutating func clearModel() {self._model = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum DeviceType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unknownDevice // = 0
        case browser // = 1
        case ios // = 2
        case androidDevice // = 3

        public init() {
          self = .unknownDevice
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownDevice
          case 1: self = .browser
          case 2: self = .ios
          case 3: self = .androidDevice
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .unknownDevice: return 0
          case .browser: return 1
          case .ios: return 2
          case .androidDevice: return 3
          }
        }

      }

      public struct BrowserDetails {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: NotificationStatus.Consumer.DeviceDetails.BrowserDetails.BrowserName {
          get {return _name ?? .unknownBrowser}
          set {_name = newValue}
        }
        /// Returns true if `name` has been explicitly set.
        public var hasName: Bool {return self._name != nil}
        /// Clears the value of `name`. Subsequent reads from it will return its default value.
        public mutating func clearName() {self._name = nil}

        public var version: String {
          get {return _version ?? String()}
          set {_version = newValue}
        }
        /// Returns true if `version` has been explicitly set.
        public var hasVersion: Bool {return self._version != nil}
        /// Clears the value of `version`. Subsequent reads from it will return its default value.
        public mutating func clearVersion() {self._version = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum BrowserName: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case unknownBrowser // = 0
          case chrome // = 1
          case firefox // = 2
          case ie // = 3
          case edge // = 4
          case safari // = 5

          public init() {
            self = .unknownBrowser
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknownBrowser
            case 1: self = .chrome
            case 2: self = .firefox
            case 3: self = .ie
            case 4: self = .edge
            case 5: self = .safari
            default: return nil
            }
          }

          public var rawValue: Int {
            switch self {
            case .unknownBrowser: return 0
            case .chrome: return 1
            case .firefox: return 2
            case .ie: return 3
            case .edge: return 4
            case .safari: return 5
            }
          }

        }

        public init() {}

        fileprivate var _name: NotificationStatus.Consumer.DeviceDetails.BrowserDetails.BrowserName? = nil
        fileprivate var _version: String? = nil
      }

      public struct OSDetails {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: NotificationStatus.Consumer.DeviceDetails.OSDetails.OSName {
          get {return _name ?? .unknownOs}
          set {_name = newValue}
        }
        /// Returns true if `name` has been explicitly set.
        public var hasName: Bool {return self._name != nil}
        /// Clears the value of `name`. Subsequent reads from it will return its default value.
        public mutating func clearName() {self._name = nil}

        public var version: String {
          get {return _version ?? String()}
          set {_version = newValue}
        }
        /// Returns true if `version` has been explicitly set.
        public var hasVersion: Bool {return self._version != nil}
        /// Clears the value of `version`. Subsequent reads from it will return its default value.
        public mutating func clearVersion() {self._version = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OSName: SwiftProtobuf.Enum {
          public typealias RawValue = Int
          case unknownOs // = 0
          case macos // = 1
          case ios // = 2
          case tvos // = 3
          case watchos // = 4
          case androidOs // = 5
          case windows // = 6
          case chromeOs // = 7
          case linux // = 8

          public init() {
            self = .unknownOs
          }

          public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknownOs
            case 1: self = .macos
            case 2: self = .ios
            case 3: self = .tvos
            case 4: self = .watchos
            case 5: self = .androidOs
            case 6: self = .windows
            case 7: self = .chromeOs
            case 8: self = .linux
            default: return nil
            }
          }

          public var rawValue: Int {
            switch self {
            case .unknownOs: return 0
            case .macos: return 1
            case .ios: return 2
            case .tvos: return 3
            case .watchos: return 4
            case .androidOs: return 5
            case .windows: return 6
            case .chromeOs: return 7
            case .linux: return 8
            }
          }

        }

        public init() {}

        fileprivate var _name: NotificationStatus.Consumer.DeviceDetails.OSDetails.OSName? = nil
        fileprivate var _version: String? = nil
      }

      public init() {}

      fileprivate var _type: NotificationStatus.Consumer.DeviceDetails.DeviceType? = nil
      fileprivate var _browser: NotificationStatus.Consumer.DeviceDetails.BrowserDetails? = nil
      fileprivate var _os: NotificationStatus.Consumer.DeviceDetails.OSDetails? = nil
      fileprivate var _model: String? = nil
    }

    public init() {}

    fileprivate var _time: Time? = nil
    fileprivate var _device: NotificationStatus.Consumer.DeviceDetails? = nil
  }

  public init() {}

  fileprivate var _status: NotificationStatus.Status? = nil
  fileprivate var _consumer: NotificationStatus.Consumer? = nil
}

#if swift(>=4.2)

extension NotificationStatus.Status: CaseIterable {
  // Support synthesized by the compiler.
}

extension NotificationStatus.Consumer.DeviceDetails.DeviceType: CaseIterable {
  // Support synthesized by the compiler.
}

extension NotificationStatus.Consumer.DeviceDetails.BrowserDetails.BrowserName: CaseIterable {
  // Support synthesized by the compiler.
}

extension NotificationStatus.Consumer.DeviceDetails.OSDetails.OSName: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct ResourceMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _description_p: String? = nil
}

public struct UserDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var nickName: String {
    get {return _nickName ?? String()}
    set {_nickName = newValue}
  }
  /// Returns true if `nickName` has been explicitly set.
  public var hasNickName: Bool {return self._nickName != nil}
  /// Clears the value of `nickName`. Subsequent reads from it will return its default value.
  public mutating func clearNickName() {self._nickName = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _nickName: String? = nil
}

public struct MemberDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var meta: UserDetails {
    get {return _meta ?? UserDetails()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {self._meta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _meta: UserDetails? = nil
}

public struct OrgDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var meta: ResourceMeta {
    get {return _meta ?? ResourceMeta()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {self._meta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _meta: ResourceMeta? = nil
}

/// Notification details.
public struct ProjectLevelNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id ?? String()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// Refers to Project in Nila and Board in RB
  public var project: ProjectLevelNotification.DocDetails {
    get {return _storage._project ?? ProjectLevelNotification.DocDetails()}
    set {_uniqueStorage()._project = newValue}
  }
  /// Returns true if `project` has been explicitly set.
  public var hasProject: Bool {return _storage._project != nil}
  /// Clears the value of `project`. Subsequent reads from it will return its default value.
  public mutating func clearProject() {_uniqueStorage()._project = nil}

  /// This refers to the documents in Show , Pages in Nila and Spaces in RB.
  public var documents: [ProjectLevelNotification.DocDetails] {
    get {return _storage._documents}
    set {_uniqueStorage()._documents = newValue}
  }

  public var operation: ProjectLevelNotification.Operation {
    get {return _storage._operation ?? ProjectLevelNotification.Operation()}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  public var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  public mutating func clearOperation() {_uniqueStorage()._operation = nil}

  public var time: Time {
    get {return _storage._time ?? Time()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DocDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Refers to ProjectId for a project and documentId for a document
    public var resourceID: String {
      get {return _resourceID ?? String()}
      set {_resourceID = newValue}
    }
    /// Returns true if `resourceID` has been explicitly set.
    public var hasResourceID: Bool {return self._resourceID != nil}
    /// Clears the value of `resourceID`. Subsequent reads from it will return its default value.
    public mutating func clearResourceID() {self._resourceID = nil}

    /// ZUID of the creator , will help us identify if the doc is shared or owned.
    public var creatorID: String {
      get {return _creatorID ?? String()}
      set {_creatorID = newValue}
    }
    /// Returns true if `creatorID` has been explicitly set.
    public var hasCreatorID: Bool {return self._creatorID != nil}
    /// Clears the value of `creatorID`. Subsequent reads from it will return its default value.
    public mutating func clearCreatorID() {self._creatorID = nil}

    public var type: ProjectLevelNotification.DocDetails.ResourceType {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var meta: ResourceMeta {
      get {return _meta ?? ResourceMeta()}
      set {_meta = newValue}
    }
    /// Returns true if `meta` has been explicitly set.
    public var hasMeta: Bool {return self._meta != nil}
    /// Clears the value of `meta`. Subsequent reads from it will return its default value.
    public mutating func clearMeta() {self._meta = nil}

    /// this maintains the meta details for creator.
    public var creatorMeta: UserDetails {
      get {return _creatorMeta ?? UserDetails()}
      set {_creatorMeta = newValue}
    }
    /// Returns true if `creatorMeta` has been explicitly set.
    public var hasCreatorMeta: Bool {return self._creatorMeta != nil}
    /// Clears the value of `creatorMeta`. Subsequent reads from it will return its default value.
    public mutating func clearCreatorMeta() {self._creatorMeta = nil}

    /// this field maintains the org details for the project
    public var org: OrgDetails {
      get {return _org ?? OrgDetails()}
      set {_org = newValue}
    }
    /// Returns true if `org` has been explicitly set.
    public var hasOrg: Bool {return self._org != nil}
    /// Clears the value of `org`. Subsequent reads from it will return its default value.
    public mutating func clearOrg() {self._org = nil}

    /// this maintains the team details for the project
    public var team: OrgDetails {
      get {return _team ?? OrgDetails()}
      set {_team = newValue}
    }
    /// Returns true if `team` has been explicitly set.
    public var hasTeam: Bool {return self._team != nil}
    /// Clears the value of `team`. Subsequent reads from it will return its default value.
    public mutating func clearTeam() {self._team = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ResourceType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case nonNative // = 1
      case native // = 2

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .nonNative
        case 2: self = .native
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .nonNative: return 1
        case .native: return 2
        }
      }

    }

    public init() {}

    fileprivate var _resourceID: String? = nil
    fileprivate var _creatorID: String? = nil
    fileprivate var _type: ProjectLevelNotification.DocDetails.ResourceType? = nil
    fileprivate var _meta: ResourceMeta? = nil
    fileprivate var _creatorMeta: UserDetails? = nil
    fileprivate var _org: OrgDetails? = nil
    fileprivate var _team: OrgDetails? = nil
  }

  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: ProjectLevelNotification.Operation.OperationType {
      get {return _storage._type ?? .noOperation}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    /// ZUID of the user who performed the operation.
    public var by: String {
      get {return _storage._by ?? String()}
      set {_uniqueStorage()._by = newValue}
    }
    /// Returns true if `by` has been explicitly set.
    public var hasBy: Bool {return _storage._by != nil}
    /// Clears the value of `by`. Subsequent reads from it will return its default value.
    public mutating func clearBy() {_uniqueStorage()._by = nil}

    public var editOperation: OperationFields.EditOperationType {
      get {return _storage._editOperation ?? .unknownEdit}
      set {_uniqueStorage()._editOperation = newValue}
    }
    /// Returns true if `editOperation` has been explicitly set.
    public var hasEditOperation: Bool {return _storage._editOperation != nil}
    /// Clears the value of `editOperation`. Subsequent reads from it will return its default value.
    public mutating func clearEditOperation() {_uniqueStorage()._editOperation = nil}

    public var modifiedDetails: ProjectLevelNotification.Operation.ModifiedDetails {
      get {return _storage._modifiedDetails ?? ProjectLevelNotification.Operation.ModifiedDetails()}
      set {_uniqueStorage()._modifiedDetails = newValue}
    }
    /// Returns true if `modifiedDetails` has been explicitly set.
    public var hasModifiedDetails: Bool {return _storage._modifiedDetails != nil}
    /// Clears the value of `modifiedDetails`. Subsequent reads from it will return its default value.
    public mutating func clearModifiedDetails() {_uniqueStorage()._modifiedDetails = nil}

    public var byMeta: UserDetails {
      get {return _storage._byMeta ?? UserDetails()}
      set {_uniqueStorage()._byMeta = newValue}
    }
    /// Returns true if `byMeta` has been explicitly set.
    public var hasByMeta: Bool {return _storage._byMeta != nil}
    /// Clears the value of `byMeta`. Subsequent reads from it will return its default value.
    public mutating func clearByMeta() {_uniqueStorage()._byMeta = nil}

    public var commentDetails: ProjectLevelNotification.Operation.CommentDetails {
      get {return _storage._commentDetails ?? ProjectLevelNotification.Operation.CommentDetails()}
      set {_uniqueStorage()._commentDetails = newValue}
    }
    /// Returns true if `commentDetails` has been explicitly set.
    public var hasCommentDetails: Bool {return _storage._commentDetails != nil}
    /// Clears the value of `commentDetails`. Subsequent reads from it will return its default value.
    public mutating func clearCommentDetails() {_uniqueStorage()._commentDetails = nil}

    public var sharedDetails: ProjectLevelNotification.Operation.SharedDetails {
      get {return _storage._sharedDetails ?? ProjectLevelNotification.Operation.SharedDetails()}
      set {_uniqueStorage()._sharedDetails = newValue}
    }
    /// Returns true if `sharedDetails` has been explicitly set.
    public var hasSharedDetails: Bool {return _storage._sharedDetails != nil}
    /// Clears the value of `sharedDetails`. Subsequent reads from it will return its default value.
    public mutating func clearSharedDetails() {_uniqueStorage()._sharedDetails = nil}

    public var mentionDetails: ProjectLevelNotification.Operation.MentionDetails {
      get {return _storage._mentionDetails ?? ProjectLevelNotification.Operation.MentionDetails()}
      set {_uniqueStorage()._mentionDetails = newValue}
    }
    /// Returns true if `mentionDetails` has been explicitly set.
    public var hasMentionDetails: Bool {return _storage._mentionDetails != nil}
    /// Clears the value of `mentionDetails`. Subsequent reads from it will return its default value.
    public mutating func clearMentionDetails() {_uniqueStorage()._mentionDetails = nil}

    public var publishDetails: ProjectLevelNotification.Operation.PublishDetails {
      get {return _storage._publishDetails ?? ProjectLevelNotification.Operation.PublishDetails()}
      set {_uniqueStorage()._publishDetails = newValue}
    }
    /// Returns true if `publishDetails` has been explicitly set.
    public var hasPublishDetails: Bool {return _storage._publishDetails != nil}
    /// Clears the value of `publishDetails`. Subsequent reads from it will return its default value.
    public mutating func clearPublishDetails() {_uniqueStorage()._publishDetails = nil}

    public var metaDetails: ProjectLevelNotification.Operation.MetaDetails {
      get {return _storage._metaDetails ?? ProjectLevelNotification.Operation.MetaDetails()}
      set {_uniqueStorage()._metaDetails = newValue}
    }
    /// Returns true if `metaDetails` has been explicitly set.
    public var hasMetaDetails: Bool {return _storage._metaDetails != nil}
    /// Clears the value of `metaDetails`. Subsequent reads from it will return its default value.
    public mutating func clearMetaDetails() {_uniqueStorage()._metaDetails = nil}

    public var catchupDetails: ProjectLevelNotification.Operation.CatchupDetails {
      get {return _storage._catchupDetails ?? ProjectLevelNotification.Operation.CatchupDetails()}
      set {_uniqueStorage()._catchupDetails = newValue}
    }
    /// Returns true if `catchupDetails` has been explicitly set.
    public var hasCatchupDetails: Bool {return _storage._catchupDetails != nil}
    /// Clears the value of `catchupDetails`. Subsequent reads from it will return its default value.
    public mutating func clearCatchupDetails() {_uniqueStorage()._catchupDetails = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OperationType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case noOperation // = 0
      case share // = 1
      case removeShare // = 2
      case create // = 3
      case upload // = 4
      case copy // = 5
      case trash // = 6
      case restore // = 7
      case view // = 8
      case edit // = 9
      case publish // = 10
      case catchup // = 11

      public init() {
        self = .noOperation
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .noOperation
        case 1: self = .share
        case 2: self = .removeShare
        case 3: self = .create
        case 4: self = .upload
        case 5: self = .copy
        case 6: self = .trash
        case 7: self = .restore
        case 8: self = .view
        case 9: self = .edit
        case 10: self = .publish
        case 11: self = .catchup
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .noOperation: return 0
        case .share: return 1
        case .removeShare: return 2
        case .create: return 3
        case .upload: return 4
        case .copy: return 5
        case .trash: return 6
        case .restore: return 7
        case .view: return 8
        case .edit: return 9
        case .publish: return 10
        case .catchup: return 11
        }
      }

    }

    public struct ModifiedDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var modifyOperation: OperationFields.ModifyOperationType {
        get {return _modifyOperation ?? .unknownModify}
        set {_modifyOperation = newValue}
      }
      /// Returns true if `modifyOperation` has been explicitly set.
      public var hasModifyOperation: Bool {return self._modifyOperation != nil}
      /// Clears the value of `modifyOperation`. Subsequent reads from it will return its default value.
      public mutating func clearModifyOperation() {self._modifyOperation = nil}

      /// FrameID refers to Slide in Show , ArtBoard/Screen in Nila , Frame/Container in RB.
      public var frameID: String {
        get {return _frameID ?? String()}
        set {_frameID = newValue}
      }
      /// Returns true if `frameID` has been explicitly set.
      public var hasFrameID: Bool {return self._frameID != nil}
      /// Clears the value of `frameID`. Subsequent reads from it will return its default value.
      public mutating func clearFrameID() {self._frameID = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _modifyOperation: OperationFields.ModifyOperationType? = nil
      fileprivate var _frameID: String? = nil
    }

    public struct CommentDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var commentOperation: OperationFields.CommentOperationType {
        get {return _commentOperation ?? .unknownComment}
        set {_commentOperation = newValue}
      }
      /// Returns true if `commentOperation` has been explicitly set.
      public var hasCommentOperation: Bool {return self._commentOperation != nil}
      /// Clears the value of `commentOperation`. Subsequent reads from it will return its default value.
      public mutating func clearCommentOperation() {self._commentOperation = nil}

      /// Actual comment Id which contains the mention or constitutes the reply.
      public var commentID: String {
        get {return _commentID ?? String()}
        set {_commentID = newValue}
      }
      /// Returns true if `commentID` has been explicitly set.
      public var hasCommentID: Bool {return self._commentID != nil}
      /// Clears the value of `commentID`. Subsequent reads from it will return its default value.
      public mutating func clearCommentID() {self._commentID = nil}

      /// The ID of the comment for which the reply was added.
      public var repliedToID: String {
        get {return _repliedToID ?? String()}
        set {_repliedToID = newValue}
      }
      /// Returns true if `repliedToID` has been explicitly set.
      public var hasRepliedToID: Bool {return self._repliedToID != nil}
      /// Clears the value of `repliedToID`. Subsequent reads from it will return its default value.
      public mutating func clearRepliedToID() {self._repliedToID = nil}

      /// Commented text
      public var content: String {
        get {return _content ?? String()}
        set {_content = newValue}
      }
      /// Returns true if `content` has been explicitly set.
      public var hasContent: Bool {return self._content != nil}
      /// Clears the value of `content`. Subsequent reads from it will return its default value.
      public mutating func clearContent() {self._content = nil}

      /// pictures associated with the comment
      public var pictures: [PicProperties] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _commentOperation: OperationFields.CommentOperationType? = nil
      fileprivate var _commentID: String? = nil
      fileprivate var _repliedToID: String? = nil
      fileprivate var _content: String? = nil
    }

    public struct SharedDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var permission: OperationFields.ShareOperationType {
        get {return _permission ?? .unknownSharePermission}
        set {_permission = newValue}
      }
      /// Returns true if `permission` has been explicitly set.
      public var hasPermission: Bool {return self._permission != nil}
      /// Clears the value of `permission`. Subsequent reads from it will return its default value.
      public mutating func clearPermission() {self._permission = nil}

      /// ZUID of the user who shared the presentation.
      public var sharedBy: String {
        get {return _sharedBy ?? String()}
        set {_sharedBy = newValue}
      }
      /// Returns true if `sharedBy` has been explicitly set.
      public var hasSharedBy: Bool {return self._sharedBy != nil}
      /// Clears the value of `sharedBy`. Subsequent reads from it will return its default value.
      public mutating func clearSharedBy() {self._sharedBy = nil}

      public var memberDetails: [MemberDetails] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _permission: OperationFields.ShareOperationType? = nil
      fileprivate var _sharedBy: String? = nil
    }

    public struct MentionDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var association: ProjectLevelNotification.Operation.MentionDetails.AssociatedObject {
        get {return _association ?? ProjectLevelNotification.Operation.MentionDetails.AssociatedObject()}
        set {_association = newValue}
      }
      /// Returns true if `association` has been explicitly set.
      public var hasAssociation: Bool {return self._association != nil}
      /// Clears the value of `association`. Subsequent reads from it will return its default value.
      public mutating func clearAssociation() {self._association = nil}

      /// Mention text
      public var content: String {
        get {return _content ?? String()}
        set {_content = newValue}
      }
      /// Returns true if `content` has been explicitly set.
      public var hasContent: Bool {return self._content != nil}
      /// Clears the value of `content`. Subsequent reads from it will return its default value.
      public mutating func clearContent() {self._content = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct AssociatedObject {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objectID: String {
          get {return _objectID ?? String()}
          set {_objectID = newValue}
        }
        /// Returns true if `objectID` has been explicitly set.
        public var hasObjectID: Bool {return self._objectID != nil}
        /// Clears the value of `objectID`. Subsequent reads from it will return its default value.
        public mutating func clearObjectID() {self._objectID = nil}

        /// FrameID refers to Slide in Show , ArtBoard/Screen in Nila , Frame/Container in RB.
        public var frameID: String {
          get {return _frameID ?? String()}
          set {_frameID = newValue}
        }
        /// Returns true if `frameID` has been explicitly set.
        public var hasFrameID: Bool {return self._frameID != nil}
        /// Clears the value of `frameID`. Subsequent reads from it will return its default value.
        public mutating func clearFrameID() {self._frameID = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _objectID: String? = nil
        fileprivate var _frameID: String? = nil
      }

      public init() {}

      fileprivate var _association: ProjectLevelNotification.Operation.MentionDetails.AssociatedObject? = nil
      fileprivate var _content: String? = nil
    }

    public struct PublishDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: OperationFields.PublishOperationType {
        get {return _type ?? .unknownPublish}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var notes: String {
        get {return _notes ?? String()}
        set {_notes = newValue}
      }
      /// Returns true if `notes` has been explicitly set.
      public var hasNotes: Bool {return self._notes != nil}
      /// Clears the value of `notes`. Subsequent reads from it will return its default value.
      public mutating func clearNotes() {self._notes = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _type: OperationFields.PublishOperationType? = nil
      fileprivate var _notes: String? = nil
    }

    public struct MetaDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: OperationFields.MetaOperationType {
        get {return _type ?? .unknownMetaType}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      public var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      public mutating func clearType() {self._type = nil}

      public var documentStatusDetails: ProjectLevelNotification.Operation.MetaDetails.DocumentStatusDetails {
        get {return _documentStatusDetails ?? ProjectLevelNotification.Operation.MetaDetails.DocumentStatusDetails()}
        set {_documentStatusDetails = newValue}
      }
      /// Returns true if `documentStatusDetails` has been explicitly set.
      public var hasDocumentStatusDetails: Bool {return self._documentStatusDetails != nil}
      /// Clears the value of `documentStatusDetails`. Subsequent reads from it will return its default value.
      public mutating func clearDocumentStatusDetails() {self._documentStatusDetails = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct DocumentStatusDetails {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var statusType: DocumentStatusField.DocumentStatusType {
          get {return _statusType ?? .unknownStatus}
          set {_statusType = newValue}
        }
        /// Returns true if `statusType` has been explicitly set.
        public var hasStatusType: Bool {return self._statusType != nil}
        /// Clears the value of `statusType`. Subsequent reads from it will return its default value.
        public mutating func clearStatusType() {self._statusType = nil}

        public var previousStatusType: DocumentStatusField.DocumentStatusType {
          get {return _previousStatusType ?? .unknownStatus}
          set {_previousStatusType = newValue}
        }
        /// Returns true if `previousStatusType` has been explicitly set.
        public var hasPreviousStatusType: Bool {return self._previousStatusType != nil}
        /// Clears the value of `previousStatusType`. Subsequent reads from it will return its default value.
        public mutating func clearPreviousStatusType() {self._previousStatusType = nil}

        public var notes: String {
          get {return _notes ?? String()}
          set {_notes = newValue}
        }
        /// Returns true if `notes` has been explicitly set.
        public var hasNotes: Bool {return self._notes != nil}
        /// Clears the value of `notes`. Subsequent reads from it will return its default value.
        public mutating func clearNotes() {self._notes = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _statusType: DocumentStatusField.DocumentStatusType? = nil
        fileprivate var _previousStatusType: DocumentStatusField.DocumentStatusType? = nil
        fileprivate var _notes: String? = nil
      }

      public init() {}

      fileprivate var _type: OperationFields.MetaOperationType? = nil
      fileprivate var _documentStatusDetails: ProjectLevelNotification.Operation.MetaDetails.DocumentStatusDetails? = nil
    }

    public struct CatchupDetails {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var catchupOperation: OperationFields.CatchupOperationType {
        get {return _catchupOperation ?? .unknownCatchup}
        set {_catchupOperation = newValue}
      }
      /// Returns true if `catchupOperation` has been explicitly set.
      public var hasCatchupOperation: Bool {return self._catchupOperation != nil}
      /// Clears the value of `catchupOperation`. Subsequent reads from it will return its default value.
      public mutating func clearCatchupOperation() {self._catchupOperation = nil}

      /// catchupId
      public var catchupID: String {
        get {return _catchupID ?? String()}
        set {_catchupID = newValue}
      }
      /// Returns true if `catchupID` has been explicitly set.
      public var hasCatchupID: Bool {return self._catchupID != nil}
      /// Clears the value of `catchupID`. Subsequent reads from it will return its default value.
      public mutating func clearCatchupID() {self._catchupID = nil}

      /// Scheduled Time
      public var time: Time {
        get {return _time ?? Time()}
        set {_time = newValue}
      }
      /// Returns true if `time` has been explicitly set.
      public var hasTime: Bool {return self._time != nil}
      /// Clears the value of `time`. Subsequent reads from it will return its default value.
      public mutating func clearTime() {self._time = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _catchupOperation: OperationFields.CatchupOperationType? = nil
      fileprivate var _catchupID: String? = nil
      fileprivate var _time: Time? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension ProjectLevelNotification.DocDetails.ResourceType: CaseIterable {
  // Support synthesized by the compiler.
}

extension ProjectLevelNotification.Operation.OperationType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct OrgLevelNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var org: OrgDetails {
    get {return _org ?? OrgDetails()}
    set {_org = newValue}
  }
  /// Returns true if `org` has been explicitly set.
  public var hasOrg: Bool {return self._org != nil}
  /// Clears the value of `org`. Subsequent reads from it will return its default value.
  public mutating func clearOrg() {self._org = nil}

  public var team: OrgDetails {
    get {return _team ?? OrgDetails()}
    set {_team = newValue}
  }
  /// Returns true if `team` has been explicitly set.
  public var hasTeam: Bool {return self._team != nil}
  /// Clears the value of `team`. Subsequent reads from it will return its default value.
  public mutating func clearTeam() {self._team = nil}

  public var operation: OrgLevelNotification.Operation {
    get {return _operation ?? OrgLevelNotification.Operation()}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  public var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  public mutating func clearOperation() {self._operation = nil}

  public var time: Time {
    get {return _time ?? Time()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: OperationFields.OperationFieldType {
      get {return _type ?? .unknownOperation}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    public var functionalType: OperationFields.MemberOperationType {
      get {return _functionalType ?? .unknownMember}
      set {_functionalType = newValue}
    }
    /// Returns true if `functionalType` has been explicitly set.
    public var hasFunctionalType: Bool {return self._functionalType != nil}
    /// Clears the value of `functionalType`. Subsequent reads from it will return its default value.
    public mutating func clearFunctionalType() {self._functionalType = nil}

    public var by: String {
      get {return _by ?? String()}
      set {_by = newValue}
    }
    /// Returns true if `by` has been explicitly set.
    public var hasBy: Bool {return self._by != nil}
    /// Clears the value of `by`. Subsequent reads from it will return its default value.
    public mutating func clearBy() {self._by = nil}

    public var byMeta: UserDetails {
      get {return _byMeta ?? UserDetails()}
      set {_byMeta = newValue}
    }
    /// Returns true if `byMeta` has been explicitly set.
    public var hasByMeta: Bool {return self._byMeta != nil}
    /// Clears the value of `byMeta`. Subsequent reads from it will return its default value.
    public mutating func clearByMeta() {self._byMeta = nil}

    public var memberDetails: [MemberDetails] = []

    public var previousRole: MemberField.MemberRoleType {
      get {return _previousRole ?? .unknownMemberRoleType}
      set {_previousRole = newValue}
    }
    /// Returns true if `previousRole` has been explicitly set.
    public var hasPreviousRole: Bool {return self._previousRole != nil}
    /// Clears the value of `previousRole`. Subsequent reads from it will return its default value.
    public mutating func clearPreviousRole() {self._previousRole = nil}

    public var role: MemberField.MemberRoleType {
      get {return _role ?? .unknownMemberRoleType}
      set {_role = newValue}
    }
    /// Returns true if `role` has been explicitly set.
    public var hasRole: Bool {return self._role != nil}
    /// Clears the value of `role`. Subsequent reads from it will return its default value.
    public mutating func clearRole() {self._role = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _type: OperationFields.OperationFieldType? = nil
    fileprivate var _functionalType: OperationFields.MemberOperationType? = nil
    fileprivate var _by: String? = nil
    fileprivate var _byMeta: UserDetails? = nil
    fileprivate var _previousRole: MemberField.MemberRoleType? = nil
    fileprivate var _role: MemberField.MemberRoleType? = nil
  }

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _org: OrgDetails? = nil
  fileprivate var _team: OrgDetails? = nil
  fileprivate var _operation: OrgLevelNotification.Operation? = nil
  fileprivate var _time: Time? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Notifications: @unchecked Sendable {}
extension Notifications.NotificationDetails: @unchecked Sendable {}
extension Notifications.NotificationDetails.NotificationType: @unchecked Sendable {}
extension NotificationStatus: @unchecked Sendable {}
extension NotificationStatus.Status: @unchecked Sendable {}
extension NotificationStatus.Consumer: @unchecked Sendable {}
extension NotificationStatus.Consumer.DeviceDetails: @unchecked Sendable {}
extension NotificationStatus.Consumer.DeviceDetails.DeviceType: @unchecked Sendable {}
extension NotificationStatus.Consumer.DeviceDetails.BrowserDetails: @unchecked Sendable {}
extension NotificationStatus.Consumer.DeviceDetails.BrowserDetails.BrowserName: @unchecked Sendable {}
extension NotificationStatus.Consumer.DeviceDetails.OSDetails: @unchecked Sendable {}
extension NotificationStatus.Consumer.DeviceDetails.OSDetails.OSName: @unchecked Sendable {}
extension ResourceMeta: @unchecked Sendable {}
extension UserDetails: @unchecked Sendable {}
extension MemberDetails: @unchecked Sendable {}
extension OrgDetails: @unchecked Sendable {}
extension ProjectLevelNotification: @unchecked Sendable {}
extension ProjectLevelNotification.DocDetails: @unchecked Sendable {}
extension ProjectLevelNotification.DocDetails.ResourceType: @unchecked Sendable {}
extension ProjectLevelNotification.Operation: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.OperationType: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.ModifiedDetails: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.CommentDetails: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.SharedDetails: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.MentionDetails: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.MentionDetails.AssociatedObject: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.PublishDetails: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.MetaDetails: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.MetaDetails.DocumentStatusDetails: @unchecked Sendable {}
extension ProjectLevelNotification.Operation.CatchupDetails: @unchecked Sendable {}
extension OrgLevelNotification: @unchecked Sendable {}
extension OrgLevelNotification.Operation: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.common"

extension Notifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notifications"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notificationDetails"),
    2: .same(proto: "lastConsumedId"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.notificationDetails) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notificationDetails) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._lastConsumedID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.notificationDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notificationDetails, fieldNumber: 1)
    }
    try { if let v = self._lastConsumedID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Notifications, rhs: Notifications) -> Bool {
    if lhs.notificationDetails != rhs.notificationDetails {return false}
    if lhs._lastConsumedID != rhs._lastConsumedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Notifications.NotificationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Notifications.protoMessageName + ".NotificationDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "project"),
    2: .same(proto: "status"),
    3: .same(proto: "type"),
    4: .same(proto: "organisation"),
  ]

  fileprivate class _StorageClass {
    var _project: ProjectLevelNotification? = nil
    var _status: NotificationStatus? = nil
    var _type: Notifications.NotificationDetails.NotificationType? = nil
    var _organisation: OrgLevelNotification? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _project = source._project
      _status = source._status
      _type = source._type
      _organisation = source._organisation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._project, !v.isInitialized {return false}
      if let v = _storage._status, !v.isInitialized {return false}
      if let v = _storage._organisation, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._project) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._organisation) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._project {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._organisation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Notifications.NotificationDetails, rhs: Notifications.NotificationDetails) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._project != rhs_storage._project {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._organisation != rhs_storage._organisation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Notifications.NotificationDetails.NotificationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_NOTIFICATION_TYPE"),
    1: .same(proto: "ORGANISATION"),
    2: .same(proto: "PROJECT"),
  ]
}

extension NotificationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "consumer"),
  ]

  public var isInitialized: Bool {
    if let v = self._consumer, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._consumer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._consumer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationStatus, rhs: NotificationStatus) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._consumer != rhs._consumer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationStatus.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "UNREAD"),
    2: .same(proto: "READ"),
  ]
}

extension NotificationStatus.Consumer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NotificationStatus.protoMessageName + ".Consumer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "device"),
  ]

  public var isInitialized: Bool {
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationStatus.Consumer, rhs: NotificationStatus.Consumer) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationStatus.Consumer.DeviceDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NotificationStatus.Consumer.protoMessageName + ".DeviceDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "browser"),
    3: .same(proto: "os"),
    4: .same(proto: "model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._os) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._model) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._os {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._model {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationStatus.Consumer.DeviceDetails, rhs: NotificationStatus.Consumer.DeviceDetails) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs._os != rhs._os {return false}
    if lhs._model != rhs._model {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationStatus.Consumer.DeviceDetails.DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DEVICE"),
    1: .same(proto: "BROWSER"),
    2: .same(proto: "IOS"),
    3: .same(proto: "ANDROID_DEVICE"),
  ]
}

extension NotificationStatus.Consumer.DeviceDetails.BrowserDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NotificationStatus.Consumer.DeviceDetails.protoMessageName + ".BrowserDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationStatus.Consumer.DeviceDetails.BrowserDetails, rhs: NotificationStatus.Consumer.DeviceDetails.BrowserDetails) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationStatus.Consumer.DeviceDetails.BrowserDetails.BrowserName: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_BROWSER"),
    1: .same(proto: "CHROME"),
    2: .same(proto: "FIREFOX"),
    3: .same(proto: "IE"),
    4: .same(proto: "EDGE"),
    5: .same(proto: "SAFARI"),
  ]
}

extension NotificationStatus.Consumer.DeviceDetails.OSDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = NotificationStatus.Consumer.DeviceDetails.protoMessageName + ".OSDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationStatus.Consumer.DeviceDetails.OSDetails, rhs: NotificationStatus.Consumer.DeviceDetails.OSDetails) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationStatus.Consumer.DeviceDetails.OSDetails.OSName: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_OS"),
    1: .same(proto: "MACOS"),
    2: .same(proto: "IOS"),
    3: .same(proto: "TVOS"),
    4: .same(proto: "WATCHOS"),
    5: .same(proto: "ANDROID_OS"),
    6: .same(proto: "WINDOWS"),
    7: .same(proto: "CHROME_OS"),
    8: .same(proto: "LINUX"),
  ]
}

extension ResourceMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceMeta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ResourceMeta, rhs: ResourceMeta) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "nickName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nickName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nickName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserDetails, rhs: UserDetails) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._nickName != rhs._nickName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MemberDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MemberDetails, rhs: MemberDetails) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._meta != rhs._meta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrgDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrgDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "meta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrgDetails, rhs: OrgDetails) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._meta != rhs._meta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProjectLevelNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    5: .same(proto: "project"),
    2: .same(proto: "documents"),
    3: .same(proto: "operation"),
    4: .same(proto: "time"),
  ]

  fileprivate class _StorageClass {
    var _id: String? = nil
    var _project: ProjectLevelNotification.DocDetails? = nil
    var _documents: [ProjectLevelNotification.DocDetails] = []
    var _operation: ProjectLevelNotification.Operation? = nil
    var _time: Time? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _project = source._project
      _documents = source._documents
      _operation = source._operation
      _time = source._time
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._operation, !v.isInitialized {return false}
      if let v = _storage._time, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._documents) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._operation) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._project) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      if !_storage._documents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._documents, fieldNumber: 2)
      }
      try { if let v = _storage._operation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._project {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification, rhs: ProjectLevelNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._project != rhs_storage._project {return false}
        if _storage._documents != rhs_storage._documents {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._time != rhs_storage._time {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.DocDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.protoMessageName + ".DocDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resourceId"),
    2: .same(proto: "creatorId"),
    3: .same(proto: "type"),
    4: .same(proto: "meta"),
    5: .same(proto: "creatorMeta"),
    6: .same(proto: "org"),
    7: .same(proto: "team"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._resourceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._creatorID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._creatorMeta) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._org) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._team) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resourceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._creatorID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._creatorMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._org {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._team {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.DocDetails, rhs: ProjectLevelNotification.DocDetails) -> Bool {
    if lhs._resourceID != rhs._resourceID {return false}
    if lhs._creatorID != rhs._creatorID {return false}
    if lhs._type != rhs._type {return false}
    if lhs._meta != rhs._meta {return false}
    if lhs._creatorMeta != rhs._creatorMeta {return false}
    if lhs._org != rhs._org {return false}
    if lhs._team != rhs._team {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.DocDetails.ResourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NON_NATIVE"),
    2: .same(proto: "NATIVE"),
  ]
}

extension ProjectLevelNotification.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "by"),
    3: .same(proto: "editOperation"),
    4: .same(proto: "modifiedDetails"),
    5: .same(proto: "byMeta"),
    6: .same(proto: "commentDetails"),
    7: .same(proto: "sharedDetails"),
    8: .same(proto: "mentionDetails"),
    9: .same(proto: "publishDetails"),
    10: .same(proto: "metaDetails"),
    11: .same(proto: "catchupDetails"),
  ]

  fileprivate class _StorageClass {
    var _type: ProjectLevelNotification.Operation.OperationType? = nil
    var _by: String? = nil
    var _editOperation: OperationFields.EditOperationType? = nil
    var _modifiedDetails: ProjectLevelNotification.Operation.ModifiedDetails? = nil
    var _byMeta: UserDetails? = nil
    var _commentDetails: ProjectLevelNotification.Operation.CommentDetails? = nil
    var _sharedDetails: ProjectLevelNotification.Operation.SharedDetails? = nil
    var _mentionDetails: ProjectLevelNotification.Operation.MentionDetails? = nil
    var _publishDetails: ProjectLevelNotification.Operation.PublishDetails? = nil
    var _metaDetails: ProjectLevelNotification.Operation.MetaDetails? = nil
    var _catchupDetails: ProjectLevelNotification.Operation.CatchupDetails? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _by = source._by
      _editOperation = source._editOperation
      _modifiedDetails = source._modifiedDetails
      _byMeta = source._byMeta
      _commentDetails = source._commentDetails
      _sharedDetails = source._sharedDetails
      _mentionDetails = source._mentionDetails
      _publishDetails = source._publishDetails
      _metaDetails = source._metaDetails
      _catchupDetails = source._catchupDetails
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._commentDetails, !v.isInitialized {return false}
      if let v = _storage._catchupDetails, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._by) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._editOperation) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedDetails) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._byMeta) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._commentDetails) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._sharedDetails) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._mentionDetails) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._publishDetails) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._metaDetails) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._catchupDetails) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._by {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._editOperation {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._modifiedDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._byMeta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._commentDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._sharedDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._mentionDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._publishDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._metaDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._catchupDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation, rhs: ProjectLevelNotification.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._by != rhs_storage._by {return false}
        if _storage._editOperation != rhs_storage._editOperation {return false}
        if _storage._modifiedDetails != rhs_storage._modifiedDetails {return false}
        if _storage._byMeta != rhs_storage._byMeta {return false}
        if _storage._commentDetails != rhs_storage._commentDetails {return false}
        if _storage._sharedDetails != rhs_storage._sharedDetails {return false}
        if _storage._mentionDetails != rhs_storage._mentionDetails {return false}
        if _storage._publishDetails != rhs_storage._publishDetails {return false}
        if _storage._metaDetails != rhs_storage._metaDetails {return false}
        if _storage._catchupDetails != rhs_storage._catchupDetails {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.OperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_OPERATION"),
    1: .same(proto: "SHARE"),
    2: .same(proto: "REMOVE_SHARE"),
    3: .same(proto: "CREATE"),
    4: .same(proto: "UPLOAD"),
    5: .same(proto: "COPY"),
    6: .same(proto: "TRASH"),
    7: .same(proto: "RESTORE"),
    8: .same(proto: "VIEW"),
    9: .same(proto: "EDIT"),
    10: .same(proto: "PUBLISH"),
    11: .same(proto: "CATCHUP"),
  ]
}

extension ProjectLevelNotification.Operation.ModifiedDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.protoMessageName + ".ModifiedDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modifyOperation"),
    2: .same(proto: "frameId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._modifyOperation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._frameID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modifyOperation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._frameID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.ModifiedDetails, rhs: ProjectLevelNotification.Operation.ModifiedDetails) -> Bool {
    if lhs._modifyOperation != rhs._modifyOperation {return false}
    if lhs._frameID != rhs._frameID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.CommentDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.protoMessageName + ".CommentDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentOperation"),
    2: .same(proto: "commentId"),
    3: .same(proto: "repliedToId"),
    4: .same(proto: "content"),
    5: .same(proto: "pictures"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.pictures) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._commentOperation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._commentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._repliedToID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._content) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.pictures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commentOperation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._commentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._repliedToID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.pictures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pictures, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.CommentDetails, rhs: ProjectLevelNotification.Operation.CommentDetails) -> Bool {
    if lhs._commentOperation != rhs._commentOperation {return false}
    if lhs._commentID != rhs._commentID {return false}
    if lhs._repliedToID != rhs._repliedToID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.pictures != rhs.pictures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.SharedDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.protoMessageName + ".SharedDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permission"),
    2: .same(proto: "sharedBy"),
    3: .same(proto: "memberDetails"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._permission) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sharedBy) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.memberDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._permission {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sharedBy {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.memberDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memberDetails, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.SharedDetails, rhs: ProjectLevelNotification.Operation.SharedDetails) -> Bool {
    if lhs._permission != rhs._permission {return false}
    if lhs._sharedBy != rhs._sharedBy {return false}
    if lhs.memberDetails != rhs.memberDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.MentionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.protoMessageName + ".MentionDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "association"),
    4: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._association) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._association {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.MentionDetails, rhs: ProjectLevelNotification.Operation.MentionDetails) -> Bool {
    if lhs._association != rhs._association {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.MentionDetails.AssociatedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.MentionDetails.protoMessageName + ".AssociatedObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objectId"),
    2: .same(proto: "frameId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._objectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._frameID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._objectID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._frameID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.MentionDetails.AssociatedObject, rhs: ProjectLevelNotification.Operation.MentionDetails.AssociatedObject) -> Bool {
    if lhs._objectID != rhs._objectID {return false}
    if lhs._frameID != rhs._frameID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.PublishDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.protoMessageName + ".PublishDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "notes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._notes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._notes {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.PublishDetails, rhs: ProjectLevelNotification.Operation.PublishDetails) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._notes != rhs._notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.MetaDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.protoMessageName + ".MetaDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "documentStatusDetails"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._documentStatusDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._documentStatusDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.MetaDetails, rhs: ProjectLevelNotification.Operation.MetaDetails) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._documentStatusDetails != rhs._documentStatusDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.MetaDetails.DocumentStatusDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.MetaDetails.protoMessageName + ".DocumentStatusDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statusType"),
    2: .same(proto: "previousStatusType"),
    3: .same(proto: "notes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._statusType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._previousStatusType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._notes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._statusType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._previousStatusType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._notes {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.MetaDetails.DocumentStatusDetails, rhs: ProjectLevelNotification.Operation.MetaDetails.DocumentStatusDetails) -> Bool {
    if lhs._statusType != rhs._statusType {return false}
    if lhs._previousStatusType != rhs._previousStatusType {return false}
    if lhs._notes != rhs._notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProjectLevelNotification.Operation.CatchupDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProjectLevelNotification.Operation.protoMessageName + ".CatchupDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "catchupOperation"),
    2: .same(proto: "catchupId"),
    3: .same(proto: "time"),
  ]

  public var isInitialized: Bool {
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._catchupOperation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._catchupID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._catchupOperation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._catchupID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProjectLevelNotification.Operation.CatchupDetails, rhs: ProjectLevelNotification.Operation.CatchupDetails) -> Bool {
    if lhs._catchupOperation != rhs._catchupOperation {return false}
    if lhs._catchupID != rhs._catchupID {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrgLevelNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrgLevelNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "org"),
    3: .same(proto: "team"),
    4: .same(proto: "operation"),
    5: .same(proto: "time"),
  ]

  public var isInitialized: Bool {
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._org) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._team) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._operation) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._org {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._team {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._operation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrgLevelNotification, rhs: OrgLevelNotification) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._org != rhs._org {return false}
    if lhs._team != rhs._team {return false}
    if lhs._operation != rhs._operation {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrgLevelNotification.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = OrgLevelNotification.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "functionalType"),
    3: .same(proto: "by"),
    4: .same(proto: "byMeta"),
    5: .same(proto: "memberDetails"),
    6: .same(proto: "previousRole"),
    7: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._functionalType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._by) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._byMeta) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.memberDetails) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._previousRole) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._functionalType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._by {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._byMeta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.memberDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memberDetails, fieldNumber: 5)
    }
    try { if let v = self._previousRole {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._role {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OrgLevelNotification.Operation, rhs: OrgLevelNotification.Operation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._functionalType != rhs._functionalType {return false}
    if lhs._by != rhs._by {return false}
    if lhs._byMeta != rhs._byMeta {return false}
    if lhs.memberDetails != rhs.memberDetails {return false}
    if lhs._previousRole != rhs._previousRole {return false}
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
