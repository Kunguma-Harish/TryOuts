// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: collaboration.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct DocumentDeltas {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var delta: [DocumentDelta] = []

  public var lastSavedVersion: Int32 {
    get {return _lastSavedVersion ?? 0}
    set {_lastSavedVersion = newValue}
  }
  /// Returns true if `lastSavedVersion` has been explicitly set.
  public var hasLastSavedVersion: Bool {return self._lastSavedVersion != nil}
  /// Clears the value of `lastSavedVersion`. Subsequent reads from it will return its default value.
  public mutating func clearLastSavedVersion() {self._lastSavedVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastSavedVersion: Int32? = nil
}

public struct DocumentDelta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Presentation version that the delta is intended to be applied to. 
  public var version: Int32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  /// ZUID/ ZGID. The author of this delta could be a group or user
  public var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {self._author = nil}

  /// Operations included in this delta 
  public var docOp: [DocumentOperation] = []

  /// Indicates the time at which the operation was performed 
  public var modTime: String {
    get {return _modTime ?? String()}
    set {_modTime = newValue}
  }
  /// Returns true if `modTime` has been explicitly set.
  public var hasModTime: Bool {return self._modTime != nil}
  /// Clears the value of `modTime`. Subsequent reads from it will return its default value.
  public mutating func clearModTime() {self._modTime = nil}

  /// 
  /// For example, "show-team" group may be the explicit participant of
  /// this presentation, and is set as the author of a delta. However, this group is
  /// being asked to act on behalf of "vijayr@zohocorp.com", who is a member
  /// of "show-team". In this example, the delta would be configured as :
  ///  delta.author = "<show-team's group id>"
  ///  delta.groupMember = <zuid of vijayr> 
  public var grpMember: String {
    get {return _grpMember ?? String()}
    set {_grpMember = newValue}
  }
  /// Returns true if `grpMember` has been explicitly set.
  public var hasGrpMember: Bool {return self._grpMember != nil}
  /// Clears the value of `grpMember`. Subsequent reads from it will return its default value.
  public mutating func clearGrpMember() {self._grpMember = nil}

  /// csrf token of the user session
  public var uniqueID: String {
    get {return _uniqueID ?? String()}
    set {_uniqueID = newValue}
  }
  /// Returns true if `uniqueID` has been explicitly set.
  public var hasUniqueID: Bool {return self._uniqueID != nil}
  /// Clears the value of `uniqueID`. Subsequent reads from it will return its default value.
  public mutating func clearUniqueID() {self._uniqueID = nil}

  public var anonUserID: String {
    get {return _anonUserID ?? String()}
    set {_anonUserID = newValue}
  }
  /// Returns true if `anonUserID` has been explicitly set.
  public var hasAnonUserID: Bool {return self._anonUserID != nil}
  /// Clears the value of `anonUserID`. Subsequent reads from it will return its default value.
  public mutating func clearAnonUserID() {self._anonUserID = nil}

  /// Document ID , to be used on need.
  public var documentID: String {
    get {return _documentID ?? String()}
    set {_documentID = newValue}
  }
  /// Returns true if `documentID` has been explicitly set.
  public var hasDocumentID: Bool {return self._documentID != nil}
  /// Clears the value of `documentID`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentID() {self._documentID = nil}

  /// Application version of the client that sends the delta
  public var appVersion: ApplicationVersion {
    get {return _appVersion ?? ApplicationVersion()}
    set {_appVersion = newValue}
  }
  /// Returns true if `appVersion` has been explicitly set.
  public var hasAppVersion: Bool {return self._appVersion != nil}
  /// Clears the value of `appVersion`. Subsequent reads from it will return its default value.
  public mutating func clearAppVersion() {self._appVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: Int32? = nil
  fileprivate var _author: String? = nil
  fileprivate var _modTime: String? = nil
  fileprivate var _grpMember: String? = nil
  fileprivate var _uniqueID: String? = nil
  fileprivate var _anonUserID: String? = nil
  fileprivate var _documentID: String? = nil
  fileprivate var _appVersion: ApplicationVersion? = nil
}

public struct DocumentOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Adds a new participant to the presentation (the moment a user joins the collaboration, we'll add them to our history)
  public var addParticipant: String {
    get {return _addParticipant ?? String()}
    set {_addParticipant = newValue}
  }
  /// Returns true if `addParticipant` has been explicitly set.
  public var hasAddParticipant: Bool {return self._addParticipant != nil}
  /// Clears the value of `addParticipant`. Subsequent reads from it will return its default value.
  public mutating func clearAddParticipant() {self._addParticipant = nil}

  /// Removes an existing participant 
  public var removeParticipant: String {
    get {return _removeParticipant ?? String()}
    set {_removeParticipant = newValue}
  }
  /// Returns true if `removeParticipant` has been explicitly set.
  public var hasRemoveParticipant: Bool {return self._removeParticipant != nil}
  /// Clears the value of `removeParticipant`. Subsequent reads from it will return its default value.
  public mutating func clearRemoveParticipant() {self._removeParticipant = nil}

  public var mutateDocument: DocumentOperation.MutateDocument {
    get {return _mutateDocument ?? DocumentOperation.MutateDocument()}
    set {_mutateDocument = newValue}
  }
  /// Returns true if `mutateDocument` has been explicitly set.
  public var hasMutateDocument: Bool {return self._mutateDocument != nil}
  /// Clears the value of `mutateDocument`. Subsequent reads from it will return its default value.
  public mutating func clearMutateDocument() {self._mutateDocument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Mutates a document.
  public struct MutateDocument {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// this should not be confused with the presenation id. this mutateDocumentId can be a slide Id / master Id / presentation Id
    public var mDocID: String {
      get {return _mDocID ?? String()}
      set {_mDocID = newValue}
    }
    /// Returns true if `mDocID` has been explicitly set.
    public var hasMDocID: Bool {return self._mDocID != nil}
    /// Clears the value of `mDocID`. Subsequent reads from it will return its default value.
    public mutating func clearMDocID() {self._mDocID = nil}

    public var contentOp: DocumentContentOperation {
      get {return _contentOp ?? DocumentContentOperation()}
      set {_contentOp = newValue}
    }
    /// Returns true if `contentOp` has been explicitly set.
    public var hasContentOp: Bool {return self._contentOp != nil}
    /// Clears the value of `contentOp`. Subsequent reads from it will return its default value.
    public mutating func clearContentOp() {self._contentOp = nil}

    public var mDocKey: String {
      get {return _mDocKey ?? String()}
      set {_mDocKey = newValue}
    }
    /// Returns true if `mDocKey` has been explicitly set.
    public var hasMDocKey: Bool {return self._mDocKey != nil}
    /// Clears the value of `mDocKey`. Subsequent reads from it will return its default value.
    public mutating func clearMDocKey() {self._mDocKey = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _mDocID: String? = nil
    fileprivate var _contentOp: DocumentContentOperation? = nil
    fileprivate var _mDocKey: String? = nil
  }

  public init() {}

  fileprivate var _addParticipant: String? = nil
  fileprivate var _removeParticipant: String? = nil
  fileprivate var _mutateDocument: DocumentOperation.MutateDocument? = nil
}

public struct DocumentContentOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var component: [DocumentContentOperation.Component] = []

  public var type: DocumentContentOperation.DocumentContentOperationType {
    get {return _type ?? .defGroupType}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DocumentContentOperationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case defGroupType // = 0
    case group // = 1
    case ungroup // = 2

    public init() {
      self = .defGroupType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .defGroupType
      case 1: self = .group
      case 2: self = .ungroup
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .defGroupType: return 0
      case .group: return 1
      case .ungroup: return 2
      }
    }

  }

  public struct Component {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var opType: DocumentContentOperation.Component.OperationType {
      get {return _storage._opType ?? .defOperationType}
      set {_uniqueStorage()._opType = newValue}
    }
    /// Returns true if `opType` has been explicitly set.
    public var hasOpType: Bool {return _storage._opType != nil}
    /// Clears the value of `opType`. Subsequent reads from it will return its default value.
    public mutating func clearOpType() {_uniqueStorage()._opType = nil}

    /// The first position in the fields will hold the root element. 
    public var fields: String {
      get {return _storage._fields ?? String()}
      set {_uniqueStorage()._fields = newValue}
    }
    /// Returns true if `fields` has been explicitly set.
    public var hasFields: Bool {return _storage._fields != nil}
    /// Clears the value of `fields`. Subsequent reads from it will return its default value.
    public mutating func clearFields() {_uniqueStorage()._fields = nil}

    public var value: DocumentContentOperation.Component.Value {
      get {return _storage._value ?? DocumentContentOperation.Component.Value()}
      set {_uniqueStorage()._value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return _storage._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {_uniqueStorage()._value = nil}

    public var text: [DocumentContentOperation.Component.Text] {
      get {return _storage._text}
      set {_uniqueStorage()._text = newValue}
    }

    public var associated: [DocumentContentOperation.Component.AssociatedTexts] {
      get {return _storage._associated}
      set {_uniqueStorage()._associated = newValue}
    }

    public var custom: Custom {
      get {return _storage._custom ?? Custom()}
      set {_uniqueStorage()._custom = newValue}
    }
    /// Returns true if `custom` has been explicitly set.
    public var hasCustom: Bool {return _storage._custom != nil}
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    public mutating func clearCustom() {_uniqueStorage()._custom = nil}

    public var ni: Int32 {
      get {return _storage._ni ?? 0}
      set {_uniqueStorage()._ni = newValue}
    }
    /// Returns true if `ni` has been explicitly set.
    public var hasNi: Bool {return _storage._ni != nil}
    /// Clears the value of `ni`. Subsequent reads from it will return its default value.
    public mutating func clearNi() {_uniqueStorage()._ni = nil}

    /// Use this , if we do not want this delta to be rendered. Basically this could be dependent on some other delta.
    public var noRender: Bool {
      get {return _storage._noRender ?? false}
      set {_uniqueStorage()._noRender = newValue}
    }
    /// Returns true if `noRender` has been explicitly set.
    public var hasNoRender: Bool {return _storage._noRender != nil}
    /// Clears the value of `noRender`. Subsequent reads from it will return its default value.
    public mutating func clearNoRender() {_uniqueStorage()._noRender = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OperationType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case defOperationType // = 0
      case insert // = 1
      case update // = 2
      case delete // = 4
      case text // = 5
      case custom // = 6
      case reorder // = 7
      case reorderInsert // = 8
      case reorderDelete // = 9

      public init() {
        self = .defOperationType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .defOperationType
        case 1: self = .insert
        case 2: self = .update
        case 4: self = .delete
        case 5: self = .text
        case 6: self = .custom
        case 7: self = .reorder
        case 8: self = .reorderInsert
        case 9: self = .reorderDelete
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .defOperationType: return 0
        case .insert: return 1
        case .update: return 2
        case .delete: return 4
        case .text: return 5
        case .custom: return 6
        case .reorder: return 7
        case .reorderInsert: return 8
        case .reorderDelete: return 9
        }
      }

    }

    public struct Value {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// In case of Insert, new_value will hold the value 
      /// In case of Update, if the field is absent, the attribute should be removed/should be set to null.
      public var value: String {
        get {return _value ?? String()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      public var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      public mutating func clearValue() {self._value = nil}

      /// Absent field means that the attribute is absent and/or null.
      public var oldValue: String {
        get {return _oldValue ?? String()}
        set {_oldValue = newValue}
      }
      /// Returns true if `oldValue` has been explicitly set.
      public var hasOldValue: Bool {return self._oldValue != nil}
      /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
      public mutating func clearOldValue() {self._oldValue = nil}

      /// maintains the fields that needs to be deleted from the message mentioned in "fields" variable
      public var deleteData: String {
        get {return _deleteData ?? String()}
        set {_deleteData = newValue}
      }
      /// Returns true if `deleteData` has been explicitly set.
      public var hasDeleteData: Bool {return self._deleteData != nil}
      /// Clears the value of `deleteData`. Subsequent reads from it will return its default value.
      public mutating func clearDeleteData() {self._deleteData = nil}

      /// if true, this will replace the current data present in the message with the 
      /// json string present in "value" field. 
      public var replace: Bool {
        get {return _replace ?? false}
        set {_replace = newValue}
      }
      /// Returns true if `replace` has been explicitly set.
      public var hasReplace: Bool {return self._replace != nil}
      /// Clears the value of `replace`. Subsequent reads from it will return its default value.
      public mutating func clearReplace() {self._replace = nil}

      /// unique id, can be used for insert operation
      public var ids: [String] = []

      public var inBytes: DocumentContentOperation.Component.Value.InBytes {
        get {return _inBytes ?? DocumentContentOperation.Component.Value.InBytes()}
        set {_inBytes = newValue}
      }
      /// Returns true if `inBytes` has been explicitly set.
      public var hasInBytes: Bool {return self._inBytes != nil}
      /// Clears the value of `inBytes`. Subsequent reads from it will return its default value.
      public mutating func clearInBytes() {self._inBytes = nil}

      /// while creating a new para - An id has to be assigned to a paragraph - Which has to be reflected, while saving the content in server too.
      public var paraID: String {
        get {return _paraID ?? String()}
        set {_paraID = newValue}
      }
      /// Returns true if `paraID` has been explicitly set.
      public var hasParaID: Bool {return self._paraID != nil}
      /// Clears the value of `paraID`. Subsequent reads from it will return its default value.
      public mutating func clearParaID() {self._paraID = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct InBytes {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var value: Data {
          get {return _value ?? Data()}
          set {_value = newValue}
        }
        /// Returns true if `value` has been explicitly set.
        public var hasValue: Bool {return self._value != nil}
        /// Clears the value of `value`. Subsequent reads from it will return its default value.
        public mutating func clearValue() {self._value = nil}

        public var oldValue: Data {
          get {return _oldValue ?? Data()}
          set {_oldValue = newValue}
        }
        /// Returns true if `oldValue` has been explicitly set.
        public var hasOldValue: Bool {return self._oldValue != nil}
        /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
        public mutating func clearOldValue() {self._oldValue = nil}

        public var deleteData: Data {
          get {return _deleteData ?? Data()}
          set {_deleteData = newValue}
        }
        /// Returns true if `deleteData` has been explicitly set.
        public var hasDeleteData: Bool {return self._deleteData != nil}
        /// Clears the value of `deleteData`. Subsequent reads from it will return its default value.
        public mutating func clearDeleteData() {self._deleteData = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _value: Data? = nil
        fileprivate var _oldValue: Data? = nil
        fileprivate var _deleteData: Data? = nil
      }

      public init() {}

      fileprivate var _value: String? = nil
      fileprivate var _oldValue: String? = nil
      fileprivate var _deleteData: String? = nil
      fileprivate var _replace: Bool? = nil
      fileprivate var _inBytes: DocumentContentOperation.Component.Value.InBytes? = nil
      fileprivate var _paraID: String? = nil
    }

    public struct Text {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var at: DocumentContentOperation.Component.OperationType {
        get {return _at ?? .defOperationType}
        set {_at = newValue}
      }
      /// Returns true if `at` has been explicitly set.
      public var hasAt: Bool {return self._at != nil}
      /// Clears the value of `at`. Subsequent reads from it will return its default value.
      public mutating func clearAt() {self._at = nil}

      public var si: Int32 {
        get {return _si ?? 0}
        set {_si = newValue}
      }
      /// Returns true if `si` has been explicitly set.
      public var hasSi: Bool {return self._si != nil}
      /// Clears the value of `si`. Subsequent reads from it will return its default value.
      public mutating func clearSi() {self._si = nil}

      ///optional string t = 4;
      public var ei: Int32 {
        get {return _ei ?? 0}
        set {_ei = newValue}
      }
      /// Returns true if `ei` has been explicitly set.
      public var hasEi: Bool {return self._ei != nil}
      /// Clears the value of `ei`. Subsequent reads from it will return its default value.
      public mutating func clearEi() {self._ei = nil}

      public var ut: DocumentContentOperation.Component.Text.UpdateType {
        get {return _ut ?? .defTextUpdateType}
        set {_ut = newValue}
      }
      /// Returns true if `ut` has been explicitly set.
      public var hasUt: Bool {return self._ut != nil}
      /// Clears the value of `ut`. Subsequent reads from it will return its default value.
      public mutating func clearUt() {self._ut = nil}

      public var value: DocumentContentOperation.Component.Value {
        get {return _value ?? DocumentContentOperation.Component.Value()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      public var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      public mutating func clearValue() {self._value = nil}

      public var doNotExtendProps: Bool {
        get {return _doNotExtendProps ?? false}
        set {_doNotExtendProps = newValue}
      }
      /// Returns true if `doNotExtendProps` has been explicitly set.
      public var hasDoNotExtendProps: Bool {return self._doNotExtendProps != nil}
      /// Clears the value of `doNotExtendProps`. Subsequent reads from it will return its default value.
      public mutating func clearDoNotExtendProps() {self._doNotExtendProps = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum UpdateType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case defTextUpdateType // = 0
        case portion // = 1
        case para // = 2

        public init() {
          self = .defTextUpdateType
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .defTextUpdateType
          case 1: self = .portion
          case 2: self = .para
          default: return nil
          }
        }

        public var rawValue: Int {
          switch self {
          case .defTextUpdateType: return 0
          case .portion: return 1
          case .para: return 2
          }
        }

      }

      public init() {}

      fileprivate var _at: DocumentContentOperation.Component.OperationType? = nil
      fileprivate var _si: Int32? = nil
      fileprivate var _ei: Int32? = nil
      fileprivate var _ut: DocumentContentOperation.Component.Text.UpdateType? = nil
      fileprivate var _value: DocumentContentOperation.Component.Value? = nil
      fileprivate var _doNotExtendProps: Bool? = nil
    }

    /// this is used for undo/redo purposes. this should not be sent to the server. an unnecessary data for the server
    public struct AssociatedTexts {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var texts: [DocumentContentOperation.Component.Text] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _type: DocumentContentOperation.DocumentContentOperationType? = nil
}

#if swift(>=4.2)

extension DocumentContentOperation.DocumentContentOperationType: CaseIterable {
  // Support synthesized by the compiler.
}

extension DocumentContentOperation.Component.OperationType: CaseIterable {
  // Support synthesized by the compiler.
}

extension DocumentContentOperation.Component.Text.UpdateType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension DocumentDeltas: @unchecked Sendable {}
extension DocumentDelta: @unchecked Sendable {}
extension DocumentOperation: @unchecked Sendable {}
extension DocumentOperation.MutateDocument: @unchecked Sendable {}
extension DocumentContentOperation: @unchecked Sendable {}
extension DocumentContentOperation.DocumentContentOperationType: @unchecked Sendable {}
extension DocumentContentOperation.Component: @unchecked Sendable {}
extension DocumentContentOperation.Component.OperationType: @unchecked Sendable {}
extension DocumentContentOperation.Component.Value: @unchecked Sendable {}
extension DocumentContentOperation.Component.Value.InBytes: @unchecked Sendable {}
extension DocumentContentOperation.Component.Text: @unchecked Sendable {}
extension DocumentContentOperation.Component.Text.UpdateType: @unchecked Sendable {}
extension DocumentContentOperation.Component.AssociatedTexts: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.zoho.collaboration"

extension DocumentDeltas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentDeltas"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delta"),
    2: .same(proto: "lastSavedVersion"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.delta) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.delta) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._lastSavedVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.delta.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delta, fieldNumber: 1)
    }
    try { if let v = self._lastSavedVersion {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentDeltas, rhs: DocumentDeltas) -> Bool {
    if lhs.delta != rhs.delta {return false}
    if lhs._lastSavedVersion != rhs._lastSavedVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentDelta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "author"),
    3: .same(proto: "docOp"),
    4: .same(proto: "modTime"),
    5: .same(proto: "grpMember"),
    6: .same(proto: "uniqueId"),
    7: .same(proto: "anonUserId"),
    8: .same(proto: "documentId"),
    9: .same(proto: "appVersion"),
  ]

  public var isInitialized: Bool {
    if self._version == nil {return false}
    if self._author == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.docOp) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.docOp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._modTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._grpMember) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._uniqueID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._anonUserID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._documentID) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._appVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.docOp.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.docOp, fieldNumber: 3)
    }
    try { if let v = self._modTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._grpMember {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._uniqueID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._anonUserID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._documentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._appVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentDelta, rhs: DocumentDelta) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._author != rhs._author {return false}
    if lhs.docOp != rhs.docOp {return false}
    if lhs._modTime != rhs._modTime {return false}
    if lhs._grpMember != rhs._grpMember {return false}
    if lhs._uniqueID != rhs._uniqueID {return false}
    if lhs._anonUserID != rhs._anonUserID {return false}
    if lhs._documentID != rhs._documentID {return false}
    if lhs._appVersion != rhs._appVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addParticipant"),
    2: .same(proto: "removeParticipant"),
    3: .same(proto: "mutateDocument"),
  ]

  public var isInitialized: Bool {
    if let v = self._mutateDocument, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._addParticipant) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._removeParticipant) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mutateDocument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._addParticipant {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._removeParticipant {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mutateDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentOperation, rhs: DocumentOperation) -> Bool {
    if lhs._addParticipant != rhs._addParticipant {return false}
    if lhs._removeParticipant != rhs._removeParticipant {return false}
    if lhs._mutateDocument != rhs._mutateDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentOperation.MutateDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DocumentOperation.protoMessageName + ".MutateDocument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mDocId"),
    3: .same(proto: "contentOp"),
    4: .same(proto: "mDocKey"),
  ]

  public var isInitialized: Bool {
    if self._mDocID == nil {return false}
    if self._contentOp == nil {return false}
    if let v = self._contentOp, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mDocID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._contentOp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._mDocKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mDocID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contentOp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mDocKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentOperation.MutateDocument, rhs: DocumentOperation.MutateDocument) -> Bool {
    if lhs._mDocID != rhs._mDocID {return false}
    if lhs._contentOp != rhs._contentOp {return false}
    if lhs._mDocKey != rhs._mDocKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentContentOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentContentOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "component"),
    2: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.component) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.component) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.component.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.component, fieldNumber: 1)
    }
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentContentOperation, rhs: DocumentContentOperation) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentContentOperation.DocumentContentOperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_GROUP_TYPE"),
    1: .same(proto: "GROUP"),
    2: .same(proto: "UNGROUP"),
  ]
}

extension DocumentContentOperation.Component: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DocumentContentOperation.protoMessageName + ".Component"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "opType"),
    3: .same(proto: "fields"),
    5: .same(proto: "value"),
    6: .same(proto: "text"),
    7: .same(proto: "associated"),
    8: .same(proto: "custom"),
    9: .same(proto: "ni"),
    10: .same(proto: "noRender"),
  ]

  fileprivate class _StorageClass {
    var _opType: DocumentContentOperation.Component.OperationType? = nil
    var _fields: String? = nil
    var _value: DocumentContentOperation.Component.Value? = nil
    var _text: [DocumentContentOperation.Component.Text] = []
    var _associated: [DocumentContentOperation.Component.AssociatedTexts] = []
    var _custom: Custom? = nil
    var _ni: Int32? = nil
    var _noRender: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _opType = source._opType
      _fields = source._fields
      _value = source._value
      _text = source._text
      _associated = source._associated
      _custom = source._custom
      _ni = source._ni
      _noRender = source._noRender
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._opType == nil {return false}
      if _storage._fields == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._text) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._associated) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._opType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._fields) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._text) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._associated) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._custom) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._ni) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._noRender) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._opType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._fields {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._text.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._text, fieldNumber: 6)
      }
      if !_storage._associated.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._associated, fieldNumber: 7)
      }
      try { if let v = _storage._custom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._ni {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._noRender {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentContentOperation.Component, rhs: DocumentContentOperation.Component) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._opType != rhs_storage._opType {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._associated != rhs_storage._associated {return false}
        if _storage._custom != rhs_storage._custom {return false}
        if _storage._ni != rhs_storage._ni {return false}
        if _storage._noRender != rhs_storage._noRender {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentContentOperation.Component.OperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_OPERATION_TYPE"),
    1: .same(proto: "INSERT"),
    2: .same(proto: "UPDATE"),
    4: .same(proto: "DELETE"),
    5: .same(proto: "TEXT"),
    6: .same(proto: "CUSTOM"),
    7: .same(proto: "REORDER"),
    8: .same(proto: "REORDER_INSERT"),
    9: .same(proto: "REORDER_DELETE"),
  ]
}

extension DocumentContentOperation.Component.Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DocumentContentOperation.Component.protoMessageName + ".Value"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "oldValue"),
    3: .same(proto: "deleteData"),
    4: .same(proto: "replace"),
    5: .same(proto: "ids"),
    6: .same(proto: "inBytes"),
    7: .same(proto: "paraId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._oldValue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._deleteData) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._replace) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._inBytes) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._paraID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._deleteData {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._replace {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 5)
    }
    try { if let v = self._inBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._paraID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentContentOperation.Component.Value, rhs: DocumentContentOperation.Component.Value) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._deleteData != rhs._deleteData {return false}
    if lhs._replace != rhs._replace {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs._inBytes != rhs._inBytes {return false}
    if lhs._paraID != rhs._paraID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentContentOperation.Component.Value.InBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DocumentContentOperation.Component.Value.protoMessageName + ".InBytes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "oldValue"),
    3: .same(proto: "deleteData"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._oldValue) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._deleteData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldValue {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._deleteData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentContentOperation.Component.Value.InBytes, rhs: DocumentContentOperation.Component.Value.InBytes) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._deleteData != rhs._deleteData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentContentOperation.Component.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DocumentContentOperation.Component.protoMessageName + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "at"),
    2: .same(proto: "si"),
    3: .same(proto: "ei"),
    4: .same(proto: "ut"),
    5: .same(proto: "value"),
    6: .same(proto: "doNotExtendProps"),
  ]

  public var isInitialized: Bool {
    if self._at == nil {return false}
    if self._si == nil {return false}
    if self._ei == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._at) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._si) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._ei) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._ut) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._doNotExtendProps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._at {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._si {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ei {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ut {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._doNotExtendProps {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentContentOperation.Component.Text, rhs: DocumentContentOperation.Component.Text) -> Bool {
    if lhs._at != rhs._at {return false}
    if lhs._si != rhs._si {return false}
    if lhs._ei != rhs._ei {return false}
    if lhs._ut != rhs._ut {return false}
    if lhs._value != rhs._value {return false}
    if lhs._doNotExtendProps != rhs._doNotExtendProps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentContentOperation.Component.Text.UpdateType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEF_TEXT_UPDATE_TYPE"),
    1: .same(proto: "PORTION"),
    2: .same(proto: "PARA"),
  ]
}

extension DocumentContentOperation.Component.AssociatedTexts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = DocumentContentOperation.Component.protoMessageName + ".AssociatedTexts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "texts"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.texts) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.texts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.texts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.texts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DocumentContentOperation.Component.AssociatedTexts, rhs: DocumentContentOperation.Component.AssociatedTexts) -> Bool {
    if lhs.texts != rhs.texts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
